/*
** ###################################################################
**     Compilers:           Keil ARM C/C++ Compiler
**                          Freescale C/C++ for Embedded ARM
**                          GNU C Compiler
**                          GNU C Compiler - CodeSourcery Sourcery G++
**                          IAR ANSI C/C++ Compiler for ARM
**
**     Reference manual:    KM34P144M75SF0RM, Rev.1, Jan 2015
**     Version:             rev. 1.2, 2015-03-06
**     Build:               b150723
**
**     Abstract:
**         Extension to the CMSIS register access layer header.
**
**     Copyright (c) 2015 Freescale Semiconductor, Inc.
**     All rights reserved.
**
**     Redistribution and use in source and binary forms, with or without modification,
**     are permitted provided that the following conditions are met:
**
**     o Redistributions of source code must retain the above copyright notice, this list
**       of conditions and the following disclaimer.
**
**     o Redistributions in binary form must reproduce the above copyright notice, this
**       list of conditions and the following disclaimer in the documentation and/or
**       other materials provided with the distribution.
**
**     o Neither the name of Freescale Semiconductor, Inc. nor the names of its
**       contributors may be used to endorse or promote products derived from this
**       software without specific prior written permission.
**
**     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
**     ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
**     WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
**     DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
**     ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
**     (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
**     LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
**     ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
**     (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
**     SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
**
**     http:                 www.freescale.com
**     mail:                 support@freescale.com
**
**     Revisions:
**     - rev. 1.0 (2014-10-17)
**         Initial version.
**     - rev. 1.1 (2015-01-27)
**         Update according to reference manual rev. 1, RC.
**     - rev. 1.2 (2015-03-06)
**         Update according to reference manual rev. 1.
**
** ###################################################################
*/

/*
 * WARNING! DO NOT EDIT THIS FILE DIRECTLY!
 *
 * This file was generated automatically and any changes may be lost.
 */
#ifndef __MKM34Z7_EXTENSION_H__
#define __MKM34Z7_EXTENSION_H__

#include "MKM34Z7.h"
#include "fsl_bitaccess.h"

#if defined(__IAR_SYSTEMS_ICC__)
  /*
   * Suppress "Error[Pm008]: sections of code should not be 'commented out' (MISRA C 2004 rule 2.4)"
   * as some register descriptions contain code examples
   */
  #pragma diag_suppress=pm008
#endif

/*
 * MKM34Z7 ADC
 *
 * Analog-to-Digital Converter
 *
 * Registers defined in this header file:
 * - ADC_SC1 - ADC Status and Control Registers 1
 * - ADC_CFG1 - ADC Configuration Register 1
 * - ADC_CFG2 - ADC Configuration Register 2
 * - ADC_R - ADC Data Result Register
 * - ADC_CV1 - Compare Value Registers
 * - ADC_CV2 - Compare Value Registers
 * - ADC_SC2 - Status and Control Register 2
 * - ADC_SC3 - Status and Control Register 3
 * - ADC_OFS - ADC Offset Correction Register
 * - ADC_PG - ADC Plus-Side Gain Register
 * - ADC_CLPD - ADC Plus-Side General Calibration Value Register
 * - ADC_CLPS - ADC Plus-Side General Calibration Value Register
 * - ADC_CLP4 - ADC Plus-Side General Calibration Value Register
 * - ADC_CLP3 - ADC Plus-Side General Calibration Value Register
 * - ADC_CLP2 - ADC Plus-Side General Calibration Value Register
 * - ADC_CLP1 - ADC Plus-Side General Calibration Value Register
 * - ADC_CLP0 - ADC Plus-Side General Calibration Value Register
 */

#define ADC_INSTANCE_COUNT (1U) /*!< Number of instances of the ADC module. */
#define ADC0_IDX (0U) /*!< Instance number for ADC0. */

/*******************************************************************************
 * ADC_SC1 - ADC Status and Control Registers 1
 ******************************************************************************/

/*!
 * @brief ADC_SC1 - ADC Status and Control Registers 1 (RW)
 *
 * Reset value: 0x0000001FU
 *
 * SC1A is used for both software and hardware trigger modes of operation. To
 * allow sequential conversions of the ADC to be triggered by internal peripherals,
 * the ADC can have more than one status and control register: one for each
 * conversion. The SC1B-SC1n registers indicate potentially multiple SC1 registers
 * for use only in hardware trigger mode. See the chip configuration information
 * about the number of SC1n registers specific to this device. The SC1n registers
 * have identical fields, and are used in a "ping-pong" approach to control ADC
 * operation. At any one point in time, only one of the SC1n registers is actively
 * controlling ADC conversions. Updating SC1A while SC1n is actively controlling
 * a conversion is allowed, and vice-versa for any of the SC1n registers specific
 * to this MCU. Writing SC1A while SC1A is actively controlling a conversion
 * aborts the current conversion. In Software Trigger mode, when SC2[ADTRG]=0,
 * writes to SC1A subsequently initiate a new conversion, if SC1[ADCH] contains a
 * value other than all 1s (module disabled). Writing any of the SC1n registers while
 * that specific SC1n register is actively controlling a conversion aborts the
 * current conversion. None of the SC1B-SC1n registers are used for software
 * trigger operation and therefore writes to the SC1B-SC1n registers do not initiate a
 * new conversion.
 */
/*!
 * @name Constants and macros for entire ADC_SC1 register
 */
/*@{*/
#define ADC_RD_SC1(base, index)  (ADC_SC1_REG(base, index))
#define ADC_WR_SC1(base, index, value) (ADC_SC1_REG(base, index) = (value))
#define ADC_RMW_SC1(base, index, mask, value) (ADC_WR_SC1(base, index, (ADC_RD_SC1(base, index) & ~(mask)) | (value)))
#define ADC_SET_SC1(base, index, value) (BME_OR32(&ADC_SC1_REG(base, index), (uint32_t)(value)))
#define ADC_CLR_SC1(base, index, value) (BME_AND32(&ADC_SC1_REG(base, index), (uint32_t)(~(value))))
#define ADC_TOG_SC1(base, index, value) (BME_XOR32(&ADC_SC1_REG(base, index), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ADC_SC1 bitfields
 */

/*!
 * @name Register ADC_SC1, field ADCH[4:0] (RW)
 *
 * Selects one of the input channels. Some of the input channel options in the
 * bitfield-setting descriptions might not be available for your device. For the
 * actual ADC channel assignments for your device, see the Chip Configuration
 * details. The successive approximation converter subsystem is turned off when the
 * channel select bits are all set, that is, ADCH = 11111. This feature allows
 * explicit disabling of the ADC and isolation of the input channel from all
 * sources. Terminating continuous conversions this way prevents an additional single
 * conversion from being performed. It is not necessary to set ADCH to all 1s to
 * place the ADC in a low-power state when continuous conversions are not enabled
 * because the module automatically enters a low-power state when a conversion
 * completes.
 *
 * Values:
 * - 0b00000 - AD0 is selected as input.
 * - 0b00001 - AD1 is selected as input.
 * - 0b00010 - AD2 is selected as input.
 * - 0b00011 - AD3 is selected as input.
 * - 0b00100 - AD4 is selected as input.
 * - 0b00101 - AD5 is selected as input.
 * - 0b00110 - AD6 is selected as input.
 * - 0b00111 - AD7 is selected as input.
 * - 0b01000 - AD8 is selected as input.
 * - 0b01001 - AD9 is selected as input.
 * - 0b01010 - AD10 is selected as input.
 * - 0b01011 - AD11 is selected as input.
 * - 0b01100 - AD12 is selected as input.
 * - 0b01101 - AD13 is selected as input.
 * - 0b01110 - AD14 is selected as input.
 * - 0b01111 - AD15 is selected as input.
 * - 0b10000 - AD16 is selected as input.
 * - 0b10001 - AD17 is selected as input.
 * - 0b10010 - AD18 is selected as input.
 * - 0b10011 - AD19 is selected as input.
 * - 0b10100 - AD20 is selected as input.
 * - 0b10101 - AD21 is selected as input.
 * - 0b10110 - AD22 is selected as input.
 * - 0b10111 - AD23 is selected as input.
 * - 0b11000 - Reserved.
 * - 0b11001 - Reserved.
 * - 0b11010 - Temp Sensor (single-ended) is selected as input.
 * - 0b11011 - Bandgap (single-ended) is selected as input.
 * - 0b11100 - Reserved.
 * - 0b11101 - VREFSH is selected as input. Voltage reference selected is
 *     determined by SC2[REFSEL].
 * - 0b11110 - VREFSL is selected as input. Voltage reference selected is
 *     determined by SC2[REFSEL].
 * - 0b11111 - Module is disabled.
 */
/*@{*/
/*! @brief Read current value of the ADC_SC1_ADCH field. */
#define ADC_RD_SC1_ADCH(base, index) ((ADC_SC1_REG(base, index) & ADC_SC1_ADCH_MASK) >> ADC_SC1_ADCH_SHIFT)
#define ADC_BRD_SC1_ADCH(base, index) (BME_UBFX32(&ADC_SC1_REG(base, index), ADC_SC1_ADCH_SHIFT, ADC_SC1_ADCH_WIDTH))

/*! @brief Set the ADCH field to a new value. */
#define ADC_WR_SC1_ADCH(base, index, value) (ADC_RMW_SC1(base, index, ADC_SC1_ADCH_MASK, ADC_SC1_ADCH(value)))
#define ADC_BWR_SC1_ADCH(base, index, value) (BME_BFI32(&ADC_SC1_REG(base, index), ((uint32_t)(value) << ADC_SC1_ADCH_SHIFT), ADC_SC1_ADCH_SHIFT, ADC_SC1_ADCH_WIDTH))
/*@}*/

/*!
 * @name Register ADC_SC1, field AIEN[6] (RW)
 *
 * Enables conversion complete interrupts. When COCO becomes set while the
 * respective AIEN is high, an interrupt is asserted.
 *
 * Values:
 * - 0b0 - Conversion complete interrupt is disabled.
 * - 0b1 - Conversion complete interrupt is enabled.
 */
/*@{*/
/*! @brief Read current value of the ADC_SC1_AIEN field. */
#define ADC_RD_SC1_AIEN(base, index) ((ADC_SC1_REG(base, index) & ADC_SC1_AIEN_MASK) >> ADC_SC1_AIEN_SHIFT)
#define ADC_BRD_SC1_AIEN(base, index) (BME_UBFX32(&ADC_SC1_REG(base, index), ADC_SC1_AIEN_SHIFT, ADC_SC1_AIEN_WIDTH))

/*! @brief Set the AIEN field to a new value. */
#define ADC_WR_SC1_AIEN(base, index, value) (ADC_RMW_SC1(base, index, ADC_SC1_AIEN_MASK, ADC_SC1_AIEN(value)))
#define ADC_BWR_SC1_AIEN(base, index, value) (BME_BFI32(&ADC_SC1_REG(base, index), ((uint32_t)(value) << ADC_SC1_AIEN_SHIFT), ADC_SC1_AIEN_SHIFT, ADC_SC1_AIEN_WIDTH))
/*@}*/

/*!
 * @name Register ADC_SC1, field COCO[7] (RO)
 *
 * This is a read-only field that is set each time a conversion is completed
 * when the compare function is disabled, or SC2[ACFE]=0 and the hardware average
 * function is disabled, or SC3[AVGE]=0. When the compare function is enabled, or
 * SC2[ACFE]=1, COCO is set upon completion of a conversion only if the compare
 * result is true. When the hardware average function is enabled, or SC3[AVGE]=1,
 * COCO is set upon completion of the selected number of conversions (determined
 * by AVGS). COCO in SC1A is also set at the completion of a calibration sequence.
 * COCO is cleared when the respective SC1n register is written or when the
 * respective Rn register is read.
 *
 * Values:
 * - 0b0 - Conversion is not completed.
 * - 0b1 - Conversion is completed.
 */
/*@{*/
/*! @brief Read current value of the ADC_SC1_COCO field. */
#define ADC_RD_SC1_COCO(base, index) ((ADC_SC1_REG(base, index) & ADC_SC1_COCO_MASK) >> ADC_SC1_COCO_SHIFT)
#define ADC_BRD_SC1_COCO(base, index) (BME_UBFX32(&ADC_SC1_REG(base, index), ADC_SC1_COCO_SHIFT, ADC_SC1_COCO_WIDTH))
/*@}*/

/*******************************************************************************
 * ADC_CFG1 - ADC Configuration Register 1
 ******************************************************************************/

/*!
 * @brief ADC_CFG1 - ADC Configuration Register 1 (RW)
 *
 * Reset value: 0x00000000U
 *
 * The configuration Register 1 (CFG1) selects the mode of operation, clock
 * source, clock divide, and configuration for low power or long sample time.
 */
/*!
 * @name Constants and macros for entire ADC_CFG1 register
 */
/*@{*/
#define ADC_RD_CFG1(base)        (ADC_CFG1_REG(base))
#define ADC_WR_CFG1(base, value) (ADC_CFG1_REG(base) = (value))
#define ADC_RMW_CFG1(base, mask, value) (ADC_WR_CFG1(base, (ADC_RD_CFG1(base) & ~(mask)) | (value)))
#define ADC_SET_CFG1(base, value) (BME_OR32(&ADC_CFG1_REG(base), (uint32_t)(value)))
#define ADC_CLR_CFG1(base, value) (BME_AND32(&ADC_CFG1_REG(base), (uint32_t)(~(value))))
#define ADC_TOG_CFG1(base, value) (BME_XOR32(&ADC_CFG1_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ADC_CFG1 bitfields
 */

/*!
 * @name Register ADC_CFG1, field ADICLK[1:0] (RW)
 *
 * Selects the input clock source to generate the internal clock, ADCK. Note
 * that when the ADACK clock source is selected, it is not required to be active
 * prior to conversion start. When it is selected and it is not active prior to a
 * conversion start, when CFG2[ADACKEN]=0, the asynchronous clock is activated at
 * the start of a conversion and deactivated when conversions are terminated. In
 * this case, there is an associated clock startup delay each time the clock
 * source is re-activated.
 *
 * Values:
 * - 0b00 - Bus clock
 * - 0b01 - Bus clock divided by 2(BUSCLK/2)
 * - 0b10 - Alternate clock (ALTCLK)
 * - 0b11 - Asynchronous clock (ADACK)
 */
/*@{*/
/*! @brief Read current value of the ADC_CFG1_ADICLK field. */
#define ADC_RD_CFG1_ADICLK(base) ((ADC_CFG1_REG(base) & ADC_CFG1_ADICLK_MASK) >> ADC_CFG1_ADICLK_SHIFT)
#define ADC_BRD_CFG1_ADICLK(base) (BME_UBFX32(&ADC_CFG1_REG(base), ADC_CFG1_ADICLK_SHIFT, ADC_CFG1_ADICLK_WIDTH))

/*! @brief Set the ADICLK field to a new value. */
#define ADC_WR_CFG1_ADICLK(base, value) (ADC_RMW_CFG1(base, ADC_CFG1_ADICLK_MASK, ADC_CFG1_ADICLK(value)))
#define ADC_BWR_CFG1_ADICLK(base, value) (BME_BFI32(&ADC_CFG1_REG(base), ((uint32_t)(value) << ADC_CFG1_ADICLK_SHIFT), ADC_CFG1_ADICLK_SHIFT, ADC_CFG1_ADICLK_WIDTH))
/*@}*/

/*!
 * @name Register ADC_CFG1, field MODE[3:2] (RW)
 *
 * Selects the ADC resolution mode.
 *
 * Values:
 * - 0b00 - It is single-ended 8-bit conversion.
 * - 0b01 - It is single-ended 12-bit conversion .
 * - 0b10 - It is single-ended 10-bit conversion.
 * - 0b11 - It is single-ended 16-bit conversion..
 */
/*@{*/
/*! @brief Read current value of the ADC_CFG1_MODE field. */
#define ADC_RD_CFG1_MODE(base) ((ADC_CFG1_REG(base) & ADC_CFG1_MODE_MASK) >> ADC_CFG1_MODE_SHIFT)
#define ADC_BRD_CFG1_MODE(base) (BME_UBFX32(&ADC_CFG1_REG(base), ADC_CFG1_MODE_SHIFT, ADC_CFG1_MODE_WIDTH))

/*! @brief Set the MODE field to a new value. */
#define ADC_WR_CFG1_MODE(base, value) (ADC_RMW_CFG1(base, ADC_CFG1_MODE_MASK, ADC_CFG1_MODE(value)))
#define ADC_BWR_CFG1_MODE(base, value) (BME_BFI32(&ADC_CFG1_REG(base), ((uint32_t)(value) << ADC_CFG1_MODE_SHIFT), ADC_CFG1_MODE_SHIFT, ADC_CFG1_MODE_WIDTH))
/*@}*/

/*!
 * @name Register ADC_CFG1, field ADLSMP[4] (RW)
 *
 * Selects between different sample times based on the conversion mode selected.
 * This field adjusts the sample period to allow higher impedance inputs to be
 * accurately sampled or to maximize conversion speed for lower impedance inputs.
 * Longer sample times can also be used to lower overall power consumption if
 * continuous conversions are enabled and high conversion rates are not required.
 * When ADLSMP=1, the long sample time select bits, (ADLSTS[1:0]), can select the
 * extent of the long sample time.
 *
 * Values:
 * - 0b0 - Short sample time.
 * - 0b1 - Long sample time.
 */
/*@{*/
/*! @brief Read current value of the ADC_CFG1_ADLSMP field. */
#define ADC_RD_CFG1_ADLSMP(base) ((ADC_CFG1_REG(base) & ADC_CFG1_ADLSMP_MASK) >> ADC_CFG1_ADLSMP_SHIFT)
#define ADC_BRD_CFG1_ADLSMP(base) (BME_UBFX32(&ADC_CFG1_REG(base), ADC_CFG1_ADLSMP_SHIFT, ADC_CFG1_ADLSMP_WIDTH))

/*! @brief Set the ADLSMP field to a new value. */
#define ADC_WR_CFG1_ADLSMP(base, value) (ADC_RMW_CFG1(base, ADC_CFG1_ADLSMP_MASK, ADC_CFG1_ADLSMP(value)))
#define ADC_BWR_CFG1_ADLSMP(base, value) (BME_BFI32(&ADC_CFG1_REG(base), ((uint32_t)(value) << ADC_CFG1_ADLSMP_SHIFT), ADC_CFG1_ADLSMP_SHIFT, ADC_CFG1_ADLSMP_WIDTH))
/*@}*/

/*!
 * @name Register ADC_CFG1, field ADIV[6:5] (RW)
 *
 * Selects the divide ratio used by the ADC to generate the internal clock ADCK.
 *
 * Values:
 * - 0b00 - The divide ratio is 1 and the clock rate is input clock.
 * - 0b01 - The divide ratio is 2 and the clock rate is (input clock)/2.
 * - 0b10 - The divide ratio is 4 and the clock rate is (input clock)/4.
 * - 0b11 - The divide ratio is 8 and the clock rate is (input clock)/8.
 */
/*@{*/
/*! @brief Read current value of the ADC_CFG1_ADIV field. */
#define ADC_RD_CFG1_ADIV(base) ((ADC_CFG1_REG(base) & ADC_CFG1_ADIV_MASK) >> ADC_CFG1_ADIV_SHIFT)
#define ADC_BRD_CFG1_ADIV(base) (BME_UBFX32(&ADC_CFG1_REG(base), ADC_CFG1_ADIV_SHIFT, ADC_CFG1_ADIV_WIDTH))

/*! @brief Set the ADIV field to a new value. */
#define ADC_WR_CFG1_ADIV(base, value) (ADC_RMW_CFG1(base, ADC_CFG1_ADIV_MASK, ADC_CFG1_ADIV(value)))
#define ADC_BWR_CFG1_ADIV(base, value) (BME_BFI32(&ADC_CFG1_REG(base), ((uint32_t)(value) << ADC_CFG1_ADIV_SHIFT), ADC_CFG1_ADIV_SHIFT, ADC_CFG1_ADIV_WIDTH))
/*@}*/

/*!
 * @name Register ADC_CFG1, field ADLPC[7] (RW)
 *
 * Controls the power configuration of the successive approximation converter.
 * This optimizes power consumption when higher sample rates are not required.
 *
 * Values:
 * - 0b0 - Normal power configuration.
 * - 0b1 - Low-power configuration. The power is reduced at the expense of
 *     maximum clock speed.
 */
/*@{*/
/*! @brief Read current value of the ADC_CFG1_ADLPC field. */
#define ADC_RD_CFG1_ADLPC(base) ((ADC_CFG1_REG(base) & ADC_CFG1_ADLPC_MASK) >> ADC_CFG1_ADLPC_SHIFT)
#define ADC_BRD_CFG1_ADLPC(base) (BME_UBFX32(&ADC_CFG1_REG(base), ADC_CFG1_ADLPC_SHIFT, ADC_CFG1_ADLPC_WIDTH))

/*! @brief Set the ADLPC field to a new value. */
#define ADC_WR_CFG1_ADLPC(base, value) (ADC_RMW_CFG1(base, ADC_CFG1_ADLPC_MASK, ADC_CFG1_ADLPC(value)))
#define ADC_BWR_CFG1_ADLPC(base, value) (BME_BFI32(&ADC_CFG1_REG(base), ((uint32_t)(value) << ADC_CFG1_ADLPC_SHIFT), ADC_CFG1_ADLPC_SHIFT, ADC_CFG1_ADLPC_WIDTH))
/*@}*/

/*******************************************************************************
 * ADC_CFG2 - ADC Configuration Register 2
 ******************************************************************************/

/*!
 * @brief ADC_CFG2 - ADC Configuration Register 2 (RW)
 *
 * Reset value: 0x00000000U
 *
 * Configuration Register 2 (CFG2) selects the special high-speed configuration
 * for very high speed conversions and selects the long sample time duration
 * during long sample mode.
 */
/*!
 * @name Constants and macros for entire ADC_CFG2 register
 */
/*@{*/
#define ADC_RD_CFG2(base)        (ADC_CFG2_REG(base))
#define ADC_WR_CFG2(base, value) (ADC_CFG2_REG(base) = (value))
#define ADC_RMW_CFG2(base, mask, value) (ADC_WR_CFG2(base, (ADC_RD_CFG2(base) & ~(mask)) | (value)))
#define ADC_SET_CFG2(base, value) (BME_OR32(&ADC_CFG2_REG(base), (uint32_t)(value)))
#define ADC_CLR_CFG2(base, value) (BME_AND32(&ADC_CFG2_REG(base), (uint32_t)(~(value))))
#define ADC_TOG_CFG2(base, value) (BME_XOR32(&ADC_CFG2_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ADC_CFG2 bitfields
 */

/*!
 * @name Register ADC_CFG2, field ADLSTS[1:0] (RW)
 *
 * Selects between the extended sample times when long sample time is selected,
 * that is, when CFG1[ADLSMP]=1. This allows higher impedance inputs to be
 * accurately sampled or to maximize conversion speed for lower impedance inputs.
 * Longer sample times can also be used to lower overall power consumption when
 * continuous conversions are enabled if high conversion rates are not required.
 *
 * Values:
 * - 0b00 - Default longest sample time; 20 extra ADCK cycles; 24 ADCK cycles
 *     total.
 * - 0b01 - 12 extra ADCK cycles; 16 ADCK cycles total sample time.
 * - 0b10 - 6 extra ADCK cycles; 10 ADCK cycles total sample time.
 * - 0b11 - 2 extra ADCK cycles; 6 ADCK cycles total sample time.
 */
/*@{*/
/*! @brief Read current value of the ADC_CFG2_ADLSTS field. */
#define ADC_RD_CFG2_ADLSTS(base) ((ADC_CFG2_REG(base) & ADC_CFG2_ADLSTS_MASK) >> ADC_CFG2_ADLSTS_SHIFT)
#define ADC_BRD_CFG2_ADLSTS(base) (BME_UBFX32(&ADC_CFG2_REG(base), ADC_CFG2_ADLSTS_SHIFT, ADC_CFG2_ADLSTS_WIDTH))

/*! @brief Set the ADLSTS field to a new value. */
#define ADC_WR_CFG2_ADLSTS(base, value) (ADC_RMW_CFG2(base, ADC_CFG2_ADLSTS_MASK, ADC_CFG2_ADLSTS(value)))
#define ADC_BWR_CFG2_ADLSTS(base, value) (BME_BFI32(&ADC_CFG2_REG(base), ((uint32_t)(value) << ADC_CFG2_ADLSTS_SHIFT), ADC_CFG2_ADLSTS_SHIFT, ADC_CFG2_ADLSTS_WIDTH))
/*@}*/

/*!
 * @name Register ADC_CFG2, field ADHSC[2] (RW)
 *
 * Configures the ADC for very high-speed operation. The conversion sequence is
 * altered with 2 ADCK cycles added to the conversion time to allow higher speed
 * conversion clocks.
 *
 * Values:
 * - 0b0 - Normal conversion sequence selected.
 * - 0b1 - High-speed conversion sequence selected with 2 additional ADCK cycles
 *     to total conversion time.
 */
/*@{*/
/*! @brief Read current value of the ADC_CFG2_ADHSC field. */
#define ADC_RD_CFG2_ADHSC(base) ((ADC_CFG2_REG(base) & ADC_CFG2_ADHSC_MASK) >> ADC_CFG2_ADHSC_SHIFT)
#define ADC_BRD_CFG2_ADHSC(base) (BME_UBFX32(&ADC_CFG2_REG(base), ADC_CFG2_ADHSC_SHIFT, ADC_CFG2_ADHSC_WIDTH))

/*! @brief Set the ADHSC field to a new value. */
#define ADC_WR_CFG2_ADHSC(base, value) (ADC_RMW_CFG2(base, ADC_CFG2_ADHSC_MASK, ADC_CFG2_ADHSC(value)))
#define ADC_BWR_CFG2_ADHSC(base, value) (BME_BFI32(&ADC_CFG2_REG(base), ((uint32_t)(value) << ADC_CFG2_ADHSC_SHIFT), ADC_CFG2_ADHSC_SHIFT, ADC_CFG2_ADHSC_WIDTH))
/*@}*/

/*!
 * @name Register ADC_CFG2, field ADACKEN[3] (RW)
 *
 * Enables the asynchronous clock source and the clock source output regardless
 * of the conversion and status of CFG1[ADICLK]. Based on MCU configuration, the
 * asynchronous clock may be used by other modules. See chip configuration
 * information. Setting this field allows the clock to be used even while the ADC is
 * idle or operating from a different clock source. Also, latency of initiating a
 * single or first-continuous conversion with the asynchronous clock selected is
 * reduced because the ADACK clock is already operational.
 *
 * Values:
 * - 0b0 - Asynchronous clock output disabled; Asynchronous clock is enabled
 *     only if selected by ADICLK and a conversion is active.
 * - 0b1 - Asynchronous clock and clock output is enabled regardless of the
 *     state of the ADC.
 */
/*@{*/
/*! @brief Read current value of the ADC_CFG2_ADACKEN field. */
#define ADC_RD_CFG2_ADACKEN(base) ((ADC_CFG2_REG(base) & ADC_CFG2_ADACKEN_MASK) >> ADC_CFG2_ADACKEN_SHIFT)
#define ADC_BRD_CFG2_ADACKEN(base) (BME_UBFX32(&ADC_CFG2_REG(base), ADC_CFG2_ADACKEN_SHIFT, ADC_CFG2_ADACKEN_WIDTH))

/*! @brief Set the ADACKEN field to a new value. */
#define ADC_WR_CFG2_ADACKEN(base, value) (ADC_RMW_CFG2(base, ADC_CFG2_ADACKEN_MASK, ADC_CFG2_ADACKEN(value)))
#define ADC_BWR_CFG2_ADACKEN(base, value) (BME_BFI32(&ADC_CFG2_REG(base), ((uint32_t)(value) << ADC_CFG2_ADACKEN_SHIFT), ADC_CFG2_ADACKEN_SHIFT, ADC_CFG2_ADACKEN_WIDTH))
/*@}*/

/*!
 * @name Register ADC_CFG2, field MUXSEL[4] (RW)
 *
 * Changes the ADC mux setting to select between alternate sets of ADC channels.
 *
 * Values:
 * - 0b0 - ADxxa channels are selected.
 * - 0b1 - ADxxb channels are selected.
 */
/*@{*/
/*! @brief Read current value of the ADC_CFG2_MUXSEL field. */
#define ADC_RD_CFG2_MUXSEL(base) ((ADC_CFG2_REG(base) & ADC_CFG2_MUXSEL_MASK) >> ADC_CFG2_MUXSEL_SHIFT)
#define ADC_BRD_CFG2_MUXSEL(base) (BME_UBFX32(&ADC_CFG2_REG(base), ADC_CFG2_MUXSEL_SHIFT, ADC_CFG2_MUXSEL_WIDTH))

/*! @brief Set the MUXSEL field to a new value. */
#define ADC_WR_CFG2_MUXSEL(base, value) (ADC_RMW_CFG2(base, ADC_CFG2_MUXSEL_MASK, ADC_CFG2_MUXSEL(value)))
#define ADC_BWR_CFG2_MUXSEL(base, value) (BME_BFI32(&ADC_CFG2_REG(base), ((uint32_t)(value) << ADC_CFG2_MUXSEL_SHIFT), ADC_CFG2_MUXSEL_SHIFT, ADC_CFG2_MUXSEL_WIDTH))
/*@}*/

/*******************************************************************************
 * ADC_R - ADC Data Result Register
 ******************************************************************************/

/*!
 * @brief ADC_R - ADC Data Result Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The data result registers (Rn) contain the result of an ADC conversion of the
 * channel selected by the corresponding status and channel control register
 * (SC1A:SC1n). For every status and channel control register, there is a
 * corresponding data result register. Unused bits in R n are cleared in unsigned
 * right-aligned modes and carry the sign bit (MSB) in sign-extended 2's complement modes.
 * The following table describes the behavior of the data result registers in
 * the different modes of operation. Data result register description Conversion
 * mode D15 D14 D13 D12 D11 D10 D9 D8 D7 D6 D5 D4 D3 D2 D1 D0 Format 16-bit
 * single-ended D D D D D D D D D D D D D D D D Unsigned right justified 12-bit
 * single-ended 0 0 0 0 D D D D D D D D D D D D Unsigned right-justified 10-bit
 * single-ended 0 0 0 0 0 0 D D D D D D D D D D Unsigned right-justified 8-bit
 * single-ended 0 0 0 0 0 0 0 0 D D D D D D D D Unsigned right-justified S: Sign bit or sign
 * bit extension; D: Data, which is 2's complement data if indicated
 */
/*!
 * @name Constants and macros for entire ADC_R register
 */
/*@{*/
#define ADC_RD_R(base, index)    (ADC_R_REG(base, index))
/*@}*/

/*
 * Constants & macros for individual ADC_R bitfields
 */

/*!
 * @name Register ADC_R, field D[15:0] (RO)
 */
/*@{*/
/*! @brief Read current value of the ADC_R_D field. */
#define ADC_RD_R_D(base, index) ((ADC_R_REG(base, index) & ADC_R_D_MASK) >> ADC_R_D_SHIFT)
#define ADC_BRD_R_D(base, index) (BME_UBFX32(&ADC_R_REG(base, index), ADC_R_D_SHIFT, ADC_R_D_WIDTH))
/*@}*/

/*******************************************************************************
 * ADC_CV1 - Compare Value Registers
 ******************************************************************************/

/*!
 * @brief ADC_CV1 - Compare Value Registers (RW)
 *
 * Reset value: 0x00000000U
 *
 * The Compare Value Registers (CV1 and CV2) contain a compare value used to
 * compare the conversion result when the compare function is enabled, that is,
 * SC2[ACFE]=1. This register is formatted in the same way as the Rn registers in
 * different modes of operation for both bit position definition and value format
 * using unsigned or sign-extended 2's complement. Therefore, the compare function
 * uses only the CVn fields that are related to the ADC mode of operation. The
 * compare value 2 register (CV2) is used only when the compare range function is
 * enabled, that is, SC2[ACREN]=1.
 */
/*!
 * @name Constants and macros for entire ADC_CV1 register
 */
/*@{*/
#define ADC_RD_CV1(base)         (ADC_CV1_REG(base))
#define ADC_WR_CV1(base, value)  (ADC_CV1_REG(base) = (value))
#define ADC_RMW_CV1(base, mask, value) (ADC_WR_CV1(base, (ADC_RD_CV1(base) & ~(mask)) | (value)))
#define ADC_SET_CV1(base, value) (BME_OR32(&ADC_CV1_REG(base), (uint32_t)(value)))
#define ADC_CLR_CV1(base, value) (BME_AND32(&ADC_CV1_REG(base), (uint32_t)(~(value))))
#define ADC_TOG_CV1(base, value) (BME_XOR32(&ADC_CV1_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ADC_CV1 bitfields
 */

/*!
 * @name Register ADC_CV1, field CV[15:0] (RW)
 */
/*@{*/
/*! @brief Read current value of the ADC_CV1_CV field. */
#define ADC_RD_CV1_CV(base)  ((ADC_CV1_REG(base) & ADC_CV1_CV_MASK) >> ADC_CV1_CV_SHIFT)
#define ADC_BRD_CV1_CV(base) (BME_UBFX32(&ADC_CV1_REG(base), ADC_CV1_CV_SHIFT, ADC_CV1_CV_WIDTH))

/*! @brief Set the CV field to a new value. */
#define ADC_WR_CV1_CV(base, value) (ADC_RMW_CV1(base, ADC_CV1_CV_MASK, ADC_CV1_CV(value)))
#define ADC_BWR_CV1_CV(base, value) (BME_BFI32(&ADC_CV1_REG(base), ((uint32_t)(value) << ADC_CV1_CV_SHIFT), ADC_CV1_CV_SHIFT, ADC_CV1_CV_WIDTH))
/*@}*/

/*******************************************************************************
 * ADC_CV2 - Compare Value Registers
 ******************************************************************************/

/*!
 * @brief ADC_CV2 - Compare Value Registers (RW)
 *
 * Reset value: 0x00000000U
 *
 * The Compare Value Registers (CV1 and CV2) contain a compare value used to
 * compare the conversion result when the compare function is enabled, that is,
 * SC2[ACFE]=1. This register is formatted in the same way as the Rn registers in
 * different modes of operation for both bit position definition and value format
 * using unsigned or sign-extended 2's complement. Therefore, the compare function
 * uses only the CVn fields that are related to the ADC mode of operation. The
 * compare value 2 register (CV2) is used only when the compare range function is
 * enabled, that is, SC2[ACREN]=1.
 */
/*!
 * @name Constants and macros for entire ADC_CV2 register
 */
/*@{*/
#define ADC_RD_CV2(base)         (ADC_CV2_REG(base))
#define ADC_WR_CV2(base, value)  (ADC_CV2_REG(base) = (value))
#define ADC_RMW_CV2(base, mask, value) (ADC_WR_CV2(base, (ADC_RD_CV2(base) & ~(mask)) | (value)))
#define ADC_SET_CV2(base, value) (BME_OR32(&ADC_CV2_REG(base), (uint32_t)(value)))
#define ADC_CLR_CV2(base, value) (BME_AND32(&ADC_CV2_REG(base), (uint32_t)(~(value))))
#define ADC_TOG_CV2(base, value) (BME_XOR32(&ADC_CV2_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ADC_CV2 bitfields
 */

/*!
 * @name Register ADC_CV2, field CV[15:0] (RW)
 */
/*@{*/
/*! @brief Read current value of the ADC_CV2_CV field. */
#define ADC_RD_CV2_CV(base)  ((ADC_CV2_REG(base) & ADC_CV2_CV_MASK) >> ADC_CV2_CV_SHIFT)
#define ADC_BRD_CV2_CV(base) (BME_UBFX32(&ADC_CV2_REG(base), ADC_CV2_CV_SHIFT, ADC_CV2_CV_WIDTH))

/*! @brief Set the CV field to a new value. */
#define ADC_WR_CV2_CV(base, value) (ADC_RMW_CV2(base, ADC_CV2_CV_MASK, ADC_CV2_CV(value)))
#define ADC_BWR_CV2_CV(base, value) (BME_BFI32(&ADC_CV2_REG(base), ((uint32_t)(value) << ADC_CV2_CV_SHIFT), ADC_CV2_CV_SHIFT, ADC_CV2_CV_WIDTH))
/*@}*/

/*******************************************************************************
 * ADC_SC2 - Status and Control Register 2
 ******************************************************************************/

/*!
 * @brief ADC_SC2 - Status and Control Register 2 (RW)
 *
 * Reset value: 0x00000000U
 *
 * The status and control register 2 (SC2) contains the conversion active,
 * hardware/software trigger select, compare function, and voltage reference select of
 * the ADC module.
 */
/*!
 * @name Constants and macros for entire ADC_SC2 register
 */
/*@{*/
#define ADC_RD_SC2(base)         (ADC_SC2_REG(base))
#define ADC_WR_SC2(base, value)  (ADC_SC2_REG(base) = (value))
#define ADC_RMW_SC2(base, mask, value) (ADC_WR_SC2(base, (ADC_RD_SC2(base) & ~(mask)) | (value)))
#define ADC_SET_SC2(base, value) (BME_OR32(&ADC_SC2_REG(base), (uint32_t)(value)))
#define ADC_CLR_SC2(base, value) (BME_AND32(&ADC_SC2_REG(base), (uint32_t)(~(value))))
#define ADC_TOG_SC2(base, value) (BME_XOR32(&ADC_SC2_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ADC_SC2 bitfields
 */

/*!
 * @name Register ADC_SC2, field REFSEL[1:0] (RW)
 *
 * Selects the voltage reference source used for conversions.
 *
 * Values:
 * - 0b00 - Default voltage reference pin pair, that is, external pins VREFH and
 *     VREFL
 * - 0b01 - Alternate reference pair, that is, VALTH and VALTL . This pair may
 *     be additional external pins or internal sources depending on the MCU
 *     configuration. See the chip configuration information for details specific to
 *     this MCU
 * - 0b10 - Internal bandgap reference and associated ground reference (V BGH
 *     and V BGL ). Consult the Chip Configuration information for details specific
 *     to this MCU.
 * - 0b11 - Reserved
 */
/*@{*/
/*! @brief Read current value of the ADC_SC2_REFSEL field. */
#define ADC_RD_SC2_REFSEL(base) ((ADC_SC2_REG(base) & ADC_SC2_REFSEL_MASK) >> ADC_SC2_REFSEL_SHIFT)
#define ADC_BRD_SC2_REFSEL(base) (BME_UBFX32(&ADC_SC2_REG(base), ADC_SC2_REFSEL_SHIFT, ADC_SC2_REFSEL_WIDTH))

/*! @brief Set the REFSEL field to a new value. */
#define ADC_WR_SC2_REFSEL(base, value) (ADC_RMW_SC2(base, ADC_SC2_REFSEL_MASK, ADC_SC2_REFSEL(value)))
#define ADC_BWR_SC2_REFSEL(base, value) (BME_BFI32(&ADC_SC2_REG(base), ((uint32_t)(value) << ADC_SC2_REFSEL_SHIFT), ADC_SC2_REFSEL_SHIFT, ADC_SC2_REFSEL_WIDTH))
/*@}*/

/*!
 * @name Register ADC_SC2, field DMAEN[2] (RW)
 *
 * Values:
 * - 0b0 - DMA is disabled.
 * - 0b1 - DMA is enabled and will assert the ADC DMA request during an ADC
 *     conversion complete event noted when any of the SC1n[COCO] flags is asserted.
 */
/*@{*/
/*! @brief Read current value of the ADC_SC2_DMAEN field. */
#define ADC_RD_SC2_DMAEN(base) ((ADC_SC2_REG(base) & ADC_SC2_DMAEN_MASK) >> ADC_SC2_DMAEN_SHIFT)
#define ADC_BRD_SC2_DMAEN(base) (BME_UBFX32(&ADC_SC2_REG(base), ADC_SC2_DMAEN_SHIFT, ADC_SC2_DMAEN_WIDTH))

/*! @brief Set the DMAEN field to a new value. */
#define ADC_WR_SC2_DMAEN(base, value) (ADC_RMW_SC2(base, ADC_SC2_DMAEN_MASK, ADC_SC2_DMAEN(value)))
#define ADC_BWR_SC2_DMAEN(base, value) (BME_BFI32(&ADC_SC2_REG(base), ((uint32_t)(value) << ADC_SC2_DMAEN_SHIFT), ADC_SC2_DMAEN_SHIFT, ADC_SC2_DMAEN_WIDTH))
/*@}*/

/*!
 * @name Register ADC_SC2, field ACREN[3] (RW)
 *
 * Configures the compare function to check if the conversion result of the
 * input being monitored is either between or outside the range formed by CV1 and CV2
 * determined by the value of ACFGT. ACFE must be set for ACFGT to have any
 * effect.
 *
 * Values:
 * - 0b0 - Range function disabled. Only CV1 is compared.
 * - 0b1 - Range function enabled. Both CV1 and CV2 are compared.
 */
/*@{*/
/*! @brief Read current value of the ADC_SC2_ACREN field. */
#define ADC_RD_SC2_ACREN(base) ((ADC_SC2_REG(base) & ADC_SC2_ACREN_MASK) >> ADC_SC2_ACREN_SHIFT)
#define ADC_BRD_SC2_ACREN(base) (BME_UBFX32(&ADC_SC2_REG(base), ADC_SC2_ACREN_SHIFT, ADC_SC2_ACREN_WIDTH))

/*! @brief Set the ACREN field to a new value. */
#define ADC_WR_SC2_ACREN(base, value) (ADC_RMW_SC2(base, ADC_SC2_ACREN_MASK, ADC_SC2_ACREN(value)))
#define ADC_BWR_SC2_ACREN(base, value) (BME_BFI32(&ADC_SC2_REG(base), ((uint32_t)(value) << ADC_SC2_ACREN_SHIFT), ADC_SC2_ACREN_SHIFT, ADC_SC2_ACREN_WIDTH))
/*@}*/

/*!
 * @name Register ADC_SC2, field ACFGT[4] (RW)
 *
 * Configures the compare function to check the conversion result relative to
 * the CV1 and CV2 based upon the value of ACREN. ACFE must be set for ACFGT to
 * have any effect.
 *
 * Values:
 * - 0b0 - Configures less than threshold, outside range not inclusive and
 *     inside range not inclusive; functionality based on the values placed in CV1 and
 *     CV2.
 * - 0b1 - Configures greater than or equal to threshold, outside and inside
 *     ranges inclusive; functionality based on the values placed in CV1 and CV2.
 */
/*@{*/
/*! @brief Read current value of the ADC_SC2_ACFGT field. */
#define ADC_RD_SC2_ACFGT(base) ((ADC_SC2_REG(base) & ADC_SC2_ACFGT_MASK) >> ADC_SC2_ACFGT_SHIFT)
#define ADC_BRD_SC2_ACFGT(base) (BME_UBFX32(&ADC_SC2_REG(base), ADC_SC2_ACFGT_SHIFT, ADC_SC2_ACFGT_WIDTH))

/*! @brief Set the ACFGT field to a new value. */
#define ADC_WR_SC2_ACFGT(base, value) (ADC_RMW_SC2(base, ADC_SC2_ACFGT_MASK, ADC_SC2_ACFGT(value)))
#define ADC_BWR_SC2_ACFGT(base, value) (BME_BFI32(&ADC_SC2_REG(base), ((uint32_t)(value) << ADC_SC2_ACFGT_SHIFT), ADC_SC2_ACFGT_SHIFT, ADC_SC2_ACFGT_WIDTH))
/*@}*/

/*!
 * @name Register ADC_SC2, field ACFE[5] (RW)
 *
 * Enables the compare function.
 *
 * Values:
 * - 0b0 - Compare function disabled.
 * - 0b1 - Compare function enabled.
 */
/*@{*/
/*! @brief Read current value of the ADC_SC2_ACFE field. */
#define ADC_RD_SC2_ACFE(base) ((ADC_SC2_REG(base) & ADC_SC2_ACFE_MASK) >> ADC_SC2_ACFE_SHIFT)
#define ADC_BRD_SC2_ACFE(base) (BME_UBFX32(&ADC_SC2_REG(base), ADC_SC2_ACFE_SHIFT, ADC_SC2_ACFE_WIDTH))

/*! @brief Set the ACFE field to a new value. */
#define ADC_WR_SC2_ACFE(base, value) (ADC_RMW_SC2(base, ADC_SC2_ACFE_MASK, ADC_SC2_ACFE(value)))
#define ADC_BWR_SC2_ACFE(base, value) (BME_BFI32(&ADC_SC2_REG(base), ((uint32_t)(value) << ADC_SC2_ACFE_SHIFT), ADC_SC2_ACFE_SHIFT, ADC_SC2_ACFE_WIDTH))
/*@}*/

/*!
 * @name Register ADC_SC2, field ADTRG[6] (RW)
 *
 * Selects the type of trigger used for initiating a conversion. Two types of
 * trigger are selectable: Software trigger: When software trigger is selected, a
 * conversion is initiated following a write to SC1A. Hardware trigger: When
 * hardware trigger is selected, a conversion is initiated following the assertion of
 * the ADHWT input after a pulse of the ADHWTSn input.
 *
 * Values:
 * - 0b0 - Software trigger selected.
 * - 0b1 - Hardware trigger selected.
 */
/*@{*/
/*! @brief Read current value of the ADC_SC2_ADTRG field. */
#define ADC_RD_SC2_ADTRG(base) ((ADC_SC2_REG(base) & ADC_SC2_ADTRG_MASK) >> ADC_SC2_ADTRG_SHIFT)
#define ADC_BRD_SC2_ADTRG(base) (BME_UBFX32(&ADC_SC2_REG(base), ADC_SC2_ADTRG_SHIFT, ADC_SC2_ADTRG_WIDTH))

/*! @brief Set the ADTRG field to a new value. */
#define ADC_WR_SC2_ADTRG(base, value) (ADC_RMW_SC2(base, ADC_SC2_ADTRG_MASK, ADC_SC2_ADTRG(value)))
#define ADC_BWR_SC2_ADTRG(base, value) (BME_BFI32(&ADC_SC2_REG(base), ((uint32_t)(value) << ADC_SC2_ADTRG_SHIFT), ADC_SC2_ADTRG_SHIFT, ADC_SC2_ADTRG_WIDTH))
/*@}*/

/*!
 * @name Register ADC_SC2, field ADACT[7] (RO)
 *
 * Indicates that a conversion or hardware averaging is in progress. ADACT is
 * set when a conversion is initiated and cleared when a conversion is completed or
 * aborted.
 *
 * Values:
 * - 0b0 - Conversion not in progress.
 * - 0b1 - Conversion in progress.
 */
/*@{*/
/*! @brief Read current value of the ADC_SC2_ADACT field. */
#define ADC_RD_SC2_ADACT(base) ((ADC_SC2_REG(base) & ADC_SC2_ADACT_MASK) >> ADC_SC2_ADACT_SHIFT)
#define ADC_BRD_SC2_ADACT(base) (BME_UBFX32(&ADC_SC2_REG(base), ADC_SC2_ADACT_SHIFT, ADC_SC2_ADACT_WIDTH))
/*@}*/

/*******************************************************************************
 * ADC_SC3 - Status and Control Register 3
 ******************************************************************************/

/*!
 * @brief ADC_SC3 - Status and Control Register 3 (RW)
 *
 * Reset value: 0x00000000U
 *
 * The Status and Control Register 3 (SC3) controls the calibration, continuous
 * convert, and hardware averaging functions of the ADC module.
 */
/*!
 * @name Constants and macros for entire ADC_SC3 register
 */
/*@{*/
#define ADC_RD_SC3(base)         (ADC_SC3_REG(base))
#define ADC_WR_SC3(base, value)  (ADC_SC3_REG(base) = (value))
#define ADC_RMW_SC3(base, mask, value) (ADC_WR_SC3(base, (ADC_RD_SC3(base) & ~(mask)) | (value)))
#define ADC_SET_SC3(base, value) (BME_OR32(&ADC_SC3_REG(base), (uint32_t)(value)))
#define ADC_CLR_SC3(base, value) (BME_AND32(&ADC_SC3_REG(base), (uint32_t)(~(value))))
#define ADC_TOG_SC3(base, value) (BME_XOR32(&ADC_SC3_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ADC_SC3 bitfields
 */

/*!
 * @name Register ADC_SC3, field AVGS[1:0] (RW)
 *
 * Determines how many ADC conversions will be averaged to create the ADC
 * average result.
 *
 * Values:
 * - 0b00 - 4 samples averaged.
 * - 0b01 - 8 samples averaged.
 * - 0b10 - 16 samples averaged.
 * - 0b11 - 32 samples averaged.
 */
/*@{*/
/*! @brief Read current value of the ADC_SC3_AVGS field. */
#define ADC_RD_SC3_AVGS(base) ((ADC_SC3_REG(base) & ADC_SC3_AVGS_MASK) >> ADC_SC3_AVGS_SHIFT)
#define ADC_BRD_SC3_AVGS(base) (BME_UBFX32(&ADC_SC3_REG(base), ADC_SC3_AVGS_SHIFT, ADC_SC3_AVGS_WIDTH))

/*! @brief Set the AVGS field to a new value. */
#define ADC_WR_SC3_AVGS(base, value) (ADC_RMW_SC3(base, (ADC_SC3_AVGS_MASK | ADC_SC3_CALF_MASK), ADC_SC3_AVGS(value)))
#define ADC_BWR_SC3_AVGS(base, value) (BME_BFI32(&ADC_SC3_REG(base), ((uint32_t)(value) << ADC_SC3_AVGS_SHIFT), ADC_SC3_AVGS_SHIFT, ADC_SC3_AVGS_WIDTH))
/*@}*/

/*!
 * @name Register ADC_SC3, field AVGE[2] (RW)
 *
 * Enables the hardware average function of the ADC.
 *
 * Values:
 * - 0b0 - Hardware average function disabled.
 * - 0b1 - Hardware average function enabled.
 */
/*@{*/
/*! @brief Read current value of the ADC_SC3_AVGE field. */
#define ADC_RD_SC3_AVGE(base) ((ADC_SC3_REG(base) & ADC_SC3_AVGE_MASK) >> ADC_SC3_AVGE_SHIFT)
#define ADC_BRD_SC3_AVGE(base) (BME_UBFX32(&ADC_SC3_REG(base), ADC_SC3_AVGE_SHIFT, ADC_SC3_AVGE_WIDTH))

/*! @brief Set the AVGE field to a new value. */
#define ADC_WR_SC3_AVGE(base, value) (ADC_RMW_SC3(base, (ADC_SC3_AVGE_MASK | ADC_SC3_CALF_MASK), ADC_SC3_AVGE(value)))
#define ADC_BWR_SC3_AVGE(base, value) (BME_BFI32(&ADC_SC3_REG(base), ((uint32_t)(value) << ADC_SC3_AVGE_SHIFT), ADC_SC3_AVGE_SHIFT, ADC_SC3_AVGE_WIDTH))
/*@}*/

/*!
 * @name Register ADC_SC3, field ADCO[3] (RW)
 *
 * Enables continuous conversions.
 *
 * Values:
 * - 0b0 - One conversion or one set of conversions if the hardware average
 *     function is enabled, that is, AVGE=1, after initiating a conversion.
 * - 0b1 - Continuous conversions or sets of conversions if the hardware average
 *     function is enabled, that is, AVGE=1, after initiating a conversion.
 */
/*@{*/
/*! @brief Read current value of the ADC_SC3_ADCO field. */
#define ADC_RD_SC3_ADCO(base) ((ADC_SC3_REG(base) & ADC_SC3_ADCO_MASK) >> ADC_SC3_ADCO_SHIFT)
#define ADC_BRD_SC3_ADCO(base) (BME_UBFX32(&ADC_SC3_REG(base), ADC_SC3_ADCO_SHIFT, ADC_SC3_ADCO_WIDTH))

/*! @brief Set the ADCO field to a new value. */
#define ADC_WR_SC3_ADCO(base, value) (ADC_RMW_SC3(base, (ADC_SC3_ADCO_MASK | ADC_SC3_CALF_MASK), ADC_SC3_ADCO(value)))
#define ADC_BWR_SC3_ADCO(base, value) (BME_BFI32(&ADC_SC3_REG(base), ((uint32_t)(value) << ADC_SC3_ADCO_SHIFT), ADC_SC3_ADCO_SHIFT, ADC_SC3_ADCO_WIDTH))
/*@}*/

/*!
 * @name Register ADC_SC3, field CALF[6] (W1C)
 *
 * Displays the result of the calibration sequence. The calibration sequence
 * will fail if SC2[ADTRG] = 1, any ADC register is written, or any stop mode is
 * entered before the calibration sequence completes. Writing 1 to CALF clears it.
 *
 * Values:
 * - 0b0 - Calibration completed normally.
 * - 0b1 - Calibration failed. ADC accuracy specifications are not guaranteed.
 */
/*@{*/
/*! @brief Read current value of the ADC_SC3_CALF field. */
#define ADC_RD_SC3_CALF(base) ((ADC_SC3_REG(base) & ADC_SC3_CALF_MASK) >> ADC_SC3_CALF_SHIFT)
#define ADC_BRD_SC3_CALF(base) (BME_UBFX32(&ADC_SC3_REG(base), ADC_SC3_CALF_SHIFT, ADC_SC3_CALF_WIDTH))

/*! @brief Set the CALF field to a new value. */
#define ADC_WR_SC3_CALF(base, value) (ADC_RMW_SC3(base, ADC_SC3_CALF_MASK, ADC_SC3_CALF(value)))
#define ADC_BWR_SC3_CALF(base, value) (BME_BFI32(&ADC_SC3_REG(base), ((uint32_t)(value) << ADC_SC3_CALF_SHIFT), ADC_SC3_CALF_SHIFT, ADC_SC3_CALF_WIDTH))
/*@}*/

/*!
 * @name Register ADC_SC3, field CAL[7] (RW)
 *
 * Begins the calibration sequence when set. This field stays set while the
 * calibration is in progress and is cleared when the calibration sequence is
 * completed. CALF must be checked to determine the result of the calibration sequence.
 * Once started, the calibration routine cannot be interrupted by writes to the
 * ADC registers or the results will be invalid and CALF will set. Setting CAL
 * will abort any current conversion.
 */
/*@{*/
/*! @brief Read current value of the ADC_SC3_CAL field. */
#define ADC_RD_SC3_CAL(base) ((ADC_SC3_REG(base) & ADC_SC3_CAL_MASK) >> ADC_SC3_CAL_SHIFT)
#define ADC_BRD_SC3_CAL(base) (BME_UBFX32(&ADC_SC3_REG(base), ADC_SC3_CAL_SHIFT, ADC_SC3_CAL_WIDTH))

/*! @brief Set the CAL field to a new value. */
#define ADC_WR_SC3_CAL(base, value) (ADC_RMW_SC3(base, (ADC_SC3_CAL_MASK | ADC_SC3_CALF_MASK), ADC_SC3_CAL(value)))
#define ADC_BWR_SC3_CAL(base, value) (BME_BFI32(&ADC_SC3_REG(base), ((uint32_t)(value) << ADC_SC3_CAL_SHIFT), ADC_SC3_CAL_SHIFT, ADC_SC3_CAL_WIDTH))
/*@}*/

/*******************************************************************************
 * ADC_OFS - ADC Offset Correction Register
 ******************************************************************************/

/*!
 * @brief ADC_OFS - ADC Offset Correction Register (RW)
 *
 * Reset value: 0x00000004U
 *
 * The ADC Offset Correction Register (OFS) contains the user-selected or
 * calibration-generated offset error correction value. This register is a 2's
 * complement, left-justified, 16-bit value . The value in OFS is subtracted from the
 * conversion and the result is transferred into the result registers, Rn. If the
 * result is greater than the maximum or less than the minimum result value, it is
 * forced to the appropriate limit for the current mode of operation. For more
 * information regarding the calibration procedure, please refer to the Calibration
 * functionThe ADC contains a self-calibration function that is required to
 * achieve the specified accuracy. section.
 */
/*!
 * @name Constants and macros for entire ADC_OFS register
 */
/*@{*/
#define ADC_RD_OFS(base)         (ADC_OFS_REG(base))
#define ADC_WR_OFS(base, value)  (ADC_OFS_REG(base) = (value))
#define ADC_RMW_OFS(base, mask, value) (ADC_WR_OFS(base, (ADC_RD_OFS(base) & ~(mask)) | (value)))
#define ADC_SET_OFS(base, value) (BME_OR32(&ADC_OFS_REG(base), (uint32_t)(value)))
#define ADC_CLR_OFS(base, value) (BME_AND32(&ADC_OFS_REG(base), (uint32_t)(~(value))))
#define ADC_TOG_OFS(base, value) (BME_XOR32(&ADC_OFS_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ADC_OFS bitfields
 */

/*!
 * @name Register ADC_OFS, field OFS[15:0] (RW)
 */
/*@{*/
/*! @brief Read current value of the ADC_OFS_OFS field. */
#define ADC_RD_OFS_OFS(base) ((ADC_OFS_REG(base) & ADC_OFS_OFS_MASK) >> ADC_OFS_OFS_SHIFT)
#define ADC_BRD_OFS_OFS(base) (BME_UBFX32(&ADC_OFS_REG(base), ADC_OFS_OFS_SHIFT, ADC_OFS_OFS_WIDTH))

/*! @brief Set the OFS field to a new value. */
#define ADC_WR_OFS_OFS(base, value) (ADC_RMW_OFS(base, ADC_OFS_OFS_MASK, ADC_OFS_OFS(value)))
#define ADC_BWR_OFS_OFS(base, value) (BME_BFI32(&ADC_OFS_REG(base), ((uint32_t)(value) << ADC_OFS_OFS_SHIFT), ADC_OFS_OFS_SHIFT, ADC_OFS_OFS_WIDTH))
/*@}*/

/*******************************************************************************
 * ADC_PG - ADC Plus-Side Gain Register
 ******************************************************************************/

/*!
 * @brief ADC_PG - ADC Plus-Side Gain Register (RW)
 *
 * Reset value: 0x00008200U
 *
 * The Plus-Side Gain Register (PG) contains the gain error correction for the
 * overall conversion in single-ended mode. PG, a 16-bit real number in binary
 * format, is the gain adjustment factor, with the radix point fixed between PG[15]
 * and PG[14]. This register must be written by the user with the value described
 * in the calibration procedure. Otherwise, the gain error specifications may
 * not be met. For more information regarding the calibration procedure, please
 * refer to the Calibration functionThe ADC contains a self-calibration function
 * that is required to achieve the specified accuracy. section.
 */
/*!
 * @name Constants and macros for entire ADC_PG register
 */
/*@{*/
#define ADC_RD_PG(base)          (ADC_PG_REG(base))
#define ADC_WR_PG(base, value)   (ADC_PG_REG(base) = (value))
#define ADC_RMW_PG(base, mask, value) (ADC_WR_PG(base, (ADC_RD_PG(base) & ~(mask)) | (value)))
#define ADC_SET_PG(base, value)  (BME_OR32(&ADC_PG_REG(base), (uint32_t)(value)))
#define ADC_CLR_PG(base, value)  (BME_AND32(&ADC_PG_REG(base), (uint32_t)(~(value))))
#define ADC_TOG_PG(base, value)  (BME_XOR32(&ADC_PG_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ADC_PG bitfields
 */

/*!
 * @name Register ADC_PG, field PG[15:0] (RW)
 */
/*@{*/
/*! @brief Read current value of the ADC_PG_PG field. */
#define ADC_RD_PG_PG(base)   ((ADC_PG_REG(base) & ADC_PG_PG_MASK) >> ADC_PG_PG_SHIFT)
#define ADC_BRD_PG_PG(base)  (BME_UBFX32(&ADC_PG_REG(base), ADC_PG_PG_SHIFT, ADC_PG_PG_WIDTH))

/*! @brief Set the PG field to a new value. */
#define ADC_WR_PG_PG(base, value) (ADC_RMW_PG(base, ADC_PG_PG_MASK, ADC_PG_PG(value)))
#define ADC_BWR_PG_PG(base, value) (BME_BFI32(&ADC_PG_REG(base), ((uint32_t)(value) << ADC_PG_PG_SHIFT), ADC_PG_PG_SHIFT, ADC_PG_PG_WIDTH))
/*@}*/

/*******************************************************************************
 * ADC_CLPD - ADC Plus-Side General Calibration Value Register
 ******************************************************************************/

/*!
 * @brief ADC_CLPD - ADC Plus-Side General Calibration Value Register (RW)
 *
 * Reset value: 0x0000000AU
 *
 * The Plus-Side General Calibration Value Registers (CLPx) contain calibration
 * information that is generated by the calibration function. These registers
 * contain seven calibration values of varying widths: CLP0[5:0], CLP1[6:0],
 * CLP2[7:0], CLP3[8:0], CLP4[9:0], CLPS[5:0], and CLPD[5:0]. CLPx are automatically set
 * when the self-calibration sequence is done, that is, CAL is cleared. If these
 * registers are written by the user after calibration, the linearity error
 * specifications may not be met. For more information regarding the calibration
 * procedure, please refer to the Calibration functionThe ADC contains a
 * self-calibration function that is required to achieve the specified accuracy. section.
 */
/*!
 * @name Constants and macros for entire ADC_CLPD register
 */
/*@{*/
#define ADC_RD_CLPD(base)        (ADC_CLPD_REG(base))
#define ADC_WR_CLPD(base, value) (ADC_CLPD_REG(base) = (value))
#define ADC_RMW_CLPD(base, mask, value) (ADC_WR_CLPD(base, (ADC_RD_CLPD(base) & ~(mask)) | (value)))
#define ADC_SET_CLPD(base, value) (BME_OR32(&ADC_CLPD_REG(base), (uint32_t)(value)))
#define ADC_CLR_CLPD(base, value) (BME_AND32(&ADC_CLPD_REG(base), (uint32_t)(~(value))))
#define ADC_TOG_CLPD(base, value) (BME_XOR32(&ADC_CLPD_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ADC_CLPD bitfields
 */

/*!
 * @name Register ADC_CLPD, field CLPD[5:0] (RW)
 *
 * Calibration Value
 */
/*@{*/
/*! @brief Read current value of the ADC_CLPD_CLPD field. */
#define ADC_RD_CLPD_CLPD(base) ((ADC_CLPD_REG(base) & ADC_CLPD_CLPD_MASK) >> ADC_CLPD_CLPD_SHIFT)
#define ADC_BRD_CLPD_CLPD(base) (BME_UBFX32(&ADC_CLPD_REG(base), ADC_CLPD_CLPD_SHIFT, ADC_CLPD_CLPD_WIDTH))

/*! @brief Set the CLPD field to a new value. */
#define ADC_WR_CLPD_CLPD(base, value) (ADC_RMW_CLPD(base, ADC_CLPD_CLPD_MASK, ADC_CLPD_CLPD(value)))
#define ADC_BWR_CLPD_CLPD(base, value) (BME_BFI32(&ADC_CLPD_REG(base), ((uint32_t)(value) << ADC_CLPD_CLPD_SHIFT), ADC_CLPD_CLPD_SHIFT, ADC_CLPD_CLPD_WIDTH))
/*@}*/

/*******************************************************************************
 * ADC_CLPS - ADC Plus-Side General Calibration Value Register
 ******************************************************************************/

/*!
 * @brief ADC_CLPS - ADC Plus-Side General Calibration Value Register (RW)
 *
 * Reset value: 0x00000020U
 *
 * For more information, see CLPD register description.
 */
/*!
 * @name Constants and macros for entire ADC_CLPS register
 */
/*@{*/
#define ADC_RD_CLPS(base)        (ADC_CLPS_REG(base))
#define ADC_WR_CLPS(base, value) (ADC_CLPS_REG(base) = (value))
#define ADC_RMW_CLPS(base, mask, value) (ADC_WR_CLPS(base, (ADC_RD_CLPS(base) & ~(mask)) | (value)))
#define ADC_SET_CLPS(base, value) (BME_OR32(&ADC_CLPS_REG(base), (uint32_t)(value)))
#define ADC_CLR_CLPS(base, value) (BME_AND32(&ADC_CLPS_REG(base), (uint32_t)(~(value))))
#define ADC_TOG_CLPS(base, value) (BME_XOR32(&ADC_CLPS_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ADC_CLPS bitfields
 */

/*!
 * @name Register ADC_CLPS, field CLPS[5:0] (RW)
 *
 * Calibration Value
 */
/*@{*/
/*! @brief Read current value of the ADC_CLPS_CLPS field. */
#define ADC_RD_CLPS_CLPS(base) ((ADC_CLPS_REG(base) & ADC_CLPS_CLPS_MASK) >> ADC_CLPS_CLPS_SHIFT)
#define ADC_BRD_CLPS_CLPS(base) (BME_UBFX32(&ADC_CLPS_REG(base), ADC_CLPS_CLPS_SHIFT, ADC_CLPS_CLPS_WIDTH))

/*! @brief Set the CLPS field to a new value. */
#define ADC_WR_CLPS_CLPS(base, value) (ADC_RMW_CLPS(base, ADC_CLPS_CLPS_MASK, ADC_CLPS_CLPS(value)))
#define ADC_BWR_CLPS_CLPS(base, value) (BME_BFI32(&ADC_CLPS_REG(base), ((uint32_t)(value) << ADC_CLPS_CLPS_SHIFT), ADC_CLPS_CLPS_SHIFT, ADC_CLPS_CLPS_WIDTH))
/*@}*/

/*******************************************************************************
 * ADC_CLP4 - ADC Plus-Side General Calibration Value Register
 ******************************************************************************/

/*!
 * @brief ADC_CLP4 - ADC Plus-Side General Calibration Value Register (RW)
 *
 * Reset value: 0x00000200U
 *
 * For more information, see CLPD register description.
 */
/*!
 * @name Constants and macros for entire ADC_CLP4 register
 */
/*@{*/
#define ADC_RD_CLP4(base)        (ADC_CLP4_REG(base))
#define ADC_WR_CLP4(base, value) (ADC_CLP4_REG(base) = (value))
#define ADC_RMW_CLP4(base, mask, value) (ADC_WR_CLP4(base, (ADC_RD_CLP4(base) & ~(mask)) | (value)))
#define ADC_SET_CLP4(base, value) (BME_OR32(&ADC_CLP4_REG(base), (uint32_t)(value)))
#define ADC_CLR_CLP4(base, value) (BME_AND32(&ADC_CLP4_REG(base), (uint32_t)(~(value))))
#define ADC_TOG_CLP4(base, value) (BME_XOR32(&ADC_CLP4_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ADC_CLP4 bitfields
 */

/*!
 * @name Register ADC_CLP4, field CLP4[9:0] (RW)
 *
 * Calibration Value
 */
/*@{*/
/*! @brief Read current value of the ADC_CLP4_CLP4 field. */
#define ADC_RD_CLP4_CLP4(base) ((ADC_CLP4_REG(base) & ADC_CLP4_CLP4_MASK) >> ADC_CLP4_CLP4_SHIFT)
#define ADC_BRD_CLP4_CLP4(base) (BME_UBFX32(&ADC_CLP4_REG(base), ADC_CLP4_CLP4_SHIFT, ADC_CLP4_CLP4_WIDTH))

/*! @brief Set the CLP4 field to a new value. */
#define ADC_WR_CLP4_CLP4(base, value) (ADC_RMW_CLP4(base, ADC_CLP4_CLP4_MASK, ADC_CLP4_CLP4(value)))
#define ADC_BWR_CLP4_CLP4(base, value) (BME_BFI32(&ADC_CLP4_REG(base), ((uint32_t)(value) << ADC_CLP4_CLP4_SHIFT), ADC_CLP4_CLP4_SHIFT, ADC_CLP4_CLP4_WIDTH))
/*@}*/

/*******************************************************************************
 * ADC_CLP3 - ADC Plus-Side General Calibration Value Register
 ******************************************************************************/

/*!
 * @brief ADC_CLP3 - ADC Plus-Side General Calibration Value Register (RW)
 *
 * Reset value: 0x00000100U
 *
 * For more information, see CLPD register description.
 */
/*!
 * @name Constants and macros for entire ADC_CLP3 register
 */
/*@{*/
#define ADC_RD_CLP3(base)        (ADC_CLP3_REG(base))
#define ADC_WR_CLP3(base, value) (ADC_CLP3_REG(base) = (value))
#define ADC_RMW_CLP3(base, mask, value) (ADC_WR_CLP3(base, (ADC_RD_CLP3(base) & ~(mask)) | (value)))
#define ADC_SET_CLP3(base, value) (BME_OR32(&ADC_CLP3_REG(base), (uint32_t)(value)))
#define ADC_CLR_CLP3(base, value) (BME_AND32(&ADC_CLP3_REG(base), (uint32_t)(~(value))))
#define ADC_TOG_CLP3(base, value) (BME_XOR32(&ADC_CLP3_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ADC_CLP3 bitfields
 */

/*!
 * @name Register ADC_CLP3, field CLP3[8:0] (RW)
 *
 * Calibration Value
 */
/*@{*/
/*! @brief Read current value of the ADC_CLP3_CLP3 field. */
#define ADC_RD_CLP3_CLP3(base) ((ADC_CLP3_REG(base) & ADC_CLP3_CLP3_MASK) >> ADC_CLP3_CLP3_SHIFT)
#define ADC_BRD_CLP3_CLP3(base) (BME_UBFX32(&ADC_CLP3_REG(base), ADC_CLP3_CLP3_SHIFT, ADC_CLP3_CLP3_WIDTH))

/*! @brief Set the CLP3 field to a new value. */
#define ADC_WR_CLP3_CLP3(base, value) (ADC_RMW_CLP3(base, ADC_CLP3_CLP3_MASK, ADC_CLP3_CLP3(value)))
#define ADC_BWR_CLP3_CLP3(base, value) (BME_BFI32(&ADC_CLP3_REG(base), ((uint32_t)(value) << ADC_CLP3_CLP3_SHIFT), ADC_CLP3_CLP3_SHIFT, ADC_CLP3_CLP3_WIDTH))
/*@}*/

/*******************************************************************************
 * ADC_CLP2 - ADC Plus-Side General Calibration Value Register
 ******************************************************************************/

/*!
 * @brief ADC_CLP2 - ADC Plus-Side General Calibration Value Register (RW)
 *
 * Reset value: 0x00000080U
 *
 * For more information, see CLPD register description.
 */
/*!
 * @name Constants and macros for entire ADC_CLP2 register
 */
/*@{*/
#define ADC_RD_CLP2(base)        (ADC_CLP2_REG(base))
#define ADC_WR_CLP2(base, value) (ADC_CLP2_REG(base) = (value))
#define ADC_RMW_CLP2(base, mask, value) (ADC_WR_CLP2(base, (ADC_RD_CLP2(base) & ~(mask)) | (value)))
#define ADC_SET_CLP2(base, value) (BME_OR32(&ADC_CLP2_REG(base), (uint32_t)(value)))
#define ADC_CLR_CLP2(base, value) (BME_AND32(&ADC_CLP2_REG(base), (uint32_t)(~(value))))
#define ADC_TOG_CLP2(base, value) (BME_XOR32(&ADC_CLP2_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ADC_CLP2 bitfields
 */

/*!
 * @name Register ADC_CLP2, field CLP2[7:0] (RW)
 *
 * Calibration Value
 */
/*@{*/
/*! @brief Read current value of the ADC_CLP2_CLP2 field. */
#define ADC_RD_CLP2_CLP2(base) ((ADC_CLP2_REG(base) & ADC_CLP2_CLP2_MASK) >> ADC_CLP2_CLP2_SHIFT)
#define ADC_BRD_CLP2_CLP2(base) (BME_UBFX32(&ADC_CLP2_REG(base), ADC_CLP2_CLP2_SHIFT, ADC_CLP2_CLP2_WIDTH))

/*! @brief Set the CLP2 field to a new value. */
#define ADC_WR_CLP2_CLP2(base, value) (ADC_RMW_CLP2(base, ADC_CLP2_CLP2_MASK, ADC_CLP2_CLP2(value)))
#define ADC_BWR_CLP2_CLP2(base, value) (BME_BFI32(&ADC_CLP2_REG(base), ((uint32_t)(value) << ADC_CLP2_CLP2_SHIFT), ADC_CLP2_CLP2_SHIFT, ADC_CLP2_CLP2_WIDTH))
/*@}*/

/*******************************************************************************
 * ADC_CLP1 - ADC Plus-Side General Calibration Value Register
 ******************************************************************************/

/*!
 * @brief ADC_CLP1 - ADC Plus-Side General Calibration Value Register (RW)
 *
 * Reset value: 0x00000040U
 *
 * For more information, see CLPD register description.
 */
/*!
 * @name Constants and macros for entire ADC_CLP1 register
 */
/*@{*/
#define ADC_RD_CLP1(base)        (ADC_CLP1_REG(base))
#define ADC_WR_CLP1(base, value) (ADC_CLP1_REG(base) = (value))
#define ADC_RMW_CLP1(base, mask, value) (ADC_WR_CLP1(base, (ADC_RD_CLP1(base) & ~(mask)) | (value)))
#define ADC_SET_CLP1(base, value) (BME_OR32(&ADC_CLP1_REG(base), (uint32_t)(value)))
#define ADC_CLR_CLP1(base, value) (BME_AND32(&ADC_CLP1_REG(base), (uint32_t)(~(value))))
#define ADC_TOG_CLP1(base, value) (BME_XOR32(&ADC_CLP1_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ADC_CLP1 bitfields
 */

/*!
 * @name Register ADC_CLP1, field CLP1[6:0] (RW)
 *
 * Calibration Value
 */
/*@{*/
/*! @brief Read current value of the ADC_CLP1_CLP1 field. */
#define ADC_RD_CLP1_CLP1(base) ((ADC_CLP1_REG(base) & ADC_CLP1_CLP1_MASK) >> ADC_CLP1_CLP1_SHIFT)
#define ADC_BRD_CLP1_CLP1(base) (BME_UBFX32(&ADC_CLP1_REG(base), ADC_CLP1_CLP1_SHIFT, ADC_CLP1_CLP1_WIDTH))

/*! @brief Set the CLP1 field to a new value. */
#define ADC_WR_CLP1_CLP1(base, value) (ADC_RMW_CLP1(base, ADC_CLP1_CLP1_MASK, ADC_CLP1_CLP1(value)))
#define ADC_BWR_CLP1_CLP1(base, value) (BME_BFI32(&ADC_CLP1_REG(base), ((uint32_t)(value) << ADC_CLP1_CLP1_SHIFT), ADC_CLP1_CLP1_SHIFT, ADC_CLP1_CLP1_WIDTH))
/*@}*/

/*******************************************************************************
 * ADC_CLP0 - ADC Plus-Side General Calibration Value Register
 ******************************************************************************/

/*!
 * @brief ADC_CLP0 - ADC Plus-Side General Calibration Value Register (RW)
 *
 * Reset value: 0x00000020U
 *
 * For more information, see CLPD register description.
 */
/*!
 * @name Constants and macros for entire ADC_CLP0 register
 */
/*@{*/
#define ADC_RD_CLP0(base)        (ADC_CLP0_REG(base))
#define ADC_WR_CLP0(base, value) (ADC_CLP0_REG(base) = (value))
#define ADC_RMW_CLP0(base, mask, value) (ADC_WR_CLP0(base, (ADC_RD_CLP0(base) & ~(mask)) | (value)))
#define ADC_SET_CLP0(base, value) (BME_OR32(&ADC_CLP0_REG(base), (uint32_t)(value)))
#define ADC_CLR_CLP0(base, value) (BME_AND32(&ADC_CLP0_REG(base), (uint32_t)(~(value))))
#define ADC_TOG_CLP0(base, value) (BME_XOR32(&ADC_CLP0_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ADC_CLP0 bitfields
 */

/*!
 * @name Register ADC_CLP0, field CLP0[5:0] (RW)
 *
 * Calibration Value
 */
/*@{*/
/*! @brief Read current value of the ADC_CLP0_CLP0 field. */
#define ADC_RD_CLP0_CLP0(base) ((ADC_CLP0_REG(base) & ADC_CLP0_CLP0_MASK) >> ADC_CLP0_CLP0_SHIFT)
#define ADC_BRD_CLP0_CLP0(base) (BME_UBFX32(&ADC_CLP0_REG(base), ADC_CLP0_CLP0_SHIFT, ADC_CLP0_CLP0_WIDTH))

/*! @brief Set the CLP0 field to a new value. */
#define ADC_WR_CLP0_CLP0(base, value) (ADC_RMW_CLP0(base, ADC_CLP0_CLP0_MASK, ADC_CLP0_CLP0(value)))
#define ADC_BWR_CLP0_CLP0(base, value) (BME_BFI32(&ADC_CLP0_REG(base), ((uint32_t)(value) << ADC_CLP0_CLP0_SHIFT), ADC_CLP0_CLP0_SHIFT, ADC_CLP0_CLP0_WIDTH))
/*@}*/

/*
 * MKM34Z7 AFE
 *
 * This section describes the ADC registers.
 *
 * Registers defined in this header file:
 * - AFE_CFR - Channel0 Configuration Register
 * - AFE_CR - Control Register
 * - AFE_CKR - Clock Configuration Register
 * - AFE_DI - DMA and Interrupt Register
 * - AFE_DR - Channel0 Delay Register
 * - AFE_RR - Channel0 Result Register
 * - AFE_SR - Status Register
 */

#define AFE_INSTANCE_COUNT (1U) /*!< Number of instances of the AFE module. */
#define AFE_IDX (0U) /*!< Instance number for AFE. */

/*******************************************************************************
 * AFE_CFR - Channel0 Configuration Register
 ******************************************************************************/

/*!
 * @brief AFE_CFR - Channel0 Configuration Register (RW)
 *
 * Reset value: 0x00080000U
 *
 * Channel0 Configuration Register has various fields to configure channel0 of
 * AFE. Any changes done in this register while the conversion is in progress will
 * come into effect from next conversion only.
 */
/*!
 * @name Constants and macros for entire AFE_CFR register
 */
/*@{*/
#define AFE_RD_CFR(base, index)  (AFE_CFR_REG(base, index))
#define AFE_WR_CFR(base, index, value) (AFE_CFR_REG(base, index) = (value))
#define AFE_RMW_CFR(base, index, mask, value) (AFE_WR_CFR(base, index, (AFE_RD_CFR(base, index) & ~(mask)) | (value)))
#define AFE_SET_CFR(base, index, value) (BME_OR32(&AFE_CFR_REG(base, index), (uint32_t)(value)))
#define AFE_CLR_CFR(base, index, value) (BME_AND32(&AFE_CFR_REG(base, index), (uint32_t)(~(value))))
#define AFE_TOG_CFR(base, index, value) (BME_XOR32(&AFE_CFR_REG(base, index), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual AFE_CFR bitfields
 */

/*!
 * @name Register AFE_CFR, field HW_TRG[9] (RW)
 *
 * This field is used to select trigger source for conversion.
 *
 * Values:
 * - 0b0 - Software trigger select
 * - 0b1 - Hardware trigger select
 */
/*@{*/
/*! @brief Read current value of the AFE_CFR_HW_TRG field. */
#define AFE_RD_CFR_HW_TRG(base, index) ((AFE_CFR_REG(base, index) & AFE_CFR_HW_TRG_MASK) >> AFE_CFR_HW_TRG_SHIFT)
#define AFE_BRD_CFR_HW_TRG(base, index) (BME_UBFX32(&AFE_CFR_REG(base, index), AFE_CFR_HW_TRG_SHIFT, AFE_CFR_HW_TRG_WIDTH))

/*! @brief Set the HW_TRG field to a new value. */
#define AFE_WR_CFR_HW_TRG(base, index, value) (AFE_RMW_CFR(base, index, AFE_CFR_HW_TRG_MASK, AFE_CFR_HW_TRG(value)))
#define AFE_BWR_CFR_HW_TRG(base, index, value) (BME_BFI32(&AFE_CFR_REG(base, index), ((uint32_t)(value) << AFE_CFR_HW_TRG_SHIFT), AFE_CFR_HW_TRG_SHIFT, AFE_CFR_HW_TRG_WIDTH))
/*@}*/

/*!
 * @name Register AFE_CFR, field DEC_CLK_INP_SEL[10] (RW)
 *
 * This field is used to select on the chip modulator clock or an external clock
 * for the decimator in case of bypass mode.
 *
 * Values:
 * - 0b0 - On the chip modulator clock will be used
 * - 0b1 - External clock will be used.
 */
/*@{*/
/*! @brief Read current value of the AFE_CFR_DEC_CLK_INP_SEL field. */
#define AFE_RD_CFR_DEC_CLK_INP_SEL(base, index) ((AFE_CFR_REG(base, index) & AFE_CFR_DEC_CLK_INP_SEL_MASK) >> AFE_CFR_DEC_CLK_INP_SEL_SHIFT)
#define AFE_BRD_CFR_DEC_CLK_INP_SEL(base, index) (BME_UBFX32(&AFE_CFR_REG(base, index), AFE_CFR_DEC_CLK_INP_SEL_SHIFT, AFE_CFR_DEC_CLK_INP_SEL_WIDTH))

/*! @brief Set the DEC_CLK_INP_SEL field to a new value. */
#define AFE_WR_CFR_DEC_CLK_INP_SEL(base, index, value) (AFE_RMW_CFR(base, index, AFE_CFR_DEC_CLK_INP_SEL_MASK, AFE_CFR_DEC_CLK_INP_SEL(value)))
#define AFE_BWR_CFR_DEC_CLK_INP_SEL(base, index, value) (BME_BFI32(&AFE_CFR_REG(base, index), ((uint32_t)(value) << AFE_CFR_DEC_CLK_INP_SEL_SHIFT), AFE_CFR_DEC_CLK_INP_SEL_SHIFT, AFE_CFR_DEC_CLK_INP_SEL_WIDTH))
/*@}*/

/*!
 * @name Register AFE_CFR, field DEC_CLK_EDGE_SEL[11] (RW)
 *
 * This field is used to select rising edge or falling edge for registering
 * input data by the decimation filter in case of by-pass mode.
 *
 * Values:
 * - 0b0 - Posedge will be used.
 * - 0b1 - Negedge will be used.
 */
/*@{*/
/*! @brief Read current value of the AFE_CFR_DEC_CLK_EDGE_SEL field. */
#define AFE_RD_CFR_DEC_CLK_EDGE_SEL(base, index) ((AFE_CFR_REG(base, index) & AFE_CFR_DEC_CLK_EDGE_SEL_MASK) >> AFE_CFR_DEC_CLK_EDGE_SEL_SHIFT)
#define AFE_BRD_CFR_DEC_CLK_EDGE_SEL(base, index) (BME_UBFX32(&AFE_CFR_REG(base, index), AFE_CFR_DEC_CLK_EDGE_SEL_SHIFT, AFE_CFR_DEC_CLK_EDGE_SEL_WIDTH))

/*! @brief Set the DEC_CLK_EDGE_SEL field to a new value. */
#define AFE_WR_CFR_DEC_CLK_EDGE_SEL(base, index, value) (AFE_RMW_CFR(base, index, AFE_CFR_DEC_CLK_EDGE_SEL_MASK, AFE_CFR_DEC_CLK_EDGE_SEL(value)))
#define AFE_BWR_CFR_DEC_CLK_EDGE_SEL(base, index, value) (BME_BFI32(&AFE_CFR_REG(base, index), ((uint32_t)(value) << AFE_CFR_DEC_CLK_EDGE_SEL_SHIFT), AFE_CFR_DEC_CLK_EDGE_SEL_SHIFT, AFE_CFR_DEC_CLK_EDGE_SEL_WIDTH))
/*@}*/

/*!
 * @name Register AFE_CFR, field CC[12] (RW)
 *
 * Values:
 * - 0b0 - One conversion following a triggering event
 * - 0b1 - Continuous conversions following a triggering event.
 */
/*@{*/
/*! @brief Read current value of the AFE_CFR_CC field. */
#define AFE_RD_CFR_CC(base, index) ((AFE_CFR_REG(base, index) & AFE_CFR_CC_MASK) >> AFE_CFR_CC_SHIFT)
#define AFE_BRD_CFR_CC(base, index) (BME_UBFX32(&AFE_CFR_REG(base, index), AFE_CFR_CC_SHIFT, AFE_CFR_CC_WIDTH))

/*! @brief Set the CC field to a new value. */
#define AFE_WR_CFR_CC(base, index, value) (AFE_RMW_CFR(base, index, AFE_CFR_CC_MASK, AFE_CFR_CC(value)))
#define AFE_BWR_CFR_CC(base, index, value) (BME_BFI32(&AFE_CFR_REG(base, index), ((uint32_t)(value) << AFE_CFR_CC_SHIFT), AFE_CFR_CC_SHIFT, AFE_CFR_CC_WIDTH))
/*@}*/

/*!
 * @name Register AFE_CFR, field DEC_EN[13] (RW)
 *
 * This is used to enable decimation filter.
 *
 * Values:
 * - 0b0 - Decimation filter is disabled.
 * - 0b1 - Decimation filter is enabled.
 */
/*@{*/
/*! @brief Read current value of the AFE_CFR_DEC_EN field. */
#define AFE_RD_CFR_DEC_EN(base, index) ((AFE_CFR_REG(base, index) & AFE_CFR_DEC_EN_MASK) >> AFE_CFR_DEC_EN_SHIFT)
#define AFE_BRD_CFR_DEC_EN(base, index) (BME_UBFX32(&AFE_CFR_REG(base, index), AFE_CFR_DEC_EN_SHIFT, AFE_CFR_DEC_EN_WIDTH))

/*! @brief Set the DEC_EN field to a new value. */
#define AFE_WR_CFR_DEC_EN(base, index, value) (AFE_RMW_CFR(base, index, AFE_CFR_DEC_EN_MASK, AFE_CFR_DEC_EN(value)))
#define AFE_BWR_CFR_DEC_EN(base, index, value) (BME_BFI32(&AFE_CFR_REG(base, index), ((uint32_t)(value) << AFE_CFR_DEC_EN_SHIFT), AFE_CFR_DEC_EN_SHIFT, AFE_CFR_DEC_EN_WIDTH))
/*@}*/

/*!
 * @name Register AFE_CFR, field SD_MOD_EN[14] (RW)
 *
 * This is used to enable SD ADC1 .
 *
 * Values:
 * - 0b0 - SD ADC1 is disabled
 * - 0b1 - SD ADC1 is enabled
 */
/*@{*/
/*! @brief Read current value of the AFE_CFR_SD_MOD_EN field. */
#define AFE_RD_CFR_SD_MOD_EN(base, index) ((AFE_CFR_REG(base, index) & AFE_CFR_SD_MOD_EN_MASK) >> AFE_CFR_SD_MOD_EN_SHIFT)
#define AFE_BRD_CFR_SD_MOD_EN(base, index) (BME_UBFX32(&AFE_CFR_REG(base, index), AFE_CFR_SD_MOD_EN_SHIFT, AFE_CFR_SD_MOD_EN_WIDTH))

/*! @brief Set the SD_MOD_EN field to a new value. */
#define AFE_WR_CFR_SD_MOD_EN(base, index, value) (AFE_RMW_CFR(base, index, AFE_CFR_SD_MOD_EN_MASK, AFE_CFR_SD_MOD_EN(value)))
#define AFE_BWR_CFR_SD_MOD_EN(base, index, value) (BME_BFI32(&AFE_CFR_REG(base, index), ((uint32_t)(value) << AFE_CFR_SD_MOD_EN_SHIFT), AFE_CFR_SD_MOD_EN_SHIFT, AFE_CFR_SD_MOD_EN_WIDTH))
/*@}*/

/*!
 * @name Register AFE_CFR, field BYP_MODE[17] (RW)
 *
 * This field is used to disable internal modulators of channel0. External
 * modulators will be used.
 *
 * Values:
 * - 0b0 - Normal mode
 * - 0b1 - Bypass mode where ADC and PGA of channel0 are disabled.
 */
/*@{*/
/*! @brief Read current value of the AFE_CFR_BYP_MODE field. */
#define AFE_RD_CFR_BYP_MODE(base, index) ((AFE_CFR_REG(base, index) & AFE_CFR_BYP_MODE_MASK) >> AFE_CFR_BYP_MODE_SHIFT)
#define AFE_BRD_CFR_BYP_MODE(base, index) (BME_UBFX32(&AFE_CFR_REG(base, index), AFE_CFR_BYP_MODE_SHIFT, AFE_CFR_BYP_MODE_WIDTH))

/*! @brief Set the BYP_MODE field to a new value. */
#define AFE_WR_CFR_BYP_MODE(base, index, value) (AFE_RMW_CFR(base, index, AFE_CFR_BYP_MODE_MASK, AFE_CFR_BYP_MODE(value)))
#define AFE_BWR_CFR_BYP_MODE(base, index, value) (BME_BFI32(&AFE_CFR_REG(base, index), ((uint32_t)(value) << AFE_CFR_BYP_MODE_SHIFT), AFE_CFR_BYP_MODE_SHIFT, AFE_CFR_BYP_MODE_WIDTH))
/*@}*/

/*!
 * @name Register AFE_CFR, field PGA_GAIN_SEL[21:19] (RW)
 *
 * This field selects the analog gain applied to the input signal.
 *
 * Values:
 * - 0b000 - reserved
 * - 0b001 - 1x (default)
 * - 0b010 - 2x
 * - 0b011 - 4x
 * - 0b100 - 8x
 * - 0b101 - 16x
 * - 0b110 - 32x
 * - 0b111 - reserved
 */
/*@{*/
/*! @brief Read current value of the AFE_CFR_PGA_GAIN_SEL field. */
#define AFE_RD_CFR_PGA_GAIN_SEL(base, index) ((AFE_CFR_REG(base, index) & AFE_CFR_PGA_GAIN_SEL_MASK) >> AFE_CFR_PGA_GAIN_SEL_SHIFT)
#define AFE_BRD_CFR_PGA_GAIN_SEL(base, index) (BME_UBFX32(&AFE_CFR_REG(base, index), AFE_CFR_PGA_GAIN_SEL_SHIFT, AFE_CFR_PGA_GAIN_SEL_WIDTH))

/*! @brief Set the PGA_GAIN_SEL field to a new value. */
#define AFE_WR_CFR_PGA_GAIN_SEL(base, index, value) (AFE_RMW_CFR(base, index, AFE_CFR_PGA_GAIN_SEL_MASK, AFE_CFR_PGA_GAIN_SEL(value)))
#define AFE_BWR_CFR_PGA_GAIN_SEL(base, index, value) (BME_BFI32(&AFE_CFR_REG(base, index), ((uint32_t)(value) << AFE_CFR_PGA_GAIN_SEL_SHIFT), AFE_CFR_PGA_GAIN_SEL_SHIFT, AFE_CFR_PGA_GAIN_SEL_WIDTH))
/*@}*/

/*!
 * @name Register AFE_CFR, field PGA_EN[24] (RW)
 *
 * It enables the PGA gain stage.
 *
 * Values:
 * - 0b0 - PGA disabled
 * - 0b1 - PGA enabled
 */
/*@{*/
/*! @brief Read current value of the AFE_CFR_PGA_EN field. */
#define AFE_RD_CFR_PGA_EN(base, index) ((AFE_CFR_REG(base, index) & AFE_CFR_PGA_EN_MASK) >> AFE_CFR_PGA_EN_SHIFT)
#define AFE_BRD_CFR_PGA_EN(base, index) (BME_UBFX32(&AFE_CFR_REG(base, index), AFE_CFR_PGA_EN_SHIFT, AFE_CFR_PGA_EN_WIDTH))

/*! @brief Set the PGA_EN field to a new value. */
#define AFE_WR_CFR_PGA_EN(base, index, value) (AFE_RMW_CFR(base, index, AFE_CFR_PGA_EN_MASK, AFE_CFR_PGA_EN(value)))
#define AFE_BWR_CFR_PGA_EN(base, index, value) (BME_BFI32(&AFE_CFR_REG(base, index), ((uint32_t)(value) << AFE_CFR_PGA_EN_SHIFT), AFE_CFR_PGA_EN_SHIFT, AFE_CFR_PGA_EN_WIDTH))
/*@}*/

/*!
 * @name Register AFE_CFR, field DEC_OSR[31:29] (RW)
 *
 * This field selects the oversampling ratio. It should not be modified while
 * the filter is operating. The Sinc filter output is scaled based on the OSR to
 * produce a 24 bit signed, two's complement output..
 *
 * Values:
 * - 0b000 - 64
 * - 0b001 - 128
 * - 0b010 - 256
 * - 0b011 - 512
 * - 0b100 - 1024
 * - 0b101 - 2048
 */
/*@{*/
/*! @brief Read current value of the AFE_CFR_DEC_OSR field. */
#define AFE_RD_CFR_DEC_OSR(base, index) ((AFE_CFR_REG(base, index) & AFE_CFR_DEC_OSR_MASK) >> AFE_CFR_DEC_OSR_SHIFT)
#define AFE_BRD_CFR_DEC_OSR(base, index) (BME_UBFX32(&AFE_CFR_REG(base, index), AFE_CFR_DEC_OSR_SHIFT, AFE_CFR_DEC_OSR_WIDTH))

/*! @brief Set the DEC_OSR field to a new value. */
#define AFE_WR_CFR_DEC_OSR(base, index, value) (AFE_RMW_CFR(base, index, AFE_CFR_DEC_OSR_MASK, AFE_CFR_DEC_OSR(value)))
#define AFE_BWR_CFR_DEC_OSR(base, index, value) (BME_BFI32(&AFE_CFR_REG(base, index), ((uint32_t)(value) << AFE_CFR_DEC_OSR_SHIFT), AFE_CFR_DEC_OSR_SHIFT, AFE_CFR_DEC_OSR_WIDTH))
/*@}*/

/*******************************************************************************
 * AFE_CR - Control Register
 ******************************************************************************/

/*!
 * @brief AFE_CR - Control Register (RW)
 *
 * Reset value: 0x0040FA00U
 *
 * AFE Control Register has fields to control the global features of all
 * channels of AFE.
 */
/*!
 * @name Constants and macros for entire AFE_CR register
 */
/*@{*/
#define AFE_RD_CR(base)          (AFE_CR_REG(base))
#define AFE_WR_CR(base, value)   (AFE_CR_REG(base) = (value))
#define AFE_RMW_CR(base, mask, value) (AFE_WR_CR(base, (AFE_RD_CR(base) & ~(mask)) | (value)))
#define AFE_SET_CR(base, value)  (BME_OR32(&AFE_CR_REG(base), (uint32_t)(value)))
#define AFE_CLR_CR(base, value)  (BME_AND32(&AFE_CR_REG(base), (uint32_t)(~(value))))
#define AFE_TOG_CR(base, value)  (BME_XOR32(&AFE_CR_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual AFE_CR bitfields
 */

/*!
 * @name Register AFE_CR, field STRTUP_CNT[15:9] (RW)
 *
 * This field is used to program the start up delay of modulators. Minimum value
 * is two. if set less than that it would be converted to two.
 */
/*@{*/
/*! @brief Read current value of the AFE_CR_STRTUP_CNT field. */
#define AFE_RD_CR_STRTUP_CNT(base) ((AFE_CR_REG(base) & AFE_CR_STRTUP_CNT_MASK) >> AFE_CR_STRTUP_CNT_SHIFT)
#define AFE_BRD_CR_STRTUP_CNT(base) (BME_UBFX32(&AFE_CR_REG(base), AFE_CR_STRTUP_CNT_SHIFT, AFE_CR_STRTUP_CNT_WIDTH))

/*! @brief Set the STRTUP_CNT field to a new value. */
#define AFE_WR_CR_STRTUP_CNT(base, value) (AFE_RMW_CR(base, AFE_CR_STRTUP_CNT_MASK, AFE_CR_STRTUP_CNT(value)))
#define AFE_BWR_CR_STRTUP_CNT(base, value) (BME_BFI32(&AFE_CR_REG(base), ((uint32_t)(value) << AFE_CR_STRTUP_CNT_SHIFT), AFE_CR_STRTUP_CNT_SHIFT, AFE_CR_STRTUP_CNT_WIDTH))
/*@}*/

/*!
 * @name Register AFE_CR, field RESULT_FORMAT[18] (RW)
 *
 * This field can be used to select AFE Result Register formating.
 *
 * Values:
 * - 0b0 - Left justified 2's complement 32-bit :
 *     SVVVVVVVVVVVVVVVVVVVVVVV00000000 where (S= sign bit , V=valid result value, 0=zero)
 * - 0b1 - Right justified 2's complement 32-bit :
 *     SSSSSSSSSVVVVVVVVVVVVVVVVVVVVVVV where (S= sign bit , V= valid result value, 0= zero)
 */
/*@{*/
/*! @brief Read current value of the AFE_CR_RESULT_FORMAT field. */
#define AFE_RD_CR_RESULT_FORMAT(base) ((AFE_CR_REG(base) & AFE_CR_RESULT_FORMAT_MASK) >> AFE_CR_RESULT_FORMAT_SHIFT)
#define AFE_BRD_CR_RESULT_FORMAT(base) (BME_UBFX32(&AFE_CR_REG(base), AFE_CR_RESULT_FORMAT_SHIFT, AFE_CR_RESULT_FORMAT_WIDTH))

/*! @brief Set the RESULT_FORMAT field to a new value. */
#define AFE_WR_CR_RESULT_FORMAT(base, value) (AFE_RMW_CR(base, AFE_CR_RESULT_FORMAT_MASK, AFE_CR_RESULT_FORMAT(value)))
#define AFE_BWR_CR_RESULT_FORMAT(base, value) (BME_BFI32(&AFE_CR_REG(base), ((uint32_t)(value) << AFE_CR_RESULT_FORMAT_SHIFT), AFE_CR_RESULT_FORMAT_SHIFT, AFE_CR_RESULT_FORMAT_WIDTH))
/*@}*/

/*!
 * @name Register AFE_CR, field DLY_OK[21] (WORZ)
 *
 * This field should be asserted after all the four delay registers are loaded.
 * DLY values in CHx_DR will become active when DLY_OK =1 and "a new conversion
 * starts". This bit is self clearing.
 */
/*@{*/
/*! @brief Set the DLY_OK field to a new value. */
#define AFE_WR_CR_DLY_OK(base, value) (AFE_RMW_CR(base, AFE_CR_DLY_OK_MASK, AFE_CR_DLY_OK(value)))
#define AFE_BWR_CR_DLY_OK(base, value) (BME_BFI32(&AFE_CR_REG(base), ((uint32_t)(value) << AFE_CR_DLY_OK_SHIFT), AFE_CR_DLY_OK_SHIFT, AFE_CR_DLY_OK_WIDTH))
/*@}*/

/*!
 * @name Register AFE_CR, field RST_B[22] (RW)
 *
 * RST_B field is used to reset all ADCs, PGAs , Decimation filters and Clock
 * configuration bits.
 *
 * Values:
 * - 0b0 - All ADCs, PGAs and Decimation filters are disabled. Clock
 *     Configuration bits will be reset.
 * - 0b1 - .= All ADCs, PGAs and Decimation filters are enabled.
 */
/*@{*/
/*! @brief Read current value of the AFE_CR_RST_B field. */
#define AFE_RD_CR_RST_B(base) ((AFE_CR_REG(base) & AFE_CR_RST_B_MASK) >> AFE_CR_RST_B_SHIFT)
#define AFE_BRD_CR_RST_B(base) (BME_UBFX32(&AFE_CR_REG(base), AFE_CR_RST_B_SHIFT, AFE_CR_RST_B_WIDTH))

/*! @brief Set the RST_B field to a new value. */
#define AFE_WR_CR_RST_B(base, value) (AFE_RMW_CR(base, AFE_CR_RST_B_MASK, AFE_CR_RST_B(value)))
#define AFE_BWR_CR_RST_B(base, value) (BME_BFI32(&AFE_CR_REG(base), ((uint32_t)(value) << AFE_CR_RST_B_SHIFT), AFE_CR_RST_B_SHIFT, AFE_CR_RST_B_WIDTH))
/*@}*/

/*!
 * @name Register AFE_CR, field LPM_EN[25] (RW)
 *
 * Values:
 * - 0b0 - AFE will be in normal mode
 * - 0b1 - AFE will be in low power mode. Setting this bit reduce the current
 *     consumption of ADC and Buffer Amplifier , the max modulator clock frequency
 *     is below 1Mhz.
 */
/*@{*/
/*! @brief Read current value of the AFE_CR_LPM_EN field. */
#define AFE_RD_CR_LPM_EN(base) ((AFE_CR_REG(base) & AFE_CR_LPM_EN_MASK) >> AFE_CR_LPM_EN_SHIFT)
#define AFE_BRD_CR_LPM_EN(base) (BME_UBFX32(&AFE_CR_REG(base), AFE_CR_LPM_EN_SHIFT, AFE_CR_LPM_EN_WIDTH))

/*! @brief Set the LPM_EN field to a new value. */
#define AFE_WR_CR_LPM_EN(base, value) (AFE_RMW_CR(base, AFE_CR_LPM_EN_MASK, AFE_CR_LPM_EN(value)))
#define AFE_BWR_CR_LPM_EN(base, value) (BME_BFI32(&AFE_CR_REG(base), ((uint32_t)(value) << AFE_CR_LPM_EN_SHIFT), AFE_CR_LPM_EN_SHIFT, AFE_CR_LPM_EN_WIDTH))
/*@}*/

/*!
 * @name Register AFE_CR, field SOFT_TRG3[27] (WORZ)
 *
 * This field is set to trigger conversion on AFE Channel3.
 */
/*@{*/
/*! @brief Set the SOFT_TRG3 field to a new value. */
#define AFE_WR_CR_SOFT_TRG3(base, value) (AFE_RMW_CR(base, AFE_CR_SOFT_TRG3_MASK, AFE_CR_SOFT_TRG3(value)))
#define AFE_BWR_CR_SOFT_TRG3(base, value) (BME_BFI32(&AFE_CR_REG(base), ((uint32_t)(value) << AFE_CR_SOFT_TRG3_SHIFT), AFE_CR_SOFT_TRG3_SHIFT, AFE_CR_SOFT_TRG3_WIDTH))
/*@}*/

/*!
 * @name Register AFE_CR, field SOFT_TRG2[28] (WORZ)
 *
 * This field is set to trigger conversion on AFE Channel2.
 */
/*@{*/
/*! @brief Set the SOFT_TRG2 field to a new value. */
#define AFE_WR_CR_SOFT_TRG2(base, value) (AFE_RMW_CR(base, AFE_CR_SOFT_TRG2_MASK, AFE_CR_SOFT_TRG2(value)))
#define AFE_BWR_CR_SOFT_TRG2(base, value) (BME_BFI32(&AFE_CR_REG(base), ((uint32_t)(value) << AFE_CR_SOFT_TRG2_SHIFT), AFE_CR_SOFT_TRG2_SHIFT, AFE_CR_SOFT_TRG2_WIDTH))
/*@}*/

/*!
 * @name Register AFE_CR, field SOFT_TRG1[29] (WORZ)
 *
 * This field is set to trigger conversion on AFE Channel1.
 */
/*@{*/
/*! @brief Set the SOFT_TRG1 field to a new value. */
#define AFE_WR_CR_SOFT_TRG1(base, value) (AFE_RMW_CR(base, AFE_CR_SOFT_TRG1_MASK, AFE_CR_SOFT_TRG1(value)))
#define AFE_BWR_CR_SOFT_TRG1(base, value) (BME_BFI32(&AFE_CR_REG(base), ((uint32_t)(value) << AFE_CR_SOFT_TRG1_SHIFT), AFE_CR_SOFT_TRG1_SHIFT, AFE_CR_SOFT_TRG1_WIDTH))
/*@}*/

/*!
 * @name Register AFE_CR, field SOFT_TRG0[30] (WORZ)
 *
 * This field is set to trigger conversion on AFE Channel0.
 */
/*@{*/
/*! @brief Set the SOFT_TRG0 field to a new value. */
#define AFE_WR_CR_SOFT_TRG0(base, value) (AFE_RMW_CR(base, AFE_CR_SOFT_TRG0_MASK, AFE_CR_SOFT_TRG0(value)))
#define AFE_BWR_CR_SOFT_TRG0(base, value) (BME_BFI32(&AFE_CR_REG(base), ((uint32_t)(value) << AFE_CR_SOFT_TRG0_SHIFT), AFE_CR_SOFT_TRG0_SHIFT, AFE_CR_SOFT_TRG0_WIDTH))
/*@}*/

/*!
 * @name Register AFE_CR, field MSTR_EN[31] (RW)
 *
 * Setting this bit enables all ADCs and filters simultaneously whose SD_MOD_EN
 * and DEC_EN is asserted. If AFE bypass mode is enabled SD_MOD_EN bit will be
 * ignored.
 *
 * Values:
 * - 0b0 - All ADCs are disabled.
 * - 0b1 - All ADCs and filters will get simultaneously enabled .
 */
/*@{*/
/*! @brief Read current value of the AFE_CR_MSTR_EN field. */
#define AFE_RD_CR_MSTR_EN(base) ((AFE_CR_REG(base) & AFE_CR_MSTR_EN_MASK) >> AFE_CR_MSTR_EN_SHIFT)
#define AFE_BRD_CR_MSTR_EN(base) (BME_UBFX32(&AFE_CR_REG(base), AFE_CR_MSTR_EN_SHIFT, AFE_CR_MSTR_EN_WIDTH))

/*! @brief Set the MSTR_EN field to a new value. */
#define AFE_WR_CR_MSTR_EN(base, value) (AFE_RMW_CR(base, AFE_CR_MSTR_EN_MASK, AFE_CR_MSTR_EN(value)))
#define AFE_BWR_CR_MSTR_EN(base, value) (BME_BFI32(&AFE_CR_REG(base), ((uint32_t)(value) << AFE_CR_MSTR_EN_SHIFT), AFE_CR_MSTR_EN_SHIFT, AFE_CR_MSTR_EN_WIDTH))
/*@}*/

/*******************************************************************************
 * AFE_CKR - Clock Configuration Register
 ******************************************************************************/

/*!
 * @brief AFE_CKR - Clock Configuration Register (RW)
 *
 * Reset value: 0x10000000U
 *
 * AFE Clock Configuration Register has fields to control the source of clock,
 * DIV factor and gating of clocks to AFEs.
 */
/*!
 * @name Constants and macros for entire AFE_CKR register
 */
/*@{*/
#define AFE_RD_CKR(base)         (AFE_CKR_REG(base))
#define AFE_WR_CKR(base, value)  (AFE_CKR_REG(base) = (value))
#define AFE_RMW_CKR(base, mask, value) (AFE_WR_CKR(base, (AFE_RD_CKR(base) & ~(mask)) | (value)))
#define AFE_SET_CKR(base, value) (BME_OR32(&AFE_CKR_REG(base), (uint32_t)(value)))
#define AFE_CLR_CKR(base, value) (BME_AND32(&AFE_CKR_REG(base), (uint32_t)(~(value))))
#define AFE_TOG_CKR(base, value) (BME_XOR32(&AFE_CKR_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual AFE_CKR bitfields
 */

/*!
 * @name Register AFE_CKR, field CLS[22:21] (RW)
 *
 * The CLS bits are used to select one of the four clock sources for modulator
 * clk.
 *
 * Values:
 * - 0b00 - mod_clk0
 * - 0b01 - mod_clk1
 * - 0b10 - mod_clk2
 * - 0b11 - mod_clk3
 */
/*@{*/
/*! @brief Read current value of the AFE_CKR_CLS field. */
#define AFE_RD_CKR_CLS(base) ((AFE_CKR_REG(base) & AFE_CKR_CLS_MASK) >> AFE_CKR_CLS_SHIFT)
#define AFE_BRD_CKR_CLS(base) (BME_UBFX32(&AFE_CKR_REG(base), AFE_CKR_CLS_SHIFT, AFE_CKR_CLS_WIDTH))

/*! @brief Set the CLS field to a new value. */
#define AFE_WR_CKR_CLS(base, value) (AFE_RMW_CKR(base, AFE_CKR_CLS_MASK, AFE_CKR_CLS(value)))
#define AFE_BWR_CKR_CLS(base, value) (BME_BFI32(&AFE_CKR_REG(base), ((uint32_t)(value) << AFE_CKR_CLS_SHIFT), AFE_CKR_CLS_SHIFT, AFE_CKR_CLS_WIDTH))
/*@}*/

/*!
 * @name Register AFE_CKR, field DIV[31:28] (RW)
 *
 * The DIV selects the clock divider ratio for the modulator clock. The
 * modulator clock frequency is the source clock divided by division factor. The default
 * value of DIV is 2.
 *
 * Values:
 * - 0b0000 - divide by 1
 * - 0b0001 - divide by 2 (default)
 * - 0b0010 - divide by 4
 * - 0b0011 - divide by 8
 * - 0b0100 - divide by 16
 * - 0b0101 - divide by 32
 * - 0b0110 - divide by 64
 * - 0b0111 - divide by 128
 * - 0b1xxx - divide by 256
 */
/*@{*/
/*! @brief Read current value of the AFE_CKR_DIV field. */
#define AFE_RD_CKR_DIV(base) ((AFE_CKR_REG(base) & AFE_CKR_DIV_MASK) >> AFE_CKR_DIV_SHIFT)
#define AFE_BRD_CKR_DIV(base) (BME_UBFX32(&AFE_CKR_REG(base), AFE_CKR_DIV_SHIFT, AFE_CKR_DIV_WIDTH))

/*! @brief Set the DIV field to a new value. */
#define AFE_WR_CKR_DIV(base, value) (AFE_RMW_CKR(base, AFE_CKR_DIV_MASK, AFE_CKR_DIV(value)))
#define AFE_BWR_CKR_DIV(base, value) (BME_BFI32(&AFE_CKR_REG(base), ((uint32_t)(value) << AFE_CKR_DIV_SHIFT), AFE_CKR_DIV_SHIFT, AFE_CKR_DIV_WIDTH))
/*@}*/

/*******************************************************************************
 * AFE_DI - DMA and Interrupt Register
 ******************************************************************************/

/*!
 * @brief AFE_DI - DMA and Interrupt Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * DMA and Interrupt Register has fields to enable DMA and Interrupt requests.
 */
/*!
 * @name Constants and macros for entire AFE_DI register
 */
/*@{*/
#define AFE_RD_DI(base)          (AFE_DI_REG(base))
#define AFE_WR_DI(base, value)   (AFE_DI_REG(base) = (value))
#define AFE_RMW_DI(base, mask, value) (AFE_WR_DI(base, (AFE_RD_DI(base) & ~(mask)) | (value)))
#define AFE_SET_DI(base, value)  (BME_OR32(&AFE_DI_REG(base), (uint32_t)(value)))
#define AFE_CLR_DI(base, value)  (BME_AND32(&AFE_DI_REG(base), (uint32_t)(~(value))))
#define AFE_TOG_DI(base, value)  (BME_XOR32(&AFE_DI_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual AFE_DI bitfields
 */

/*!
 * @name Register AFE_DI, field INTEN3[23] (RW)
 *
 * The conversion complete interrupt request is asserted for channel 3 when
 * INTEN3 and COC3 bits are set.
 */
/*@{*/
/*! @brief Read current value of the AFE_DI_INTEN3 field. */
#define AFE_RD_DI_INTEN3(base) ((AFE_DI_REG(base) & AFE_DI_INTEN3_MASK) >> AFE_DI_INTEN3_SHIFT)
#define AFE_BRD_DI_INTEN3(base) (BME_UBFX32(&AFE_DI_REG(base), AFE_DI_INTEN3_SHIFT, AFE_DI_INTEN3_WIDTH))

/*! @brief Set the INTEN3 field to a new value. */
#define AFE_WR_DI_INTEN3(base, value) (AFE_RMW_DI(base, AFE_DI_INTEN3_MASK, AFE_DI_INTEN3(value)))
#define AFE_BWR_DI_INTEN3(base, value) (BME_BFI32(&AFE_DI_REG(base), ((uint32_t)(value) << AFE_DI_INTEN3_SHIFT), AFE_DI_INTEN3_SHIFT, AFE_DI_INTEN3_WIDTH))
/*@}*/

/*!
 * @name Register AFE_DI, field INTEN2[24] (RW)
 *
 * The conversion complete interrupt request is asserted for channel 2 when
 * INTEN2 and COC2 bits are set.
 */
/*@{*/
/*! @brief Read current value of the AFE_DI_INTEN2 field. */
#define AFE_RD_DI_INTEN2(base) ((AFE_DI_REG(base) & AFE_DI_INTEN2_MASK) >> AFE_DI_INTEN2_SHIFT)
#define AFE_BRD_DI_INTEN2(base) (BME_UBFX32(&AFE_DI_REG(base), AFE_DI_INTEN2_SHIFT, AFE_DI_INTEN2_WIDTH))

/*! @brief Set the INTEN2 field to a new value. */
#define AFE_WR_DI_INTEN2(base, value) (AFE_RMW_DI(base, AFE_DI_INTEN2_MASK, AFE_DI_INTEN2(value)))
#define AFE_BWR_DI_INTEN2(base, value) (BME_BFI32(&AFE_DI_REG(base), ((uint32_t)(value) << AFE_DI_INTEN2_SHIFT), AFE_DI_INTEN2_SHIFT, AFE_DI_INTEN2_WIDTH))
/*@}*/

/*!
 * @name Register AFE_DI, field INTEN1[25] (RW)
 *
 * The conversion complete interrupt request is asserted for channel 1 when
 * INTEN1 and COC1 bits are set.
 */
/*@{*/
/*! @brief Read current value of the AFE_DI_INTEN1 field. */
#define AFE_RD_DI_INTEN1(base) ((AFE_DI_REG(base) & AFE_DI_INTEN1_MASK) >> AFE_DI_INTEN1_SHIFT)
#define AFE_BRD_DI_INTEN1(base) (BME_UBFX32(&AFE_DI_REG(base), AFE_DI_INTEN1_SHIFT, AFE_DI_INTEN1_WIDTH))

/*! @brief Set the INTEN1 field to a new value. */
#define AFE_WR_DI_INTEN1(base, value) (AFE_RMW_DI(base, AFE_DI_INTEN1_MASK, AFE_DI_INTEN1(value)))
#define AFE_BWR_DI_INTEN1(base, value) (BME_BFI32(&AFE_DI_REG(base), ((uint32_t)(value) << AFE_DI_INTEN1_SHIFT), AFE_DI_INTEN1_SHIFT, AFE_DI_INTEN1_WIDTH))
/*@}*/

/*!
 * @name Register AFE_DI, field INTEN0[26] (RW)
 *
 * The conversion complete interrupt request is asserted for channel 0 when
 * INTEN0 and COC0 bits are set.
 */
/*@{*/
/*! @brief Read current value of the AFE_DI_INTEN0 field. */
#define AFE_RD_DI_INTEN0(base) ((AFE_DI_REG(base) & AFE_DI_INTEN0_MASK) >> AFE_DI_INTEN0_SHIFT)
#define AFE_BRD_DI_INTEN0(base) (BME_UBFX32(&AFE_DI_REG(base), AFE_DI_INTEN0_SHIFT, AFE_DI_INTEN0_WIDTH))

/*! @brief Set the INTEN0 field to a new value. */
#define AFE_WR_DI_INTEN0(base, value) (AFE_RMW_DI(base, AFE_DI_INTEN0_MASK, AFE_DI_INTEN0(value)))
#define AFE_BWR_DI_INTEN0(base, value) (BME_BFI32(&AFE_DI_REG(base), ((uint32_t)(value) << AFE_DI_INTEN0_SHIFT), AFE_DI_INTEN0_SHIFT, AFE_DI_INTEN0_WIDTH))
/*@}*/

/*!
 * @name Register AFE_DI, field DMAEN3[28] (RW)
 *
 * The DMA request is asserted for channel3 when the DMAEN3 and COC3 bits are
 * set.
 */
/*@{*/
/*! @brief Read current value of the AFE_DI_DMAEN3 field. */
#define AFE_RD_DI_DMAEN3(base) ((AFE_DI_REG(base) & AFE_DI_DMAEN3_MASK) >> AFE_DI_DMAEN3_SHIFT)
#define AFE_BRD_DI_DMAEN3(base) (BME_UBFX32(&AFE_DI_REG(base), AFE_DI_DMAEN3_SHIFT, AFE_DI_DMAEN3_WIDTH))

/*! @brief Set the DMAEN3 field to a new value. */
#define AFE_WR_DI_DMAEN3(base, value) (AFE_RMW_DI(base, AFE_DI_DMAEN3_MASK, AFE_DI_DMAEN3(value)))
#define AFE_BWR_DI_DMAEN3(base, value) (BME_BFI32(&AFE_DI_REG(base), ((uint32_t)(value) << AFE_DI_DMAEN3_SHIFT), AFE_DI_DMAEN3_SHIFT, AFE_DI_DMAEN3_WIDTH))
/*@}*/

/*!
 * @name Register AFE_DI, field DMAEN2[29] (RW)
 *
 * The DMA request is asserted for channel2 when the DMAEN2 and COC2 bits are
 * set.
 */
/*@{*/
/*! @brief Read current value of the AFE_DI_DMAEN2 field. */
#define AFE_RD_DI_DMAEN2(base) ((AFE_DI_REG(base) & AFE_DI_DMAEN2_MASK) >> AFE_DI_DMAEN2_SHIFT)
#define AFE_BRD_DI_DMAEN2(base) (BME_UBFX32(&AFE_DI_REG(base), AFE_DI_DMAEN2_SHIFT, AFE_DI_DMAEN2_WIDTH))

/*! @brief Set the DMAEN2 field to a new value. */
#define AFE_WR_DI_DMAEN2(base, value) (AFE_RMW_DI(base, AFE_DI_DMAEN2_MASK, AFE_DI_DMAEN2(value)))
#define AFE_BWR_DI_DMAEN2(base, value) (BME_BFI32(&AFE_DI_REG(base), ((uint32_t)(value) << AFE_DI_DMAEN2_SHIFT), AFE_DI_DMAEN2_SHIFT, AFE_DI_DMAEN2_WIDTH))
/*@}*/

/*!
 * @name Register AFE_DI, field DMAEN1[30] (RW)
 *
 * The DMA request is asserted for channel1 when the DMAEN1 and COC1 bits are
 * set.
 */
/*@{*/
/*! @brief Read current value of the AFE_DI_DMAEN1 field. */
#define AFE_RD_DI_DMAEN1(base) ((AFE_DI_REG(base) & AFE_DI_DMAEN1_MASK) >> AFE_DI_DMAEN1_SHIFT)
#define AFE_BRD_DI_DMAEN1(base) (BME_UBFX32(&AFE_DI_REG(base), AFE_DI_DMAEN1_SHIFT, AFE_DI_DMAEN1_WIDTH))

/*! @brief Set the DMAEN1 field to a new value. */
#define AFE_WR_DI_DMAEN1(base, value) (AFE_RMW_DI(base, AFE_DI_DMAEN1_MASK, AFE_DI_DMAEN1(value)))
#define AFE_BWR_DI_DMAEN1(base, value) (BME_BFI32(&AFE_DI_REG(base), ((uint32_t)(value) << AFE_DI_DMAEN1_SHIFT), AFE_DI_DMAEN1_SHIFT, AFE_DI_DMAEN1_WIDTH))
/*@}*/

/*!
 * @name Register AFE_DI, field DMAEN0[31] (RW)
 *
 * The DMA request is asserted for channel0 when the DMAEN0 and COC0 bits are
 * set.
 */
/*@{*/
/*! @brief Read current value of the AFE_DI_DMAEN0 field. */
#define AFE_RD_DI_DMAEN0(base) ((AFE_DI_REG(base) & AFE_DI_DMAEN0_MASK) >> AFE_DI_DMAEN0_SHIFT)
#define AFE_BRD_DI_DMAEN0(base) (BME_UBFX32(&AFE_DI_REG(base), AFE_DI_DMAEN0_SHIFT, AFE_DI_DMAEN0_WIDTH))

/*! @brief Set the DMAEN0 field to a new value. */
#define AFE_WR_DI_DMAEN0(base, value) (AFE_RMW_DI(base, AFE_DI_DMAEN0_MASK, AFE_DI_DMAEN0(value)))
#define AFE_BWR_DI_DMAEN0(base, value) (BME_BFI32(&AFE_DI_REG(base), ((uint32_t)(value) << AFE_DI_DMAEN0_SHIFT), AFE_DI_DMAEN0_SHIFT, AFE_DI_DMAEN0_WIDTH))
/*@}*/

/*******************************************************************************
 * AFE_DR - Channel0 Delay Register
 ******************************************************************************/

/*!
 * @brief AFE_DR - Channel0 Delay Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * Channel0 Delay Register contains a 11-bit field used to insert a delay into
 * the trigger response of the decimation filters in order to provide phase
 * compensation between four channels.
 */
/*!
 * @name Constants and macros for entire AFE_DR register
 */
/*@{*/
#define AFE_RD_DR(base, index)   (AFE_DR_REG(base, index))
#define AFE_WR_DR(base, index, value) (AFE_DR_REG(base, index) = (value))
#define AFE_RMW_DR(base, index, mask, value) (AFE_WR_DR(base, index, (AFE_RD_DR(base, index) & ~(mask)) | (value)))
#define AFE_SET_DR(base, index, value) (BME_OR32(&AFE_DR_REG(base, index), (uint32_t)(value)))
#define AFE_CLR_DR(base, index, value) (BME_AND32(&AFE_DR_REG(base, index), (uint32_t)(~(value))))
#define AFE_TOG_DR(base, index, value) (BME_XOR32(&AFE_DR_REG(base, index), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual AFE_DR bitfields
 */

/*!
 * @name Register AFE_DR, field DLY[10:0] (RW)
 *
 * This field can be used to provide phase compensation between four AFE
 * Channels in step of prescaled modulator clock periods. This delay will be seen in
 * every subsequent change to sampling phase after initial sampling.
 */
/*@{*/
/*! @brief Read current value of the AFE_DR_DLY field. */
#define AFE_RD_DR_DLY(base, index) ((AFE_DR_REG(base, index) & AFE_DR_DLY_MASK) >> AFE_DR_DLY_SHIFT)
#define AFE_BRD_DR_DLY(base, index) (BME_UBFX32(&AFE_DR_REG(base, index), AFE_DR_DLY_SHIFT, AFE_DR_DLY_WIDTH))

/*! @brief Set the DLY field to a new value. */
#define AFE_WR_DR_DLY(base, index, value) (AFE_RMW_DR(base, index, AFE_DR_DLY_MASK, AFE_DR_DLY(value)))
#define AFE_BWR_DR_DLY(base, index, value) (BME_BFI32(&AFE_DR_REG(base, index), ((uint32_t)(value) << AFE_DR_DLY_SHIFT), AFE_DR_DLY_SHIFT, AFE_DR_DLY_WIDTH))
/*@}*/

/*******************************************************************************
 * AFE_RR - Channel0 Result Register
 ******************************************************************************/

/*!
 * @brief AFE_RR - Channel0 Result Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * Depending upon AFE_CR[RESULT_FORMAT] field result can be represented in
 * following ways: where (S= sign bit , V=valid result value, 0=zero) Left justified
 * 2's complement 32-bit : SVVVVVVVVVVVVVVVVVVVVVVV00000000 Right justified 2's
 * complement 32-bit : SSSSSSSSSVVVVVVVVVVVVVVVVVVVVVVV
 */
/*!
 * @name Constants and macros for entire AFE_RR register
 */
/*@{*/
#define AFE_RD_RR(base, index)   (AFE_RR_REG(base, index))
/*@}*/

/*
 * Constants & macros for individual AFE_RR bitfields
 */

/*!
 * @name Register AFE_RR, field SDR[22:0] (RO)
 *
 * This field represents valid sample value in 2's complement form.
 */
/*@{*/
/*! @brief Read current value of the AFE_RR_SDR field. */
#define AFE_RD_RR_SDR(base, index) ((AFE_RR_REG(base, index) & AFE_RR_SDR_MASK) >> AFE_RR_SDR_SHIFT)
#define AFE_BRD_RR_SDR(base, index) (AFE_RD_RR_SDR(base, index))
/*@}*/

/*!
 * @name Register AFE_RR, field SIGN_BITS[31:23] (RO)
 *
 * This field represents sign bits (bits 31 to 23 are filled with sign bits) if
 * result is right justified or else 31-bit will be signbit and the lowest 8LSBs
 * will be zeroes in case result is left justified. The formatting option can be
 * selected from AFE_CR[RESULT_FORMAT].
 */
/*@{*/
/*! @brief Read current value of the AFE_RR_SIGN_BITS field. */
#define AFE_RD_RR_SIGN_BITS(base, index) ((AFE_RR_REG(base, index) & AFE_RR_SIGN_BITS_MASK) >> AFE_RR_SIGN_BITS_SHIFT)
#define AFE_BRD_RR_SIGN_BITS(base, index) (BME_UBFX32(&AFE_RR_REG(base, index), AFE_RR_SIGN_BITS_SHIFT, AFE_RR_SIGN_BITS_WIDTH))
/*@}*/

/*******************************************************************************
 * AFE_SR - Status Register
 ******************************************************************************/

/*!
 * @brief AFE_SR - Status Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * AFE Status Register has three types of flags COC, OVR, RDY that indicate the
 * status of each channel of AFE.
 */
/*!
 * @name Constants and macros for entire AFE_SR register
 */
/*@{*/
#define AFE_RD_SR(base)          (AFE_SR_REG(base))
/*@}*/

/*
 * Constants & macros for individual AFE_SR bitfields
 */

/*!
 * @name Register AFE_SR, field RDY3[16] (RO)
 *
 * It indicates that AFE Channel3 is ready for conversion.
 *
 * Values:
 * - 0b0 - AFE Channel3 is disabled or has not completed its start up period
 * - 0b1 - AFE Channel3 is ready to initiate conversions.
 */
/*@{*/
/*! @brief Read current value of the AFE_SR_RDY3 field. */
#define AFE_RD_SR_RDY3(base) ((AFE_SR_REG(base) & AFE_SR_RDY3_MASK) >> AFE_SR_RDY3_SHIFT)
#define AFE_BRD_SR_RDY3(base) (BME_UBFX32(&AFE_SR_REG(base), AFE_SR_RDY3_SHIFT, AFE_SR_RDY3_WIDTH))
/*@}*/

/*!
 * @name Register AFE_SR, field RDY2[17] (RO)
 *
 * It indicates that AFE Channel2 is ready for conversion.
 *
 * Values:
 * - 0b0 - AFE Channel2 is disabled or has not completed its start up period
 * - 0b1 - AFE Channel2 is ready to initiate conversions.
 */
/*@{*/
/*! @brief Read current value of the AFE_SR_RDY2 field. */
#define AFE_RD_SR_RDY2(base) ((AFE_SR_REG(base) & AFE_SR_RDY2_MASK) >> AFE_SR_RDY2_SHIFT)
#define AFE_BRD_SR_RDY2(base) (BME_UBFX32(&AFE_SR_REG(base), AFE_SR_RDY2_SHIFT, AFE_SR_RDY2_WIDTH))
/*@}*/

/*!
 * @name Register AFE_SR, field RDY1[18] (RO)
 *
 * It indicates that AFE Channel1 is ready for conversion.
 *
 * Values:
 * - 0b0 - AFE Channel1 is disabled or has not completed its start up period
 * - 0b1 - AFE Channel1 is ready to initiate conversions.
 */
/*@{*/
/*! @brief Read current value of the AFE_SR_RDY1 field. */
#define AFE_RD_SR_RDY1(base) ((AFE_SR_REG(base) & AFE_SR_RDY1_MASK) >> AFE_SR_RDY1_SHIFT)
#define AFE_BRD_SR_RDY1(base) (BME_UBFX32(&AFE_SR_REG(base), AFE_SR_RDY1_SHIFT, AFE_SR_RDY1_WIDTH))
/*@}*/

/*!
 * @name Register AFE_SR, field RDY0[19] (RO)
 *
 * It indicates that AFE Channel0 is ready for conversion.
 *
 * Values:
 * - 0b0 - AFE Channel0 is disabled or has not completed its start up period
 * - 0b1 - AFE Channel0 is ready to initiate conversions.
 */
/*@{*/
/*! @brief Read current value of the AFE_SR_RDY0 field. */
#define AFE_RD_SR_RDY0(base) ((AFE_SR_REG(base) & AFE_SR_RDY0_MASK) >> AFE_SR_RDY0_SHIFT)
#define AFE_BRD_SR_RDY0(base) (BME_UBFX32(&AFE_SR_REG(base), AFE_SR_RDY0_SHIFT, AFE_SR_RDY0_WIDTH))
/*@}*/

/*!
 * @name Register AFE_SR, field OVR3[21] (RO)
 *
 * This bit is set when the previous data has not been read and new data has
 * already been arrived to be loaded in result register of the AFE Channel3 and
 * cleared on a read of the result register
 */
/*@{*/
/*! @brief Read current value of the AFE_SR_OVR3 field. */
#define AFE_RD_SR_OVR3(base) ((AFE_SR_REG(base) & AFE_SR_OVR3_MASK) >> AFE_SR_OVR3_SHIFT)
#define AFE_BRD_SR_OVR3(base) (BME_UBFX32(&AFE_SR_REG(base), AFE_SR_OVR3_SHIFT, AFE_SR_OVR3_WIDTH))
/*@}*/

/*!
 * @name Register AFE_SR, field OVR2[22] (RO)
 *
 * This bit is set when the previous data has not been read and new data has
 * already been arrived to be loaded in result register of the AFE Channel2 and
 * cleared on a read of the result register
 */
/*@{*/
/*! @brief Read current value of the AFE_SR_OVR2 field. */
#define AFE_RD_SR_OVR2(base) ((AFE_SR_REG(base) & AFE_SR_OVR2_MASK) >> AFE_SR_OVR2_SHIFT)
#define AFE_BRD_SR_OVR2(base) (BME_UBFX32(&AFE_SR_REG(base), AFE_SR_OVR2_SHIFT, AFE_SR_OVR2_WIDTH))
/*@}*/

/*!
 * @name Register AFE_SR, field OVR1[23] (RO)
 *
 * This bit is set when the previous data has not been read and new data has
 * already been arrived to be loaded in result register of the AFE Channel1 and
 * cleared on a read of the result register
 */
/*@{*/
/*! @brief Read current value of the AFE_SR_OVR1 field. */
#define AFE_RD_SR_OVR1(base) ((AFE_SR_REG(base) & AFE_SR_OVR1_MASK) >> AFE_SR_OVR1_SHIFT)
#define AFE_BRD_SR_OVR1(base) (BME_UBFX32(&AFE_SR_REG(base), AFE_SR_OVR1_SHIFT, AFE_SR_OVR1_WIDTH))
/*@}*/

/*!
 * @name Register AFE_SR, field OVR0[24] (RO)
 *
 * This bit is set when the previous data has not been read and new data has
 * already been arrived to be loaded in result register of the AFE Channel0 and
 * cleared on a read of the result register.
 */
/*@{*/
/*! @brief Read current value of the AFE_SR_OVR0 field. */
#define AFE_RD_SR_OVR0(base) ((AFE_SR_REG(base) & AFE_SR_OVR0_MASK) >> AFE_SR_OVR0_SHIFT)
#define AFE_BRD_SR_OVR0(base) (BME_UBFX32(&AFE_SR_REG(base), AFE_SR_OVR0_SHIFT, AFE_SR_OVR0_WIDTH))
/*@}*/

/*!
 * @name Register AFE_SR, field COC3[28] (RO)
 *
 * The COC flag is set when a conversion is completed and cleared on a read of
 * the result register CH3_AFE_RR. Since modulators take some time to start up,
 * this field is set at third sample and first two samples are ignored.
 */
/*@{*/
/*! @brief Read current value of the AFE_SR_COC3 field. */
#define AFE_RD_SR_COC3(base) ((AFE_SR_REG(base) & AFE_SR_COC3_MASK) >> AFE_SR_COC3_SHIFT)
#define AFE_BRD_SR_COC3(base) (BME_UBFX32(&AFE_SR_REG(base), AFE_SR_COC3_SHIFT, AFE_SR_COC3_WIDTH))
/*@}*/

/*!
 * @name Register AFE_SR, field COC2[29] (RO)
 *
 * The COC flag is set when a conversion is completed and cleared on a read of
 * the result register CH2_AFE_RR. Since modulators take some time to start up,
 * this field is set at third sample and first two samples are ignored.
 */
/*@{*/
/*! @brief Read current value of the AFE_SR_COC2 field. */
#define AFE_RD_SR_COC2(base) ((AFE_SR_REG(base) & AFE_SR_COC2_MASK) >> AFE_SR_COC2_SHIFT)
#define AFE_BRD_SR_COC2(base) (BME_UBFX32(&AFE_SR_REG(base), AFE_SR_COC2_SHIFT, AFE_SR_COC2_WIDTH))
/*@}*/

/*!
 * @name Register AFE_SR, field COC1[30] (RO)
 *
 * The COC flag is set when a conversion is completed and cleared on a read of
 * the result register CH1_AFE_RR. Since modulators take some time to start up,
 * this field is set at third sample and first two samples are ignored.
 */
/*@{*/
/*! @brief Read current value of the AFE_SR_COC1 field. */
#define AFE_RD_SR_COC1(base) ((AFE_SR_REG(base) & AFE_SR_COC1_MASK) >> AFE_SR_COC1_SHIFT)
#define AFE_BRD_SR_COC1(base) (BME_UBFX32(&AFE_SR_REG(base), AFE_SR_COC1_SHIFT, AFE_SR_COC1_WIDTH))
/*@}*/

/*!
 * @name Register AFE_SR, field COC0[31] (RO)
 *
 * The COC flag is set when a conversion is completed and cleared on a read of
 * the result register CH0_AFE_RR. Since modulators take some time to start up,
 * this field is set at third sample and first two samples are ignored.
 */
/*@{*/
/*! @brief Read current value of the AFE_SR_COC0 field. */
#define AFE_RD_SR_COC0(base) ((AFE_SR_REG(base) & AFE_SR_COC0_MASK) >> AFE_SR_COC0_SHIFT)
#define AFE_BRD_SR_COC0(base) (BME_UBFX32(&AFE_SR_REG(base), AFE_SR_COC0_SHIFT, AFE_SR_COC0_WIDTH))
/*@}*/

/* Unified AFE register access macros */
#define AFE_BRD_DI_INTEN(x, c)    (BME_UBFX32(&AFE_DI_REG(x), (26U-c), AFE_DI_INTEN0_WIDTH))
#define AFE_BWR_DI_INTEN(x, c, v) (BME_BFI32(&AFE_DI_REG(x), ((uint32_t)(v) << (26U-c)), (26U-c), 1U))
#define AFE_BRD_DI_DMAEN(x, c)    (BME_UBFX32(&AFE_DI_REG(x), (31U-c), AFE_DI_DMAEN0_WIDTH))
#define AFE_BWR_DI_DMAEN(x, c, v) (BME_BFI32(&AFE_DI_REG(x), ((uint32_t)(v) << (31U-c)), (31U-c), 1U))
#define AFE_BRD_RR(x, c)          (AFE_RR_REG(x,c))
#define AFE_BRD_SR_RDY(x, c)      (BME_UBFX32(&AFE_SR_REG(x), (19U-c), AFE_SR_RDY0_WIDTH))
#define AFE_BRD_SR_OVR(x, c)      (BME_UBFX32(&AFE_SR_REG(x), (24U-c), AFE_SR_OVR0_WIDTH))
#define AFE_BRD_SR_COC(x, c)      (BME_UBFX32(&AFE_SR_REG(x), (31U-c), AFE_SR_COC0_WIDTH))
#define AFE_BWR_CR_SOFT_TRG(x, c) (BME_BFI32(&AFE_CR_REG(x), ((uint32_t)(c) << 27U), 27U, 4U))

/*
 * MKM34Z7 AIPS
 *
 * AIPS-Lite Bridge
 *
 * Registers defined in this header file:
 * - AIPS_PACRA - Peripheral Access Control Register
 * - AIPS_PACRB - Peripheral Access Control Register
 * - AIPS_PACRE - Peripheral Access Control Register
 * - AIPS_PACRF - Peripheral Access Control Register
 * - AIPS_PACRG - Peripheral Access Control Register
 * - AIPS_PACRH - Peripheral Access Control Register
 * - AIPS_PACRI - Peripheral Access Control Register
 * - AIPS_PACRJ - Peripheral Access Control Register
 * - AIPS_PACRK - Peripheral Access Control Register
 * - AIPS_PACRL - Peripheral Access Control Register
 * - AIPS_PACRM - Peripheral Access Control Register
 * - AIPS_PACRN - Peripheral Access Control Register
 * - AIPS_PACRO - Peripheral Access Control Register
 * - AIPS_PACRP - Peripheral Access Control Register
 */

#define AIPS_INSTANCE_COUNT (1U) /*!< Number of instances of the AIPS module. */
#define AIPS_IDX (0U) /*!< Instance number for AIPS. */

/*******************************************************************************
 * AIPS_PACRA - Peripheral Access Control Register
 ******************************************************************************/

/*!
 * @brief AIPS_PACRA - Peripheral Access Control Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * Each peripheral on this chip has a 4-bit PACR field which includes a
 * read-only "lock" bit plus a 3-bit attribute check field which defines the access
 * rights (privileged/user, secure/nonsecure) needed to reference the slave
 * peripheral's address space. Access to these registers is allowed using only 32-bit
 * privileged, secure reads and writes. Each 32-bit register controls eight
 * peripherals. A peripheral's assignment to a PACR field is defined by the memory map slot
 * to which the peripheral is assigned. See this chip's peripheral bridge memory
 * map information for the assignment of a particular peripheral. The following
 * table shows the top-level structure of PACRs. Offset Register [31:28] [27:24]
 * [23:20] [19:16] [15:12] [11:8] [7:4] [3:0] 0x20 PACRA PACR0 PACR1 PACR2 PACR3
 * PACR4 PACR5 PACR6 PACR7 0x24 PACRB PACR8 PACR9 PACR10 PACR11 PACR12 PACR13
 * PACR14 PACR15 The following table defines the attribute check values for each AC
 * field. For access to peripherals that have their own access attribute checks,
 * such as GPIO, refer also to their attributes checks definitions. Attribute
 * check (AC) values AC User nonsecure User secure Privileged secure 0b000
 * Read/Write Read/Write Read/Write 0b001 Read Read/Write Read/Write 0b010 None Read/Write
 * Read/Write 0b011 Read Read Read/Write 0b100 None Read Read/Write 0b101 None
 * None Read/Write 0b110 None None Read 0b111 None None None
 */
/*!
 * @name Constants and macros for entire AIPS_PACRA register
 */
/*@{*/
#define AIPS_RD_PACRA(base)      (AIPS_PACRA_REG(base))
#define AIPS_WR_PACRA(base, value) (AIPS_PACRA_REG(base) = (value))
#define AIPS_RMW_PACRA(base, mask, value) (AIPS_WR_PACRA(base, (AIPS_RD_PACRA(base) & ~(mask)) | (value)))
#define AIPS_SET_PACRA(base, value) (BME_OR32(&AIPS_PACRA_REG(base), (uint32_t)(value)))
#define AIPS_CLR_PACRA(base, value) (BME_AND32(&AIPS_PACRA_REG(base), (uint32_t)(~(value))))
#define AIPS_TOG_PACRA(base, value) (BME_XOR32(&AIPS_PACRA_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual AIPS_PACRA bitfields
 */

/*!
 * @name Register AIPS_PACRA, field AC7[2:0] (RW)
 *
 * Defines the attributes required to access the corresponding slave
 * peripheral's memory space. See #pacr_attributes , "Attribute check (AC) values" for
 * details.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRA_AC7 field. */
#define AIPS_RD_PACRA_AC7(base) ((AIPS_PACRA_REG(base) & AIPS_PACRA_AC7_MASK) >> AIPS_PACRA_AC7_SHIFT)
#define AIPS_BRD_PACRA_AC7(base) (BME_UBFX32(&AIPS_PACRA_REG(base), AIPS_PACRA_AC7_SHIFT, AIPS_PACRA_AC7_WIDTH))

/*! @brief Set the AC7 field to a new value. */
#define AIPS_WR_PACRA_AC7(base, value) (AIPS_RMW_PACRA(base, AIPS_PACRA_AC7_MASK, AIPS_PACRA_AC7(value)))
#define AIPS_BWR_PACRA_AC7(base, value) (BME_BFI32(&AIPS_PACRA_REG(base), ((uint32_t)(value) << AIPS_PACRA_AC7_SHIFT), AIPS_PACRA_AC7_SHIFT, AIPS_PACRA_AC7_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRA, field RO7[3] (RW)
 *
 * Indicates the lock status of this register's AC7 field. After this field is
 * set to 1, it cannot be changed and attempted writes to AC7 are ignored until
 * the next system reset clears this field.
 *
 * Values:
 * - 0b0 - Writes to corresponding AC field are allowed.
 * - 0b1 - Writes to corresponding AC field are ignored.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRA_RO7 field. */
#define AIPS_RD_PACRA_RO7(base) ((AIPS_PACRA_REG(base) & AIPS_PACRA_RO7_MASK) >> AIPS_PACRA_RO7_SHIFT)
#define AIPS_BRD_PACRA_RO7(base) (BME_UBFX32(&AIPS_PACRA_REG(base), AIPS_PACRA_RO7_SHIFT, AIPS_PACRA_RO7_WIDTH))

/*! @brief Set the RO7 field to a new value. */
#define AIPS_WR_PACRA_RO7(base, value) (AIPS_RMW_PACRA(base, AIPS_PACRA_RO7_MASK, AIPS_PACRA_RO7(value)))
#define AIPS_BWR_PACRA_RO7(base, value) (BME_BFI32(&AIPS_PACRA_REG(base), ((uint32_t)(value) << AIPS_PACRA_RO7_SHIFT), AIPS_PACRA_RO7_SHIFT, AIPS_PACRA_RO7_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRA, field AC6[6:4] (RW)
 *
 * Defines the attributes required to access the corresponding slave
 * peripheral's memory space. See #pacr_attributes , "Attribute check (AC) values" for
 * details.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRA_AC6 field. */
#define AIPS_RD_PACRA_AC6(base) ((AIPS_PACRA_REG(base) & AIPS_PACRA_AC6_MASK) >> AIPS_PACRA_AC6_SHIFT)
#define AIPS_BRD_PACRA_AC6(base) (BME_UBFX32(&AIPS_PACRA_REG(base), AIPS_PACRA_AC6_SHIFT, AIPS_PACRA_AC6_WIDTH))

/*! @brief Set the AC6 field to a new value. */
#define AIPS_WR_PACRA_AC6(base, value) (AIPS_RMW_PACRA(base, AIPS_PACRA_AC6_MASK, AIPS_PACRA_AC6(value)))
#define AIPS_BWR_PACRA_AC6(base, value) (BME_BFI32(&AIPS_PACRA_REG(base), ((uint32_t)(value) << AIPS_PACRA_AC6_SHIFT), AIPS_PACRA_AC6_SHIFT, AIPS_PACRA_AC6_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRA, field RO6[7] (RW)
 *
 * Indicates the lock status of this register's AC6 field. After this field is
 * set to 1, it cannot be changed and attempted writes to AC6 are ignored until
 * the next system reset clears this field.
 *
 * Values:
 * - 0b0 - Writes to corresponding AC field are allowed.
 * - 0b1 - Writes to corresponding AC field are ignored.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRA_RO6 field. */
#define AIPS_RD_PACRA_RO6(base) ((AIPS_PACRA_REG(base) & AIPS_PACRA_RO6_MASK) >> AIPS_PACRA_RO6_SHIFT)
#define AIPS_BRD_PACRA_RO6(base) (BME_UBFX32(&AIPS_PACRA_REG(base), AIPS_PACRA_RO6_SHIFT, AIPS_PACRA_RO6_WIDTH))

/*! @brief Set the RO6 field to a new value. */
#define AIPS_WR_PACRA_RO6(base, value) (AIPS_RMW_PACRA(base, AIPS_PACRA_RO6_MASK, AIPS_PACRA_RO6(value)))
#define AIPS_BWR_PACRA_RO6(base, value) (BME_BFI32(&AIPS_PACRA_REG(base), ((uint32_t)(value) << AIPS_PACRA_RO6_SHIFT), AIPS_PACRA_RO6_SHIFT, AIPS_PACRA_RO6_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRA, field AC5[10:8] (RW)
 *
 * Defines the attributes required to access the corresponding slave
 * peripheral's memory space. See #pacr_attributes , "Attribute check (AC) values" for
 * details.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRA_AC5 field. */
#define AIPS_RD_PACRA_AC5(base) ((AIPS_PACRA_REG(base) & AIPS_PACRA_AC5_MASK) >> AIPS_PACRA_AC5_SHIFT)
#define AIPS_BRD_PACRA_AC5(base) (BME_UBFX32(&AIPS_PACRA_REG(base), AIPS_PACRA_AC5_SHIFT, AIPS_PACRA_AC5_WIDTH))

/*! @brief Set the AC5 field to a new value. */
#define AIPS_WR_PACRA_AC5(base, value) (AIPS_RMW_PACRA(base, AIPS_PACRA_AC5_MASK, AIPS_PACRA_AC5(value)))
#define AIPS_BWR_PACRA_AC5(base, value) (BME_BFI32(&AIPS_PACRA_REG(base), ((uint32_t)(value) << AIPS_PACRA_AC5_SHIFT), AIPS_PACRA_AC5_SHIFT, AIPS_PACRA_AC5_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRA, field RO5[11] (RW)
 *
 * Indicates the lock status of this register's AC5 field. After this field is
 * set to 1, it cannot be changed and attempted writes to AC5 are ignored until
 * the next system reset clears this field.
 *
 * Values:
 * - 0b0 - Writes to corresponding AC field are allowed.
 * - 0b1 - Writes to corresponding AC field are ignored.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRA_RO5 field. */
#define AIPS_RD_PACRA_RO5(base) ((AIPS_PACRA_REG(base) & AIPS_PACRA_RO5_MASK) >> AIPS_PACRA_RO5_SHIFT)
#define AIPS_BRD_PACRA_RO5(base) (BME_UBFX32(&AIPS_PACRA_REG(base), AIPS_PACRA_RO5_SHIFT, AIPS_PACRA_RO5_WIDTH))

/*! @brief Set the RO5 field to a new value. */
#define AIPS_WR_PACRA_RO5(base, value) (AIPS_RMW_PACRA(base, AIPS_PACRA_RO5_MASK, AIPS_PACRA_RO5(value)))
#define AIPS_BWR_PACRA_RO5(base, value) (BME_BFI32(&AIPS_PACRA_REG(base), ((uint32_t)(value) << AIPS_PACRA_RO5_SHIFT), AIPS_PACRA_RO5_SHIFT, AIPS_PACRA_RO5_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRA, field AC4[14:12] (RW)
 *
 * Defines the attributes required to access the corresponding slave
 * peripheral's memory space. See #pacr_attributes , "Attribute check (AC) values" for
 * details.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRA_AC4 field. */
#define AIPS_RD_PACRA_AC4(base) ((AIPS_PACRA_REG(base) & AIPS_PACRA_AC4_MASK) >> AIPS_PACRA_AC4_SHIFT)
#define AIPS_BRD_PACRA_AC4(base) (BME_UBFX32(&AIPS_PACRA_REG(base), AIPS_PACRA_AC4_SHIFT, AIPS_PACRA_AC4_WIDTH))

/*! @brief Set the AC4 field to a new value. */
#define AIPS_WR_PACRA_AC4(base, value) (AIPS_RMW_PACRA(base, AIPS_PACRA_AC4_MASK, AIPS_PACRA_AC4(value)))
#define AIPS_BWR_PACRA_AC4(base, value) (BME_BFI32(&AIPS_PACRA_REG(base), ((uint32_t)(value) << AIPS_PACRA_AC4_SHIFT), AIPS_PACRA_AC4_SHIFT, AIPS_PACRA_AC4_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRA, field RO4[15] (RW)
 *
 * Indicates the lock status of this register's AC4 field. After this field is
 * set to 1, it cannot be changed and attempted writes to AC4 are ignored until
 * the next system reset clears this field.
 *
 * Values:
 * - 0b0 - Writes to corresponding AC field are allowed.
 * - 0b1 - Writes to corresponding AC field are ignored.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRA_RO4 field. */
#define AIPS_RD_PACRA_RO4(base) ((AIPS_PACRA_REG(base) & AIPS_PACRA_RO4_MASK) >> AIPS_PACRA_RO4_SHIFT)
#define AIPS_BRD_PACRA_RO4(base) (BME_UBFX32(&AIPS_PACRA_REG(base), AIPS_PACRA_RO4_SHIFT, AIPS_PACRA_RO4_WIDTH))

/*! @brief Set the RO4 field to a new value. */
#define AIPS_WR_PACRA_RO4(base, value) (AIPS_RMW_PACRA(base, AIPS_PACRA_RO4_MASK, AIPS_PACRA_RO4(value)))
#define AIPS_BWR_PACRA_RO4(base, value) (BME_BFI32(&AIPS_PACRA_REG(base), ((uint32_t)(value) << AIPS_PACRA_RO4_SHIFT), AIPS_PACRA_RO4_SHIFT, AIPS_PACRA_RO4_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRA, field AC3[18:16] (RW)
 *
 * Defines the attributes required to access the corresponding slave
 * peripheral's memory space. See #pacr_attributes , "Attribute check (AC) values" for
 * details.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRA_AC3 field. */
#define AIPS_RD_PACRA_AC3(base) ((AIPS_PACRA_REG(base) & AIPS_PACRA_AC3_MASK) >> AIPS_PACRA_AC3_SHIFT)
#define AIPS_BRD_PACRA_AC3(base) (BME_UBFX32(&AIPS_PACRA_REG(base), AIPS_PACRA_AC3_SHIFT, AIPS_PACRA_AC3_WIDTH))

/*! @brief Set the AC3 field to a new value. */
#define AIPS_WR_PACRA_AC3(base, value) (AIPS_RMW_PACRA(base, AIPS_PACRA_AC3_MASK, AIPS_PACRA_AC3(value)))
#define AIPS_BWR_PACRA_AC3(base, value) (BME_BFI32(&AIPS_PACRA_REG(base), ((uint32_t)(value) << AIPS_PACRA_AC3_SHIFT), AIPS_PACRA_AC3_SHIFT, AIPS_PACRA_AC3_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRA, field RO3[19] (RW)
 *
 * Indicates the lock status of this register's AC3 field. After this field is
 * set to 1, it cannot be changed and attempted writes to AC3 are ignored until
 * the next system reset clears this field.
 *
 * Values:
 * - 0b0 - Writes to corresponding AC field are allowed.
 * - 0b1 - Writes to corresponding AC field are ignored.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRA_RO3 field. */
#define AIPS_RD_PACRA_RO3(base) ((AIPS_PACRA_REG(base) & AIPS_PACRA_RO3_MASK) >> AIPS_PACRA_RO3_SHIFT)
#define AIPS_BRD_PACRA_RO3(base) (BME_UBFX32(&AIPS_PACRA_REG(base), AIPS_PACRA_RO3_SHIFT, AIPS_PACRA_RO3_WIDTH))

/*! @brief Set the RO3 field to a new value. */
#define AIPS_WR_PACRA_RO3(base, value) (AIPS_RMW_PACRA(base, AIPS_PACRA_RO3_MASK, AIPS_PACRA_RO3(value)))
#define AIPS_BWR_PACRA_RO3(base, value) (BME_BFI32(&AIPS_PACRA_REG(base), ((uint32_t)(value) << AIPS_PACRA_RO3_SHIFT), AIPS_PACRA_RO3_SHIFT, AIPS_PACRA_RO3_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRA, field AC2[22:20] (RW)
 *
 * Defines the attributes required to access the corresponding slave
 * peripheral's memory space. See #pacr_attributes , "Attribute check (AC) values" for
 * details.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRA_AC2 field. */
#define AIPS_RD_PACRA_AC2(base) ((AIPS_PACRA_REG(base) & AIPS_PACRA_AC2_MASK) >> AIPS_PACRA_AC2_SHIFT)
#define AIPS_BRD_PACRA_AC2(base) (BME_UBFX32(&AIPS_PACRA_REG(base), AIPS_PACRA_AC2_SHIFT, AIPS_PACRA_AC2_WIDTH))

/*! @brief Set the AC2 field to a new value. */
#define AIPS_WR_PACRA_AC2(base, value) (AIPS_RMW_PACRA(base, AIPS_PACRA_AC2_MASK, AIPS_PACRA_AC2(value)))
#define AIPS_BWR_PACRA_AC2(base, value) (BME_BFI32(&AIPS_PACRA_REG(base), ((uint32_t)(value) << AIPS_PACRA_AC2_SHIFT), AIPS_PACRA_AC2_SHIFT, AIPS_PACRA_AC2_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRA, field RO2[23] (RW)
 *
 * Indicates the lock status of this register's AC2 field. After this field is
 * set to 1, it cannot be changed and attempted writes to AC2 are ignored until
 * the next system reset clears this field.
 *
 * Values:
 * - 0b0 - Writes to corresponding AC field are allowed.
 * - 0b1 - Writes to corresponding AC field are ignored.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRA_RO2 field. */
#define AIPS_RD_PACRA_RO2(base) ((AIPS_PACRA_REG(base) & AIPS_PACRA_RO2_MASK) >> AIPS_PACRA_RO2_SHIFT)
#define AIPS_BRD_PACRA_RO2(base) (BME_UBFX32(&AIPS_PACRA_REG(base), AIPS_PACRA_RO2_SHIFT, AIPS_PACRA_RO2_WIDTH))

/*! @brief Set the RO2 field to a new value. */
#define AIPS_WR_PACRA_RO2(base, value) (AIPS_RMW_PACRA(base, AIPS_PACRA_RO2_MASK, AIPS_PACRA_RO2(value)))
#define AIPS_BWR_PACRA_RO2(base, value) (BME_BFI32(&AIPS_PACRA_REG(base), ((uint32_t)(value) << AIPS_PACRA_RO2_SHIFT), AIPS_PACRA_RO2_SHIFT, AIPS_PACRA_RO2_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRA, field AC1[26:24] (RW)
 *
 * Defines the attributes required to access the corresponding slave
 * peripheral's memory space. See #pacr_attributes , "Attribute check (AC) values" for
 * details.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRA_AC1 field. */
#define AIPS_RD_PACRA_AC1(base) ((AIPS_PACRA_REG(base) & AIPS_PACRA_AC1_MASK) >> AIPS_PACRA_AC1_SHIFT)
#define AIPS_BRD_PACRA_AC1(base) (BME_UBFX32(&AIPS_PACRA_REG(base), AIPS_PACRA_AC1_SHIFT, AIPS_PACRA_AC1_WIDTH))

/*! @brief Set the AC1 field to a new value. */
#define AIPS_WR_PACRA_AC1(base, value) (AIPS_RMW_PACRA(base, AIPS_PACRA_AC1_MASK, AIPS_PACRA_AC1(value)))
#define AIPS_BWR_PACRA_AC1(base, value) (BME_BFI32(&AIPS_PACRA_REG(base), ((uint32_t)(value) << AIPS_PACRA_AC1_SHIFT), AIPS_PACRA_AC1_SHIFT, AIPS_PACRA_AC1_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRA, field RO1[27] (RW)
 *
 * Indicates the lock status of this register's AC1 field. After this field is
 * set to 1, it cannot be changed and attempted writes to AC1 are ignored until
 * the next system reset clears this field.
 *
 * Values:
 * - 0b0 - Writes to corresponding AC field are allowed.
 * - 0b1 - Writes to corresponding AC field are ignored.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRA_RO1 field. */
#define AIPS_RD_PACRA_RO1(base) ((AIPS_PACRA_REG(base) & AIPS_PACRA_RO1_MASK) >> AIPS_PACRA_RO1_SHIFT)
#define AIPS_BRD_PACRA_RO1(base) (BME_UBFX32(&AIPS_PACRA_REG(base), AIPS_PACRA_RO1_SHIFT, AIPS_PACRA_RO1_WIDTH))

/*! @brief Set the RO1 field to a new value. */
#define AIPS_WR_PACRA_RO1(base, value) (AIPS_RMW_PACRA(base, AIPS_PACRA_RO1_MASK, AIPS_PACRA_RO1(value)))
#define AIPS_BWR_PACRA_RO1(base, value) (BME_BFI32(&AIPS_PACRA_REG(base), ((uint32_t)(value) << AIPS_PACRA_RO1_SHIFT), AIPS_PACRA_RO1_SHIFT, AIPS_PACRA_RO1_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRA, field AC0[30:28] (RW)
 *
 * Defines the attributes required to access the corresponding slave
 * peripheral's memory space. See #pacr_attributes , "Attribute check (AC) values" for
 * details.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRA_AC0 field. */
#define AIPS_RD_PACRA_AC0(base) ((AIPS_PACRA_REG(base) & AIPS_PACRA_AC0_MASK) >> AIPS_PACRA_AC0_SHIFT)
#define AIPS_BRD_PACRA_AC0(base) (BME_UBFX32(&AIPS_PACRA_REG(base), AIPS_PACRA_AC0_SHIFT, AIPS_PACRA_AC0_WIDTH))

/*! @brief Set the AC0 field to a new value. */
#define AIPS_WR_PACRA_AC0(base, value) (AIPS_RMW_PACRA(base, AIPS_PACRA_AC0_MASK, AIPS_PACRA_AC0(value)))
#define AIPS_BWR_PACRA_AC0(base, value) (BME_BFI32(&AIPS_PACRA_REG(base), ((uint32_t)(value) << AIPS_PACRA_AC0_SHIFT), AIPS_PACRA_AC0_SHIFT, AIPS_PACRA_AC0_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRA, field RO0[31] (RW)
 *
 * Indicates the lock status of this register's AC0 field. After this field is
 * set to 1, it cannot be changed and attempted writes to AC0 are ignored until
 * the next system reset clears this field.
 *
 * Values:
 * - 0b0 - Writes to corresponding AC field are allowed.
 * - 0b1 - Writes to corresponding AC field are ignored.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRA_RO0 field. */
#define AIPS_RD_PACRA_RO0(base) ((AIPS_PACRA_REG(base) & AIPS_PACRA_RO0_MASK) >> AIPS_PACRA_RO0_SHIFT)
#define AIPS_BRD_PACRA_RO0(base) (BME_UBFX32(&AIPS_PACRA_REG(base), AIPS_PACRA_RO0_SHIFT, AIPS_PACRA_RO0_WIDTH))

/*! @brief Set the RO0 field to a new value. */
#define AIPS_WR_PACRA_RO0(base, value) (AIPS_RMW_PACRA(base, AIPS_PACRA_RO0_MASK, AIPS_PACRA_RO0(value)))
#define AIPS_BWR_PACRA_RO0(base, value) (BME_BFI32(&AIPS_PACRA_REG(base), ((uint32_t)(value) << AIPS_PACRA_RO0_SHIFT), AIPS_PACRA_RO0_SHIFT, AIPS_PACRA_RO0_WIDTH))
/*@}*/

/*******************************************************************************
 * AIPS_PACRB - Peripheral Access Control Register
 ******************************************************************************/

/*!
 * @brief AIPS_PACRB - Peripheral Access Control Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * Each peripheral on this chip has a 4-bit PACR field which includes a
 * read-only "lock" bit plus a 3-bit attribute check field which defines the access
 * rights (privileged/user, secure/nonsecure) needed to reference the slave
 * peripheral's address space. Access to these registers is allowed using only 32-bit
 * privileged, secure reads and writes. Each 32-bit register controls eight
 * peripherals. A peripheral's assignment to a PACR field is defined by the memory map slot
 * to which the peripheral is assigned. See this chip's peripheral bridge memory
 * map information for the assignment of a particular peripheral. The following
 * table shows the top-level structure of PACRs. Offset Register [31:28] [27:24]
 * [23:20] [19:16] [15:12] [11:8] [7:4] [3:0] 0x20 PACRA PACR0 PACR1 PACR2 PACR3
 * PACR4 PACR5 PACR6 PACR7 0x24 PACRB PACR8 PACR9 PACR10 PACR11 PACR12 PACR13
 * PACR14 PACR15 The following table defines the attribute check values for each AC
 * field. For access to peripherals that have their own access attribute checks,
 * such as GPIO, refer also to their attributes checks definitions. Attribute
 * check (AC) values AC User nonsecure User secure Privileged secure 0b000
 * Read/Write Read/Write Read/Write 0b001 Read Read/Write Read/Write 0b010 None Read/Write
 * Read/Write 0b011 Read Read Read/Write 0b100 None Read Read/Write 0b101 None
 * None Read/Write 0b110 None None Read 0b111 None None None
 */
/*!
 * @name Constants and macros for entire AIPS_PACRB register
 */
/*@{*/
#define AIPS_RD_PACRB(base)      (AIPS_PACRB_REG(base))
#define AIPS_WR_PACRB(base, value) (AIPS_PACRB_REG(base) = (value))
#define AIPS_RMW_PACRB(base, mask, value) (AIPS_WR_PACRB(base, (AIPS_RD_PACRB(base) & ~(mask)) | (value)))
#define AIPS_SET_PACRB(base, value) (BME_OR32(&AIPS_PACRB_REG(base), (uint32_t)(value)))
#define AIPS_CLR_PACRB(base, value) (BME_AND32(&AIPS_PACRB_REG(base), (uint32_t)(~(value))))
#define AIPS_TOG_PACRB(base, value) (BME_XOR32(&AIPS_PACRB_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual AIPS_PACRB bitfields
 */

/*!
 * @name Register AIPS_PACRB, field AC7[2:0] (RW)
 *
 * Defines the attributes required to access the corresponding slave
 * peripheral's memory space. See #pacr_attributes , "Attribute check (AC) values" for
 * details.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRB_AC7 field. */
#define AIPS_RD_PACRB_AC7(base) ((AIPS_PACRB_REG(base) & AIPS_PACRB_AC7_MASK) >> AIPS_PACRB_AC7_SHIFT)
#define AIPS_BRD_PACRB_AC7(base) (BME_UBFX32(&AIPS_PACRB_REG(base), AIPS_PACRB_AC7_SHIFT, AIPS_PACRB_AC7_WIDTH))

/*! @brief Set the AC7 field to a new value. */
#define AIPS_WR_PACRB_AC7(base, value) (AIPS_RMW_PACRB(base, AIPS_PACRB_AC7_MASK, AIPS_PACRB_AC7(value)))
#define AIPS_BWR_PACRB_AC7(base, value) (BME_BFI32(&AIPS_PACRB_REG(base), ((uint32_t)(value) << AIPS_PACRB_AC7_SHIFT), AIPS_PACRB_AC7_SHIFT, AIPS_PACRB_AC7_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRB, field RO7[3] (RW)
 *
 * Indicates the lock status of this register's AC7 field. After this field is
 * set to 1, it cannot be changed and attempted writes to AC7 are ignored until
 * the next system reset clears this field.
 *
 * Values:
 * - 0b0 - Writes to corresponding AC field are allowed.
 * - 0b1 - Writes to corresponding AC field are ignored.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRB_RO7 field. */
#define AIPS_RD_PACRB_RO7(base) ((AIPS_PACRB_REG(base) & AIPS_PACRB_RO7_MASK) >> AIPS_PACRB_RO7_SHIFT)
#define AIPS_BRD_PACRB_RO7(base) (BME_UBFX32(&AIPS_PACRB_REG(base), AIPS_PACRB_RO7_SHIFT, AIPS_PACRB_RO7_WIDTH))

/*! @brief Set the RO7 field to a new value. */
#define AIPS_WR_PACRB_RO7(base, value) (AIPS_RMW_PACRB(base, AIPS_PACRB_RO7_MASK, AIPS_PACRB_RO7(value)))
#define AIPS_BWR_PACRB_RO7(base, value) (BME_BFI32(&AIPS_PACRB_REG(base), ((uint32_t)(value) << AIPS_PACRB_RO7_SHIFT), AIPS_PACRB_RO7_SHIFT, AIPS_PACRB_RO7_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRB, field AC6[6:4] (RW)
 *
 * Defines the attributes required to access the corresponding slave
 * peripheral's memory space. See #pacr_attributes , "Attribute check (AC) values" for
 * details.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRB_AC6 field. */
#define AIPS_RD_PACRB_AC6(base) ((AIPS_PACRB_REG(base) & AIPS_PACRB_AC6_MASK) >> AIPS_PACRB_AC6_SHIFT)
#define AIPS_BRD_PACRB_AC6(base) (BME_UBFX32(&AIPS_PACRB_REG(base), AIPS_PACRB_AC6_SHIFT, AIPS_PACRB_AC6_WIDTH))

/*! @brief Set the AC6 field to a new value. */
#define AIPS_WR_PACRB_AC6(base, value) (AIPS_RMW_PACRB(base, AIPS_PACRB_AC6_MASK, AIPS_PACRB_AC6(value)))
#define AIPS_BWR_PACRB_AC6(base, value) (BME_BFI32(&AIPS_PACRB_REG(base), ((uint32_t)(value) << AIPS_PACRB_AC6_SHIFT), AIPS_PACRB_AC6_SHIFT, AIPS_PACRB_AC6_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRB, field RO6[7] (RW)
 *
 * Indicates the lock status of this register's AC6 field. After this field is
 * set to 1, it cannot be changed and attempted writes to AC6 are ignored until
 * the next system reset clears this field.
 *
 * Values:
 * - 0b0 - Writes to corresponding AC field are allowed.
 * - 0b1 - Writes to corresponding AC field are ignored.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRB_RO6 field. */
#define AIPS_RD_PACRB_RO6(base) ((AIPS_PACRB_REG(base) & AIPS_PACRB_RO6_MASK) >> AIPS_PACRB_RO6_SHIFT)
#define AIPS_BRD_PACRB_RO6(base) (BME_UBFX32(&AIPS_PACRB_REG(base), AIPS_PACRB_RO6_SHIFT, AIPS_PACRB_RO6_WIDTH))

/*! @brief Set the RO6 field to a new value. */
#define AIPS_WR_PACRB_RO6(base, value) (AIPS_RMW_PACRB(base, AIPS_PACRB_RO6_MASK, AIPS_PACRB_RO6(value)))
#define AIPS_BWR_PACRB_RO6(base, value) (BME_BFI32(&AIPS_PACRB_REG(base), ((uint32_t)(value) << AIPS_PACRB_RO6_SHIFT), AIPS_PACRB_RO6_SHIFT, AIPS_PACRB_RO6_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRB, field AC5[10:8] (RW)
 *
 * Defines the attributes required to access the corresponding slave
 * peripheral's memory space. See #pacr_attributes , "Attribute check (AC) values" for
 * details.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRB_AC5 field. */
#define AIPS_RD_PACRB_AC5(base) ((AIPS_PACRB_REG(base) & AIPS_PACRB_AC5_MASK) >> AIPS_PACRB_AC5_SHIFT)
#define AIPS_BRD_PACRB_AC5(base) (BME_UBFX32(&AIPS_PACRB_REG(base), AIPS_PACRB_AC5_SHIFT, AIPS_PACRB_AC5_WIDTH))

/*! @brief Set the AC5 field to a new value. */
#define AIPS_WR_PACRB_AC5(base, value) (AIPS_RMW_PACRB(base, AIPS_PACRB_AC5_MASK, AIPS_PACRB_AC5(value)))
#define AIPS_BWR_PACRB_AC5(base, value) (BME_BFI32(&AIPS_PACRB_REG(base), ((uint32_t)(value) << AIPS_PACRB_AC5_SHIFT), AIPS_PACRB_AC5_SHIFT, AIPS_PACRB_AC5_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRB, field RO5[11] (RW)
 *
 * Indicates the lock status of this register's AC5 field. After this field is
 * set to 1, it cannot be changed and attempted writes to AC5 are ignored until
 * the next system reset clears this field.
 *
 * Values:
 * - 0b0 - Writes to corresponding AC field are allowed.
 * - 0b1 - Writes to corresponding AC field are ignored.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRB_RO5 field. */
#define AIPS_RD_PACRB_RO5(base) ((AIPS_PACRB_REG(base) & AIPS_PACRB_RO5_MASK) >> AIPS_PACRB_RO5_SHIFT)
#define AIPS_BRD_PACRB_RO5(base) (BME_UBFX32(&AIPS_PACRB_REG(base), AIPS_PACRB_RO5_SHIFT, AIPS_PACRB_RO5_WIDTH))

/*! @brief Set the RO5 field to a new value. */
#define AIPS_WR_PACRB_RO5(base, value) (AIPS_RMW_PACRB(base, AIPS_PACRB_RO5_MASK, AIPS_PACRB_RO5(value)))
#define AIPS_BWR_PACRB_RO5(base, value) (BME_BFI32(&AIPS_PACRB_REG(base), ((uint32_t)(value) << AIPS_PACRB_RO5_SHIFT), AIPS_PACRB_RO5_SHIFT, AIPS_PACRB_RO5_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRB, field AC4[14:12] (RW)
 *
 * Defines the attributes required to access the corresponding slave
 * peripheral's memory space. See #pacr_attributes , "Attribute check (AC) values" for
 * details.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRB_AC4 field. */
#define AIPS_RD_PACRB_AC4(base) ((AIPS_PACRB_REG(base) & AIPS_PACRB_AC4_MASK) >> AIPS_PACRB_AC4_SHIFT)
#define AIPS_BRD_PACRB_AC4(base) (BME_UBFX32(&AIPS_PACRB_REG(base), AIPS_PACRB_AC4_SHIFT, AIPS_PACRB_AC4_WIDTH))

/*! @brief Set the AC4 field to a new value. */
#define AIPS_WR_PACRB_AC4(base, value) (AIPS_RMW_PACRB(base, AIPS_PACRB_AC4_MASK, AIPS_PACRB_AC4(value)))
#define AIPS_BWR_PACRB_AC4(base, value) (BME_BFI32(&AIPS_PACRB_REG(base), ((uint32_t)(value) << AIPS_PACRB_AC4_SHIFT), AIPS_PACRB_AC4_SHIFT, AIPS_PACRB_AC4_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRB, field RO4[15] (RW)
 *
 * Indicates the lock status of this register's AC4 field. After this field is
 * set to 1, it cannot be changed and attempted writes to AC4 are ignored until
 * the next system reset clears this field.
 *
 * Values:
 * - 0b0 - Writes to corresponding AC field are allowed.
 * - 0b1 - Writes to corresponding AC field are ignored.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRB_RO4 field. */
#define AIPS_RD_PACRB_RO4(base) ((AIPS_PACRB_REG(base) & AIPS_PACRB_RO4_MASK) >> AIPS_PACRB_RO4_SHIFT)
#define AIPS_BRD_PACRB_RO4(base) (BME_UBFX32(&AIPS_PACRB_REG(base), AIPS_PACRB_RO4_SHIFT, AIPS_PACRB_RO4_WIDTH))

/*! @brief Set the RO4 field to a new value. */
#define AIPS_WR_PACRB_RO4(base, value) (AIPS_RMW_PACRB(base, AIPS_PACRB_RO4_MASK, AIPS_PACRB_RO4(value)))
#define AIPS_BWR_PACRB_RO4(base, value) (BME_BFI32(&AIPS_PACRB_REG(base), ((uint32_t)(value) << AIPS_PACRB_RO4_SHIFT), AIPS_PACRB_RO4_SHIFT, AIPS_PACRB_RO4_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRB, field AC3[18:16] (RW)
 *
 * Defines the attributes required to access the corresponding slave
 * peripheral's memory space. See #pacr_attributes , "Attribute check (AC) values" for
 * details.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRB_AC3 field. */
#define AIPS_RD_PACRB_AC3(base) ((AIPS_PACRB_REG(base) & AIPS_PACRB_AC3_MASK) >> AIPS_PACRB_AC3_SHIFT)
#define AIPS_BRD_PACRB_AC3(base) (BME_UBFX32(&AIPS_PACRB_REG(base), AIPS_PACRB_AC3_SHIFT, AIPS_PACRB_AC3_WIDTH))

/*! @brief Set the AC3 field to a new value. */
#define AIPS_WR_PACRB_AC3(base, value) (AIPS_RMW_PACRB(base, AIPS_PACRB_AC3_MASK, AIPS_PACRB_AC3(value)))
#define AIPS_BWR_PACRB_AC3(base, value) (BME_BFI32(&AIPS_PACRB_REG(base), ((uint32_t)(value) << AIPS_PACRB_AC3_SHIFT), AIPS_PACRB_AC3_SHIFT, AIPS_PACRB_AC3_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRB, field RO3[19] (RW)
 *
 * Indicates the lock status of this register's AC3 field. After this field is
 * set to 1, it cannot be changed and attempted writes to AC3 are ignored until
 * the next system reset clears this field.
 *
 * Values:
 * - 0b0 - Writes to corresponding AC field are allowed.
 * - 0b1 - Writes to corresponding AC field are ignored.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRB_RO3 field. */
#define AIPS_RD_PACRB_RO3(base) ((AIPS_PACRB_REG(base) & AIPS_PACRB_RO3_MASK) >> AIPS_PACRB_RO3_SHIFT)
#define AIPS_BRD_PACRB_RO3(base) (BME_UBFX32(&AIPS_PACRB_REG(base), AIPS_PACRB_RO3_SHIFT, AIPS_PACRB_RO3_WIDTH))

/*! @brief Set the RO3 field to a new value. */
#define AIPS_WR_PACRB_RO3(base, value) (AIPS_RMW_PACRB(base, AIPS_PACRB_RO3_MASK, AIPS_PACRB_RO3(value)))
#define AIPS_BWR_PACRB_RO3(base, value) (BME_BFI32(&AIPS_PACRB_REG(base), ((uint32_t)(value) << AIPS_PACRB_RO3_SHIFT), AIPS_PACRB_RO3_SHIFT, AIPS_PACRB_RO3_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRB, field AC2[22:20] (RW)
 *
 * Defines the attributes required to access the corresponding slave
 * peripheral's memory space. See #pacr_attributes , "Attribute check (AC) values" for
 * details.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRB_AC2 field. */
#define AIPS_RD_PACRB_AC2(base) ((AIPS_PACRB_REG(base) & AIPS_PACRB_AC2_MASK) >> AIPS_PACRB_AC2_SHIFT)
#define AIPS_BRD_PACRB_AC2(base) (BME_UBFX32(&AIPS_PACRB_REG(base), AIPS_PACRB_AC2_SHIFT, AIPS_PACRB_AC2_WIDTH))

/*! @brief Set the AC2 field to a new value. */
#define AIPS_WR_PACRB_AC2(base, value) (AIPS_RMW_PACRB(base, AIPS_PACRB_AC2_MASK, AIPS_PACRB_AC2(value)))
#define AIPS_BWR_PACRB_AC2(base, value) (BME_BFI32(&AIPS_PACRB_REG(base), ((uint32_t)(value) << AIPS_PACRB_AC2_SHIFT), AIPS_PACRB_AC2_SHIFT, AIPS_PACRB_AC2_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRB, field RO2[23] (RW)
 *
 * Indicates the lock status of this register's AC2 field. After this field is
 * set to 1, it cannot be changed and attempted writes to AC2 are ignored until
 * the next system reset clears this field.
 *
 * Values:
 * - 0b0 - Writes to corresponding AC field are allowed.
 * - 0b1 - Writes to corresponding AC field are ignored.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRB_RO2 field. */
#define AIPS_RD_PACRB_RO2(base) ((AIPS_PACRB_REG(base) & AIPS_PACRB_RO2_MASK) >> AIPS_PACRB_RO2_SHIFT)
#define AIPS_BRD_PACRB_RO2(base) (BME_UBFX32(&AIPS_PACRB_REG(base), AIPS_PACRB_RO2_SHIFT, AIPS_PACRB_RO2_WIDTH))

/*! @brief Set the RO2 field to a new value. */
#define AIPS_WR_PACRB_RO2(base, value) (AIPS_RMW_PACRB(base, AIPS_PACRB_RO2_MASK, AIPS_PACRB_RO2(value)))
#define AIPS_BWR_PACRB_RO2(base, value) (BME_BFI32(&AIPS_PACRB_REG(base), ((uint32_t)(value) << AIPS_PACRB_RO2_SHIFT), AIPS_PACRB_RO2_SHIFT, AIPS_PACRB_RO2_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRB, field AC1[26:24] (RW)
 *
 * Defines the attributes required to access the corresponding slave
 * peripheral's memory space. See #pacr_attributes , "Attribute check (AC) values" for
 * details.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRB_AC1 field. */
#define AIPS_RD_PACRB_AC1(base) ((AIPS_PACRB_REG(base) & AIPS_PACRB_AC1_MASK) >> AIPS_PACRB_AC1_SHIFT)
#define AIPS_BRD_PACRB_AC1(base) (BME_UBFX32(&AIPS_PACRB_REG(base), AIPS_PACRB_AC1_SHIFT, AIPS_PACRB_AC1_WIDTH))

/*! @brief Set the AC1 field to a new value. */
#define AIPS_WR_PACRB_AC1(base, value) (AIPS_RMW_PACRB(base, AIPS_PACRB_AC1_MASK, AIPS_PACRB_AC1(value)))
#define AIPS_BWR_PACRB_AC1(base, value) (BME_BFI32(&AIPS_PACRB_REG(base), ((uint32_t)(value) << AIPS_PACRB_AC1_SHIFT), AIPS_PACRB_AC1_SHIFT, AIPS_PACRB_AC1_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRB, field RO1[27] (RW)
 *
 * Indicates the lock status of this register's AC1 field. After this field is
 * set to 1, it cannot be changed and attempted writes to AC1 are ignored until
 * the next system reset clears this field.
 *
 * Values:
 * - 0b0 - Writes to corresponding AC field are allowed.
 * - 0b1 - Writes to corresponding AC field are ignored.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRB_RO1 field. */
#define AIPS_RD_PACRB_RO1(base) ((AIPS_PACRB_REG(base) & AIPS_PACRB_RO1_MASK) >> AIPS_PACRB_RO1_SHIFT)
#define AIPS_BRD_PACRB_RO1(base) (BME_UBFX32(&AIPS_PACRB_REG(base), AIPS_PACRB_RO1_SHIFT, AIPS_PACRB_RO1_WIDTH))

/*! @brief Set the RO1 field to a new value. */
#define AIPS_WR_PACRB_RO1(base, value) (AIPS_RMW_PACRB(base, AIPS_PACRB_RO1_MASK, AIPS_PACRB_RO1(value)))
#define AIPS_BWR_PACRB_RO1(base, value) (BME_BFI32(&AIPS_PACRB_REG(base), ((uint32_t)(value) << AIPS_PACRB_RO1_SHIFT), AIPS_PACRB_RO1_SHIFT, AIPS_PACRB_RO1_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRB, field AC0[30:28] (RW)
 *
 * Defines the attributes required to access the corresponding slave
 * peripheral's memory space. See #pacr_attributes , "Attribute check (AC) values" for
 * details.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRB_AC0 field. */
#define AIPS_RD_PACRB_AC0(base) ((AIPS_PACRB_REG(base) & AIPS_PACRB_AC0_MASK) >> AIPS_PACRB_AC0_SHIFT)
#define AIPS_BRD_PACRB_AC0(base) (BME_UBFX32(&AIPS_PACRB_REG(base), AIPS_PACRB_AC0_SHIFT, AIPS_PACRB_AC0_WIDTH))

/*! @brief Set the AC0 field to a new value. */
#define AIPS_WR_PACRB_AC0(base, value) (AIPS_RMW_PACRB(base, AIPS_PACRB_AC0_MASK, AIPS_PACRB_AC0(value)))
#define AIPS_BWR_PACRB_AC0(base, value) (BME_BFI32(&AIPS_PACRB_REG(base), ((uint32_t)(value) << AIPS_PACRB_AC0_SHIFT), AIPS_PACRB_AC0_SHIFT, AIPS_PACRB_AC0_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRB, field RO0[31] (RW)
 *
 * Indicates the lock status of this register's AC0 field. After this field is
 * set to 1, it cannot be changed and attempted writes to AC0 are ignored until
 * the next system reset clears this field.
 *
 * Values:
 * - 0b0 - Writes to corresponding AC field are allowed.
 * - 0b1 - Writes to corresponding AC field are ignored.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRB_RO0 field. */
#define AIPS_RD_PACRB_RO0(base) ((AIPS_PACRB_REG(base) & AIPS_PACRB_RO0_MASK) >> AIPS_PACRB_RO0_SHIFT)
#define AIPS_BRD_PACRB_RO0(base) (BME_UBFX32(&AIPS_PACRB_REG(base), AIPS_PACRB_RO0_SHIFT, AIPS_PACRB_RO0_WIDTH))

/*! @brief Set the RO0 field to a new value. */
#define AIPS_WR_PACRB_RO0(base, value) (AIPS_RMW_PACRB(base, AIPS_PACRB_RO0_MASK, AIPS_PACRB_RO0(value)))
#define AIPS_BWR_PACRB_RO0(base, value) (BME_BFI32(&AIPS_PACRB_REG(base), ((uint32_t)(value) << AIPS_PACRB_RO0_SHIFT), AIPS_PACRB_RO0_SHIFT, AIPS_PACRB_RO0_WIDTH))
/*@}*/

/*******************************************************************************
 * AIPS_PACRE - Peripheral Access Control Register
 ******************************************************************************/

/*!
 * @brief AIPS_PACRE - Peripheral Access Control Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * Each peripheral on this chip has a 4-bit PACR field which includes a
 * read-only "lock" bit plus a 3-bit attribute check field which defines the access
 * rights (privileged/user, secure/nonsecure) needed to reference the slave
 * peripheral's address space. Access to these registers is allowed using only 32-bit
 * privileged, secure reads and writes. Each 32-bit register controls eight
 * peripherals. PACRE-PACR P control access to the 96 off-platform peripherals. A
 * peripheral's assignment to a PACR field is defined by the memory map slot to which the
 * peripheral is assigned. See this device's peripheral bridge memory map
 * information for the assignment of a particular peripheral. The following table shows
 * the top-level structure of PACRs. Offset Register [31:28] [27:24] [23:20]
 * [19:16] [15:12] [11:8] [7:4] [3:0] 0x40 PACRE PACR32 PACR33 PACR34 PACR35 PACR36
 * PACR37 PACR38 PACR39 0x44 PACRF PACR40 PACR41 PACR42 PACR43 PACR44 PACR45
 * PACR46 PACR47 0x48 PACRG PACR48 PACR49 PACR50 PACR51 PACR52 PACR53 PACR54 PACR55
 * 0x4C PACRH PACR56 PACR57 PACR58 PACR59 PACR60 PACR61 PACR62 PACR63 0x50 PACRI
 * PACR64 PACR65 PACR66 PACR67 PACR68 PACR69 PACR70 PACR71 0x54 PACRJ PACR72 PACR73
 * PACR74 PACR75 PACR76 PACR77 PACR78 PACR79 0x58 PACRK PACR80 PACR81 PACR82
 * PACR83 PACR84 PACR85 PACR86 PACR87 0x5C PACRL PACR88 PACR89 PACR90 PACR91 PACR92
 * PACR93 PACR94 PACR95 0x60 PACRM PACR96 PACR97 PACR98 PACR99 PACR100 PACR101
 * PACR102 PACR103 0x64 PACRN PACR104 PACR105 PACR106 PACR107 PACR108 PACR109
 * PACR110 PACR111 0x68 PACRO PACR112 PACR113 PACR114 PACR115 PACR116 PACR117 PACR118
 * PACR119 0x6C PACRP PACR120 PACR121 PACR122 PACR123 PACR124 PACR125 PACR126
 * PACR127
 */
/*!
 * @name Constants and macros for entire AIPS_PACRE register
 */
/*@{*/
#define AIPS_RD_PACRE(base)      (AIPS_PACRE_REG(base))
#define AIPS_WR_PACRE(base, value) (AIPS_PACRE_REG(base) = (value))
#define AIPS_RMW_PACRE(base, mask, value) (AIPS_WR_PACRE(base, (AIPS_RD_PACRE(base) & ~(mask)) | (value)))
#define AIPS_SET_PACRE(base, value) (BME_OR32(&AIPS_PACRE_REG(base), (uint32_t)(value)))
#define AIPS_CLR_PACRE(base, value) (BME_AND32(&AIPS_PACRE_REG(base), (uint32_t)(~(value))))
#define AIPS_TOG_PACRE(base, value) (BME_XOR32(&AIPS_PACRE_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual AIPS_PACRE bitfields
 */

/*!
 * @name Register AIPS_PACRE, field AC7[2:0] (RW)
 *
 * Defines the attributes required to access the corresponding slave
 * peripheral's memory space. See #pacr_attributes , "Attribute check (AC) values" for
 * details.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRE_AC7 field. */
#define AIPS_RD_PACRE_AC7(base) ((AIPS_PACRE_REG(base) & AIPS_PACRE_AC7_MASK) >> AIPS_PACRE_AC7_SHIFT)
#define AIPS_BRD_PACRE_AC7(base) (BME_UBFX32(&AIPS_PACRE_REG(base), AIPS_PACRE_AC7_SHIFT, AIPS_PACRE_AC7_WIDTH))

/*! @brief Set the AC7 field to a new value. */
#define AIPS_WR_PACRE_AC7(base, value) (AIPS_RMW_PACRE(base, AIPS_PACRE_AC7_MASK, AIPS_PACRE_AC7(value)))
#define AIPS_BWR_PACRE_AC7(base, value) (BME_BFI32(&AIPS_PACRE_REG(base), ((uint32_t)(value) << AIPS_PACRE_AC7_SHIFT), AIPS_PACRE_AC7_SHIFT, AIPS_PACRE_AC7_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRE, field RO7[3] (RW)
 *
 * Indicates the lock status of this register's AC7 field. After this field is
 * set to 1, it cannot be changed and attempted writes to AC7 are ignored until
 * the next system reset clears this field.
 *
 * Values:
 * - 0b0 - Writes to corresponding AC field are allowed.
 * - 0b1 - Writes to corresponding AC field are ignored.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRE_RO7 field. */
#define AIPS_RD_PACRE_RO7(base) ((AIPS_PACRE_REG(base) & AIPS_PACRE_RO7_MASK) >> AIPS_PACRE_RO7_SHIFT)
#define AIPS_BRD_PACRE_RO7(base) (BME_UBFX32(&AIPS_PACRE_REG(base), AIPS_PACRE_RO7_SHIFT, AIPS_PACRE_RO7_WIDTH))

/*! @brief Set the RO7 field to a new value. */
#define AIPS_WR_PACRE_RO7(base, value) (AIPS_RMW_PACRE(base, AIPS_PACRE_RO7_MASK, AIPS_PACRE_RO7(value)))
#define AIPS_BWR_PACRE_RO7(base, value) (BME_BFI32(&AIPS_PACRE_REG(base), ((uint32_t)(value) << AIPS_PACRE_RO7_SHIFT), AIPS_PACRE_RO7_SHIFT, AIPS_PACRE_RO7_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRE, field AC6[6:4] (RW)
 *
 * Defines the attributes required to access the corresponding slave
 * peripheral's memory space. See #pacr_attributes , "Attribute check (AC) values" for
 * details.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRE_AC6 field. */
#define AIPS_RD_PACRE_AC6(base) ((AIPS_PACRE_REG(base) & AIPS_PACRE_AC6_MASK) >> AIPS_PACRE_AC6_SHIFT)
#define AIPS_BRD_PACRE_AC6(base) (BME_UBFX32(&AIPS_PACRE_REG(base), AIPS_PACRE_AC6_SHIFT, AIPS_PACRE_AC6_WIDTH))

/*! @brief Set the AC6 field to a new value. */
#define AIPS_WR_PACRE_AC6(base, value) (AIPS_RMW_PACRE(base, AIPS_PACRE_AC6_MASK, AIPS_PACRE_AC6(value)))
#define AIPS_BWR_PACRE_AC6(base, value) (BME_BFI32(&AIPS_PACRE_REG(base), ((uint32_t)(value) << AIPS_PACRE_AC6_SHIFT), AIPS_PACRE_AC6_SHIFT, AIPS_PACRE_AC6_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRE, field RO6[7] (RW)
 *
 * Indicates the lock status of this register's AC6 field. After this field is
 * set to 1, it cannot be changed and attempted writes to AC6 are ignored until
 * the next system reset clears this field.
 *
 * Values:
 * - 0b0 - Writes to corresponding AC field are allowed.
 * - 0b1 - Writes to corresponding AC field are ignored.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRE_RO6 field. */
#define AIPS_RD_PACRE_RO6(base) ((AIPS_PACRE_REG(base) & AIPS_PACRE_RO6_MASK) >> AIPS_PACRE_RO6_SHIFT)
#define AIPS_BRD_PACRE_RO6(base) (BME_UBFX32(&AIPS_PACRE_REG(base), AIPS_PACRE_RO6_SHIFT, AIPS_PACRE_RO6_WIDTH))

/*! @brief Set the RO6 field to a new value. */
#define AIPS_WR_PACRE_RO6(base, value) (AIPS_RMW_PACRE(base, AIPS_PACRE_RO6_MASK, AIPS_PACRE_RO6(value)))
#define AIPS_BWR_PACRE_RO6(base, value) (BME_BFI32(&AIPS_PACRE_REG(base), ((uint32_t)(value) << AIPS_PACRE_RO6_SHIFT), AIPS_PACRE_RO6_SHIFT, AIPS_PACRE_RO6_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRE, field AC5[10:8] (RW)
 *
 * Defines the attributes required to access the corresponding slave
 * peripheral's memory space. See #pacr_attributes , "Attribute check (AC) values" for
 * details.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRE_AC5 field. */
#define AIPS_RD_PACRE_AC5(base) ((AIPS_PACRE_REG(base) & AIPS_PACRE_AC5_MASK) >> AIPS_PACRE_AC5_SHIFT)
#define AIPS_BRD_PACRE_AC5(base) (BME_UBFX32(&AIPS_PACRE_REG(base), AIPS_PACRE_AC5_SHIFT, AIPS_PACRE_AC5_WIDTH))

/*! @brief Set the AC5 field to a new value. */
#define AIPS_WR_PACRE_AC5(base, value) (AIPS_RMW_PACRE(base, AIPS_PACRE_AC5_MASK, AIPS_PACRE_AC5(value)))
#define AIPS_BWR_PACRE_AC5(base, value) (BME_BFI32(&AIPS_PACRE_REG(base), ((uint32_t)(value) << AIPS_PACRE_AC5_SHIFT), AIPS_PACRE_AC5_SHIFT, AIPS_PACRE_AC5_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRE, field RO5[11] (RW)
 *
 * Indicates the lock status of this register's AC5 field. After this field is
 * set to 1, it cannot be changed and attempted writes to AC5 are ignored until
 * the next system reset clears this field.
 *
 * Values:
 * - 0b0 - Writes to corresponding AC field are allowed.
 * - 0b1 - Writes to corresponding AC field are ignored.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRE_RO5 field. */
#define AIPS_RD_PACRE_RO5(base) ((AIPS_PACRE_REG(base) & AIPS_PACRE_RO5_MASK) >> AIPS_PACRE_RO5_SHIFT)
#define AIPS_BRD_PACRE_RO5(base) (BME_UBFX32(&AIPS_PACRE_REG(base), AIPS_PACRE_RO5_SHIFT, AIPS_PACRE_RO5_WIDTH))

/*! @brief Set the RO5 field to a new value. */
#define AIPS_WR_PACRE_RO5(base, value) (AIPS_RMW_PACRE(base, AIPS_PACRE_RO5_MASK, AIPS_PACRE_RO5(value)))
#define AIPS_BWR_PACRE_RO5(base, value) (BME_BFI32(&AIPS_PACRE_REG(base), ((uint32_t)(value) << AIPS_PACRE_RO5_SHIFT), AIPS_PACRE_RO5_SHIFT, AIPS_PACRE_RO5_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRE, field AC4[14:12] (RW)
 *
 * Defines the attributes required to access the corresponding slave
 * peripheral's memory space. See #pacr_attributes , "Attribute check (AC) values" for
 * details.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRE_AC4 field. */
#define AIPS_RD_PACRE_AC4(base) ((AIPS_PACRE_REG(base) & AIPS_PACRE_AC4_MASK) >> AIPS_PACRE_AC4_SHIFT)
#define AIPS_BRD_PACRE_AC4(base) (BME_UBFX32(&AIPS_PACRE_REG(base), AIPS_PACRE_AC4_SHIFT, AIPS_PACRE_AC4_WIDTH))

/*! @brief Set the AC4 field to a new value. */
#define AIPS_WR_PACRE_AC4(base, value) (AIPS_RMW_PACRE(base, AIPS_PACRE_AC4_MASK, AIPS_PACRE_AC4(value)))
#define AIPS_BWR_PACRE_AC4(base, value) (BME_BFI32(&AIPS_PACRE_REG(base), ((uint32_t)(value) << AIPS_PACRE_AC4_SHIFT), AIPS_PACRE_AC4_SHIFT, AIPS_PACRE_AC4_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRE, field RO4[15] (RW)
 *
 * Indicates the lock status of this register's AC4 field. After this field is
 * set to 1, it cannot be changed and attempted writes to AC4 are ignored until
 * the next system reset clears this field.
 *
 * Values:
 * - 0b0 - Writes to corresponding AC field are allowed.
 * - 0b1 - Writes to corresponding AC field are ignored.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRE_RO4 field. */
#define AIPS_RD_PACRE_RO4(base) ((AIPS_PACRE_REG(base) & AIPS_PACRE_RO4_MASK) >> AIPS_PACRE_RO4_SHIFT)
#define AIPS_BRD_PACRE_RO4(base) (BME_UBFX32(&AIPS_PACRE_REG(base), AIPS_PACRE_RO4_SHIFT, AIPS_PACRE_RO4_WIDTH))

/*! @brief Set the RO4 field to a new value. */
#define AIPS_WR_PACRE_RO4(base, value) (AIPS_RMW_PACRE(base, AIPS_PACRE_RO4_MASK, AIPS_PACRE_RO4(value)))
#define AIPS_BWR_PACRE_RO4(base, value) (BME_BFI32(&AIPS_PACRE_REG(base), ((uint32_t)(value) << AIPS_PACRE_RO4_SHIFT), AIPS_PACRE_RO4_SHIFT, AIPS_PACRE_RO4_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRE, field AC3[18:16] (RW)
 *
 * Defines the attributes required to access the corresponding slave
 * peripheral's memory space. See #pacr_attributes , "Attribute check (AC) values" for
 * details.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRE_AC3 field. */
#define AIPS_RD_PACRE_AC3(base) ((AIPS_PACRE_REG(base) & AIPS_PACRE_AC3_MASK) >> AIPS_PACRE_AC3_SHIFT)
#define AIPS_BRD_PACRE_AC3(base) (BME_UBFX32(&AIPS_PACRE_REG(base), AIPS_PACRE_AC3_SHIFT, AIPS_PACRE_AC3_WIDTH))

/*! @brief Set the AC3 field to a new value. */
#define AIPS_WR_PACRE_AC3(base, value) (AIPS_RMW_PACRE(base, AIPS_PACRE_AC3_MASK, AIPS_PACRE_AC3(value)))
#define AIPS_BWR_PACRE_AC3(base, value) (BME_BFI32(&AIPS_PACRE_REG(base), ((uint32_t)(value) << AIPS_PACRE_AC3_SHIFT), AIPS_PACRE_AC3_SHIFT, AIPS_PACRE_AC3_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRE, field RO3[19] (RW)
 *
 * Indicates the lock status of this register's AC3 field. After this field is
 * set to 1, it cannot be changed and attempted writes to AC3 are ignored until
 * the next system reset clears this field.
 *
 * Values:
 * - 0b0 - Writes to corresponding AC field are allowed.
 * - 0b1 - Writes to corresponding AC field are ignored.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRE_RO3 field. */
#define AIPS_RD_PACRE_RO3(base) ((AIPS_PACRE_REG(base) & AIPS_PACRE_RO3_MASK) >> AIPS_PACRE_RO3_SHIFT)
#define AIPS_BRD_PACRE_RO3(base) (BME_UBFX32(&AIPS_PACRE_REG(base), AIPS_PACRE_RO3_SHIFT, AIPS_PACRE_RO3_WIDTH))

/*! @brief Set the RO3 field to a new value. */
#define AIPS_WR_PACRE_RO3(base, value) (AIPS_RMW_PACRE(base, AIPS_PACRE_RO3_MASK, AIPS_PACRE_RO3(value)))
#define AIPS_BWR_PACRE_RO3(base, value) (BME_BFI32(&AIPS_PACRE_REG(base), ((uint32_t)(value) << AIPS_PACRE_RO3_SHIFT), AIPS_PACRE_RO3_SHIFT, AIPS_PACRE_RO3_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRE, field AC2[22:20] (RW)
 *
 * Defines the attributes required to access the corresponding slave
 * peripheral's memory space. See #pacr_attributes , "Attribute check (AC) values" for
 * details.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRE_AC2 field. */
#define AIPS_RD_PACRE_AC2(base) ((AIPS_PACRE_REG(base) & AIPS_PACRE_AC2_MASK) >> AIPS_PACRE_AC2_SHIFT)
#define AIPS_BRD_PACRE_AC2(base) (BME_UBFX32(&AIPS_PACRE_REG(base), AIPS_PACRE_AC2_SHIFT, AIPS_PACRE_AC2_WIDTH))

/*! @brief Set the AC2 field to a new value. */
#define AIPS_WR_PACRE_AC2(base, value) (AIPS_RMW_PACRE(base, AIPS_PACRE_AC2_MASK, AIPS_PACRE_AC2(value)))
#define AIPS_BWR_PACRE_AC2(base, value) (BME_BFI32(&AIPS_PACRE_REG(base), ((uint32_t)(value) << AIPS_PACRE_AC2_SHIFT), AIPS_PACRE_AC2_SHIFT, AIPS_PACRE_AC2_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRE, field RO2[23] (RW)
 *
 * Indicates the lock status of this register's AC2 field. After this field is
 * set to 1, it cannot be changed and attempted writes to AC2 are ignored until
 * the next system reset clears this field.
 *
 * Values:
 * - 0b0 - Writes to corresponding AC field are allowed.
 * - 0b1 - Writes to corresponding AC field are ignored.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRE_RO2 field. */
#define AIPS_RD_PACRE_RO2(base) ((AIPS_PACRE_REG(base) & AIPS_PACRE_RO2_MASK) >> AIPS_PACRE_RO2_SHIFT)
#define AIPS_BRD_PACRE_RO2(base) (BME_UBFX32(&AIPS_PACRE_REG(base), AIPS_PACRE_RO2_SHIFT, AIPS_PACRE_RO2_WIDTH))

/*! @brief Set the RO2 field to a new value. */
#define AIPS_WR_PACRE_RO2(base, value) (AIPS_RMW_PACRE(base, AIPS_PACRE_RO2_MASK, AIPS_PACRE_RO2(value)))
#define AIPS_BWR_PACRE_RO2(base, value) (BME_BFI32(&AIPS_PACRE_REG(base), ((uint32_t)(value) << AIPS_PACRE_RO2_SHIFT), AIPS_PACRE_RO2_SHIFT, AIPS_PACRE_RO2_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRE, field AC1[26:24] (RW)
 *
 * Defines the attributes required to access the corresponding slave
 * peripheral's memory space. See #pacr_attributes , "Attribute check (AC) values" for
 * details.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRE_AC1 field. */
#define AIPS_RD_PACRE_AC1(base) ((AIPS_PACRE_REG(base) & AIPS_PACRE_AC1_MASK) >> AIPS_PACRE_AC1_SHIFT)
#define AIPS_BRD_PACRE_AC1(base) (BME_UBFX32(&AIPS_PACRE_REG(base), AIPS_PACRE_AC1_SHIFT, AIPS_PACRE_AC1_WIDTH))

/*! @brief Set the AC1 field to a new value. */
#define AIPS_WR_PACRE_AC1(base, value) (AIPS_RMW_PACRE(base, AIPS_PACRE_AC1_MASK, AIPS_PACRE_AC1(value)))
#define AIPS_BWR_PACRE_AC1(base, value) (BME_BFI32(&AIPS_PACRE_REG(base), ((uint32_t)(value) << AIPS_PACRE_AC1_SHIFT), AIPS_PACRE_AC1_SHIFT, AIPS_PACRE_AC1_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRE, field RO1[27] (RW)
 *
 * Indicates the lock status of this register's AC1 field. After this field is
 * set to 1, it cannot be changed and attempted writes to AC1 are ignored until
 * the next system reset clears this field.
 *
 * Values:
 * - 0b0 - Writes to corresponding AC field are allowed.
 * - 0b1 - Writes to corresponding AC field are ignored.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRE_RO1 field. */
#define AIPS_RD_PACRE_RO1(base) ((AIPS_PACRE_REG(base) & AIPS_PACRE_RO1_MASK) >> AIPS_PACRE_RO1_SHIFT)
#define AIPS_BRD_PACRE_RO1(base) (BME_UBFX32(&AIPS_PACRE_REG(base), AIPS_PACRE_RO1_SHIFT, AIPS_PACRE_RO1_WIDTH))

/*! @brief Set the RO1 field to a new value. */
#define AIPS_WR_PACRE_RO1(base, value) (AIPS_RMW_PACRE(base, AIPS_PACRE_RO1_MASK, AIPS_PACRE_RO1(value)))
#define AIPS_BWR_PACRE_RO1(base, value) (BME_BFI32(&AIPS_PACRE_REG(base), ((uint32_t)(value) << AIPS_PACRE_RO1_SHIFT), AIPS_PACRE_RO1_SHIFT, AIPS_PACRE_RO1_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRE, field AC0[30:28] (RW)
 *
 * Defines the attributes required to access the corresponding slave
 * peripheral's memory space. See #pacr_attributes , "Attribute check (AC) values" for
 * details.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRE_AC0 field. */
#define AIPS_RD_PACRE_AC0(base) ((AIPS_PACRE_REG(base) & AIPS_PACRE_AC0_MASK) >> AIPS_PACRE_AC0_SHIFT)
#define AIPS_BRD_PACRE_AC0(base) (BME_UBFX32(&AIPS_PACRE_REG(base), AIPS_PACRE_AC0_SHIFT, AIPS_PACRE_AC0_WIDTH))

/*! @brief Set the AC0 field to a new value. */
#define AIPS_WR_PACRE_AC0(base, value) (AIPS_RMW_PACRE(base, AIPS_PACRE_AC0_MASK, AIPS_PACRE_AC0(value)))
#define AIPS_BWR_PACRE_AC0(base, value) (BME_BFI32(&AIPS_PACRE_REG(base), ((uint32_t)(value) << AIPS_PACRE_AC0_SHIFT), AIPS_PACRE_AC0_SHIFT, AIPS_PACRE_AC0_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRE, field RO0[31] (RW)
 *
 * Indicates the lock status of this register's AC0 field. After this field is
 * set to 1, it cannot be changed and attempted writes to AC0 are ignored until
 * the next system reset clears this field.
 *
 * Values:
 * - 0b0 - Writes to corresponding AC field are allowed.
 * - 0b1 - Writes to corresponding AC field are ignored.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRE_RO0 field. */
#define AIPS_RD_PACRE_RO0(base) ((AIPS_PACRE_REG(base) & AIPS_PACRE_RO0_MASK) >> AIPS_PACRE_RO0_SHIFT)
#define AIPS_BRD_PACRE_RO0(base) (BME_UBFX32(&AIPS_PACRE_REG(base), AIPS_PACRE_RO0_SHIFT, AIPS_PACRE_RO0_WIDTH))

/*! @brief Set the RO0 field to a new value. */
#define AIPS_WR_PACRE_RO0(base, value) (AIPS_RMW_PACRE(base, AIPS_PACRE_RO0_MASK, AIPS_PACRE_RO0(value)))
#define AIPS_BWR_PACRE_RO0(base, value) (BME_BFI32(&AIPS_PACRE_REG(base), ((uint32_t)(value) << AIPS_PACRE_RO0_SHIFT), AIPS_PACRE_RO0_SHIFT, AIPS_PACRE_RO0_WIDTH))
/*@}*/

/*******************************************************************************
 * AIPS_PACRF - Peripheral Access Control Register
 ******************************************************************************/

/*!
 * @brief AIPS_PACRF - Peripheral Access Control Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * Each peripheral on this chip has a 4-bit PACR field which includes a
 * read-only "lock" bit plus a 3-bit attribute check field which defines the access
 * rights (privileged/user, secure/nonsecure) needed to reference the slave
 * peripheral's address space. Access to these registers is allowed using only 32-bit
 * privileged, secure reads and writes. Each 32-bit register controls eight
 * peripherals. PACRE-PACR P control access to the 96 off-platform peripherals. A
 * peripheral's assignment to a PACR field is defined by the memory map slot to which the
 * peripheral is assigned. See this device's peripheral bridge memory map
 * information for the assignment of a particular peripheral. The following table shows
 * the top-level structure of PACRs. Offset Register [31:28] [27:24] [23:20]
 * [19:16] [15:12] [11:8] [7:4] [3:0] 0x40 PACRE PACR32 PACR33 PACR34 PACR35 PACR36
 * PACR37 PACR38 PACR39 0x44 PACRF PACR40 PACR41 PACR42 PACR43 PACR44 PACR45
 * PACR46 PACR47 0x48 PACRG PACR48 PACR49 PACR50 PACR51 PACR52 PACR53 PACR54 PACR55
 * 0x4C PACRH PACR56 PACR57 PACR58 PACR59 PACR60 PACR61 PACR62 PACR63 0x50 PACRI
 * PACR64 PACR65 PACR66 PACR67 PACR68 PACR69 PACR70 PACR71 0x54 PACRJ PACR72 PACR73
 * PACR74 PACR75 PACR76 PACR77 PACR78 PACR79 0x58 PACRK PACR80 PACR81 PACR82
 * PACR83 PACR84 PACR85 PACR86 PACR87 0x5C PACRL PACR88 PACR89 PACR90 PACR91 PACR92
 * PACR93 PACR94 PACR95 0x60 PACRM PACR96 PACR97 PACR98 PACR99 PACR100 PACR101
 * PACR102 PACR103 0x64 PACRN PACR104 PACR105 PACR106 PACR107 PACR108 PACR109
 * PACR110 PACR111 0x68 PACRO PACR112 PACR113 PACR114 PACR115 PACR116 PACR117 PACR118
 * PACR119 0x6C PACRP PACR120 PACR121 PACR122 PACR123 PACR124 PACR125 PACR126
 * PACR127
 */
/*!
 * @name Constants and macros for entire AIPS_PACRF register
 */
/*@{*/
#define AIPS_RD_PACRF(base)      (AIPS_PACRF_REG(base))
#define AIPS_WR_PACRF(base, value) (AIPS_PACRF_REG(base) = (value))
#define AIPS_RMW_PACRF(base, mask, value) (AIPS_WR_PACRF(base, (AIPS_RD_PACRF(base) & ~(mask)) | (value)))
#define AIPS_SET_PACRF(base, value) (BME_OR32(&AIPS_PACRF_REG(base), (uint32_t)(value)))
#define AIPS_CLR_PACRF(base, value) (BME_AND32(&AIPS_PACRF_REG(base), (uint32_t)(~(value))))
#define AIPS_TOG_PACRF(base, value) (BME_XOR32(&AIPS_PACRF_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual AIPS_PACRF bitfields
 */

/*!
 * @name Register AIPS_PACRF, field AC7[2:0] (RW)
 *
 * Defines the attributes required to access the corresponding slave
 * peripheral's memory space. See #pacr_attributes , "Attribute check (AC) values" for
 * details.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRF_AC7 field. */
#define AIPS_RD_PACRF_AC7(base) ((AIPS_PACRF_REG(base) & AIPS_PACRF_AC7_MASK) >> AIPS_PACRF_AC7_SHIFT)
#define AIPS_BRD_PACRF_AC7(base) (BME_UBFX32(&AIPS_PACRF_REG(base), AIPS_PACRF_AC7_SHIFT, AIPS_PACRF_AC7_WIDTH))

/*! @brief Set the AC7 field to a new value. */
#define AIPS_WR_PACRF_AC7(base, value) (AIPS_RMW_PACRF(base, AIPS_PACRF_AC7_MASK, AIPS_PACRF_AC7(value)))
#define AIPS_BWR_PACRF_AC7(base, value) (BME_BFI32(&AIPS_PACRF_REG(base), ((uint32_t)(value) << AIPS_PACRF_AC7_SHIFT), AIPS_PACRF_AC7_SHIFT, AIPS_PACRF_AC7_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRF, field RO7[3] (RW)
 *
 * Indicates the lock status of this register's AC7 field. After this field is
 * set to 1, it cannot be changed and attempted writes to AC7 are ignored until
 * the next system reset clears this field.
 *
 * Values:
 * - 0b0 - Writes to corresponding AC field are allowed.
 * - 0b1 - Writes to corresponding AC field are ignored.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRF_RO7 field. */
#define AIPS_RD_PACRF_RO7(base) ((AIPS_PACRF_REG(base) & AIPS_PACRF_RO7_MASK) >> AIPS_PACRF_RO7_SHIFT)
#define AIPS_BRD_PACRF_RO7(base) (BME_UBFX32(&AIPS_PACRF_REG(base), AIPS_PACRF_RO7_SHIFT, AIPS_PACRF_RO7_WIDTH))

/*! @brief Set the RO7 field to a new value. */
#define AIPS_WR_PACRF_RO7(base, value) (AIPS_RMW_PACRF(base, AIPS_PACRF_RO7_MASK, AIPS_PACRF_RO7(value)))
#define AIPS_BWR_PACRF_RO7(base, value) (BME_BFI32(&AIPS_PACRF_REG(base), ((uint32_t)(value) << AIPS_PACRF_RO7_SHIFT), AIPS_PACRF_RO7_SHIFT, AIPS_PACRF_RO7_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRF, field AC6[6:4] (RW)
 *
 * Defines the attributes required to access the corresponding slave
 * peripheral's memory space. See #pacr_attributes , "Attribute check (AC) values" for
 * details.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRF_AC6 field. */
#define AIPS_RD_PACRF_AC6(base) ((AIPS_PACRF_REG(base) & AIPS_PACRF_AC6_MASK) >> AIPS_PACRF_AC6_SHIFT)
#define AIPS_BRD_PACRF_AC6(base) (BME_UBFX32(&AIPS_PACRF_REG(base), AIPS_PACRF_AC6_SHIFT, AIPS_PACRF_AC6_WIDTH))

/*! @brief Set the AC6 field to a new value. */
#define AIPS_WR_PACRF_AC6(base, value) (AIPS_RMW_PACRF(base, AIPS_PACRF_AC6_MASK, AIPS_PACRF_AC6(value)))
#define AIPS_BWR_PACRF_AC6(base, value) (BME_BFI32(&AIPS_PACRF_REG(base), ((uint32_t)(value) << AIPS_PACRF_AC6_SHIFT), AIPS_PACRF_AC6_SHIFT, AIPS_PACRF_AC6_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRF, field RO6[7] (RW)
 *
 * Indicates the lock status of this register's AC6 field. After this field is
 * set to 1, it cannot be changed and attempted writes to AC6 are ignored until
 * the next system reset clears this field.
 *
 * Values:
 * - 0b0 - Writes to corresponding AC field are allowed.
 * - 0b1 - Writes to corresponding AC field are ignored.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRF_RO6 field. */
#define AIPS_RD_PACRF_RO6(base) ((AIPS_PACRF_REG(base) & AIPS_PACRF_RO6_MASK) >> AIPS_PACRF_RO6_SHIFT)
#define AIPS_BRD_PACRF_RO6(base) (BME_UBFX32(&AIPS_PACRF_REG(base), AIPS_PACRF_RO6_SHIFT, AIPS_PACRF_RO6_WIDTH))

/*! @brief Set the RO6 field to a new value. */
#define AIPS_WR_PACRF_RO6(base, value) (AIPS_RMW_PACRF(base, AIPS_PACRF_RO6_MASK, AIPS_PACRF_RO6(value)))
#define AIPS_BWR_PACRF_RO6(base, value) (BME_BFI32(&AIPS_PACRF_REG(base), ((uint32_t)(value) << AIPS_PACRF_RO6_SHIFT), AIPS_PACRF_RO6_SHIFT, AIPS_PACRF_RO6_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRF, field AC5[10:8] (RW)
 *
 * Defines the attributes required to access the corresponding slave
 * peripheral's memory space. See #pacr_attributes , "Attribute check (AC) values" for
 * details.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRF_AC5 field. */
#define AIPS_RD_PACRF_AC5(base) ((AIPS_PACRF_REG(base) & AIPS_PACRF_AC5_MASK) >> AIPS_PACRF_AC5_SHIFT)
#define AIPS_BRD_PACRF_AC5(base) (BME_UBFX32(&AIPS_PACRF_REG(base), AIPS_PACRF_AC5_SHIFT, AIPS_PACRF_AC5_WIDTH))

/*! @brief Set the AC5 field to a new value. */
#define AIPS_WR_PACRF_AC5(base, value) (AIPS_RMW_PACRF(base, AIPS_PACRF_AC5_MASK, AIPS_PACRF_AC5(value)))
#define AIPS_BWR_PACRF_AC5(base, value) (BME_BFI32(&AIPS_PACRF_REG(base), ((uint32_t)(value) << AIPS_PACRF_AC5_SHIFT), AIPS_PACRF_AC5_SHIFT, AIPS_PACRF_AC5_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRF, field RO5[11] (RW)
 *
 * Indicates the lock status of this register's AC5 field. After this field is
 * set to 1, it cannot be changed and attempted writes to AC5 are ignored until
 * the next system reset clears this field.
 *
 * Values:
 * - 0b0 - Writes to corresponding AC field are allowed.
 * - 0b1 - Writes to corresponding AC field are ignored.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRF_RO5 field. */
#define AIPS_RD_PACRF_RO5(base) ((AIPS_PACRF_REG(base) & AIPS_PACRF_RO5_MASK) >> AIPS_PACRF_RO5_SHIFT)
#define AIPS_BRD_PACRF_RO5(base) (BME_UBFX32(&AIPS_PACRF_REG(base), AIPS_PACRF_RO5_SHIFT, AIPS_PACRF_RO5_WIDTH))

/*! @brief Set the RO5 field to a new value. */
#define AIPS_WR_PACRF_RO5(base, value) (AIPS_RMW_PACRF(base, AIPS_PACRF_RO5_MASK, AIPS_PACRF_RO5(value)))
#define AIPS_BWR_PACRF_RO5(base, value) (BME_BFI32(&AIPS_PACRF_REG(base), ((uint32_t)(value) << AIPS_PACRF_RO5_SHIFT), AIPS_PACRF_RO5_SHIFT, AIPS_PACRF_RO5_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRF, field AC4[14:12] (RW)
 *
 * Defines the attributes required to access the corresponding slave
 * peripheral's memory space. See #pacr_attributes , "Attribute check (AC) values" for
 * details.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRF_AC4 field. */
#define AIPS_RD_PACRF_AC4(base) ((AIPS_PACRF_REG(base) & AIPS_PACRF_AC4_MASK) >> AIPS_PACRF_AC4_SHIFT)
#define AIPS_BRD_PACRF_AC4(base) (BME_UBFX32(&AIPS_PACRF_REG(base), AIPS_PACRF_AC4_SHIFT, AIPS_PACRF_AC4_WIDTH))

/*! @brief Set the AC4 field to a new value. */
#define AIPS_WR_PACRF_AC4(base, value) (AIPS_RMW_PACRF(base, AIPS_PACRF_AC4_MASK, AIPS_PACRF_AC4(value)))
#define AIPS_BWR_PACRF_AC4(base, value) (BME_BFI32(&AIPS_PACRF_REG(base), ((uint32_t)(value) << AIPS_PACRF_AC4_SHIFT), AIPS_PACRF_AC4_SHIFT, AIPS_PACRF_AC4_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRF, field RO4[15] (RW)
 *
 * Indicates the lock status of this register's AC4 field. After this field is
 * set to 1, it cannot be changed and attempted writes to AC4 are ignored until
 * the next system reset clears this field.
 *
 * Values:
 * - 0b0 - Writes to corresponding AC field are allowed.
 * - 0b1 - Writes to corresponding AC field are ignored.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRF_RO4 field. */
#define AIPS_RD_PACRF_RO4(base) ((AIPS_PACRF_REG(base) & AIPS_PACRF_RO4_MASK) >> AIPS_PACRF_RO4_SHIFT)
#define AIPS_BRD_PACRF_RO4(base) (BME_UBFX32(&AIPS_PACRF_REG(base), AIPS_PACRF_RO4_SHIFT, AIPS_PACRF_RO4_WIDTH))

/*! @brief Set the RO4 field to a new value. */
#define AIPS_WR_PACRF_RO4(base, value) (AIPS_RMW_PACRF(base, AIPS_PACRF_RO4_MASK, AIPS_PACRF_RO4(value)))
#define AIPS_BWR_PACRF_RO4(base, value) (BME_BFI32(&AIPS_PACRF_REG(base), ((uint32_t)(value) << AIPS_PACRF_RO4_SHIFT), AIPS_PACRF_RO4_SHIFT, AIPS_PACRF_RO4_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRF, field AC3[18:16] (RW)
 *
 * Defines the attributes required to access the corresponding slave
 * peripheral's memory space. See #pacr_attributes , "Attribute check (AC) values" for
 * details.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRF_AC3 field. */
#define AIPS_RD_PACRF_AC3(base) ((AIPS_PACRF_REG(base) & AIPS_PACRF_AC3_MASK) >> AIPS_PACRF_AC3_SHIFT)
#define AIPS_BRD_PACRF_AC3(base) (BME_UBFX32(&AIPS_PACRF_REG(base), AIPS_PACRF_AC3_SHIFT, AIPS_PACRF_AC3_WIDTH))

/*! @brief Set the AC3 field to a new value. */
#define AIPS_WR_PACRF_AC3(base, value) (AIPS_RMW_PACRF(base, AIPS_PACRF_AC3_MASK, AIPS_PACRF_AC3(value)))
#define AIPS_BWR_PACRF_AC3(base, value) (BME_BFI32(&AIPS_PACRF_REG(base), ((uint32_t)(value) << AIPS_PACRF_AC3_SHIFT), AIPS_PACRF_AC3_SHIFT, AIPS_PACRF_AC3_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRF, field RO3[19] (RW)
 *
 * Indicates the lock status of this register's AC3 field. After this field is
 * set to 1, it cannot be changed and attempted writes to AC3 are ignored until
 * the next system reset clears this field.
 *
 * Values:
 * - 0b0 - Writes to corresponding AC field are allowed.
 * - 0b1 - Writes to corresponding AC field are ignored.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRF_RO3 field. */
#define AIPS_RD_PACRF_RO3(base) ((AIPS_PACRF_REG(base) & AIPS_PACRF_RO3_MASK) >> AIPS_PACRF_RO3_SHIFT)
#define AIPS_BRD_PACRF_RO3(base) (BME_UBFX32(&AIPS_PACRF_REG(base), AIPS_PACRF_RO3_SHIFT, AIPS_PACRF_RO3_WIDTH))

/*! @brief Set the RO3 field to a new value. */
#define AIPS_WR_PACRF_RO3(base, value) (AIPS_RMW_PACRF(base, AIPS_PACRF_RO3_MASK, AIPS_PACRF_RO3(value)))
#define AIPS_BWR_PACRF_RO3(base, value) (BME_BFI32(&AIPS_PACRF_REG(base), ((uint32_t)(value) << AIPS_PACRF_RO3_SHIFT), AIPS_PACRF_RO3_SHIFT, AIPS_PACRF_RO3_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRF, field AC2[22:20] (RW)
 *
 * Defines the attributes required to access the corresponding slave
 * peripheral's memory space. See #pacr_attributes , "Attribute check (AC) values" for
 * details.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRF_AC2 field. */
#define AIPS_RD_PACRF_AC2(base) ((AIPS_PACRF_REG(base) & AIPS_PACRF_AC2_MASK) >> AIPS_PACRF_AC2_SHIFT)
#define AIPS_BRD_PACRF_AC2(base) (BME_UBFX32(&AIPS_PACRF_REG(base), AIPS_PACRF_AC2_SHIFT, AIPS_PACRF_AC2_WIDTH))

/*! @brief Set the AC2 field to a new value. */
#define AIPS_WR_PACRF_AC2(base, value) (AIPS_RMW_PACRF(base, AIPS_PACRF_AC2_MASK, AIPS_PACRF_AC2(value)))
#define AIPS_BWR_PACRF_AC2(base, value) (BME_BFI32(&AIPS_PACRF_REG(base), ((uint32_t)(value) << AIPS_PACRF_AC2_SHIFT), AIPS_PACRF_AC2_SHIFT, AIPS_PACRF_AC2_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRF, field RO2[23] (RW)
 *
 * Indicates the lock status of this register's AC2 field. After this field is
 * set to 1, it cannot be changed and attempted writes to AC2 are ignored until
 * the next system reset clears this field.
 *
 * Values:
 * - 0b0 - Writes to corresponding AC field are allowed.
 * - 0b1 - Writes to corresponding AC field are ignored.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRF_RO2 field. */
#define AIPS_RD_PACRF_RO2(base) ((AIPS_PACRF_REG(base) & AIPS_PACRF_RO2_MASK) >> AIPS_PACRF_RO2_SHIFT)
#define AIPS_BRD_PACRF_RO2(base) (BME_UBFX32(&AIPS_PACRF_REG(base), AIPS_PACRF_RO2_SHIFT, AIPS_PACRF_RO2_WIDTH))

/*! @brief Set the RO2 field to a new value. */
#define AIPS_WR_PACRF_RO2(base, value) (AIPS_RMW_PACRF(base, AIPS_PACRF_RO2_MASK, AIPS_PACRF_RO2(value)))
#define AIPS_BWR_PACRF_RO2(base, value) (BME_BFI32(&AIPS_PACRF_REG(base), ((uint32_t)(value) << AIPS_PACRF_RO2_SHIFT), AIPS_PACRF_RO2_SHIFT, AIPS_PACRF_RO2_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRF, field AC1[26:24] (RW)
 *
 * Defines the attributes required to access the corresponding slave
 * peripheral's memory space. See #pacr_attributes , "Attribute check (AC) values" for
 * details.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRF_AC1 field. */
#define AIPS_RD_PACRF_AC1(base) ((AIPS_PACRF_REG(base) & AIPS_PACRF_AC1_MASK) >> AIPS_PACRF_AC1_SHIFT)
#define AIPS_BRD_PACRF_AC1(base) (BME_UBFX32(&AIPS_PACRF_REG(base), AIPS_PACRF_AC1_SHIFT, AIPS_PACRF_AC1_WIDTH))

/*! @brief Set the AC1 field to a new value. */
#define AIPS_WR_PACRF_AC1(base, value) (AIPS_RMW_PACRF(base, AIPS_PACRF_AC1_MASK, AIPS_PACRF_AC1(value)))
#define AIPS_BWR_PACRF_AC1(base, value) (BME_BFI32(&AIPS_PACRF_REG(base), ((uint32_t)(value) << AIPS_PACRF_AC1_SHIFT), AIPS_PACRF_AC1_SHIFT, AIPS_PACRF_AC1_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRF, field RO1[27] (RW)
 *
 * Indicates the lock status of this register's AC1 field. After this field is
 * set to 1, it cannot be changed and attempted writes to AC1 are ignored until
 * the next system reset clears this field.
 *
 * Values:
 * - 0b0 - Writes to corresponding AC field are allowed.
 * - 0b1 - Writes to corresponding AC field are ignored.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRF_RO1 field. */
#define AIPS_RD_PACRF_RO1(base) ((AIPS_PACRF_REG(base) & AIPS_PACRF_RO1_MASK) >> AIPS_PACRF_RO1_SHIFT)
#define AIPS_BRD_PACRF_RO1(base) (BME_UBFX32(&AIPS_PACRF_REG(base), AIPS_PACRF_RO1_SHIFT, AIPS_PACRF_RO1_WIDTH))

/*! @brief Set the RO1 field to a new value. */
#define AIPS_WR_PACRF_RO1(base, value) (AIPS_RMW_PACRF(base, AIPS_PACRF_RO1_MASK, AIPS_PACRF_RO1(value)))
#define AIPS_BWR_PACRF_RO1(base, value) (BME_BFI32(&AIPS_PACRF_REG(base), ((uint32_t)(value) << AIPS_PACRF_RO1_SHIFT), AIPS_PACRF_RO1_SHIFT, AIPS_PACRF_RO1_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRF, field AC0[30:28] (RW)
 *
 * Defines the attributes required to access the corresponding slave
 * peripheral's memory space. See #pacr_attributes , "Attribute check (AC) values" for
 * details.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRF_AC0 field. */
#define AIPS_RD_PACRF_AC0(base) ((AIPS_PACRF_REG(base) & AIPS_PACRF_AC0_MASK) >> AIPS_PACRF_AC0_SHIFT)
#define AIPS_BRD_PACRF_AC0(base) (BME_UBFX32(&AIPS_PACRF_REG(base), AIPS_PACRF_AC0_SHIFT, AIPS_PACRF_AC0_WIDTH))

/*! @brief Set the AC0 field to a new value. */
#define AIPS_WR_PACRF_AC0(base, value) (AIPS_RMW_PACRF(base, AIPS_PACRF_AC0_MASK, AIPS_PACRF_AC0(value)))
#define AIPS_BWR_PACRF_AC0(base, value) (BME_BFI32(&AIPS_PACRF_REG(base), ((uint32_t)(value) << AIPS_PACRF_AC0_SHIFT), AIPS_PACRF_AC0_SHIFT, AIPS_PACRF_AC0_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRF, field RO0[31] (RW)
 *
 * Indicates the lock status of this register's AC0 field. After this field is
 * set to 1, it cannot be changed and attempted writes to AC0 are ignored until
 * the next system reset clears this field.
 *
 * Values:
 * - 0b0 - Writes to corresponding AC field are allowed.
 * - 0b1 - Writes to corresponding AC field are ignored.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRF_RO0 field. */
#define AIPS_RD_PACRF_RO0(base) ((AIPS_PACRF_REG(base) & AIPS_PACRF_RO0_MASK) >> AIPS_PACRF_RO0_SHIFT)
#define AIPS_BRD_PACRF_RO0(base) (BME_UBFX32(&AIPS_PACRF_REG(base), AIPS_PACRF_RO0_SHIFT, AIPS_PACRF_RO0_WIDTH))

/*! @brief Set the RO0 field to a new value. */
#define AIPS_WR_PACRF_RO0(base, value) (AIPS_RMW_PACRF(base, AIPS_PACRF_RO0_MASK, AIPS_PACRF_RO0(value)))
#define AIPS_BWR_PACRF_RO0(base, value) (BME_BFI32(&AIPS_PACRF_REG(base), ((uint32_t)(value) << AIPS_PACRF_RO0_SHIFT), AIPS_PACRF_RO0_SHIFT, AIPS_PACRF_RO0_WIDTH))
/*@}*/

/*******************************************************************************
 * AIPS_PACRG - Peripheral Access Control Register
 ******************************************************************************/

/*!
 * @brief AIPS_PACRG - Peripheral Access Control Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * Each peripheral on this chip has a 4-bit PACR field which includes a
 * read-only "lock" bit plus a 3-bit attribute check field which defines the access
 * rights (privileged/user, secure/nonsecure) needed to reference the slave
 * peripheral's address space. Access to these registers is allowed using only 32-bit
 * privileged, secure reads and writes. Each 32-bit register controls eight
 * peripherals. PACRE-PACR P control access to the 96 off-platform peripherals. A
 * peripheral's assignment to a PACR field is defined by the memory map slot to which the
 * peripheral is assigned. See this device's peripheral bridge memory map
 * information for the assignment of a particular peripheral. The following table shows
 * the top-level structure of PACRs. Offset Register [31:28] [27:24] [23:20]
 * [19:16] [15:12] [11:8] [7:4] [3:0] 0x40 PACRE PACR32 PACR33 PACR34 PACR35 PACR36
 * PACR37 PACR38 PACR39 0x44 PACRF PACR40 PACR41 PACR42 PACR43 PACR44 PACR45
 * PACR46 PACR47 0x48 PACRG PACR48 PACR49 PACR50 PACR51 PACR52 PACR53 PACR54 PACR55
 * 0x4C PACRH PACR56 PACR57 PACR58 PACR59 PACR60 PACR61 PACR62 PACR63 0x50 PACRI
 * PACR64 PACR65 PACR66 PACR67 PACR68 PACR69 PACR70 PACR71 0x54 PACRJ PACR72 PACR73
 * PACR74 PACR75 PACR76 PACR77 PACR78 PACR79 0x58 PACRK PACR80 PACR81 PACR82
 * PACR83 PACR84 PACR85 PACR86 PACR87 0x5C PACRL PACR88 PACR89 PACR90 PACR91 PACR92
 * PACR93 PACR94 PACR95 0x60 PACRM PACR96 PACR97 PACR98 PACR99 PACR100 PACR101
 * PACR102 PACR103 0x64 PACRN PACR104 PACR105 PACR106 PACR107 PACR108 PACR109
 * PACR110 PACR111 0x68 PACRO PACR112 PACR113 PACR114 PACR115 PACR116 PACR117 PACR118
 * PACR119 0x6C PACRP PACR120 PACR121 PACR122 PACR123 PACR124 PACR125 PACR126
 * PACR127
 */
/*!
 * @name Constants and macros for entire AIPS_PACRG register
 */
/*@{*/
#define AIPS_RD_PACRG(base)      (AIPS_PACRG_REG(base))
#define AIPS_WR_PACRG(base, value) (AIPS_PACRG_REG(base) = (value))
#define AIPS_RMW_PACRG(base, mask, value) (AIPS_WR_PACRG(base, (AIPS_RD_PACRG(base) & ~(mask)) | (value)))
#define AIPS_SET_PACRG(base, value) (BME_OR32(&AIPS_PACRG_REG(base), (uint32_t)(value)))
#define AIPS_CLR_PACRG(base, value) (BME_AND32(&AIPS_PACRG_REG(base), (uint32_t)(~(value))))
#define AIPS_TOG_PACRG(base, value) (BME_XOR32(&AIPS_PACRG_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual AIPS_PACRG bitfields
 */

/*!
 * @name Register AIPS_PACRG, field AC7[2:0] (RW)
 *
 * Defines the attributes required to access the corresponding slave
 * peripheral's memory space. See #pacr_attributes , "Attribute check (AC) values" for
 * details.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRG_AC7 field. */
#define AIPS_RD_PACRG_AC7(base) ((AIPS_PACRG_REG(base) & AIPS_PACRG_AC7_MASK) >> AIPS_PACRG_AC7_SHIFT)
#define AIPS_BRD_PACRG_AC7(base) (BME_UBFX32(&AIPS_PACRG_REG(base), AIPS_PACRG_AC7_SHIFT, AIPS_PACRG_AC7_WIDTH))

/*! @brief Set the AC7 field to a new value. */
#define AIPS_WR_PACRG_AC7(base, value) (AIPS_RMW_PACRG(base, AIPS_PACRG_AC7_MASK, AIPS_PACRG_AC7(value)))
#define AIPS_BWR_PACRG_AC7(base, value) (BME_BFI32(&AIPS_PACRG_REG(base), ((uint32_t)(value) << AIPS_PACRG_AC7_SHIFT), AIPS_PACRG_AC7_SHIFT, AIPS_PACRG_AC7_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRG, field RO7[3] (RW)
 *
 * Indicates the lock status of this register's AC7 field. After this field is
 * set to 1, it cannot be changed and attempted writes to AC7 are ignored until
 * the next system reset clears this field.
 *
 * Values:
 * - 0b0 - Writes to corresponding AC field are allowed.
 * - 0b1 - Writes to corresponding AC field are ignored.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRG_RO7 field. */
#define AIPS_RD_PACRG_RO7(base) ((AIPS_PACRG_REG(base) & AIPS_PACRG_RO7_MASK) >> AIPS_PACRG_RO7_SHIFT)
#define AIPS_BRD_PACRG_RO7(base) (BME_UBFX32(&AIPS_PACRG_REG(base), AIPS_PACRG_RO7_SHIFT, AIPS_PACRG_RO7_WIDTH))

/*! @brief Set the RO7 field to a new value. */
#define AIPS_WR_PACRG_RO7(base, value) (AIPS_RMW_PACRG(base, AIPS_PACRG_RO7_MASK, AIPS_PACRG_RO7(value)))
#define AIPS_BWR_PACRG_RO7(base, value) (BME_BFI32(&AIPS_PACRG_REG(base), ((uint32_t)(value) << AIPS_PACRG_RO7_SHIFT), AIPS_PACRG_RO7_SHIFT, AIPS_PACRG_RO7_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRG, field AC6[6:4] (RW)
 *
 * Defines the attributes required to access the corresponding slave
 * peripheral's memory space. See #pacr_attributes , "Attribute check (AC) values" for
 * details.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRG_AC6 field. */
#define AIPS_RD_PACRG_AC6(base) ((AIPS_PACRG_REG(base) & AIPS_PACRG_AC6_MASK) >> AIPS_PACRG_AC6_SHIFT)
#define AIPS_BRD_PACRG_AC6(base) (BME_UBFX32(&AIPS_PACRG_REG(base), AIPS_PACRG_AC6_SHIFT, AIPS_PACRG_AC6_WIDTH))

/*! @brief Set the AC6 field to a new value. */
#define AIPS_WR_PACRG_AC6(base, value) (AIPS_RMW_PACRG(base, AIPS_PACRG_AC6_MASK, AIPS_PACRG_AC6(value)))
#define AIPS_BWR_PACRG_AC6(base, value) (BME_BFI32(&AIPS_PACRG_REG(base), ((uint32_t)(value) << AIPS_PACRG_AC6_SHIFT), AIPS_PACRG_AC6_SHIFT, AIPS_PACRG_AC6_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRG, field RO6[7] (RW)
 *
 * Indicates the lock status of this register's AC6 field. After this field is
 * set to 1, it cannot be changed and attempted writes to AC6 are ignored until
 * the next system reset clears this field.
 *
 * Values:
 * - 0b0 - Writes to corresponding AC field are allowed.
 * - 0b1 - Writes to corresponding AC field are ignored.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRG_RO6 field. */
#define AIPS_RD_PACRG_RO6(base) ((AIPS_PACRG_REG(base) & AIPS_PACRG_RO6_MASK) >> AIPS_PACRG_RO6_SHIFT)
#define AIPS_BRD_PACRG_RO6(base) (BME_UBFX32(&AIPS_PACRG_REG(base), AIPS_PACRG_RO6_SHIFT, AIPS_PACRG_RO6_WIDTH))

/*! @brief Set the RO6 field to a new value. */
#define AIPS_WR_PACRG_RO6(base, value) (AIPS_RMW_PACRG(base, AIPS_PACRG_RO6_MASK, AIPS_PACRG_RO6(value)))
#define AIPS_BWR_PACRG_RO6(base, value) (BME_BFI32(&AIPS_PACRG_REG(base), ((uint32_t)(value) << AIPS_PACRG_RO6_SHIFT), AIPS_PACRG_RO6_SHIFT, AIPS_PACRG_RO6_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRG, field AC5[10:8] (RW)
 *
 * Defines the attributes required to access the corresponding slave
 * peripheral's memory space. See #pacr_attributes , "Attribute check (AC) values" for
 * details.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRG_AC5 field. */
#define AIPS_RD_PACRG_AC5(base) ((AIPS_PACRG_REG(base) & AIPS_PACRG_AC5_MASK) >> AIPS_PACRG_AC5_SHIFT)
#define AIPS_BRD_PACRG_AC5(base) (BME_UBFX32(&AIPS_PACRG_REG(base), AIPS_PACRG_AC5_SHIFT, AIPS_PACRG_AC5_WIDTH))

/*! @brief Set the AC5 field to a new value. */
#define AIPS_WR_PACRG_AC5(base, value) (AIPS_RMW_PACRG(base, AIPS_PACRG_AC5_MASK, AIPS_PACRG_AC5(value)))
#define AIPS_BWR_PACRG_AC5(base, value) (BME_BFI32(&AIPS_PACRG_REG(base), ((uint32_t)(value) << AIPS_PACRG_AC5_SHIFT), AIPS_PACRG_AC5_SHIFT, AIPS_PACRG_AC5_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRG, field RO5[11] (RW)
 *
 * Indicates the lock status of this register's AC5 field. After this field is
 * set to 1, it cannot be changed and attempted writes to AC5 are ignored until
 * the next system reset clears this field.
 *
 * Values:
 * - 0b0 - Writes to corresponding AC field are allowed.
 * - 0b1 - Writes to corresponding AC field are ignored.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRG_RO5 field. */
#define AIPS_RD_PACRG_RO5(base) ((AIPS_PACRG_REG(base) & AIPS_PACRG_RO5_MASK) >> AIPS_PACRG_RO5_SHIFT)
#define AIPS_BRD_PACRG_RO5(base) (BME_UBFX32(&AIPS_PACRG_REG(base), AIPS_PACRG_RO5_SHIFT, AIPS_PACRG_RO5_WIDTH))

/*! @brief Set the RO5 field to a new value. */
#define AIPS_WR_PACRG_RO5(base, value) (AIPS_RMW_PACRG(base, AIPS_PACRG_RO5_MASK, AIPS_PACRG_RO5(value)))
#define AIPS_BWR_PACRG_RO5(base, value) (BME_BFI32(&AIPS_PACRG_REG(base), ((uint32_t)(value) << AIPS_PACRG_RO5_SHIFT), AIPS_PACRG_RO5_SHIFT, AIPS_PACRG_RO5_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRG, field AC4[14:12] (RW)
 *
 * Defines the attributes required to access the corresponding slave
 * peripheral's memory space. See #pacr_attributes , "Attribute check (AC) values" for
 * details.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRG_AC4 field. */
#define AIPS_RD_PACRG_AC4(base) ((AIPS_PACRG_REG(base) & AIPS_PACRG_AC4_MASK) >> AIPS_PACRG_AC4_SHIFT)
#define AIPS_BRD_PACRG_AC4(base) (BME_UBFX32(&AIPS_PACRG_REG(base), AIPS_PACRG_AC4_SHIFT, AIPS_PACRG_AC4_WIDTH))

/*! @brief Set the AC4 field to a new value. */
#define AIPS_WR_PACRG_AC4(base, value) (AIPS_RMW_PACRG(base, AIPS_PACRG_AC4_MASK, AIPS_PACRG_AC4(value)))
#define AIPS_BWR_PACRG_AC4(base, value) (BME_BFI32(&AIPS_PACRG_REG(base), ((uint32_t)(value) << AIPS_PACRG_AC4_SHIFT), AIPS_PACRG_AC4_SHIFT, AIPS_PACRG_AC4_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRG, field RO4[15] (RW)
 *
 * Indicates the lock status of this register's AC4 field. After this field is
 * set to 1, it cannot be changed and attempted writes to AC4 are ignored until
 * the next system reset clears this field.
 *
 * Values:
 * - 0b0 - Writes to corresponding AC field are allowed.
 * - 0b1 - Writes to corresponding AC field are ignored.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRG_RO4 field. */
#define AIPS_RD_PACRG_RO4(base) ((AIPS_PACRG_REG(base) & AIPS_PACRG_RO4_MASK) >> AIPS_PACRG_RO4_SHIFT)
#define AIPS_BRD_PACRG_RO4(base) (BME_UBFX32(&AIPS_PACRG_REG(base), AIPS_PACRG_RO4_SHIFT, AIPS_PACRG_RO4_WIDTH))

/*! @brief Set the RO4 field to a new value. */
#define AIPS_WR_PACRG_RO4(base, value) (AIPS_RMW_PACRG(base, AIPS_PACRG_RO4_MASK, AIPS_PACRG_RO4(value)))
#define AIPS_BWR_PACRG_RO4(base, value) (BME_BFI32(&AIPS_PACRG_REG(base), ((uint32_t)(value) << AIPS_PACRG_RO4_SHIFT), AIPS_PACRG_RO4_SHIFT, AIPS_PACRG_RO4_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRG, field AC3[18:16] (RW)
 *
 * Defines the attributes required to access the corresponding slave
 * peripheral's memory space. See #pacr_attributes , "Attribute check (AC) values" for
 * details.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRG_AC3 field. */
#define AIPS_RD_PACRG_AC3(base) ((AIPS_PACRG_REG(base) & AIPS_PACRG_AC3_MASK) >> AIPS_PACRG_AC3_SHIFT)
#define AIPS_BRD_PACRG_AC3(base) (BME_UBFX32(&AIPS_PACRG_REG(base), AIPS_PACRG_AC3_SHIFT, AIPS_PACRG_AC3_WIDTH))

/*! @brief Set the AC3 field to a new value. */
#define AIPS_WR_PACRG_AC3(base, value) (AIPS_RMW_PACRG(base, AIPS_PACRG_AC3_MASK, AIPS_PACRG_AC3(value)))
#define AIPS_BWR_PACRG_AC3(base, value) (BME_BFI32(&AIPS_PACRG_REG(base), ((uint32_t)(value) << AIPS_PACRG_AC3_SHIFT), AIPS_PACRG_AC3_SHIFT, AIPS_PACRG_AC3_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRG, field RO3[19] (RW)
 *
 * Indicates the lock status of this register's AC3 field. After this field is
 * set to 1, it cannot be changed and attempted writes to AC3 are ignored until
 * the next system reset clears this field.
 *
 * Values:
 * - 0b0 - Writes to corresponding AC field are allowed.
 * - 0b1 - Writes to corresponding AC field are ignored.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRG_RO3 field. */
#define AIPS_RD_PACRG_RO3(base) ((AIPS_PACRG_REG(base) & AIPS_PACRG_RO3_MASK) >> AIPS_PACRG_RO3_SHIFT)
#define AIPS_BRD_PACRG_RO3(base) (BME_UBFX32(&AIPS_PACRG_REG(base), AIPS_PACRG_RO3_SHIFT, AIPS_PACRG_RO3_WIDTH))

/*! @brief Set the RO3 field to a new value. */
#define AIPS_WR_PACRG_RO3(base, value) (AIPS_RMW_PACRG(base, AIPS_PACRG_RO3_MASK, AIPS_PACRG_RO3(value)))
#define AIPS_BWR_PACRG_RO3(base, value) (BME_BFI32(&AIPS_PACRG_REG(base), ((uint32_t)(value) << AIPS_PACRG_RO3_SHIFT), AIPS_PACRG_RO3_SHIFT, AIPS_PACRG_RO3_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRG, field AC2[22:20] (RW)
 *
 * Defines the attributes required to access the corresponding slave
 * peripheral's memory space. See #pacr_attributes , "Attribute check (AC) values" for
 * details.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRG_AC2 field. */
#define AIPS_RD_PACRG_AC2(base) ((AIPS_PACRG_REG(base) & AIPS_PACRG_AC2_MASK) >> AIPS_PACRG_AC2_SHIFT)
#define AIPS_BRD_PACRG_AC2(base) (BME_UBFX32(&AIPS_PACRG_REG(base), AIPS_PACRG_AC2_SHIFT, AIPS_PACRG_AC2_WIDTH))

/*! @brief Set the AC2 field to a new value. */
#define AIPS_WR_PACRG_AC2(base, value) (AIPS_RMW_PACRG(base, AIPS_PACRG_AC2_MASK, AIPS_PACRG_AC2(value)))
#define AIPS_BWR_PACRG_AC2(base, value) (BME_BFI32(&AIPS_PACRG_REG(base), ((uint32_t)(value) << AIPS_PACRG_AC2_SHIFT), AIPS_PACRG_AC2_SHIFT, AIPS_PACRG_AC2_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRG, field RO2[23] (RW)
 *
 * Indicates the lock status of this register's AC2 field. After this field is
 * set to 1, it cannot be changed and attempted writes to AC2 are ignored until
 * the next system reset clears this field.
 *
 * Values:
 * - 0b0 - Writes to corresponding AC field are allowed.
 * - 0b1 - Writes to corresponding AC field are ignored.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRG_RO2 field. */
#define AIPS_RD_PACRG_RO2(base) ((AIPS_PACRG_REG(base) & AIPS_PACRG_RO2_MASK) >> AIPS_PACRG_RO2_SHIFT)
#define AIPS_BRD_PACRG_RO2(base) (BME_UBFX32(&AIPS_PACRG_REG(base), AIPS_PACRG_RO2_SHIFT, AIPS_PACRG_RO2_WIDTH))

/*! @brief Set the RO2 field to a new value. */
#define AIPS_WR_PACRG_RO2(base, value) (AIPS_RMW_PACRG(base, AIPS_PACRG_RO2_MASK, AIPS_PACRG_RO2(value)))
#define AIPS_BWR_PACRG_RO2(base, value) (BME_BFI32(&AIPS_PACRG_REG(base), ((uint32_t)(value) << AIPS_PACRG_RO2_SHIFT), AIPS_PACRG_RO2_SHIFT, AIPS_PACRG_RO2_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRG, field AC1[26:24] (RW)
 *
 * Defines the attributes required to access the corresponding slave
 * peripheral's memory space. See #pacr_attributes , "Attribute check (AC) values" for
 * details.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRG_AC1 field. */
#define AIPS_RD_PACRG_AC1(base) ((AIPS_PACRG_REG(base) & AIPS_PACRG_AC1_MASK) >> AIPS_PACRG_AC1_SHIFT)
#define AIPS_BRD_PACRG_AC1(base) (BME_UBFX32(&AIPS_PACRG_REG(base), AIPS_PACRG_AC1_SHIFT, AIPS_PACRG_AC1_WIDTH))

/*! @brief Set the AC1 field to a new value. */
#define AIPS_WR_PACRG_AC1(base, value) (AIPS_RMW_PACRG(base, AIPS_PACRG_AC1_MASK, AIPS_PACRG_AC1(value)))
#define AIPS_BWR_PACRG_AC1(base, value) (BME_BFI32(&AIPS_PACRG_REG(base), ((uint32_t)(value) << AIPS_PACRG_AC1_SHIFT), AIPS_PACRG_AC1_SHIFT, AIPS_PACRG_AC1_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRG, field RO1[27] (RW)
 *
 * Indicates the lock status of this register's AC1 field. After this field is
 * set to 1, it cannot be changed and attempted writes to AC1 are ignored until
 * the next system reset clears this field.
 *
 * Values:
 * - 0b0 - Writes to corresponding AC field are allowed.
 * - 0b1 - Writes to corresponding AC field are ignored.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRG_RO1 field. */
#define AIPS_RD_PACRG_RO1(base) ((AIPS_PACRG_REG(base) & AIPS_PACRG_RO1_MASK) >> AIPS_PACRG_RO1_SHIFT)
#define AIPS_BRD_PACRG_RO1(base) (BME_UBFX32(&AIPS_PACRG_REG(base), AIPS_PACRG_RO1_SHIFT, AIPS_PACRG_RO1_WIDTH))

/*! @brief Set the RO1 field to a new value. */
#define AIPS_WR_PACRG_RO1(base, value) (AIPS_RMW_PACRG(base, AIPS_PACRG_RO1_MASK, AIPS_PACRG_RO1(value)))
#define AIPS_BWR_PACRG_RO1(base, value) (BME_BFI32(&AIPS_PACRG_REG(base), ((uint32_t)(value) << AIPS_PACRG_RO1_SHIFT), AIPS_PACRG_RO1_SHIFT, AIPS_PACRG_RO1_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRG, field AC0[30:28] (RW)
 *
 * Defines the attributes required to access the corresponding slave
 * peripheral's memory space. See #pacr_attributes , "Attribute check (AC) values" for
 * details.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRG_AC0 field. */
#define AIPS_RD_PACRG_AC0(base) ((AIPS_PACRG_REG(base) & AIPS_PACRG_AC0_MASK) >> AIPS_PACRG_AC0_SHIFT)
#define AIPS_BRD_PACRG_AC0(base) (BME_UBFX32(&AIPS_PACRG_REG(base), AIPS_PACRG_AC0_SHIFT, AIPS_PACRG_AC0_WIDTH))

/*! @brief Set the AC0 field to a new value. */
#define AIPS_WR_PACRG_AC0(base, value) (AIPS_RMW_PACRG(base, AIPS_PACRG_AC0_MASK, AIPS_PACRG_AC0(value)))
#define AIPS_BWR_PACRG_AC0(base, value) (BME_BFI32(&AIPS_PACRG_REG(base), ((uint32_t)(value) << AIPS_PACRG_AC0_SHIFT), AIPS_PACRG_AC0_SHIFT, AIPS_PACRG_AC0_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRG, field RO0[31] (RW)
 *
 * Indicates the lock status of this register's AC0 field. After this field is
 * set to 1, it cannot be changed and attempted writes to AC0 are ignored until
 * the next system reset clears this field.
 *
 * Values:
 * - 0b0 - Writes to corresponding AC field are allowed.
 * - 0b1 - Writes to corresponding AC field are ignored.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRG_RO0 field. */
#define AIPS_RD_PACRG_RO0(base) ((AIPS_PACRG_REG(base) & AIPS_PACRG_RO0_MASK) >> AIPS_PACRG_RO0_SHIFT)
#define AIPS_BRD_PACRG_RO0(base) (BME_UBFX32(&AIPS_PACRG_REG(base), AIPS_PACRG_RO0_SHIFT, AIPS_PACRG_RO0_WIDTH))

/*! @brief Set the RO0 field to a new value. */
#define AIPS_WR_PACRG_RO0(base, value) (AIPS_RMW_PACRG(base, AIPS_PACRG_RO0_MASK, AIPS_PACRG_RO0(value)))
#define AIPS_BWR_PACRG_RO0(base, value) (BME_BFI32(&AIPS_PACRG_REG(base), ((uint32_t)(value) << AIPS_PACRG_RO0_SHIFT), AIPS_PACRG_RO0_SHIFT, AIPS_PACRG_RO0_WIDTH))
/*@}*/

/*******************************************************************************
 * AIPS_PACRH - Peripheral Access Control Register
 ******************************************************************************/

/*!
 * @brief AIPS_PACRH - Peripheral Access Control Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * Each peripheral on this chip has a 4-bit PACR field which includes a
 * read-only "lock" bit plus a 3-bit attribute check field which defines the access
 * rights (privileged/user, secure/nonsecure) needed to reference the slave
 * peripheral's address space. Access to these registers is allowed using only 32-bit
 * privileged, secure reads and writes. Each 32-bit register controls eight
 * peripherals. PACRE-PACR P control access to the 96 off-platform peripherals. A
 * peripheral's assignment to a PACR field is defined by the memory map slot to which the
 * peripheral is assigned. See this device's peripheral bridge memory map
 * information for the assignment of a particular peripheral. The following table shows
 * the top-level structure of PACRs. Offset Register [31:28] [27:24] [23:20]
 * [19:16] [15:12] [11:8] [7:4] [3:0] 0x40 PACRE PACR32 PACR33 PACR34 PACR35 PACR36
 * PACR37 PACR38 PACR39 0x44 PACRF PACR40 PACR41 PACR42 PACR43 PACR44 PACR45
 * PACR46 PACR47 0x48 PACRG PACR48 PACR49 PACR50 PACR51 PACR52 PACR53 PACR54 PACR55
 * 0x4C PACRH PACR56 PACR57 PACR58 PACR59 PACR60 PACR61 PACR62 PACR63 0x50 PACRI
 * PACR64 PACR65 PACR66 PACR67 PACR68 PACR69 PACR70 PACR71 0x54 PACRJ PACR72 PACR73
 * PACR74 PACR75 PACR76 PACR77 PACR78 PACR79 0x58 PACRK PACR80 PACR81 PACR82
 * PACR83 PACR84 PACR85 PACR86 PACR87 0x5C PACRL PACR88 PACR89 PACR90 PACR91 PACR92
 * PACR93 PACR94 PACR95 0x60 PACRM PACR96 PACR97 PACR98 PACR99 PACR100 PACR101
 * PACR102 PACR103 0x64 PACRN PACR104 PACR105 PACR106 PACR107 PACR108 PACR109
 * PACR110 PACR111 0x68 PACRO PACR112 PACR113 PACR114 PACR115 PACR116 PACR117 PACR118
 * PACR119 0x6C PACRP PACR120 PACR121 PACR122 PACR123 PACR124 PACR125 PACR126
 * PACR127
 */
/*!
 * @name Constants and macros for entire AIPS_PACRH register
 */
/*@{*/
#define AIPS_RD_PACRH(base)      (AIPS_PACRH_REG(base))
#define AIPS_WR_PACRH(base, value) (AIPS_PACRH_REG(base) = (value))
#define AIPS_RMW_PACRH(base, mask, value) (AIPS_WR_PACRH(base, (AIPS_RD_PACRH(base) & ~(mask)) | (value)))
#define AIPS_SET_PACRH(base, value) (BME_OR32(&AIPS_PACRH_REG(base), (uint32_t)(value)))
#define AIPS_CLR_PACRH(base, value) (BME_AND32(&AIPS_PACRH_REG(base), (uint32_t)(~(value))))
#define AIPS_TOG_PACRH(base, value) (BME_XOR32(&AIPS_PACRH_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual AIPS_PACRH bitfields
 */

/*!
 * @name Register AIPS_PACRH, field AC7[2:0] (RW)
 *
 * Defines the attributes required to access the corresponding slave
 * peripheral's memory space. See #pacr_attributes , "Attribute check (AC) values" for
 * details.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRH_AC7 field. */
#define AIPS_RD_PACRH_AC7(base) ((AIPS_PACRH_REG(base) & AIPS_PACRH_AC7_MASK) >> AIPS_PACRH_AC7_SHIFT)
#define AIPS_BRD_PACRH_AC7(base) (BME_UBFX32(&AIPS_PACRH_REG(base), AIPS_PACRH_AC7_SHIFT, AIPS_PACRH_AC7_WIDTH))

/*! @brief Set the AC7 field to a new value. */
#define AIPS_WR_PACRH_AC7(base, value) (AIPS_RMW_PACRH(base, AIPS_PACRH_AC7_MASK, AIPS_PACRH_AC7(value)))
#define AIPS_BWR_PACRH_AC7(base, value) (BME_BFI32(&AIPS_PACRH_REG(base), ((uint32_t)(value) << AIPS_PACRH_AC7_SHIFT), AIPS_PACRH_AC7_SHIFT, AIPS_PACRH_AC7_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRH, field RO7[3] (RW)
 *
 * Indicates the lock status of this register's AC7 field. After this field is
 * set to 1, it cannot be changed and attempted writes to AC7 are ignored until
 * the next system reset clears this field.
 *
 * Values:
 * - 0b0 - Writes to corresponding AC field are allowed.
 * - 0b1 - Writes to corresponding AC field are ignored.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRH_RO7 field. */
#define AIPS_RD_PACRH_RO7(base) ((AIPS_PACRH_REG(base) & AIPS_PACRH_RO7_MASK) >> AIPS_PACRH_RO7_SHIFT)
#define AIPS_BRD_PACRH_RO7(base) (BME_UBFX32(&AIPS_PACRH_REG(base), AIPS_PACRH_RO7_SHIFT, AIPS_PACRH_RO7_WIDTH))

/*! @brief Set the RO7 field to a new value. */
#define AIPS_WR_PACRH_RO7(base, value) (AIPS_RMW_PACRH(base, AIPS_PACRH_RO7_MASK, AIPS_PACRH_RO7(value)))
#define AIPS_BWR_PACRH_RO7(base, value) (BME_BFI32(&AIPS_PACRH_REG(base), ((uint32_t)(value) << AIPS_PACRH_RO7_SHIFT), AIPS_PACRH_RO7_SHIFT, AIPS_PACRH_RO7_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRH, field AC6[6:4] (RW)
 *
 * Defines the attributes required to access the corresponding slave
 * peripheral's memory space. See #pacr_attributes , "Attribute check (AC) values" for
 * details.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRH_AC6 field. */
#define AIPS_RD_PACRH_AC6(base) ((AIPS_PACRH_REG(base) & AIPS_PACRH_AC6_MASK) >> AIPS_PACRH_AC6_SHIFT)
#define AIPS_BRD_PACRH_AC6(base) (BME_UBFX32(&AIPS_PACRH_REG(base), AIPS_PACRH_AC6_SHIFT, AIPS_PACRH_AC6_WIDTH))

/*! @brief Set the AC6 field to a new value. */
#define AIPS_WR_PACRH_AC6(base, value) (AIPS_RMW_PACRH(base, AIPS_PACRH_AC6_MASK, AIPS_PACRH_AC6(value)))
#define AIPS_BWR_PACRH_AC6(base, value) (BME_BFI32(&AIPS_PACRH_REG(base), ((uint32_t)(value) << AIPS_PACRH_AC6_SHIFT), AIPS_PACRH_AC6_SHIFT, AIPS_PACRH_AC6_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRH, field RO6[7] (RW)
 *
 * Indicates the lock status of this register's AC6 field. After this field is
 * set to 1, it cannot be changed and attempted writes to AC6 are ignored until
 * the next system reset clears this field.
 *
 * Values:
 * - 0b0 - Writes to corresponding AC field are allowed.
 * - 0b1 - Writes to corresponding AC field are ignored.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRH_RO6 field. */
#define AIPS_RD_PACRH_RO6(base) ((AIPS_PACRH_REG(base) & AIPS_PACRH_RO6_MASK) >> AIPS_PACRH_RO6_SHIFT)
#define AIPS_BRD_PACRH_RO6(base) (BME_UBFX32(&AIPS_PACRH_REG(base), AIPS_PACRH_RO6_SHIFT, AIPS_PACRH_RO6_WIDTH))

/*! @brief Set the RO6 field to a new value. */
#define AIPS_WR_PACRH_RO6(base, value) (AIPS_RMW_PACRH(base, AIPS_PACRH_RO6_MASK, AIPS_PACRH_RO6(value)))
#define AIPS_BWR_PACRH_RO6(base, value) (BME_BFI32(&AIPS_PACRH_REG(base), ((uint32_t)(value) << AIPS_PACRH_RO6_SHIFT), AIPS_PACRH_RO6_SHIFT, AIPS_PACRH_RO6_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRH, field AC5[10:8] (RW)
 *
 * Defines the attributes required to access the corresponding slave
 * peripheral's memory space. See #pacr_attributes , "Attribute check (AC) values" for
 * details.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRH_AC5 field. */
#define AIPS_RD_PACRH_AC5(base) ((AIPS_PACRH_REG(base) & AIPS_PACRH_AC5_MASK) >> AIPS_PACRH_AC5_SHIFT)
#define AIPS_BRD_PACRH_AC5(base) (BME_UBFX32(&AIPS_PACRH_REG(base), AIPS_PACRH_AC5_SHIFT, AIPS_PACRH_AC5_WIDTH))

/*! @brief Set the AC5 field to a new value. */
#define AIPS_WR_PACRH_AC5(base, value) (AIPS_RMW_PACRH(base, AIPS_PACRH_AC5_MASK, AIPS_PACRH_AC5(value)))
#define AIPS_BWR_PACRH_AC5(base, value) (BME_BFI32(&AIPS_PACRH_REG(base), ((uint32_t)(value) << AIPS_PACRH_AC5_SHIFT), AIPS_PACRH_AC5_SHIFT, AIPS_PACRH_AC5_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRH, field RO5[11] (RW)
 *
 * Indicates the lock status of this register's AC5 field. After this field is
 * set to 1, it cannot be changed and attempted writes to AC5 are ignored until
 * the next system reset clears this field.
 *
 * Values:
 * - 0b0 - Writes to corresponding AC field are allowed.
 * - 0b1 - Writes to corresponding AC field are ignored.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRH_RO5 field. */
#define AIPS_RD_PACRH_RO5(base) ((AIPS_PACRH_REG(base) & AIPS_PACRH_RO5_MASK) >> AIPS_PACRH_RO5_SHIFT)
#define AIPS_BRD_PACRH_RO5(base) (BME_UBFX32(&AIPS_PACRH_REG(base), AIPS_PACRH_RO5_SHIFT, AIPS_PACRH_RO5_WIDTH))

/*! @brief Set the RO5 field to a new value. */
#define AIPS_WR_PACRH_RO5(base, value) (AIPS_RMW_PACRH(base, AIPS_PACRH_RO5_MASK, AIPS_PACRH_RO5(value)))
#define AIPS_BWR_PACRH_RO5(base, value) (BME_BFI32(&AIPS_PACRH_REG(base), ((uint32_t)(value) << AIPS_PACRH_RO5_SHIFT), AIPS_PACRH_RO5_SHIFT, AIPS_PACRH_RO5_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRH, field AC4[14:12] (RW)
 *
 * Defines the attributes required to access the corresponding slave
 * peripheral's memory space. See #pacr_attributes , "Attribute check (AC) values" for
 * details.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRH_AC4 field. */
#define AIPS_RD_PACRH_AC4(base) ((AIPS_PACRH_REG(base) & AIPS_PACRH_AC4_MASK) >> AIPS_PACRH_AC4_SHIFT)
#define AIPS_BRD_PACRH_AC4(base) (BME_UBFX32(&AIPS_PACRH_REG(base), AIPS_PACRH_AC4_SHIFT, AIPS_PACRH_AC4_WIDTH))

/*! @brief Set the AC4 field to a new value. */
#define AIPS_WR_PACRH_AC4(base, value) (AIPS_RMW_PACRH(base, AIPS_PACRH_AC4_MASK, AIPS_PACRH_AC4(value)))
#define AIPS_BWR_PACRH_AC4(base, value) (BME_BFI32(&AIPS_PACRH_REG(base), ((uint32_t)(value) << AIPS_PACRH_AC4_SHIFT), AIPS_PACRH_AC4_SHIFT, AIPS_PACRH_AC4_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRH, field RO4[15] (RW)
 *
 * Indicates the lock status of this register's AC4 field. After this field is
 * set to 1, it cannot be changed and attempted writes to AC4 are ignored until
 * the next system reset clears this field.
 *
 * Values:
 * - 0b0 - Writes to corresponding AC field are allowed.
 * - 0b1 - Writes to corresponding AC field are ignored.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRH_RO4 field. */
#define AIPS_RD_PACRH_RO4(base) ((AIPS_PACRH_REG(base) & AIPS_PACRH_RO4_MASK) >> AIPS_PACRH_RO4_SHIFT)
#define AIPS_BRD_PACRH_RO4(base) (BME_UBFX32(&AIPS_PACRH_REG(base), AIPS_PACRH_RO4_SHIFT, AIPS_PACRH_RO4_WIDTH))

/*! @brief Set the RO4 field to a new value. */
#define AIPS_WR_PACRH_RO4(base, value) (AIPS_RMW_PACRH(base, AIPS_PACRH_RO4_MASK, AIPS_PACRH_RO4(value)))
#define AIPS_BWR_PACRH_RO4(base, value) (BME_BFI32(&AIPS_PACRH_REG(base), ((uint32_t)(value) << AIPS_PACRH_RO4_SHIFT), AIPS_PACRH_RO4_SHIFT, AIPS_PACRH_RO4_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRH, field AC3[18:16] (RW)
 *
 * Defines the attributes required to access the corresponding slave
 * peripheral's memory space. See #pacr_attributes , "Attribute check (AC) values" for
 * details.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRH_AC3 field. */
#define AIPS_RD_PACRH_AC3(base) ((AIPS_PACRH_REG(base) & AIPS_PACRH_AC3_MASK) >> AIPS_PACRH_AC3_SHIFT)
#define AIPS_BRD_PACRH_AC3(base) (BME_UBFX32(&AIPS_PACRH_REG(base), AIPS_PACRH_AC3_SHIFT, AIPS_PACRH_AC3_WIDTH))

/*! @brief Set the AC3 field to a new value. */
#define AIPS_WR_PACRH_AC3(base, value) (AIPS_RMW_PACRH(base, AIPS_PACRH_AC3_MASK, AIPS_PACRH_AC3(value)))
#define AIPS_BWR_PACRH_AC3(base, value) (BME_BFI32(&AIPS_PACRH_REG(base), ((uint32_t)(value) << AIPS_PACRH_AC3_SHIFT), AIPS_PACRH_AC3_SHIFT, AIPS_PACRH_AC3_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRH, field RO3[19] (RW)
 *
 * Indicates the lock status of this register's AC3 field. After this field is
 * set to 1, it cannot be changed and attempted writes to AC3 are ignored until
 * the next system reset clears this field.
 *
 * Values:
 * - 0b0 - Writes to corresponding AC field are allowed.
 * - 0b1 - Writes to corresponding AC field are ignored.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRH_RO3 field. */
#define AIPS_RD_PACRH_RO3(base) ((AIPS_PACRH_REG(base) & AIPS_PACRH_RO3_MASK) >> AIPS_PACRH_RO3_SHIFT)
#define AIPS_BRD_PACRH_RO3(base) (BME_UBFX32(&AIPS_PACRH_REG(base), AIPS_PACRH_RO3_SHIFT, AIPS_PACRH_RO3_WIDTH))

/*! @brief Set the RO3 field to a new value. */
#define AIPS_WR_PACRH_RO3(base, value) (AIPS_RMW_PACRH(base, AIPS_PACRH_RO3_MASK, AIPS_PACRH_RO3(value)))
#define AIPS_BWR_PACRH_RO3(base, value) (BME_BFI32(&AIPS_PACRH_REG(base), ((uint32_t)(value) << AIPS_PACRH_RO3_SHIFT), AIPS_PACRH_RO3_SHIFT, AIPS_PACRH_RO3_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRH, field AC2[22:20] (RW)
 *
 * Defines the attributes required to access the corresponding slave
 * peripheral's memory space. See #pacr_attributes , "Attribute check (AC) values" for
 * details.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRH_AC2 field. */
#define AIPS_RD_PACRH_AC2(base) ((AIPS_PACRH_REG(base) & AIPS_PACRH_AC2_MASK) >> AIPS_PACRH_AC2_SHIFT)
#define AIPS_BRD_PACRH_AC2(base) (BME_UBFX32(&AIPS_PACRH_REG(base), AIPS_PACRH_AC2_SHIFT, AIPS_PACRH_AC2_WIDTH))

/*! @brief Set the AC2 field to a new value. */
#define AIPS_WR_PACRH_AC2(base, value) (AIPS_RMW_PACRH(base, AIPS_PACRH_AC2_MASK, AIPS_PACRH_AC2(value)))
#define AIPS_BWR_PACRH_AC2(base, value) (BME_BFI32(&AIPS_PACRH_REG(base), ((uint32_t)(value) << AIPS_PACRH_AC2_SHIFT), AIPS_PACRH_AC2_SHIFT, AIPS_PACRH_AC2_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRH, field RO2[23] (RW)
 *
 * Indicates the lock status of this register's AC2 field. After this field is
 * set to 1, it cannot be changed and attempted writes to AC2 are ignored until
 * the next system reset clears this field.
 *
 * Values:
 * - 0b0 - Writes to corresponding AC field are allowed.
 * - 0b1 - Writes to corresponding AC field are ignored.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRH_RO2 field. */
#define AIPS_RD_PACRH_RO2(base) ((AIPS_PACRH_REG(base) & AIPS_PACRH_RO2_MASK) >> AIPS_PACRH_RO2_SHIFT)
#define AIPS_BRD_PACRH_RO2(base) (BME_UBFX32(&AIPS_PACRH_REG(base), AIPS_PACRH_RO2_SHIFT, AIPS_PACRH_RO2_WIDTH))

/*! @brief Set the RO2 field to a new value. */
#define AIPS_WR_PACRH_RO2(base, value) (AIPS_RMW_PACRH(base, AIPS_PACRH_RO2_MASK, AIPS_PACRH_RO2(value)))
#define AIPS_BWR_PACRH_RO2(base, value) (BME_BFI32(&AIPS_PACRH_REG(base), ((uint32_t)(value) << AIPS_PACRH_RO2_SHIFT), AIPS_PACRH_RO2_SHIFT, AIPS_PACRH_RO2_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRH, field AC1[26:24] (RW)
 *
 * Defines the attributes required to access the corresponding slave
 * peripheral's memory space. See #pacr_attributes , "Attribute check (AC) values" for
 * details.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRH_AC1 field. */
#define AIPS_RD_PACRH_AC1(base) ((AIPS_PACRH_REG(base) & AIPS_PACRH_AC1_MASK) >> AIPS_PACRH_AC1_SHIFT)
#define AIPS_BRD_PACRH_AC1(base) (BME_UBFX32(&AIPS_PACRH_REG(base), AIPS_PACRH_AC1_SHIFT, AIPS_PACRH_AC1_WIDTH))

/*! @brief Set the AC1 field to a new value. */
#define AIPS_WR_PACRH_AC1(base, value) (AIPS_RMW_PACRH(base, AIPS_PACRH_AC1_MASK, AIPS_PACRH_AC1(value)))
#define AIPS_BWR_PACRH_AC1(base, value) (BME_BFI32(&AIPS_PACRH_REG(base), ((uint32_t)(value) << AIPS_PACRH_AC1_SHIFT), AIPS_PACRH_AC1_SHIFT, AIPS_PACRH_AC1_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRH, field RO1[27] (RW)
 *
 * Indicates the lock status of this register's AC1 field. After this field is
 * set to 1, it cannot be changed and attempted writes to AC1 are ignored until
 * the next system reset clears this field.
 *
 * Values:
 * - 0b0 - Writes to corresponding AC field are allowed.
 * - 0b1 - Writes to corresponding AC field are ignored.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRH_RO1 field. */
#define AIPS_RD_PACRH_RO1(base) ((AIPS_PACRH_REG(base) & AIPS_PACRH_RO1_MASK) >> AIPS_PACRH_RO1_SHIFT)
#define AIPS_BRD_PACRH_RO1(base) (BME_UBFX32(&AIPS_PACRH_REG(base), AIPS_PACRH_RO1_SHIFT, AIPS_PACRH_RO1_WIDTH))

/*! @brief Set the RO1 field to a new value. */
#define AIPS_WR_PACRH_RO1(base, value) (AIPS_RMW_PACRH(base, AIPS_PACRH_RO1_MASK, AIPS_PACRH_RO1(value)))
#define AIPS_BWR_PACRH_RO1(base, value) (BME_BFI32(&AIPS_PACRH_REG(base), ((uint32_t)(value) << AIPS_PACRH_RO1_SHIFT), AIPS_PACRH_RO1_SHIFT, AIPS_PACRH_RO1_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRH, field AC0[30:28] (RW)
 *
 * Defines the attributes required to access the corresponding slave
 * peripheral's memory space. See #pacr_attributes , "Attribute check (AC) values" for
 * details.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRH_AC0 field. */
#define AIPS_RD_PACRH_AC0(base) ((AIPS_PACRH_REG(base) & AIPS_PACRH_AC0_MASK) >> AIPS_PACRH_AC0_SHIFT)
#define AIPS_BRD_PACRH_AC0(base) (BME_UBFX32(&AIPS_PACRH_REG(base), AIPS_PACRH_AC0_SHIFT, AIPS_PACRH_AC0_WIDTH))

/*! @brief Set the AC0 field to a new value. */
#define AIPS_WR_PACRH_AC0(base, value) (AIPS_RMW_PACRH(base, AIPS_PACRH_AC0_MASK, AIPS_PACRH_AC0(value)))
#define AIPS_BWR_PACRH_AC0(base, value) (BME_BFI32(&AIPS_PACRH_REG(base), ((uint32_t)(value) << AIPS_PACRH_AC0_SHIFT), AIPS_PACRH_AC0_SHIFT, AIPS_PACRH_AC0_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRH, field RO0[31] (RW)
 *
 * Indicates the lock status of this register's AC0 field. After this field is
 * set to 1, it cannot be changed and attempted writes to AC0 are ignored until
 * the next system reset clears this field.
 *
 * Values:
 * - 0b0 - Writes to corresponding AC field are allowed.
 * - 0b1 - Writes to corresponding AC field are ignored.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRH_RO0 field. */
#define AIPS_RD_PACRH_RO0(base) ((AIPS_PACRH_REG(base) & AIPS_PACRH_RO0_MASK) >> AIPS_PACRH_RO0_SHIFT)
#define AIPS_BRD_PACRH_RO0(base) (BME_UBFX32(&AIPS_PACRH_REG(base), AIPS_PACRH_RO0_SHIFT, AIPS_PACRH_RO0_WIDTH))

/*! @brief Set the RO0 field to a new value. */
#define AIPS_WR_PACRH_RO0(base, value) (AIPS_RMW_PACRH(base, AIPS_PACRH_RO0_MASK, AIPS_PACRH_RO0(value)))
#define AIPS_BWR_PACRH_RO0(base, value) (BME_BFI32(&AIPS_PACRH_REG(base), ((uint32_t)(value) << AIPS_PACRH_RO0_SHIFT), AIPS_PACRH_RO0_SHIFT, AIPS_PACRH_RO0_WIDTH))
/*@}*/

/*******************************************************************************
 * AIPS_PACRI - Peripheral Access Control Register
 ******************************************************************************/

/*!
 * @brief AIPS_PACRI - Peripheral Access Control Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * Each peripheral on this chip has a 4-bit PACR field which includes a
 * read-only "lock" bit plus a 3-bit attribute check field which defines the access
 * rights (privileged/user, secure/nonsecure) needed to reference the slave
 * peripheral's address space. Access to these registers is allowed using only 32-bit
 * privileged, secure reads and writes. Each 32-bit register controls eight
 * peripherals. PACRE-PACR P control access to the 96 off-platform peripherals. A
 * peripheral's assignment to a PACR field is defined by the memory map slot to which the
 * peripheral is assigned. See this device's peripheral bridge memory map
 * information for the assignment of a particular peripheral. The following table shows
 * the top-level structure of PACRs. Offset Register [31:28] [27:24] [23:20]
 * [19:16] [15:12] [11:8] [7:4] [3:0] 0x40 PACRE PACR32 PACR33 PACR34 PACR35 PACR36
 * PACR37 PACR38 PACR39 0x44 PACRF PACR40 PACR41 PACR42 PACR43 PACR44 PACR45
 * PACR46 PACR47 0x48 PACRG PACR48 PACR49 PACR50 PACR51 PACR52 PACR53 PACR54 PACR55
 * 0x4C PACRH PACR56 PACR57 PACR58 PACR59 PACR60 PACR61 PACR62 PACR63 0x50 PACRI
 * PACR64 PACR65 PACR66 PACR67 PACR68 PACR69 PACR70 PACR71 0x54 PACRJ PACR72 PACR73
 * PACR74 PACR75 PACR76 PACR77 PACR78 PACR79 0x58 PACRK PACR80 PACR81 PACR82
 * PACR83 PACR84 PACR85 PACR86 PACR87 0x5C PACRL PACR88 PACR89 PACR90 PACR91 PACR92
 * PACR93 PACR94 PACR95 0x60 PACRM PACR96 PACR97 PACR98 PACR99 PACR100 PACR101
 * PACR102 PACR103 0x64 PACRN PACR104 PACR105 PACR106 PACR107 PACR108 PACR109
 * PACR110 PACR111 0x68 PACRO PACR112 PACR113 PACR114 PACR115 PACR116 PACR117 PACR118
 * PACR119 0x6C PACRP PACR120 PACR121 PACR122 PACR123 PACR124 PACR125 PACR126
 * PACR127
 */
/*!
 * @name Constants and macros for entire AIPS_PACRI register
 */
/*@{*/
#define AIPS_RD_PACRI(base)      (AIPS_PACRI_REG(base))
#define AIPS_WR_PACRI(base, value) (AIPS_PACRI_REG(base) = (value))
#define AIPS_RMW_PACRI(base, mask, value) (AIPS_WR_PACRI(base, (AIPS_RD_PACRI(base) & ~(mask)) | (value)))
#define AIPS_SET_PACRI(base, value) (BME_OR32(&AIPS_PACRI_REG(base), (uint32_t)(value)))
#define AIPS_CLR_PACRI(base, value) (BME_AND32(&AIPS_PACRI_REG(base), (uint32_t)(~(value))))
#define AIPS_TOG_PACRI(base, value) (BME_XOR32(&AIPS_PACRI_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual AIPS_PACRI bitfields
 */

/*!
 * @name Register AIPS_PACRI, field AC7[2:0] (RW)
 *
 * Defines the attributes required to access the corresponding slave
 * peripheral's memory space. See #pacr_attributes , "Attribute check (AC) values" for
 * details.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRI_AC7 field. */
#define AIPS_RD_PACRI_AC7(base) ((AIPS_PACRI_REG(base) & AIPS_PACRI_AC7_MASK) >> AIPS_PACRI_AC7_SHIFT)
#define AIPS_BRD_PACRI_AC7(base) (BME_UBFX32(&AIPS_PACRI_REG(base), AIPS_PACRI_AC7_SHIFT, AIPS_PACRI_AC7_WIDTH))

/*! @brief Set the AC7 field to a new value. */
#define AIPS_WR_PACRI_AC7(base, value) (AIPS_RMW_PACRI(base, AIPS_PACRI_AC7_MASK, AIPS_PACRI_AC7(value)))
#define AIPS_BWR_PACRI_AC7(base, value) (BME_BFI32(&AIPS_PACRI_REG(base), ((uint32_t)(value) << AIPS_PACRI_AC7_SHIFT), AIPS_PACRI_AC7_SHIFT, AIPS_PACRI_AC7_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRI, field RO7[3] (RW)
 *
 * Indicates the lock status of this register's AC7 field. After this field is
 * set to 1, it cannot be changed and attempted writes to AC7 are ignored until
 * the next system reset clears this field.
 *
 * Values:
 * - 0b0 - Writes to corresponding AC field are allowed.
 * - 0b1 - Writes to corresponding AC field are ignored.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRI_RO7 field. */
#define AIPS_RD_PACRI_RO7(base) ((AIPS_PACRI_REG(base) & AIPS_PACRI_RO7_MASK) >> AIPS_PACRI_RO7_SHIFT)
#define AIPS_BRD_PACRI_RO7(base) (BME_UBFX32(&AIPS_PACRI_REG(base), AIPS_PACRI_RO7_SHIFT, AIPS_PACRI_RO7_WIDTH))

/*! @brief Set the RO7 field to a new value. */
#define AIPS_WR_PACRI_RO7(base, value) (AIPS_RMW_PACRI(base, AIPS_PACRI_RO7_MASK, AIPS_PACRI_RO7(value)))
#define AIPS_BWR_PACRI_RO7(base, value) (BME_BFI32(&AIPS_PACRI_REG(base), ((uint32_t)(value) << AIPS_PACRI_RO7_SHIFT), AIPS_PACRI_RO7_SHIFT, AIPS_PACRI_RO7_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRI, field AC6[6:4] (RW)
 *
 * Defines the attributes required to access the corresponding slave
 * peripheral's memory space. See #pacr_attributes , "Attribute check (AC) values" for
 * details.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRI_AC6 field. */
#define AIPS_RD_PACRI_AC6(base) ((AIPS_PACRI_REG(base) & AIPS_PACRI_AC6_MASK) >> AIPS_PACRI_AC6_SHIFT)
#define AIPS_BRD_PACRI_AC6(base) (BME_UBFX32(&AIPS_PACRI_REG(base), AIPS_PACRI_AC6_SHIFT, AIPS_PACRI_AC6_WIDTH))

/*! @brief Set the AC6 field to a new value. */
#define AIPS_WR_PACRI_AC6(base, value) (AIPS_RMW_PACRI(base, AIPS_PACRI_AC6_MASK, AIPS_PACRI_AC6(value)))
#define AIPS_BWR_PACRI_AC6(base, value) (BME_BFI32(&AIPS_PACRI_REG(base), ((uint32_t)(value) << AIPS_PACRI_AC6_SHIFT), AIPS_PACRI_AC6_SHIFT, AIPS_PACRI_AC6_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRI, field RO6[7] (RW)
 *
 * Indicates the lock status of this register's AC6 field. After this field is
 * set to 1, it cannot be changed and attempted writes to AC6 are ignored until
 * the next system reset clears this field.
 *
 * Values:
 * - 0b0 - Writes to corresponding AC field are allowed.
 * - 0b1 - Writes to corresponding AC field are ignored.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRI_RO6 field. */
#define AIPS_RD_PACRI_RO6(base) ((AIPS_PACRI_REG(base) & AIPS_PACRI_RO6_MASK) >> AIPS_PACRI_RO6_SHIFT)
#define AIPS_BRD_PACRI_RO6(base) (BME_UBFX32(&AIPS_PACRI_REG(base), AIPS_PACRI_RO6_SHIFT, AIPS_PACRI_RO6_WIDTH))

/*! @brief Set the RO6 field to a new value. */
#define AIPS_WR_PACRI_RO6(base, value) (AIPS_RMW_PACRI(base, AIPS_PACRI_RO6_MASK, AIPS_PACRI_RO6(value)))
#define AIPS_BWR_PACRI_RO6(base, value) (BME_BFI32(&AIPS_PACRI_REG(base), ((uint32_t)(value) << AIPS_PACRI_RO6_SHIFT), AIPS_PACRI_RO6_SHIFT, AIPS_PACRI_RO6_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRI, field AC5[10:8] (RW)
 *
 * Defines the attributes required to access the corresponding slave
 * peripheral's memory space. See #pacr_attributes , "Attribute check (AC) values" for
 * details.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRI_AC5 field. */
#define AIPS_RD_PACRI_AC5(base) ((AIPS_PACRI_REG(base) & AIPS_PACRI_AC5_MASK) >> AIPS_PACRI_AC5_SHIFT)
#define AIPS_BRD_PACRI_AC5(base) (BME_UBFX32(&AIPS_PACRI_REG(base), AIPS_PACRI_AC5_SHIFT, AIPS_PACRI_AC5_WIDTH))

/*! @brief Set the AC5 field to a new value. */
#define AIPS_WR_PACRI_AC5(base, value) (AIPS_RMW_PACRI(base, AIPS_PACRI_AC5_MASK, AIPS_PACRI_AC5(value)))
#define AIPS_BWR_PACRI_AC5(base, value) (BME_BFI32(&AIPS_PACRI_REG(base), ((uint32_t)(value) << AIPS_PACRI_AC5_SHIFT), AIPS_PACRI_AC5_SHIFT, AIPS_PACRI_AC5_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRI, field RO5[11] (RW)
 *
 * Indicates the lock status of this register's AC5 field. After this field is
 * set to 1, it cannot be changed and attempted writes to AC5 are ignored until
 * the next system reset clears this field.
 *
 * Values:
 * - 0b0 - Writes to corresponding AC field are allowed.
 * - 0b1 - Writes to corresponding AC field are ignored.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRI_RO5 field. */
#define AIPS_RD_PACRI_RO5(base) ((AIPS_PACRI_REG(base) & AIPS_PACRI_RO5_MASK) >> AIPS_PACRI_RO5_SHIFT)
#define AIPS_BRD_PACRI_RO5(base) (BME_UBFX32(&AIPS_PACRI_REG(base), AIPS_PACRI_RO5_SHIFT, AIPS_PACRI_RO5_WIDTH))

/*! @brief Set the RO5 field to a new value. */
#define AIPS_WR_PACRI_RO5(base, value) (AIPS_RMW_PACRI(base, AIPS_PACRI_RO5_MASK, AIPS_PACRI_RO5(value)))
#define AIPS_BWR_PACRI_RO5(base, value) (BME_BFI32(&AIPS_PACRI_REG(base), ((uint32_t)(value) << AIPS_PACRI_RO5_SHIFT), AIPS_PACRI_RO5_SHIFT, AIPS_PACRI_RO5_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRI, field AC4[14:12] (RW)
 *
 * Defines the attributes required to access the corresponding slave
 * peripheral's memory space. See #pacr_attributes , "Attribute check (AC) values" for
 * details.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRI_AC4 field. */
#define AIPS_RD_PACRI_AC4(base) ((AIPS_PACRI_REG(base) & AIPS_PACRI_AC4_MASK) >> AIPS_PACRI_AC4_SHIFT)
#define AIPS_BRD_PACRI_AC4(base) (BME_UBFX32(&AIPS_PACRI_REG(base), AIPS_PACRI_AC4_SHIFT, AIPS_PACRI_AC4_WIDTH))

/*! @brief Set the AC4 field to a new value. */
#define AIPS_WR_PACRI_AC4(base, value) (AIPS_RMW_PACRI(base, AIPS_PACRI_AC4_MASK, AIPS_PACRI_AC4(value)))
#define AIPS_BWR_PACRI_AC4(base, value) (BME_BFI32(&AIPS_PACRI_REG(base), ((uint32_t)(value) << AIPS_PACRI_AC4_SHIFT), AIPS_PACRI_AC4_SHIFT, AIPS_PACRI_AC4_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRI, field RO4[15] (RW)
 *
 * Indicates the lock status of this register's AC4 field. After this field is
 * set to 1, it cannot be changed and attempted writes to AC4 are ignored until
 * the next system reset clears this field.
 *
 * Values:
 * - 0b0 - Writes to corresponding AC field are allowed.
 * - 0b1 - Writes to corresponding AC field are ignored.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRI_RO4 field. */
#define AIPS_RD_PACRI_RO4(base) ((AIPS_PACRI_REG(base) & AIPS_PACRI_RO4_MASK) >> AIPS_PACRI_RO4_SHIFT)
#define AIPS_BRD_PACRI_RO4(base) (BME_UBFX32(&AIPS_PACRI_REG(base), AIPS_PACRI_RO4_SHIFT, AIPS_PACRI_RO4_WIDTH))

/*! @brief Set the RO4 field to a new value. */
#define AIPS_WR_PACRI_RO4(base, value) (AIPS_RMW_PACRI(base, AIPS_PACRI_RO4_MASK, AIPS_PACRI_RO4(value)))
#define AIPS_BWR_PACRI_RO4(base, value) (BME_BFI32(&AIPS_PACRI_REG(base), ((uint32_t)(value) << AIPS_PACRI_RO4_SHIFT), AIPS_PACRI_RO4_SHIFT, AIPS_PACRI_RO4_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRI, field AC3[18:16] (RW)
 *
 * Defines the attributes required to access the corresponding slave
 * peripheral's memory space. See #pacr_attributes , "Attribute check (AC) values" for
 * details.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRI_AC3 field. */
#define AIPS_RD_PACRI_AC3(base) ((AIPS_PACRI_REG(base) & AIPS_PACRI_AC3_MASK) >> AIPS_PACRI_AC3_SHIFT)
#define AIPS_BRD_PACRI_AC3(base) (BME_UBFX32(&AIPS_PACRI_REG(base), AIPS_PACRI_AC3_SHIFT, AIPS_PACRI_AC3_WIDTH))

/*! @brief Set the AC3 field to a new value. */
#define AIPS_WR_PACRI_AC3(base, value) (AIPS_RMW_PACRI(base, AIPS_PACRI_AC3_MASK, AIPS_PACRI_AC3(value)))
#define AIPS_BWR_PACRI_AC3(base, value) (BME_BFI32(&AIPS_PACRI_REG(base), ((uint32_t)(value) << AIPS_PACRI_AC3_SHIFT), AIPS_PACRI_AC3_SHIFT, AIPS_PACRI_AC3_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRI, field RO3[19] (RW)
 *
 * Indicates the lock status of this register's AC3 field. After this field is
 * set to 1, it cannot be changed and attempted writes to AC3 are ignored until
 * the next system reset clears this field.
 *
 * Values:
 * - 0b0 - Writes to corresponding AC field are allowed.
 * - 0b1 - Writes to corresponding AC field are ignored.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRI_RO3 field. */
#define AIPS_RD_PACRI_RO3(base) ((AIPS_PACRI_REG(base) & AIPS_PACRI_RO3_MASK) >> AIPS_PACRI_RO3_SHIFT)
#define AIPS_BRD_PACRI_RO3(base) (BME_UBFX32(&AIPS_PACRI_REG(base), AIPS_PACRI_RO3_SHIFT, AIPS_PACRI_RO3_WIDTH))

/*! @brief Set the RO3 field to a new value. */
#define AIPS_WR_PACRI_RO3(base, value) (AIPS_RMW_PACRI(base, AIPS_PACRI_RO3_MASK, AIPS_PACRI_RO3(value)))
#define AIPS_BWR_PACRI_RO3(base, value) (BME_BFI32(&AIPS_PACRI_REG(base), ((uint32_t)(value) << AIPS_PACRI_RO3_SHIFT), AIPS_PACRI_RO3_SHIFT, AIPS_PACRI_RO3_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRI, field AC2[22:20] (RW)
 *
 * Defines the attributes required to access the corresponding slave
 * peripheral's memory space. See #pacr_attributes , "Attribute check (AC) values" for
 * details.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRI_AC2 field. */
#define AIPS_RD_PACRI_AC2(base) ((AIPS_PACRI_REG(base) & AIPS_PACRI_AC2_MASK) >> AIPS_PACRI_AC2_SHIFT)
#define AIPS_BRD_PACRI_AC2(base) (BME_UBFX32(&AIPS_PACRI_REG(base), AIPS_PACRI_AC2_SHIFT, AIPS_PACRI_AC2_WIDTH))

/*! @brief Set the AC2 field to a new value. */
#define AIPS_WR_PACRI_AC2(base, value) (AIPS_RMW_PACRI(base, AIPS_PACRI_AC2_MASK, AIPS_PACRI_AC2(value)))
#define AIPS_BWR_PACRI_AC2(base, value) (BME_BFI32(&AIPS_PACRI_REG(base), ((uint32_t)(value) << AIPS_PACRI_AC2_SHIFT), AIPS_PACRI_AC2_SHIFT, AIPS_PACRI_AC2_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRI, field RO2[23] (RW)
 *
 * Indicates the lock status of this register's AC2 field. After this field is
 * set to 1, it cannot be changed and attempted writes to AC2 are ignored until
 * the next system reset clears this field.
 *
 * Values:
 * - 0b0 - Writes to corresponding AC field are allowed.
 * - 0b1 - Writes to corresponding AC field are ignored.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRI_RO2 field. */
#define AIPS_RD_PACRI_RO2(base) ((AIPS_PACRI_REG(base) & AIPS_PACRI_RO2_MASK) >> AIPS_PACRI_RO2_SHIFT)
#define AIPS_BRD_PACRI_RO2(base) (BME_UBFX32(&AIPS_PACRI_REG(base), AIPS_PACRI_RO2_SHIFT, AIPS_PACRI_RO2_WIDTH))

/*! @brief Set the RO2 field to a new value. */
#define AIPS_WR_PACRI_RO2(base, value) (AIPS_RMW_PACRI(base, AIPS_PACRI_RO2_MASK, AIPS_PACRI_RO2(value)))
#define AIPS_BWR_PACRI_RO2(base, value) (BME_BFI32(&AIPS_PACRI_REG(base), ((uint32_t)(value) << AIPS_PACRI_RO2_SHIFT), AIPS_PACRI_RO2_SHIFT, AIPS_PACRI_RO2_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRI, field AC1[26:24] (RW)
 *
 * Defines the attributes required to access the corresponding slave
 * peripheral's memory space. See #pacr_attributes , "Attribute check (AC) values" for
 * details.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRI_AC1 field. */
#define AIPS_RD_PACRI_AC1(base) ((AIPS_PACRI_REG(base) & AIPS_PACRI_AC1_MASK) >> AIPS_PACRI_AC1_SHIFT)
#define AIPS_BRD_PACRI_AC1(base) (BME_UBFX32(&AIPS_PACRI_REG(base), AIPS_PACRI_AC1_SHIFT, AIPS_PACRI_AC1_WIDTH))

/*! @brief Set the AC1 field to a new value. */
#define AIPS_WR_PACRI_AC1(base, value) (AIPS_RMW_PACRI(base, AIPS_PACRI_AC1_MASK, AIPS_PACRI_AC1(value)))
#define AIPS_BWR_PACRI_AC1(base, value) (BME_BFI32(&AIPS_PACRI_REG(base), ((uint32_t)(value) << AIPS_PACRI_AC1_SHIFT), AIPS_PACRI_AC1_SHIFT, AIPS_PACRI_AC1_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRI, field RO1[27] (RW)
 *
 * Indicates the lock status of this register's AC1 field. After this field is
 * set to 1, it cannot be changed and attempted writes to AC1 are ignored until
 * the next system reset clears this field.
 *
 * Values:
 * - 0b0 - Writes to corresponding AC field are allowed.
 * - 0b1 - Writes to corresponding AC field are ignored.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRI_RO1 field. */
#define AIPS_RD_PACRI_RO1(base) ((AIPS_PACRI_REG(base) & AIPS_PACRI_RO1_MASK) >> AIPS_PACRI_RO1_SHIFT)
#define AIPS_BRD_PACRI_RO1(base) (BME_UBFX32(&AIPS_PACRI_REG(base), AIPS_PACRI_RO1_SHIFT, AIPS_PACRI_RO1_WIDTH))

/*! @brief Set the RO1 field to a new value. */
#define AIPS_WR_PACRI_RO1(base, value) (AIPS_RMW_PACRI(base, AIPS_PACRI_RO1_MASK, AIPS_PACRI_RO1(value)))
#define AIPS_BWR_PACRI_RO1(base, value) (BME_BFI32(&AIPS_PACRI_REG(base), ((uint32_t)(value) << AIPS_PACRI_RO1_SHIFT), AIPS_PACRI_RO1_SHIFT, AIPS_PACRI_RO1_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRI, field AC0[30:28] (RW)
 *
 * Defines the attributes required to access the corresponding slave
 * peripheral's memory space. See #pacr_attributes , "Attribute check (AC) values" for
 * details.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRI_AC0 field. */
#define AIPS_RD_PACRI_AC0(base) ((AIPS_PACRI_REG(base) & AIPS_PACRI_AC0_MASK) >> AIPS_PACRI_AC0_SHIFT)
#define AIPS_BRD_PACRI_AC0(base) (BME_UBFX32(&AIPS_PACRI_REG(base), AIPS_PACRI_AC0_SHIFT, AIPS_PACRI_AC0_WIDTH))

/*! @brief Set the AC0 field to a new value. */
#define AIPS_WR_PACRI_AC0(base, value) (AIPS_RMW_PACRI(base, AIPS_PACRI_AC0_MASK, AIPS_PACRI_AC0(value)))
#define AIPS_BWR_PACRI_AC0(base, value) (BME_BFI32(&AIPS_PACRI_REG(base), ((uint32_t)(value) << AIPS_PACRI_AC0_SHIFT), AIPS_PACRI_AC0_SHIFT, AIPS_PACRI_AC0_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRI, field RO0[31] (RW)
 *
 * Indicates the lock status of this register's AC0 field. After this field is
 * set to 1, it cannot be changed and attempted writes to AC0 are ignored until
 * the next system reset clears this field.
 *
 * Values:
 * - 0b0 - Writes to corresponding AC field are allowed.
 * - 0b1 - Writes to corresponding AC field are ignored.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRI_RO0 field. */
#define AIPS_RD_PACRI_RO0(base) ((AIPS_PACRI_REG(base) & AIPS_PACRI_RO0_MASK) >> AIPS_PACRI_RO0_SHIFT)
#define AIPS_BRD_PACRI_RO0(base) (BME_UBFX32(&AIPS_PACRI_REG(base), AIPS_PACRI_RO0_SHIFT, AIPS_PACRI_RO0_WIDTH))

/*! @brief Set the RO0 field to a new value. */
#define AIPS_WR_PACRI_RO0(base, value) (AIPS_RMW_PACRI(base, AIPS_PACRI_RO0_MASK, AIPS_PACRI_RO0(value)))
#define AIPS_BWR_PACRI_RO0(base, value) (BME_BFI32(&AIPS_PACRI_REG(base), ((uint32_t)(value) << AIPS_PACRI_RO0_SHIFT), AIPS_PACRI_RO0_SHIFT, AIPS_PACRI_RO0_WIDTH))
/*@}*/

/*******************************************************************************
 * AIPS_PACRJ - Peripheral Access Control Register
 ******************************************************************************/

/*!
 * @brief AIPS_PACRJ - Peripheral Access Control Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * Each peripheral on this chip has a 4-bit PACR field which includes a
 * read-only "lock" bit plus a 3-bit attribute check field which defines the access
 * rights (privileged/user, secure/nonsecure) needed to reference the slave
 * peripheral's address space. Access to these registers is allowed using only 32-bit
 * privileged, secure reads and writes. Each 32-bit register controls eight
 * peripherals. PACRE-PACR P control access to the 96 off-platform peripherals. A
 * peripheral's assignment to a PACR field is defined by the memory map slot to which the
 * peripheral is assigned. See this device's peripheral bridge memory map
 * information for the assignment of a particular peripheral. The following table shows
 * the top-level structure of PACRs. Offset Register [31:28] [27:24] [23:20]
 * [19:16] [15:12] [11:8] [7:4] [3:0] 0x40 PACRE PACR32 PACR33 PACR34 PACR35 PACR36
 * PACR37 PACR38 PACR39 0x44 PACRF PACR40 PACR41 PACR42 PACR43 PACR44 PACR45
 * PACR46 PACR47 0x48 PACRG PACR48 PACR49 PACR50 PACR51 PACR52 PACR53 PACR54 PACR55
 * 0x4C PACRH PACR56 PACR57 PACR58 PACR59 PACR60 PACR61 PACR62 PACR63 0x50 PACRI
 * PACR64 PACR65 PACR66 PACR67 PACR68 PACR69 PACR70 PACR71 0x54 PACRJ PACR72 PACR73
 * PACR74 PACR75 PACR76 PACR77 PACR78 PACR79 0x58 PACRK PACR80 PACR81 PACR82
 * PACR83 PACR84 PACR85 PACR86 PACR87 0x5C PACRL PACR88 PACR89 PACR90 PACR91 PACR92
 * PACR93 PACR94 PACR95 0x60 PACRM PACR96 PACR97 PACR98 PACR99 PACR100 PACR101
 * PACR102 PACR103 0x64 PACRN PACR104 PACR105 PACR106 PACR107 PACR108 PACR109
 * PACR110 PACR111 0x68 PACRO PACR112 PACR113 PACR114 PACR115 PACR116 PACR117 PACR118
 * PACR119 0x6C PACRP PACR120 PACR121 PACR122 PACR123 PACR124 PACR125 PACR126
 * PACR127
 */
/*!
 * @name Constants and macros for entire AIPS_PACRJ register
 */
/*@{*/
#define AIPS_RD_PACRJ(base)      (AIPS_PACRJ_REG(base))
#define AIPS_WR_PACRJ(base, value) (AIPS_PACRJ_REG(base) = (value))
#define AIPS_RMW_PACRJ(base, mask, value) (AIPS_WR_PACRJ(base, (AIPS_RD_PACRJ(base) & ~(mask)) | (value)))
#define AIPS_SET_PACRJ(base, value) (BME_OR32(&AIPS_PACRJ_REG(base), (uint32_t)(value)))
#define AIPS_CLR_PACRJ(base, value) (BME_AND32(&AIPS_PACRJ_REG(base), (uint32_t)(~(value))))
#define AIPS_TOG_PACRJ(base, value) (BME_XOR32(&AIPS_PACRJ_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual AIPS_PACRJ bitfields
 */

/*!
 * @name Register AIPS_PACRJ, field AC7[2:0] (RW)
 *
 * Defines the attributes required to access the corresponding slave
 * peripheral's memory space. See #pacr_attributes , "Attribute check (AC) values" for
 * details.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRJ_AC7 field. */
#define AIPS_RD_PACRJ_AC7(base) ((AIPS_PACRJ_REG(base) & AIPS_PACRJ_AC7_MASK) >> AIPS_PACRJ_AC7_SHIFT)
#define AIPS_BRD_PACRJ_AC7(base) (BME_UBFX32(&AIPS_PACRJ_REG(base), AIPS_PACRJ_AC7_SHIFT, AIPS_PACRJ_AC7_WIDTH))

/*! @brief Set the AC7 field to a new value. */
#define AIPS_WR_PACRJ_AC7(base, value) (AIPS_RMW_PACRJ(base, AIPS_PACRJ_AC7_MASK, AIPS_PACRJ_AC7(value)))
#define AIPS_BWR_PACRJ_AC7(base, value) (BME_BFI32(&AIPS_PACRJ_REG(base), ((uint32_t)(value) << AIPS_PACRJ_AC7_SHIFT), AIPS_PACRJ_AC7_SHIFT, AIPS_PACRJ_AC7_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRJ, field RO7[3] (RW)
 *
 * Indicates the lock status of this register's AC7 field. After this field is
 * set to 1, it cannot be changed and attempted writes to AC7 are ignored until
 * the next system reset clears this field.
 *
 * Values:
 * - 0b0 - Writes to corresponding AC field are allowed.
 * - 0b1 - Writes to corresponding AC field are ignored.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRJ_RO7 field. */
#define AIPS_RD_PACRJ_RO7(base) ((AIPS_PACRJ_REG(base) & AIPS_PACRJ_RO7_MASK) >> AIPS_PACRJ_RO7_SHIFT)
#define AIPS_BRD_PACRJ_RO7(base) (BME_UBFX32(&AIPS_PACRJ_REG(base), AIPS_PACRJ_RO7_SHIFT, AIPS_PACRJ_RO7_WIDTH))

/*! @brief Set the RO7 field to a new value. */
#define AIPS_WR_PACRJ_RO7(base, value) (AIPS_RMW_PACRJ(base, AIPS_PACRJ_RO7_MASK, AIPS_PACRJ_RO7(value)))
#define AIPS_BWR_PACRJ_RO7(base, value) (BME_BFI32(&AIPS_PACRJ_REG(base), ((uint32_t)(value) << AIPS_PACRJ_RO7_SHIFT), AIPS_PACRJ_RO7_SHIFT, AIPS_PACRJ_RO7_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRJ, field AC6[6:4] (RW)
 *
 * Defines the attributes required to access the corresponding slave
 * peripheral's memory space. See #pacr_attributes , "Attribute check (AC) values" for
 * details.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRJ_AC6 field. */
#define AIPS_RD_PACRJ_AC6(base) ((AIPS_PACRJ_REG(base) & AIPS_PACRJ_AC6_MASK) >> AIPS_PACRJ_AC6_SHIFT)
#define AIPS_BRD_PACRJ_AC6(base) (BME_UBFX32(&AIPS_PACRJ_REG(base), AIPS_PACRJ_AC6_SHIFT, AIPS_PACRJ_AC6_WIDTH))

/*! @brief Set the AC6 field to a new value. */
#define AIPS_WR_PACRJ_AC6(base, value) (AIPS_RMW_PACRJ(base, AIPS_PACRJ_AC6_MASK, AIPS_PACRJ_AC6(value)))
#define AIPS_BWR_PACRJ_AC6(base, value) (BME_BFI32(&AIPS_PACRJ_REG(base), ((uint32_t)(value) << AIPS_PACRJ_AC6_SHIFT), AIPS_PACRJ_AC6_SHIFT, AIPS_PACRJ_AC6_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRJ, field RO6[7] (RW)
 *
 * Indicates the lock status of this register's AC6 field. After this field is
 * set to 1, it cannot be changed and attempted writes to AC6 are ignored until
 * the next system reset clears this field.
 *
 * Values:
 * - 0b0 - Writes to corresponding AC field are allowed.
 * - 0b1 - Writes to corresponding AC field are ignored.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRJ_RO6 field. */
#define AIPS_RD_PACRJ_RO6(base) ((AIPS_PACRJ_REG(base) & AIPS_PACRJ_RO6_MASK) >> AIPS_PACRJ_RO6_SHIFT)
#define AIPS_BRD_PACRJ_RO6(base) (BME_UBFX32(&AIPS_PACRJ_REG(base), AIPS_PACRJ_RO6_SHIFT, AIPS_PACRJ_RO6_WIDTH))

/*! @brief Set the RO6 field to a new value. */
#define AIPS_WR_PACRJ_RO6(base, value) (AIPS_RMW_PACRJ(base, AIPS_PACRJ_RO6_MASK, AIPS_PACRJ_RO6(value)))
#define AIPS_BWR_PACRJ_RO6(base, value) (BME_BFI32(&AIPS_PACRJ_REG(base), ((uint32_t)(value) << AIPS_PACRJ_RO6_SHIFT), AIPS_PACRJ_RO6_SHIFT, AIPS_PACRJ_RO6_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRJ, field AC5[10:8] (RW)
 *
 * Defines the attributes required to access the corresponding slave
 * peripheral's memory space. See #pacr_attributes , "Attribute check (AC) values" for
 * details.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRJ_AC5 field. */
#define AIPS_RD_PACRJ_AC5(base) ((AIPS_PACRJ_REG(base) & AIPS_PACRJ_AC5_MASK) >> AIPS_PACRJ_AC5_SHIFT)
#define AIPS_BRD_PACRJ_AC5(base) (BME_UBFX32(&AIPS_PACRJ_REG(base), AIPS_PACRJ_AC5_SHIFT, AIPS_PACRJ_AC5_WIDTH))

/*! @brief Set the AC5 field to a new value. */
#define AIPS_WR_PACRJ_AC5(base, value) (AIPS_RMW_PACRJ(base, AIPS_PACRJ_AC5_MASK, AIPS_PACRJ_AC5(value)))
#define AIPS_BWR_PACRJ_AC5(base, value) (BME_BFI32(&AIPS_PACRJ_REG(base), ((uint32_t)(value) << AIPS_PACRJ_AC5_SHIFT), AIPS_PACRJ_AC5_SHIFT, AIPS_PACRJ_AC5_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRJ, field RO5[11] (RW)
 *
 * Indicates the lock status of this register's AC5 field. After this field is
 * set to 1, it cannot be changed and attempted writes to AC5 are ignored until
 * the next system reset clears this field.
 *
 * Values:
 * - 0b0 - Writes to corresponding AC field are allowed.
 * - 0b1 - Writes to corresponding AC field are ignored.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRJ_RO5 field. */
#define AIPS_RD_PACRJ_RO5(base) ((AIPS_PACRJ_REG(base) & AIPS_PACRJ_RO5_MASK) >> AIPS_PACRJ_RO5_SHIFT)
#define AIPS_BRD_PACRJ_RO5(base) (BME_UBFX32(&AIPS_PACRJ_REG(base), AIPS_PACRJ_RO5_SHIFT, AIPS_PACRJ_RO5_WIDTH))

/*! @brief Set the RO5 field to a new value. */
#define AIPS_WR_PACRJ_RO5(base, value) (AIPS_RMW_PACRJ(base, AIPS_PACRJ_RO5_MASK, AIPS_PACRJ_RO5(value)))
#define AIPS_BWR_PACRJ_RO5(base, value) (BME_BFI32(&AIPS_PACRJ_REG(base), ((uint32_t)(value) << AIPS_PACRJ_RO5_SHIFT), AIPS_PACRJ_RO5_SHIFT, AIPS_PACRJ_RO5_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRJ, field AC4[14:12] (RW)
 *
 * Defines the attributes required to access the corresponding slave
 * peripheral's memory space. See #pacr_attributes , "Attribute check (AC) values" for
 * details.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRJ_AC4 field. */
#define AIPS_RD_PACRJ_AC4(base) ((AIPS_PACRJ_REG(base) & AIPS_PACRJ_AC4_MASK) >> AIPS_PACRJ_AC4_SHIFT)
#define AIPS_BRD_PACRJ_AC4(base) (BME_UBFX32(&AIPS_PACRJ_REG(base), AIPS_PACRJ_AC4_SHIFT, AIPS_PACRJ_AC4_WIDTH))

/*! @brief Set the AC4 field to a new value. */
#define AIPS_WR_PACRJ_AC4(base, value) (AIPS_RMW_PACRJ(base, AIPS_PACRJ_AC4_MASK, AIPS_PACRJ_AC4(value)))
#define AIPS_BWR_PACRJ_AC4(base, value) (BME_BFI32(&AIPS_PACRJ_REG(base), ((uint32_t)(value) << AIPS_PACRJ_AC4_SHIFT), AIPS_PACRJ_AC4_SHIFT, AIPS_PACRJ_AC4_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRJ, field RO4[15] (RW)
 *
 * Indicates the lock status of this register's AC4 field. After this field is
 * set to 1, it cannot be changed and attempted writes to AC4 are ignored until
 * the next system reset clears this field.
 *
 * Values:
 * - 0b0 - Writes to corresponding AC field are allowed.
 * - 0b1 - Writes to corresponding AC field are ignored.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRJ_RO4 field. */
#define AIPS_RD_PACRJ_RO4(base) ((AIPS_PACRJ_REG(base) & AIPS_PACRJ_RO4_MASK) >> AIPS_PACRJ_RO4_SHIFT)
#define AIPS_BRD_PACRJ_RO4(base) (BME_UBFX32(&AIPS_PACRJ_REG(base), AIPS_PACRJ_RO4_SHIFT, AIPS_PACRJ_RO4_WIDTH))

/*! @brief Set the RO4 field to a new value. */
#define AIPS_WR_PACRJ_RO4(base, value) (AIPS_RMW_PACRJ(base, AIPS_PACRJ_RO4_MASK, AIPS_PACRJ_RO4(value)))
#define AIPS_BWR_PACRJ_RO4(base, value) (BME_BFI32(&AIPS_PACRJ_REG(base), ((uint32_t)(value) << AIPS_PACRJ_RO4_SHIFT), AIPS_PACRJ_RO4_SHIFT, AIPS_PACRJ_RO4_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRJ, field AC3[18:16] (RW)
 *
 * Defines the attributes required to access the corresponding slave
 * peripheral's memory space. See #pacr_attributes , "Attribute check (AC) values" for
 * details.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRJ_AC3 field. */
#define AIPS_RD_PACRJ_AC3(base) ((AIPS_PACRJ_REG(base) & AIPS_PACRJ_AC3_MASK) >> AIPS_PACRJ_AC3_SHIFT)
#define AIPS_BRD_PACRJ_AC3(base) (BME_UBFX32(&AIPS_PACRJ_REG(base), AIPS_PACRJ_AC3_SHIFT, AIPS_PACRJ_AC3_WIDTH))

/*! @brief Set the AC3 field to a new value. */
#define AIPS_WR_PACRJ_AC3(base, value) (AIPS_RMW_PACRJ(base, AIPS_PACRJ_AC3_MASK, AIPS_PACRJ_AC3(value)))
#define AIPS_BWR_PACRJ_AC3(base, value) (BME_BFI32(&AIPS_PACRJ_REG(base), ((uint32_t)(value) << AIPS_PACRJ_AC3_SHIFT), AIPS_PACRJ_AC3_SHIFT, AIPS_PACRJ_AC3_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRJ, field RO3[19] (RW)
 *
 * Indicates the lock status of this register's AC3 field. After this field is
 * set to 1, it cannot be changed and attempted writes to AC3 are ignored until
 * the next system reset clears this field.
 *
 * Values:
 * - 0b0 - Writes to corresponding AC field are allowed.
 * - 0b1 - Writes to corresponding AC field are ignored.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRJ_RO3 field. */
#define AIPS_RD_PACRJ_RO3(base) ((AIPS_PACRJ_REG(base) & AIPS_PACRJ_RO3_MASK) >> AIPS_PACRJ_RO3_SHIFT)
#define AIPS_BRD_PACRJ_RO3(base) (BME_UBFX32(&AIPS_PACRJ_REG(base), AIPS_PACRJ_RO3_SHIFT, AIPS_PACRJ_RO3_WIDTH))

/*! @brief Set the RO3 field to a new value. */
#define AIPS_WR_PACRJ_RO3(base, value) (AIPS_RMW_PACRJ(base, AIPS_PACRJ_RO3_MASK, AIPS_PACRJ_RO3(value)))
#define AIPS_BWR_PACRJ_RO3(base, value) (BME_BFI32(&AIPS_PACRJ_REG(base), ((uint32_t)(value) << AIPS_PACRJ_RO3_SHIFT), AIPS_PACRJ_RO3_SHIFT, AIPS_PACRJ_RO3_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRJ, field AC2[22:20] (RW)
 *
 * Defines the attributes required to access the corresponding slave
 * peripheral's memory space. See #pacr_attributes , "Attribute check (AC) values" for
 * details.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRJ_AC2 field. */
#define AIPS_RD_PACRJ_AC2(base) ((AIPS_PACRJ_REG(base) & AIPS_PACRJ_AC2_MASK) >> AIPS_PACRJ_AC2_SHIFT)
#define AIPS_BRD_PACRJ_AC2(base) (BME_UBFX32(&AIPS_PACRJ_REG(base), AIPS_PACRJ_AC2_SHIFT, AIPS_PACRJ_AC2_WIDTH))

/*! @brief Set the AC2 field to a new value. */
#define AIPS_WR_PACRJ_AC2(base, value) (AIPS_RMW_PACRJ(base, AIPS_PACRJ_AC2_MASK, AIPS_PACRJ_AC2(value)))
#define AIPS_BWR_PACRJ_AC2(base, value) (BME_BFI32(&AIPS_PACRJ_REG(base), ((uint32_t)(value) << AIPS_PACRJ_AC2_SHIFT), AIPS_PACRJ_AC2_SHIFT, AIPS_PACRJ_AC2_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRJ, field RO2[23] (RW)
 *
 * Indicates the lock status of this register's AC2 field. After this field is
 * set to 1, it cannot be changed and attempted writes to AC2 are ignored until
 * the next system reset clears this field.
 *
 * Values:
 * - 0b0 - Writes to corresponding AC field are allowed.
 * - 0b1 - Writes to corresponding AC field are ignored.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRJ_RO2 field. */
#define AIPS_RD_PACRJ_RO2(base) ((AIPS_PACRJ_REG(base) & AIPS_PACRJ_RO2_MASK) >> AIPS_PACRJ_RO2_SHIFT)
#define AIPS_BRD_PACRJ_RO2(base) (BME_UBFX32(&AIPS_PACRJ_REG(base), AIPS_PACRJ_RO2_SHIFT, AIPS_PACRJ_RO2_WIDTH))

/*! @brief Set the RO2 field to a new value. */
#define AIPS_WR_PACRJ_RO2(base, value) (AIPS_RMW_PACRJ(base, AIPS_PACRJ_RO2_MASK, AIPS_PACRJ_RO2(value)))
#define AIPS_BWR_PACRJ_RO2(base, value) (BME_BFI32(&AIPS_PACRJ_REG(base), ((uint32_t)(value) << AIPS_PACRJ_RO2_SHIFT), AIPS_PACRJ_RO2_SHIFT, AIPS_PACRJ_RO2_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRJ, field AC1[26:24] (RW)
 *
 * Defines the attributes required to access the corresponding slave
 * peripheral's memory space. See #pacr_attributes , "Attribute check (AC) values" for
 * details.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRJ_AC1 field. */
#define AIPS_RD_PACRJ_AC1(base) ((AIPS_PACRJ_REG(base) & AIPS_PACRJ_AC1_MASK) >> AIPS_PACRJ_AC1_SHIFT)
#define AIPS_BRD_PACRJ_AC1(base) (BME_UBFX32(&AIPS_PACRJ_REG(base), AIPS_PACRJ_AC1_SHIFT, AIPS_PACRJ_AC1_WIDTH))

/*! @brief Set the AC1 field to a new value. */
#define AIPS_WR_PACRJ_AC1(base, value) (AIPS_RMW_PACRJ(base, AIPS_PACRJ_AC1_MASK, AIPS_PACRJ_AC1(value)))
#define AIPS_BWR_PACRJ_AC1(base, value) (BME_BFI32(&AIPS_PACRJ_REG(base), ((uint32_t)(value) << AIPS_PACRJ_AC1_SHIFT), AIPS_PACRJ_AC1_SHIFT, AIPS_PACRJ_AC1_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRJ, field RO1[27] (RW)
 *
 * Indicates the lock status of this register's AC1 field. After this field is
 * set to 1, it cannot be changed and attempted writes to AC1 are ignored until
 * the next system reset clears this field.
 *
 * Values:
 * - 0b0 - Writes to corresponding AC field are allowed.
 * - 0b1 - Writes to corresponding AC field are ignored.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRJ_RO1 field. */
#define AIPS_RD_PACRJ_RO1(base) ((AIPS_PACRJ_REG(base) & AIPS_PACRJ_RO1_MASK) >> AIPS_PACRJ_RO1_SHIFT)
#define AIPS_BRD_PACRJ_RO1(base) (BME_UBFX32(&AIPS_PACRJ_REG(base), AIPS_PACRJ_RO1_SHIFT, AIPS_PACRJ_RO1_WIDTH))

/*! @brief Set the RO1 field to a new value. */
#define AIPS_WR_PACRJ_RO1(base, value) (AIPS_RMW_PACRJ(base, AIPS_PACRJ_RO1_MASK, AIPS_PACRJ_RO1(value)))
#define AIPS_BWR_PACRJ_RO1(base, value) (BME_BFI32(&AIPS_PACRJ_REG(base), ((uint32_t)(value) << AIPS_PACRJ_RO1_SHIFT), AIPS_PACRJ_RO1_SHIFT, AIPS_PACRJ_RO1_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRJ, field AC0[30:28] (RW)
 *
 * Defines the attributes required to access the corresponding slave
 * peripheral's memory space. See #pacr_attributes , "Attribute check (AC) values" for
 * details.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRJ_AC0 field. */
#define AIPS_RD_PACRJ_AC0(base) ((AIPS_PACRJ_REG(base) & AIPS_PACRJ_AC0_MASK) >> AIPS_PACRJ_AC0_SHIFT)
#define AIPS_BRD_PACRJ_AC0(base) (BME_UBFX32(&AIPS_PACRJ_REG(base), AIPS_PACRJ_AC0_SHIFT, AIPS_PACRJ_AC0_WIDTH))

/*! @brief Set the AC0 field to a new value. */
#define AIPS_WR_PACRJ_AC0(base, value) (AIPS_RMW_PACRJ(base, AIPS_PACRJ_AC0_MASK, AIPS_PACRJ_AC0(value)))
#define AIPS_BWR_PACRJ_AC0(base, value) (BME_BFI32(&AIPS_PACRJ_REG(base), ((uint32_t)(value) << AIPS_PACRJ_AC0_SHIFT), AIPS_PACRJ_AC0_SHIFT, AIPS_PACRJ_AC0_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRJ, field RO0[31] (RW)
 *
 * Indicates the lock status of this register's AC0 field. After this field is
 * set to 1, it cannot be changed and attempted writes to AC0 are ignored until
 * the next system reset clears this field.
 *
 * Values:
 * - 0b0 - Writes to corresponding AC field are allowed.
 * - 0b1 - Writes to corresponding AC field are ignored.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRJ_RO0 field. */
#define AIPS_RD_PACRJ_RO0(base) ((AIPS_PACRJ_REG(base) & AIPS_PACRJ_RO0_MASK) >> AIPS_PACRJ_RO0_SHIFT)
#define AIPS_BRD_PACRJ_RO0(base) (BME_UBFX32(&AIPS_PACRJ_REG(base), AIPS_PACRJ_RO0_SHIFT, AIPS_PACRJ_RO0_WIDTH))

/*! @brief Set the RO0 field to a new value. */
#define AIPS_WR_PACRJ_RO0(base, value) (AIPS_RMW_PACRJ(base, AIPS_PACRJ_RO0_MASK, AIPS_PACRJ_RO0(value)))
#define AIPS_BWR_PACRJ_RO0(base, value) (BME_BFI32(&AIPS_PACRJ_REG(base), ((uint32_t)(value) << AIPS_PACRJ_RO0_SHIFT), AIPS_PACRJ_RO0_SHIFT, AIPS_PACRJ_RO0_WIDTH))
/*@}*/

/*******************************************************************************
 * AIPS_PACRK - Peripheral Access Control Register
 ******************************************************************************/

/*!
 * @brief AIPS_PACRK - Peripheral Access Control Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * Each peripheral on this chip has a 4-bit PACR field which includes a
 * read-only "lock" bit plus a 3-bit attribute check field which defines the access
 * rights (privileged/user, secure/nonsecure) needed to reference the slave
 * peripheral's address space. Access to these registers is allowed using only 32-bit
 * privileged, secure reads and writes. Each 32-bit register controls eight
 * peripherals. PACRE-PACR P control access to the 96 off-platform peripherals. A
 * peripheral's assignment to a PACR field is defined by the memory map slot to which the
 * peripheral is assigned. See this device's peripheral bridge memory map
 * information for the assignment of a particular peripheral. The following table shows
 * the top-level structure of PACRs. Offset Register [31:28] [27:24] [23:20]
 * [19:16] [15:12] [11:8] [7:4] [3:0] 0x40 PACRE PACR32 PACR33 PACR34 PACR35 PACR36
 * PACR37 PACR38 PACR39 0x44 PACRF PACR40 PACR41 PACR42 PACR43 PACR44 PACR45
 * PACR46 PACR47 0x48 PACRG PACR48 PACR49 PACR50 PACR51 PACR52 PACR53 PACR54 PACR55
 * 0x4C PACRH PACR56 PACR57 PACR58 PACR59 PACR60 PACR61 PACR62 PACR63 0x50 PACRI
 * PACR64 PACR65 PACR66 PACR67 PACR68 PACR69 PACR70 PACR71 0x54 PACRJ PACR72 PACR73
 * PACR74 PACR75 PACR76 PACR77 PACR78 PACR79 0x58 PACRK PACR80 PACR81 PACR82
 * PACR83 PACR84 PACR85 PACR86 PACR87 0x5C PACRL PACR88 PACR89 PACR90 PACR91 PACR92
 * PACR93 PACR94 PACR95 0x60 PACRM PACR96 PACR97 PACR98 PACR99 PACR100 PACR101
 * PACR102 PACR103 0x64 PACRN PACR104 PACR105 PACR106 PACR107 PACR108 PACR109
 * PACR110 PACR111 0x68 PACRO PACR112 PACR113 PACR114 PACR115 PACR116 PACR117 PACR118
 * PACR119 0x6C PACRP PACR120 PACR121 PACR122 PACR123 PACR124 PACR125 PACR126
 * PACR127
 */
/*!
 * @name Constants and macros for entire AIPS_PACRK register
 */
/*@{*/
#define AIPS_RD_PACRK(base)      (AIPS_PACRK_REG(base))
#define AIPS_WR_PACRK(base, value) (AIPS_PACRK_REG(base) = (value))
#define AIPS_RMW_PACRK(base, mask, value) (AIPS_WR_PACRK(base, (AIPS_RD_PACRK(base) & ~(mask)) | (value)))
#define AIPS_SET_PACRK(base, value) (BME_OR32(&AIPS_PACRK_REG(base), (uint32_t)(value)))
#define AIPS_CLR_PACRK(base, value) (BME_AND32(&AIPS_PACRK_REG(base), (uint32_t)(~(value))))
#define AIPS_TOG_PACRK(base, value) (BME_XOR32(&AIPS_PACRK_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual AIPS_PACRK bitfields
 */

/*!
 * @name Register AIPS_PACRK, field AC7[2:0] (RW)
 *
 * Defines the attributes required to access the corresponding slave
 * peripheral's memory space. See #pacr_attributes , "Attribute check (AC) values" for
 * details.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRK_AC7 field. */
#define AIPS_RD_PACRK_AC7(base) ((AIPS_PACRK_REG(base) & AIPS_PACRK_AC7_MASK) >> AIPS_PACRK_AC7_SHIFT)
#define AIPS_BRD_PACRK_AC7(base) (BME_UBFX32(&AIPS_PACRK_REG(base), AIPS_PACRK_AC7_SHIFT, AIPS_PACRK_AC7_WIDTH))

/*! @brief Set the AC7 field to a new value. */
#define AIPS_WR_PACRK_AC7(base, value) (AIPS_RMW_PACRK(base, AIPS_PACRK_AC7_MASK, AIPS_PACRK_AC7(value)))
#define AIPS_BWR_PACRK_AC7(base, value) (BME_BFI32(&AIPS_PACRK_REG(base), ((uint32_t)(value) << AIPS_PACRK_AC7_SHIFT), AIPS_PACRK_AC7_SHIFT, AIPS_PACRK_AC7_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRK, field RO7[3] (RW)
 *
 * Indicates the lock status of this register's AC7 field. After this field is
 * set to 1, it cannot be changed and attempted writes to AC7 are ignored until
 * the next system reset clears this field.
 *
 * Values:
 * - 0b0 - Writes to corresponding AC field are allowed.
 * - 0b1 - Writes to corresponding AC field are ignored.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRK_RO7 field. */
#define AIPS_RD_PACRK_RO7(base) ((AIPS_PACRK_REG(base) & AIPS_PACRK_RO7_MASK) >> AIPS_PACRK_RO7_SHIFT)
#define AIPS_BRD_PACRK_RO7(base) (BME_UBFX32(&AIPS_PACRK_REG(base), AIPS_PACRK_RO7_SHIFT, AIPS_PACRK_RO7_WIDTH))

/*! @brief Set the RO7 field to a new value. */
#define AIPS_WR_PACRK_RO7(base, value) (AIPS_RMW_PACRK(base, AIPS_PACRK_RO7_MASK, AIPS_PACRK_RO7(value)))
#define AIPS_BWR_PACRK_RO7(base, value) (BME_BFI32(&AIPS_PACRK_REG(base), ((uint32_t)(value) << AIPS_PACRK_RO7_SHIFT), AIPS_PACRK_RO7_SHIFT, AIPS_PACRK_RO7_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRK, field AC6[6:4] (RW)
 *
 * Defines the attributes required to access the corresponding slave
 * peripheral's memory space. See #pacr_attributes , "Attribute check (AC) values" for
 * details.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRK_AC6 field. */
#define AIPS_RD_PACRK_AC6(base) ((AIPS_PACRK_REG(base) & AIPS_PACRK_AC6_MASK) >> AIPS_PACRK_AC6_SHIFT)
#define AIPS_BRD_PACRK_AC6(base) (BME_UBFX32(&AIPS_PACRK_REG(base), AIPS_PACRK_AC6_SHIFT, AIPS_PACRK_AC6_WIDTH))

/*! @brief Set the AC6 field to a new value. */
#define AIPS_WR_PACRK_AC6(base, value) (AIPS_RMW_PACRK(base, AIPS_PACRK_AC6_MASK, AIPS_PACRK_AC6(value)))
#define AIPS_BWR_PACRK_AC6(base, value) (BME_BFI32(&AIPS_PACRK_REG(base), ((uint32_t)(value) << AIPS_PACRK_AC6_SHIFT), AIPS_PACRK_AC6_SHIFT, AIPS_PACRK_AC6_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRK, field RO6[7] (RW)
 *
 * Indicates the lock status of this register's AC6 field. After this field is
 * set to 1, it cannot be changed and attempted writes to AC6 are ignored until
 * the next system reset clears this field.
 *
 * Values:
 * - 0b0 - Writes to corresponding AC field are allowed.
 * - 0b1 - Writes to corresponding AC field are ignored.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRK_RO6 field. */
#define AIPS_RD_PACRK_RO6(base) ((AIPS_PACRK_REG(base) & AIPS_PACRK_RO6_MASK) >> AIPS_PACRK_RO6_SHIFT)
#define AIPS_BRD_PACRK_RO6(base) (BME_UBFX32(&AIPS_PACRK_REG(base), AIPS_PACRK_RO6_SHIFT, AIPS_PACRK_RO6_WIDTH))

/*! @brief Set the RO6 field to a new value. */
#define AIPS_WR_PACRK_RO6(base, value) (AIPS_RMW_PACRK(base, AIPS_PACRK_RO6_MASK, AIPS_PACRK_RO6(value)))
#define AIPS_BWR_PACRK_RO6(base, value) (BME_BFI32(&AIPS_PACRK_REG(base), ((uint32_t)(value) << AIPS_PACRK_RO6_SHIFT), AIPS_PACRK_RO6_SHIFT, AIPS_PACRK_RO6_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRK, field AC5[10:8] (RW)
 *
 * Defines the attributes required to access the corresponding slave
 * peripheral's memory space. See #pacr_attributes , "Attribute check (AC) values" for
 * details.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRK_AC5 field. */
#define AIPS_RD_PACRK_AC5(base) ((AIPS_PACRK_REG(base) & AIPS_PACRK_AC5_MASK) >> AIPS_PACRK_AC5_SHIFT)
#define AIPS_BRD_PACRK_AC5(base) (BME_UBFX32(&AIPS_PACRK_REG(base), AIPS_PACRK_AC5_SHIFT, AIPS_PACRK_AC5_WIDTH))

/*! @brief Set the AC5 field to a new value. */
#define AIPS_WR_PACRK_AC5(base, value) (AIPS_RMW_PACRK(base, AIPS_PACRK_AC5_MASK, AIPS_PACRK_AC5(value)))
#define AIPS_BWR_PACRK_AC5(base, value) (BME_BFI32(&AIPS_PACRK_REG(base), ((uint32_t)(value) << AIPS_PACRK_AC5_SHIFT), AIPS_PACRK_AC5_SHIFT, AIPS_PACRK_AC5_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRK, field RO5[11] (RW)
 *
 * Indicates the lock status of this register's AC5 field. After this field is
 * set to 1, it cannot be changed and attempted writes to AC5 are ignored until
 * the next system reset clears this field.
 *
 * Values:
 * - 0b0 - Writes to corresponding AC field are allowed.
 * - 0b1 - Writes to corresponding AC field are ignored.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRK_RO5 field. */
#define AIPS_RD_PACRK_RO5(base) ((AIPS_PACRK_REG(base) & AIPS_PACRK_RO5_MASK) >> AIPS_PACRK_RO5_SHIFT)
#define AIPS_BRD_PACRK_RO5(base) (BME_UBFX32(&AIPS_PACRK_REG(base), AIPS_PACRK_RO5_SHIFT, AIPS_PACRK_RO5_WIDTH))

/*! @brief Set the RO5 field to a new value. */
#define AIPS_WR_PACRK_RO5(base, value) (AIPS_RMW_PACRK(base, AIPS_PACRK_RO5_MASK, AIPS_PACRK_RO5(value)))
#define AIPS_BWR_PACRK_RO5(base, value) (BME_BFI32(&AIPS_PACRK_REG(base), ((uint32_t)(value) << AIPS_PACRK_RO5_SHIFT), AIPS_PACRK_RO5_SHIFT, AIPS_PACRK_RO5_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRK, field AC4[14:12] (RW)
 *
 * Defines the attributes required to access the corresponding slave
 * peripheral's memory space. See #pacr_attributes , "Attribute check (AC) values" for
 * details.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRK_AC4 field. */
#define AIPS_RD_PACRK_AC4(base) ((AIPS_PACRK_REG(base) & AIPS_PACRK_AC4_MASK) >> AIPS_PACRK_AC4_SHIFT)
#define AIPS_BRD_PACRK_AC4(base) (BME_UBFX32(&AIPS_PACRK_REG(base), AIPS_PACRK_AC4_SHIFT, AIPS_PACRK_AC4_WIDTH))

/*! @brief Set the AC4 field to a new value. */
#define AIPS_WR_PACRK_AC4(base, value) (AIPS_RMW_PACRK(base, AIPS_PACRK_AC4_MASK, AIPS_PACRK_AC4(value)))
#define AIPS_BWR_PACRK_AC4(base, value) (BME_BFI32(&AIPS_PACRK_REG(base), ((uint32_t)(value) << AIPS_PACRK_AC4_SHIFT), AIPS_PACRK_AC4_SHIFT, AIPS_PACRK_AC4_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRK, field RO4[15] (RW)
 *
 * Indicates the lock status of this register's AC4 field. After this field is
 * set to 1, it cannot be changed and attempted writes to AC4 are ignored until
 * the next system reset clears this field.
 *
 * Values:
 * - 0b0 - Writes to corresponding AC field are allowed.
 * - 0b1 - Writes to corresponding AC field are ignored.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRK_RO4 field. */
#define AIPS_RD_PACRK_RO4(base) ((AIPS_PACRK_REG(base) & AIPS_PACRK_RO4_MASK) >> AIPS_PACRK_RO4_SHIFT)
#define AIPS_BRD_PACRK_RO4(base) (BME_UBFX32(&AIPS_PACRK_REG(base), AIPS_PACRK_RO4_SHIFT, AIPS_PACRK_RO4_WIDTH))

/*! @brief Set the RO4 field to a new value. */
#define AIPS_WR_PACRK_RO4(base, value) (AIPS_RMW_PACRK(base, AIPS_PACRK_RO4_MASK, AIPS_PACRK_RO4(value)))
#define AIPS_BWR_PACRK_RO4(base, value) (BME_BFI32(&AIPS_PACRK_REG(base), ((uint32_t)(value) << AIPS_PACRK_RO4_SHIFT), AIPS_PACRK_RO4_SHIFT, AIPS_PACRK_RO4_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRK, field AC3[18:16] (RW)
 *
 * Defines the attributes required to access the corresponding slave
 * peripheral's memory space. See #pacr_attributes , "Attribute check (AC) values" for
 * details.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRK_AC3 field. */
#define AIPS_RD_PACRK_AC3(base) ((AIPS_PACRK_REG(base) & AIPS_PACRK_AC3_MASK) >> AIPS_PACRK_AC3_SHIFT)
#define AIPS_BRD_PACRK_AC3(base) (BME_UBFX32(&AIPS_PACRK_REG(base), AIPS_PACRK_AC3_SHIFT, AIPS_PACRK_AC3_WIDTH))

/*! @brief Set the AC3 field to a new value. */
#define AIPS_WR_PACRK_AC3(base, value) (AIPS_RMW_PACRK(base, AIPS_PACRK_AC3_MASK, AIPS_PACRK_AC3(value)))
#define AIPS_BWR_PACRK_AC3(base, value) (BME_BFI32(&AIPS_PACRK_REG(base), ((uint32_t)(value) << AIPS_PACRK_AC3_SHIFT), AIPS_PACRK_AC3_SHIFT, AIPS_PACRK_AC3_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRK, field RO3[19] (RW)
 *
 * Indicates the lock status of this register's AC3 field. After this field is
 * set to 1, it cannot be changed and attempted writes to AC3 are ignored until
 * the next system reset clears this field.
 *
 * Values:
 * - 0b0 - Writes to corresponding AC field are allowed.
 * - 0b1 - Writes to corresponding AC field are ignored.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRK_RO3 field. */
#define AIPS_RD_PACRK_RO3(base) ((AIPS_PACRK_REG(base) & AIPS_PACRK_RO3_MASK) >> AIPS_PACRK_RO3_SHIFT)
#define AIPS_BRD_PACRK_RO3(base) (BME_UBFX32(&AIPS_PACRK_REG(base), AIPS_PACRK_RO3_SHIFT, AIPS_PACRK_RO3_WIDTH))

/*! @brief Set the RO3 field to a new value. */
#define AIPS_WR_PACRK_RO3(base, value) (AIPS_RMW_PACRK(base, AIPS_PACRK_RO3_MASK, AIPS_PACRK_RO3(value)))
#define AIPS_BWR_PACRK_RO3(base, value) (BME_BFI32(&AIPS_PACRK_REG(base), ((uint32_t)(value) << AIPS_PACRK_RO3_SHIFT), AIPS_PACRK_RO3_SHIFT, AIPS_PACRK_RO3_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRK, field AC2[22:20] (RW)
 *
 * Defines the attributes required to access the corresponding slave
 * peripheral's memory space. See #pacr_attributes , "Attribute check (AC) values" for
 * details.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRK_AC2 field. */
#define AIPS_RD_PACRK_AC2(base) ((AIPS_PACRK_REG(base) & AIPS_PACRK_AC2_MASK) >> AIPS_PACRK_AC2_SHIFT)
#define AIPS_BRD_PACRK_AC2(base) (BME_UBFX32(&AIPS_PACRK_REG(base), AIPS_PACRK_AC2_SHIFT, AIPS_PACRK_AC2_WIDTH))

/*! @brief Set the AC2 field to a new value. */
#define AIPS_WR_PACRK_AC2(base, value) (AIPS_RMW_PACRK(base, AIPS_PACRK_AC2_MASK, AIPS_PACRK_AC2(value)))
#define AIPS_BWR_PACRK_AC2(base, value) (BME_BFI32(&AIPS_PACRK_REG(base), ((uint32_t)(value) << AIPS_PACRK_AC2_SHIFT), AIPS_PACRK_AC2_SHIFT, AIPS_PACRK_AC2_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRK, field RO2[23] (RW)
 *
 * Indicates the lock status of this register's AC2 field. After this field is
 * set to 1, it cannot be changed and attempted writes to AC2 are ignored until
 * the next system reset clears this field.
 *
 * Values:
 * - 0b0 - Writes to corresponding AC field are allowed.
 * - 0b1 - Writes to corresponding AC field are ignored.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRK_RO2 field. */
#define AIPS_RD_PACRK_RO2(base) ((AIPS_PACRK_REG(base) & AIPS_PACRK_RO2_MASK) >> AIPS_PACRK_RO2_SHIFT)
#define AIPS_BRD_PACRK_RO2(base) (BME_UBFX32(&AIPS_PACRK_REG(base), AIPS_PACRK_RO2_SHIFT, AIPS_PACRK_RO2_WIDTH))

/*! @brief Set the RO2 field to a new value. */
#define AIPS_WR_PACRK_RO2(base, value) (AIPS_RMW_PACRK(base, AIPS_PACRK_RO2_MASK, AIPS_PACRK_RO2(value)))
#define AIPS_BWR_PACRK_RO2(base, value) (BME_BFI32(&AIPS_PACRK_REG(base), ((uint32_t)(value) << AIPS_PACRK_RO2_SHIFT), AIPS_PACRK_RO2_SHIFT, AIPS_PACRK_RO2_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRK, field AC1[26:24] (RW)
 *
 * Defines the attributes required to access the corresponding slave
 * peripheral's memory space. See #pacr_attributes , "Attribute check (AC) values" for
 * details.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRK_AC1 field. */
#define AIPS_RD_PACRK_AC1(base) ((AIPS_PACRK_REG(base) & AIPS_PACRK_AC1_MASK) >> AIPS_PACRK_AC1_SHIFT)
#define AIPS_BRD_PACRK_AC1(base) (BME_UBFX32(&AIPS_PACRK_REG(base), AIPS_PACRK_AC1_SHIFT, AIPS_PACRK_AC1_WIDTH))

/*! @brief Set the AC1 field to a new value. */
#define AIPS_WR_PACRK_AC1(base, value) (AIPS_RMW_PACRK(base, AIPS_PACRK_AC1_MASK, AIPS_PACRK_AC1(value)))
#define AIPS_BWR_PACRK_AC1(base, value) (BME_BFI32(&AIPS_PACRK_REG(base), ((uint32_t)(value) << AIPS_PACRK_AC1_SHIFT), AIPS_PACRK_AC1_SHIFT, AIPS_PACRK_AC1_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRK, field RO1[27] (RW)
 *
 * Indicates the lock status of this register's AC1 field. After this field is
 * set to 1, it cannot be changed and attempted writes to AC1 are ignored until
 * the next system reset clears this field.
 *
 * Values:
 * - 0b0 - Writes to corresponding AC field are allowed.
 * - 0b1 - Writes to corresponding AC field are ignored.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRK_RO1 field. */
#define AIPS_RD_PACRK_RO1(base) ((AIPS_PACRK_REG(base) & AIPS_PACRK_RO1_MASK) >> AIPS_PACRK_RO1_SHIFT)
#define AIPS_BRD_PACRK_RO1(base) (BME_UBFX32(&AIPS_PACRK_REG(base), AIPS_PACRK_RO1_SHIFT, AIPS_PACRK_RO1_WIDTH))

/*! @brief Set the RO1 field to a new value. */
#define AIPS_WR_PACRK_RO1(base, value) (AIPS_RMW_PACRK(base, AIPS_PACRK_RO1_MASK, AIPS_PACRK_RO1(value)))
#define AIPS_BWR_PACRK_RO1(base, value) (BME_BFI32(&AIPS_PACRK_REG(base), ((uint32_t)(value) << AIPS_PACRK_RO1_SHIFT), AIPS_PACRK_RO1_SHIFT, AIPS_PACRK_RO1_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRK, field AC0[30:28] (RW)
 *
 * Defines the attributes required to access the corresponding slave
 * peripheral's memory space. See #pacr_attributes , "Attribute check (AC) values" for
 * details.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRK_AC0 field. */
#define AIPS_RD_PACRK_AC0(base) ((AIPS_PACRK_REG(base) & AIPS_PACRK_AC0_MASK) >> AIPS_PACRK_AC0_SHIFT)
#define AIPS_BRD_PACRK_AC0(base) (BME_UBFX32(&AIPS_PACRK_REG(base), AIPS_PACRK_AC0_SHIFT, AIPS_PACRK_AC0_WIDTH))

/*! @brief Set the AC0 field to a new value. */
#define AIPS_WR_PACRK_AC0(base, value) (AIPS_RMW_PACRK(base, AIPS_PACRK_AC0_MASK, AIPS_PACRK_AC0(value)))
#define AIPS_BWR_PACRK_AC0(base, value) (BME_BFI32(&AIPS_PACRK_REG(base), ((uint32_t)(value) << AIPS_PACRK_AC0_SHIFT), AIPS_PACRK_AC0_SHIFT, AIPS_PACRK_AC0_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRK, field RO0[31] (RW)
 *
 * Indicates the lock status of this register's AC0 field. After this field is
 * set to 1, it cannot be changed and attempted writes to AC0 are ignored until
 * the next system reset clears this field.
 *
 * Values:
 * - 0b0 - Writes to corresponding AC field are allowed.
 * - 0b1 - Writes to corresponding AC field are ignored.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRK_RO0 field. */
#define AIPS_RD_PACRK_RO0(base) ((AIPS_PACRK_REG(base) & AIPS_PACRK_RO0_MASK) >> AIPS_PACRK_RO0_SHIFT)
#define AIPS_BRD_PACRK_RO0(base) (BME_UBFX32(&AIPS_PACRK_REG(base), AIPS_PACRK_RO0_SHIFT, AIPS_PACRK_RO0_WIDTH))

/*! @brief Set the RO0 field to a new value. */
#define AIPS_WR_PACRK_RO0(base, value) (AIPS_RMW_PACRK(base, AIPS_PACRK_RO0_MASK, AIPS_PACRK_RO0(value)))
#define AIPS_BWR_PACRK_RO0(base, value) (BME_BFI32(&AIPS_PACRK_REG(base), ((uint32_t)(value) << AIPS_PACRK_RO0_SHIFT), AIPS_PACRK_RO0_SHIFT, AIPS_PACRK_RO0_WIDTH))
/*@}*/

/*******************************************************************************
 * AIPS_PACRL - Peripheral Access Control Register
 ******************************************************************************/

/*!
 * @brief AIPS_PACRL - Peripheral Access Control Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * Each peripheral on this chip has a 4-bit PACR field which includes a
 * read-only "lock" bit plus a 3-bit attribute check field which defines the access
 * rights (privileged/user, secure/nonsecure) needed to reference the slave
 * peripheral's address space. Access to these registers is allowed using only 32-bit
 * privileged, secure reads and writes. Each 32-bit register controls eight
 * peripherals. PACRE-PACR P control access to the 96 off-platform peripherals. A
 * peripheral's assignment to a PACR field is defined by the memory map slot to which the
 * peripheral is assigned. See this device's peripheral bridge memory map
 * information for the assignment of a particular peripheral. The following table shows
 * the top-level structure of PACRs. Offset Register [31:28] [27:24] [23:20]
 * [19:16] [15:12] [11:8] [7:4] [3:0] 0x40 PACRE PACR32 PACR33 PACR34 PACR35 PACR36
 * PACR37 PACR38 PACR39 0x44 PACRF PACR40 PACR41 PACR42 PACR43 PACR44 PACR45
 * PACR46 PACR47 0x48 PACRG PACR48 PACR49 PACR50 PACR51 PACR52 PACR53 PACR54 PACR55
 * 0x4C PACRH PACR56 PACR57 PACR58 PACR59 PACR60 PACR61 PACR62 PACR63 0x50 PACRI
 * PACR64 PACR65 PACR66 PACR67 PACR68 PACR69 PACR70 PACR71 0x54 PACRJ PACR72 PACR73
 * PACR74 PACR75 PACR76 PACR77 PACR78 PACR79 0x58 PACRK PACR80 PACR81 PACR82
 * PACR83 PACR84 PACR85 PACR86 PACR87 0x5C PACRL PACR88 PACR89 PACR90 PACR91 PACR92
 * PACR93 PACR94 PACR95 0x60 PACRM PACR96 PACR97 PACR98 PACR99 PACR100 PACR101
 * PACR102 PACR103 0x64 PACRN PACR104 PACR105 PACR106 PACR107 PACR108 PACR109
 * PACR110 PACR111 0x68 PACRO PACR112 PACR113 PACR114 PACR115 PACR116 PACR117 PACR118
 * PACR119 0x6C PACRP PACR120 PACR121 PACR122 PACR123 PACR124 PACR125 PACR126
 * PACR127
 */
/*!
 * @name Constants and macros for entire AIPS_PACRL register
 */
/*@{*/
#define AIPS_RD_PACRL(base)      (AIPS_PACRL_REG(base))
#define AIPS_WR_PACRL(base, value) (AIPS_PACRL_REG(base) = (value))
#define AIPS_RMW_PACRL(base, mask, value) (AIPS_WR_PACRL(base, (AIPS_RD_PACRL(base) & ~(mask)) | (value)))
#define AIPS_SET_PACRL(base, value) (BME_OR32(&AIPS_PACRL_REG(base), (uint32_t)(value)))
#define AIPS_CLR_PACRL(base, value) (BME_AND32(&AIPS_PACRL_REG(base), (uint32_t)(~(value))))
#define AIPS_TOG_PACRL(base, value) (BME_XOR32(&AIPS_PACRL_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual AIPS_PACRL bitfields
 */

/*!
 * @name Register AIPS_PACRL, field AC7[2:0] (RW)
 *
 * Defines the attributes required to access the corresponding slave
 * peripheral's memory space. See #pacr_attributes , "Attribute check (AC) values" for
 * details.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRL_AC7 field. */
#define AIPS_RD_PACRL_AC7(base) ((AIPS_PACRL_REG(base) & AIPS_PACRL_AC7_MASK) >> AIPS_PACRL_AC7_SHIFT)
#define AIPS_BRD_PACRL_AC7(base) (BME_UBFX32(&AIPS_PACRL_REG(base), AIPS_PACRL_AC7_SHIFT, AIPS_PACRL_AC7_WIDTH))

/*! @brief Set the AC7 field to a new value. */
#define AIPS_WR_PACRL_AC7(base, value) (AIPS_RMW_PACRL(base, AIPS_PACRL_AC7_MASK, AIPS_PACRL_AC7(value)))
#define AIPS_BWR_PACRL_AC7(base, value) (BME_BFI32(&AIPS_PACRL_REG(base), ((uint32_t)(value) << AIPS_PACRL_AC7_SHIFT), AIPS_PACRL_AC7_SHIFT, AIPS_PACRL_AC7_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRL, field RO7[3] (RW)
 *
 * Indicates the lock status of this register's AC7 field. After this field is
 * set to 1, it cannot be changed and attempted writes to AC7 are ignored until
 * the next system reset clears this field.
 *
 * Values:
 * - 0b0 - Writes to corresponding AC field are allowed.
 * - 0b1 - Writes to corresponding AC field are ignored.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRL_RO7 field. */
#define AIPS_RD_PACRL_RO7(base) ((AIPS_PACRL_REG(base) & AIPS_PACRL_RO7_MASK) >> AIPS_PACRL_RO7_SHIFT)
#define AIPS_BRD_PACRL_RO7(base) (BME_UBFX32(&AIPS_PACRL_REG(base), AIPS_PACRL_RO7_SHIFT, AIPS_PACRL_RO7_WIDTH))

/*! @brief Set the RO7 field to a new value. */
#define AIPS_WR_PACRL_RO7(base, value) (AIPS_RMW_PACRL(base, AIPS_PACRL_RO7_MASK, AIPS_PACRL_RO7(value)))
#define AIPS_BWR_PACRL_RO7(base, value) (BME_BFI32(&AIPS_PACRL_REG(base), ((uint32_t)(value) << AIPS_PACRL_RO7_SHIFT), AIPS_PACRL_RO7_SHIFT, AIPS_PACRL_RO7_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRL, field AC6[6:4] (RW)
 *
 * Defines the attributes required to access the corresponding slave
 * peripheral's memory space. See #pacr_attributes , "Attribute check (AC) values" for
 * details.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRL_AC6 field. */
#define AIPS_RD_PACRL_AC6(base) ((AIPS_PACRL_REG(base) & AIPS_PACRL_AC6_MASK) >> AIPS_PACRL_AC6_SHIFT)
#define AIPS_BRD_PACRL_AC6(base) (BME_UBFX32(&AIPS_PACRL_REG(base), AIPS_PACRL_AC6_SHIFT, AIPS_PACRL_AC6_WIDTH))

/*! @brief Set the AC6 field to a new value. */
#define AIPS_WR_PACRL_AC6(base, value) (AIPS_RMW_PACRL(base, AIPS_PACRL_AC6_MASK, AIPS_PACRL_AC6(value)))
#define AIPS_BWR_PACRL_AC6(base, value) (BME_BFI32(&AIPS_PACRL_REG(base), ((uint32_t)(value) << AIPS_PACRL_AC6_SHIFT), AIPS_PACRL_AC6_SHIFT, AIPS_PACRL_AC6_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRL, field RO6[7] (RW)
 *
 * Indicates the lock status of this register's AC6 field. After this field is
 * set to 1, it cannot be changed and attempted writes to AC6 are ignored until
 * the next system reset clears this field.
 *
 * Values:
 * - 0b0 - Writes to corresponding AC field are allowed.
 * - 0b1 - Writes to corresponding AC field are ignored.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRL_RO6 field. */
#define AIPS_RD_PACRL_RO6(base) ((AIPS_PACRL_REG(base) & AIPS_PACRL_RO6_MASK) >> AIPS_PACRL_RO6_SHIFT)
#define AIPS_BRD_PACRL_RO6(base) (BME_UBFX32(&AIPS_PACRL_REG(base), AIPS_PACRL_RO6_SHIFT, AIPS_PACRL_RO6_WIDTH))

/*! @brief Set the RO6 field to a new value. */
#define AIPS_WR_PACRL_RO6(base, value) (AIPS_RMW_PACRL(base, AIPS_PACRL_RO6_MASK, AIPS_PACRL_RO6(value)))
#define AIPS_BWR_PACRL_RO6(base, value) (BME_BFI32(&AIPS_PACRL_REG(base), ((uint32_t)(value) << AIPS_PACRL_RO6_SHIFT), AIPS_PACRL_RO6_SHIFT, AIPS_PACRL_RO6_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRL, field AC5[10:8] (RW)
 *
 * Defines the attributes required to access the corresponding slave
 * peripheral's memory space. See #pacr_attributes , "Attribute check (AC) values" for
 * details.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRL_AC5 field. */
#define AIPS_RD_PACRL_AC5(base) ((AIPS_PACRL_REG(base) & AIPS_PACRL_AC5_MASK) >> AIPS_PACRL_AC5_SHIFT)
#define AIPS_BRD_PACRL_AC5(base) (BME_UBFX32(&AIPS_PACRL_REG(base), AIPS_PACRL_AC5_SHIFT, AIPS_PACRL_AC5_WIDTH))

/*! @brief Set the AC5 field to a new value. */
#define AIPS_WR_PACRL_AC5(base, value) (AIPS_RMW_PACRL(base, AIPS_PACRL_AC5_MASK, AIPS_PACRL_AC5(value)))
#define AIPS_BWR_PACRL_AC5(base, value) (BME_BFI32(&AIPS_PACRL_REG(base), ((uint32_t)(value) << AIPS_PACRL_AC5_SHIFT), AIPS_PACRL_AC5_SHIFT, AIPS_PACRL_AC5_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRL, field RO5[11] (RW)
 *
 * Indicates the lock status of this register's AC5 field. After this field is
 * set to 1, it cannot be changed and attempted writes to AC5 are ignored until
 * the next system reset clears this field.
 *
 * Values:
 * - 0b0 - Writes to corresponding AC field are allowed.
 * - 0b1 - Writes to corresponding AC field are ignored.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRL_RO5 field. */
#define AIPS_RD_PACRL_RO5(base) ((AIPS_PACRL_REG(base) & AIPS_PACRL_RO5_MASK) >> AIPS_PACRL_RO5_SHIFT)
#define AIPS_BRD_PACRL_RO5(base) (BME_UBFX32(&AIPS_PACRL_REG(base), AIPS_PACRL_RO5_SHIFT, AIPS_PACRL_RO5_WIDTH))

/*! @brief Set the RO5 field to a new value. */
#define AIPS_WR_PACRL_RO5(base, value) (AIPS_RMW_PACRL(base, AIPS_PACRL_RO5_MASK, AIPS_PACRL_RO5(value)))
#define AIPS_BWR_PACRL_RO5(base, value) (BME_BFI32(&AIPS_PACRL_REG(base), ((uint32_t)(value) << AIPS_PACRL_RO5_SHIFT), AIPS_PACRL_RO5_SHIFT, AIPS_PACRL_RO5_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRL, field AC4[14:12] (RW)
 *
 * Defines the attributes required to access the corresponding slave
 * peripheral's memory space. See #pacr_attributes , "Attribute check (AC) values" for
 * details.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRL_AC4 field. */
#define AIPS_RD_PACRL_AC4(base) ((AIPS_PACRL_REG(base) & AIPS_PACRL_AC4_MASK) >> AIPS_PACRL_AC4_SHIFT)
#define AIPS_BRD_PACRL_AC4(base) (BME_UBFX32(&AIPS_PACRL_REG(base), AIPS_PACRL_AC4_SHIFT, AIPS_PACRL_AC4_WIDTH))

/*! @brief Set the AC4 field to a new value. */
#define AIPS_WR_PACRL_AC4(base, value) (AIPS_RMW_PACRL(base, AIPS_PACRL_AC4_MASK, AIPS_PACRL_AC4(value)))
#define AIPS_BWR_PACRL_AC4(base, value) (BME_BFI32(&AIPS_PACRL_REG(base), ((uint32_t)(value) << AIPS_PACRL_AC4_SHIFT), AIPS_PACRL_AC4_SHIFT, AIPS_PACRL_AC4_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRL, field RO4[15] (RW)
 *
 * Indicates the lock status of this register's AC4 field. After this field is
 * set to 1, it cannot be changed and attempted writes to AC4 are ignored until
 * the next system reset clears this field.
 *
 * Values:
 * - 0b0 - Writes to corresponding AC field are allowed.
 * - 0b1 - Writes to corresponding AC field are ignored.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRL_RO4 field. */
#define AIPS_RD_PACRL_RO4(base) ((AIPS_PACRL_REG(base) & AIPS_PACRL_RO4_MASK) >> AIPS_PACRL_RO4_SHIFT)
#define AIPS_BRD_PACRL_RO4(base) (BME_UBFX32(&AIPS_PACRL_REG(base), AIPS_PACRL_RO4_SHIFT, AIPS_PACRL_RO4_WIDTH))

/*! @brief Set the RO4 field to a new value. */
#define AIPS_WR_PACRL_RO4(base, value) (AIPS_RMW_PACRL(base, AIPS_PACRL_RO4_MASK, AIPS_PACRL_RO4(value)))
#define AIPS_BWR_PACRL_RO4(base, value) (BME_BFI32(&AIPS_PACRL_REG(base), ((uint32_t)(value) << AIPS_PACRL_RO4_SHIFT), AIPS_PACRL_RO4_SHIFT, AIPS_PACRL_RO4_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRL, field AC3[18:16] (RW)
 *
 * Defines the attributes required to access the corresponding slave
 * peripheral's memory space. See #pacr_attributes , "Attribute check (AC) values" for
 * details.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRL_AC3 field. */
#define AIPS_RD_PACRL_AC3(base) ((AIPS_PACRL_REG(base) & AIPS_PACRL_AC3_MASK) >> AIPS_PACRL_AC3_SHIFT)
#define AIPS_BRD_PACRL_AC3(base) (BME_UBFX32(&AIPS_PACRL_REG(base), AIPS_PACRL_AC3_SHIFT, AIPS_PACRL_AC3_WIDTH))

/*! @brief Set the AC3 field to a new value. */
#define AIPS_WR_PACRL_AC3(base, value) (AIPS_RMW_PACRL(base, AIPS_PACRL_AC3_MASK, AIPS_PACRL_AC3(value)))
#define AIPS_BWR_PACRL_AC3(base, value) (BME_BFI32(&AIPS_PACRL_REG(base), ((uint32_t)(value) << AIPS_PACRL_AC3_SHIFT), AIPS_PACRL_AC3_SHIFT, AIPS_PACRL_AC3_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRL, field RO3[19] (RW)
 *
 * Indicates the lock status of this register's AC3 field. After this field is
 * set to 1, it cannot be changed and attempted writes to AC3 are ignored until
 * the next system reset clears this field.
 *
 * Values:
 * - 0b0 - Writes to corresponding AC field are allowed.
 * - 0b1 - Writes to corresponding AC field are ignored.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRL_RO3 field. */
#define AIPS_RD_PACRL_RO3(base) ((AIPS_PACRL_REG(base) & AIPS_PACRL_RO3_MASK) >> AIPS_PACRL_RO3_SHIFT)
#define AIPS_BRD_PACRL_RO3(base) (BME_UBFX32(&AIPS_PACRL_REG(base), AIPS_PACRL_RO3_SHIFT, AIPS_PACRL_RO3_WIDTH))

/*! @brief Set the RO3 field to a new value. */
#define AIPS_WR_PACRL_RO3(base, value) (AIPS_RMW_PACRL(base, AIPS_PACRL_RO3_MASK, AIPS_PACRL_RO3(value)))
#define AIPS_BWR_PACRL_RO3(base, value) (BME_BFI32(&AIPS_PACRL_REG(base), ((uint32_t)(value) << AIPS_PACRL_RO3_SHIFT), AIPS_PACRL_RO3_SHIFT, AIPS_PACRL_RO3_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRL, field AC2[22:20] (RW)
 *
 * Defines the attributes required to access the corresponding slave
 * peripheral's memory space. See #pacr_attributes , "Attribute check (AC) values" for
 * details.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRL_AC2 field. */
#define AIPS_RD_PACRL_AC2(base) ((AIPS_PACRL_REG(base) & AIPS_PACRL_AC2_MASK) >> AIPS_PACRL_AC2_SHIFT)
#define AIPS_BRD_PACRL_AC2(base) (BME_UBFX32(&AIPS_PACRL_REG(base), AIPS_PACRL_AC2_SHIFT, AIPS_PACRL_AC2_WIDTH))

/*! @brief Set the AC2 field to a new value. */
#define AIPS_WR_PACRL_AC2(base, value) (AIPS_RMW_PACRL(base, AIPS_PACRL_AC2_MASK, AIPS_PACRL_AC2(value)))
#define AIPS_BWR_PACRL_AC2(base, value) (BME_BFI32(&AIPS_PACRL_REG(base), ((uint32_t)(value) << AIPS_PACRL_AC2_SHIFT), AIPS_PACRL_AC2_SHIFT, AIPS_PACRL_AC2_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRL, field RO2[23] (RW)
 *
 * Indicates the lock status of this register's AC2 field. After this field is
 * set to 1, it cannot be changed and attempted writes to AC2 are ignored until
 * the next system reset clears this field.
 *
 * Values:
 * - 0b0 - Writes to corresponding AC field are allowed.
 * - 0b1 - Writes to corresponding AC field are ignored.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRL_RO2 field. */
#define AIPS_RD_PACRL_RO2(base) ((AIPS_PACRL_REG(base) & AIPS_PACRL_RO2_MASK) >> AIPS_PACRL_RO2_SHIFT)
#define AIPS_BRD_PACRL_RO2(base) (BME_UBFX32(&AIPS_PACRL_REG(base), AIPS_PACRL_RO2_SHIFT, AIPS_PACRL_RO2_WIDTH))

/*! @brief Set the RO2 field to a new value. */
#define AIPS_WR_PACRL_RO2(base, value) (AIPS_RMW_PACRL(base, AIPS_PACRL_RO2_MASK, AIPS_PACRL_RO2(value)))
#define AIPS_BWR_PACRL_RO2(base, value) (BME_BFI32(&AIPS_PACRL_REG(base), ((uint32_t)(value) << AIPS_PACRL_RO2_SHIFT), AIPS_PACRL_RO2_SHIFT, AIPS_PACRL_RO2_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRL, field AC1[26:24] (RW)
 *
 * Defines the attributes required to access the corresponding slave
 * peripheral's memory space. See #pacr_attributes , "Attribute check (AC) values" for
 * details.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRL_AC1 field. */
#define AIPS_RD_PACRL_AC1(base) ((AIPS_PACRL_REG(base) & AIPS_PACRL_AC1_MASK) >> AIPS_PACRL_AC1_SHIFT)
#define AIPS_BRD_PACRL_AC1(base) (BME_UBFX32(&AIPS_PACRL_REG(base), AIPS_PACRL_AC1_SHIFT, AIPS_PACRL_AC1_WIDTH))

/*! @brief Set the AC1 field to a new value. */
#define AIPS_WR_PACRL_AC1(base, value) (AIPS_RMW_PACRL(base, AIPS_PACRL_AC1_MASK, AIPS_PACRL_AC1(value)))
#define AIPS_BWR_PACRL_AC1(base, value) (BME_BFI32(&AIPS_PACRL_REG(base), ((uint32_t)(value) << AIPS_PACRL_AC1_SHIFT), AIPS_PACRL_AC1_SHIFT, AIPS_PACRL_AC1_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRL, field RO1[27] (RW)
 *
 * Indicates the lock status of this register's AC1 field. After this field is
 * set to 1, it cannot be changed and attempted writes to AC1 are ignored until
 * the next system reset clears this field.
 *
 * Values:
 * - 0b0 - Writes to corresponding AC field are allowed.
 * - 0b1 - Writes to corresponding AC field are ignored.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRL_RO1 field. */
#define AIPS_RD_PACRL_RO1(base) ((AIPS_PACRL_REG(base) & AIPS_PACRL_RO1_MASK) >> AIPS_PACRL_RO1_SHIFT)
#define AIPS_BRD_PACRL_RO1(base) (BME_UBFX32(&AIPS_PACRL_REG(base), AIPS_PACRL_RO1_SHIFT, AIPS_PACRL_RO1_WIDTH))

/*! @brief Set the RO1 field to a new value. */
#define AIPS_WR_PACRL_RO1(base, value) (AIPS_RMW_PACRL(base, AIPS_PACRL_RO1_MASK, AIPS_PACRL_RO1(value)))
#define AIPS_BWR_PACRL_RO1(base, value) (BME_BFI32(&AIPS_PACRL_REG(base), ((uint32_t)(value) << AIPS_PACRL_RO1_SHIFT), AIPS_PACRL_RO1_SHIFT, AIPS_PACRL_RO1_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRL, field AC0[30:28] (RW)
 *
 * Defines the attributes required to access the corresponding slave
 * peripheral's memory space. See #pacr_attributes , "Attribute check (AC) values" for
 * details.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRL_AC0 field. */
#define AIPS_RD_PACRL_AC0(base) ((AIPS_PACRL_REG(base) & AIPS_PACRL_AC0_MASK) >> AIPS_PACRL_AC0_SHIFT)
#define AIPS_BRD_PACRL_AC0(base) (BME_UBFX32(&AIPS_PACRL_REG(base), AIPS_PACRL_AC0_SHIFT, AIPS_PACRL_AC0_WIDTH))

/*! @brief Set the AC0 field to a new value. */
#define AIPS_WR_PACRL_AC0(base, value) (AIPS_RMW_PACRL(base, AIPS_PACRL_AC0_MASK, AIPS_PACRL_AC0(value)))
#define AIPS_BWR_PACRL_AC0(base, value) (BME_BFI32(&AIPS_PACRL_REG(base), ((uint32_t)(value) << AIPS_PACRL_AC0_SHIFT), AIPS_PACRL_AC0_SHIFT, AIPS_PACRL_AC0_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRL, field RO0[31] (RW)
 *
 * Indicates the lock status of this register's AC0 field. After this field is
 * set to 1, it cannot be changed and attempted writes to AC0 are ignored until
 * the next system reset clears this field.
 *
 * Values:
 * - 0b0 - Writes to corresponding AC field are allowed.
 * - 0b1 - Writes to corresponding AC field are ignored.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRL_RO0 field. */
#define AIPS_RD_PACRL_RO0(base) ((AIPS_PACRL_REG(base) & AIPS_PACRL_RO0_MASK) >> AIPS_PACRL_RO0_SHIFT)
#define AIPS_BRD_PACRL_RO0(base) (BME_UBFX32(&AIPS_PACRL_REG(base), AIPS_PACRL_RO0_SHIFT, AIPS_PACRL_RO0_WIDTH))

/*! @brief Set the RO0 field to a new value. */
#define AIPS_WR_PACRL_RO0(base, value) (AIPS_RMW_PACRL(base, AIPS_PACRL_RO0_MASK, AIPS_PACRL_RO0(value)))
#define AIPS_BWR_PACRL_RO0(base, value) (BME_BFI32(&AIPS_PACRL_REG(base), ((uint32_t)(value) << AIPS_PACRL_RO0_SHIFT), AIPS_PACRL_RO0_SHIFT, AIPS_PACRL_RO0_WIDTH))
/*@}*/

/*******************************************************************************
 * AIPS_PACRM - Peripheral Access Control Register
 ******************************************************************************/

/*!
 * @brief AIPS_PACRM - Peripheral Access Control Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * Each peripheral on this chip has a 4-bit PACR field which includes a
 * read-only "lock" bit plus a 3-bit attribute check field which defines the access
 * rights (privileged/user, secure/nonsecure) needed to reference the slave
 * peripheral's address space. Access to these registers is allowed using only 32-bit
 * privileged, secure reads and writes. Each 32-bit register controls eight
 * peripherals. PACRE-PACR P control access to the 96 off-platform peripherals. A
 * peripheral's assignment to a PACR field is defined by the memory map slot to which the
 * peripheral is assigned. See this device's peripheral bridge memory map
 * information for the assignment of a particular peripheral. The following table shows
 * the top-level structure of PACRs. Offset Register [31:28] [27:24] [23:20]
 * [19:16] [15:12] [11:8] [7:4] [3:0] 0x40 PACRE PACR32 PACR33 PACR34 PACR35 PACR36
 * PACR37 PACR38 PACR39 0x44 PACRF PACR40 PACR41 PACR42 PACR43 PACR44 PACR45
 * PACR46 PACR47 0x48 PACRG PACR48 PACR49 PACR50 PACR51 PACR52 PACR53 PACR54 PACR55
 * 0x4C PACRH PACR56 PACR57 PACR58 PACR59 PACR60 PACR61 PACR62 PACR63 0x50 PACRI
 * PACR64 PACR65 PACR66 PACR67 PACR68 PACR69 PACR70 PACR71 0x54 PACRJ PACR72 PACR73
 * PACR74 PACR75 PACR76 PACR77 PACR78 PACR79 0x58 PACRK PACR80 PACR81 PACR82
 * PACR83 PACR84 PACR85 PACR86 PACR87 0x5C PACRL PACR88 PACR89 PACR90 PACR91 PACR92
 * PACR93 PACR94 PACR95 0x60 PACRM PACR96 PACR97 PACR98 PACR99 PACR100 PACR101
 * PACR102 PACR103 0x64 PACRN PACR104 PACR105 PACR106 PACR107 PACR108 PACR109
 * PACR110 PACR111 0x68 PACRO PACR112 PACR113 PACR114 PACR115 PACR116 PACR117 PACR118
 * PACR119 0x6C PACRP PACR120 PACR121 PACR122 PACR123 PACR124 PACR125 PACR126
 * PACR127
 */
/*!
 * @name Constants and macros for entire AIPS_PACRM register
 */
/*@{*/
#define AIPS_RD_PACRM(base)      (AIPS_PACRM_REG(base))
#define AIPS_WR_PACRM(base, value) (AIPS_PACRM_REG(base) = (value))
#define AIPS_RMW_PACRM(base, mask, value) (AIPS_WR_PACRM(base, (AIPS_RD_PACRM(base) & ~(mask)) | (value)))
#define AIPS_SET_PACRM(base, value) (BME_OR32(&AIPS_PACRM_REG(base), (uint32_t)(value)))
#define AIPS_CLR_PACRM(base, value) (BME_AND32(&AIPS_PACRM_REG(base), (uint32_t)(~(value))))
#define AIPS_TOG_PACRM(base, value) (BME_XOR32(&AIPS_PACRM_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual AIPS_PACRM bitfields
 */

/*!
 * @name Register AIPS_PACRM, field AC7[2:0] (RW)
 *
 * Defines the attributes required to access the corresponding slave
 * peripheral's memory space. See #pacr_attributes , "Attribute check (AC) values" for
 * details.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRM_AC7 field. */
#define AIPS_RD_PACRM_AC7(base) ((AIPS_PACRM_REG(base) & AIPS_PACRM_AC7_MASK) >> AIPS_PACRM_AC7_SHIFT)
#define AIPS_BRD_PACRM_AC7(base) (BME_UBFX32(&AIPS_PACRM_REG(base), AIPS_PACRM_AC7_SHIFT, AIPS_PACRM_AC7_WIDTH))

/*! @brief Set the AC7 field to a new value. */
#define AIPS_WR_PACRM_AC7(base, value) (AIPS_RMW_PACRM(base, AIPS_PACRM_AC7_MASK, AIPS_PACRM_AC7(value)))
#define AIPS_BWR_PACRM_AC7(base, value) (BME_BFI32(&AIPS_PACRM_REG(base), ((uint32_t)(value) << AIPS_PACRM_AC7_SHIFT), AIPS_PACRM_AC7_SHIFT, AIPS_PACRM_AC7_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRM, field RO7[3] (RW)
 *
 * Indicates the lock status of this register's AC7 field. After this field is
 * set to 1, it cannot be changed and attempted writes to AC7 are ignored until
 * the next system reset clears this field.
 *
 * Values:
 * - 0b0 - Writes to corresponding AC field are allowed.
 * - 0b1 - Writes to corresponding AC field are ignored.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRM_RO7 field. */
#define AIPS_RD_PACRM_RO7(base) ((AIPS_PACRM_REG(base) & AIPS_PACRM_RO7_MASK) >> AIPS_PACRM_RO7_SHIFT)
#define AIPS_BRD_PACRM_RO7(base) (BME_UBFX32(&AIPS_PACRM_REG(base), AIPS_PACRM_RO7_SHIFT, AIPS_PACRM_RO7_WIDTH))

/*! @brief Set the RO7 field to a new value. */
#define AIPS_WR_PACRM_RO7(base, value) (AIPS_RMW_PACRM(base, AIPS_PACRM_RO7_MASK, AIPS_PACRM_RO7(value)))
#define AIPS_BWR_PACRM_RO7(base, value) (BME_BFI32(&AIPS_PACRM_REG(base), ((uint32_t)(value) << AIPS_PACRM_RO7_SHIFT), AIPS_PACRM_RO7_SHIFT, AIPS_PACRM_RO7_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRM, field AC6[6:4] (RW)
 *
 * Defines the attributes required to access the corresponding slave
 * peripheral's memory space. See #pacr_attributes , "Attribute check (AC) values" for
 * details.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRM_AC6 field. */
#define AIPS_RD_PACRM_AC6(base) ((AIPS_PACRM_REG(base) & AIPS_PACRM_AC6_MASK) >> AIPS_PACRM_AC6_SHIFT)
#define AIPS_BRD_PACRM_AC6(base) (BME_UBFX32(&AIPS_PACRM_REG(base), AIPS_PACRM_AC6_SHIFT, AIPS_PACRM_AC6_WIDTH))

/*! @brief Set the AC6 field to a new value. */
#define AIPS_WR_PACRM_AC6(base, value) (AIPS_RMW_PACRM(base, AIPS_PACRM_AC6_MASK, AIPS_PACRM_AC6(value)))
#define AIPS_BWR_PACRM_AC6(base, value) (BME_BFI32(&AIPS_PACRM_REG(base), ((uint32_t)(value) << AIPS_PACRM_AC6_SHIFT), AIPS_PACRM_AC6_SHIFT, AIPS_PACRM_AC6_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRM, field RO6[7] (RW)
 *
 * Indicates the lock status of this register's AC6 field. After this field is
 * set to 1, it cannot be changed and attempted writes to AC6 are ignored until
 * the next system reset clears this field.
 *
 * Values:
 * - 0b0 - Writes to corresponding AC field are allowed.
 * - 0b1 - Writes to corresponding AC field are ignored.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRM_RO6 field. */
#define AIPS_RD_PACRM_RO6(base) ((AIPS_PACRM_REG(base) & AIPS_PACRM_RO6_MASK) >> AIPS_PACRM_RO6_SHIFT)
#define AIPS_BRD_PACRM_RO6(base) (BME_UBFX32(&AIPS_PACRM_REG(base), AIPS_PACRM_RO6_SHIFT, AIPS_PACRM_RO6_WIDTH))

/*! @brief Set the RO6 field to a new value. */
#define AIPS_WR_PACRM_RO6(base, value) (AIPS_RMW_PACRM(base, AIPS_PACRM_RO6_MASK, AIPS_PACRM_RO6(value)))
#define AIPS_BWR_PACRM_RO6(base, value) (BME_BFI32(&AIPS_PACRM_REG(base), ((uint32_t)(value) << AIPS_PACRM_RO6_SHIFT), AIPS_PACRM_RO6_SHIFT, AIPS_PACRM_RO6_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRM, field AC5[10:8] (RW)
 *
 * Defines the attributes required to access the corresponding slave
 * peripheral's memory space. See #pacr_attributes , "Attribute check (AC) values" for
 * details.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRM_AC5 field. */
#define AIPS_RD_PACRM_AC5(base) ((AIPS_PACRM_REG(base) & AIPS_PACRM_AC5_MASK) >> AIPS_PACRM_AC5_SHIFT)
#define AIPS_BRD_PACRM_AC5(base) (BME_UBFX32(&AIPS_PACRM_REG(base), AIPS_PACRM_AC5_SHIFT, AIPS_PACRM_AC5_WIDTH))

/*! @brief Set the AC5 field to a new value. */
#define AIPS_WR_PACRM_AC5(base, value) (AIPS_RMW_PACRM(base, AIPS_PACRM_AC5_MASK, AIPS_PACRM_AC5(value)))
#define AIPS_BWR_PACRM_AC5(base, value) (BME_BFI32(&AIPS_PACRM_REG(base), ((uint32_t)(value) << AIPS_PACRM_AC5_SHIFT), AIPS_PACRM_AC5_SHIFT, AIPS_PACRM_AC5_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRM, field RO5[11] (RW)
 *
 * Indicates the lock status of this register's AC5 field. After this field is
 * set to 1, it cannot be changed and attempted writes to AC5 are ignored until
 * the next system reset clears this field.
 *
 * Values:
 * - 0b0 - Writes to corresponding AC field are allowed.
 * - 0b1 - Writes to corresponding AC field are ignored.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRM_RO5 field. */
#define AIPS_RD_PACRM_RO5(base) ((AIPS_PACRM_REG(base) & AIPS_PACRM_RO5_MASK) >> AIPS_PACRM_RO5_SHIFT)
#define AIPS_BRD_PACRM_RO5(base) (BME_UBFX32(&AIPS_PACRM_REG(base), AIPS_PACRM_RO5_SHIFT, AIPS_PACRM_RO5_WIDTH))

/*! @brief Set the RO5 field to a new value. */
#define AIPS_WR_PACRM_RO5(base, value) (AIPS_RMW_PACRM(base, AIPS_PACRM_RO5_MASK, AIPS_PACRM_RO5(value)))
#define AIPS_BWR_PACRM_RO5(base, value) (BME_BFI32(&AIPS_PACRM_REG(base), ((uint32_t)(value) << AIPS_PACRM_RO5_SHIFT), AIPS_PACRM_RO5_SHIFT, AIPS_PACRM_RO5_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRM, field AC4[14:12] (RW)
 *
 * Defines the attributes required to access the corresponding slave
 * peripheral's memory space. See #pacr_attributes , "Attribute check (AC) values" for
 * details.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRM_AC4 field. */
#define AIPS_RD_PACRM_AC4(base) ((AIPS_PACRM_REG(base) & AIPS_PACRM_AC4_MASK) >> AIPS_PACRM_AC4_SHIFT)
#define AIPS_BRD_PACRM_AC4(base) (BME_UBFX32(&AIPS_PACRM_REG(base), AIPS_PACRM_AC4_SHIFT, AIPS_PACRM_AC4_WIDTH))

/*! @brief Set the AC4 field to a new value. */
#define AIPS_WR_PACRM_AC4(base, value) (AIPS_RMW_PACRM(base, AIPS_PACRM_AC4_MASK, AIPS_PACRM_AC4(value)))
#define AIPS_BWR_PACRM_AC4(base, value) (BME_BFI32(&AIPS_PACRM_REG(base), ((uint32_t)(value) << AIPS_PACRM_AC4_SHIFT), AIPS_PACRM_AC4_SHIFT, AIPS_PACRM_AC4_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRM, field RO4[15] (RW)
 *
 * Indicates the lock status of this register's AC4 field. After this field is
 * set to 1, it cannot be changed and attempted writes to AC4 are ignored until
 * the next system reset clears this field.
 *
 * Values:
 * - 0b0 - Writes to corresponding AC field are allowed.
 * - 0b1 - Writes to corresponding AC field are ignored.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRM_RO4 field. */
#define AIPS_RD_PACRM_RO4(base) ((AIPS_PACRM_REG(base) & AIPS_PACRM_RO4_MASK) >> AIPS_PACRM_RO4_SHIFT)
#define AIPS_BRD_PACRM_RO4(base) (BME_UBFX32(&AIPS_PACRM_REG(base), AIPS_PACRM_RO4_SHIFT, AIPS_PACRM_RO4_WIDTH))

/*! @brief Set the RO4 field to a new value. */
#define AIPS_WR_PACRM_RO4(base, value) (AIPS_RMW_PACRM(base, AIPS_PACRM_RO4_MASK, AIPS_PACRM_RO4(value)))
#define AIPS_BWR_PACRM_RO4(base, value) (BME_BFI32(&AIPS_PACRM_REG(base), ((uint32_t)(value) << AIPS_PACRM_RO4_SHIFT), AIPS_PACRM_RO4_SHIFT, AIPS_PACRM_RO4_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRM, field AC3[18:16] (RW)
 *
 * Defines the attributes required to access the corresponding slave
 * peripheral's memory space. See #pacr_attributes , "Attribute check (AC) values" for
 * details.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRM_AC3 field. */
#define AIPS_RD_PACRM_AC3(base) ((AIPS_PACRM_REG(base) & AIPS_PACRM_AC3_MASK) >> AIPS_PACRM_AC3_SHIFT)
#define AIPS_BRD_PACRM_AC3(base) (BME_UBFX32(&AIPS_PACRM_REG(base), AIPS_PACRM_AC3_SHIFT, AIPS_PACRM_AC3_WIDTH))

/*! @brief Set the AC3 field to a new value. */
#define AIPS_WR_PACRM_AC3(base, value) (AIPS_RMW_PACRM(base, AIPS_PACRM_AC3_MASK, AIPS_PACRM_AC3(value)))
#define AIPS_BWR_PACRM_AC3(base, value) (BME_BFI32(&AIPS_PACRM_REG(base), ((uint32_t)(value) << AIPS_PACRM_AC3_SHIFT), AIPS_PACRM_AC3_SHIFT, AIPS_PACRM_AC3_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRM, field RO3[19] (RW)
 *
 * Indicates the lock status of this register's AC3 field. After this field is
 * set to 1, it cannot be changed and attempted writes to AC3 are ignored until
 * the next system reset clears this field.
 *
 * Values:
 * - 0b0 - Writes to corresponding AC field are allowed.
 * - 0b1 - Writes to corresponding AC field are ignored.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRM_RO3 field. */
#define AIPS_RD_PACRM_RO3(base) ((AIPS_PACRM_REG(base) & AIPS_PACRM_RO3_MASK) >> AIPS_PACRM_RO3_SHIFT)
#define AIPS_BRD_PACRM_RO3(base) (BME_UBFX32(&AIPS_PACRM_REG(base), AIPS_PACRM_RO3_SHIFT, AIPS_PACRM_RO3_WIDTH))

/*! @brief Set the RO3 field to a new value. */
#define AIPS_WR_PACRM_RO3(base, value) (AIPS_RMW_PACRM(base, AIPS_PACRM_RO3_MASK, AIPS_PACRM_RO3(value)))
#define AIPS_BWR_PACRM_RO3(base, value) (BME_BFI32(&AIPS_PACRM_REG(base), ((uint32_t)(value) << AIPS_PACRM_RO3_SHIFT), AIPS_PACRM_RO3_SHIFT, AIPS_PACRM_RO3_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRM, field AC2[22:20] (RW)
 *
 * Defines the attributes required to access the corresponding slave
 * peripheral's memory space. See #pacr_attributes , "Attribute check (AC) values" for
 * details.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRM_AC2 field. */
#define AIPS_RD_PACRM_AC2(base) ((AIPS_PACRM_REG(base) & AIPS_PACRM_AC2_MASK) >> AIPS_PACRM_AC2_SHIFT)
#define AIPS_BRD_PACRM_AC2(base) (BME_UBFX32(&AIPS_PACRM_REG(base), AIPS_PACRM_AC2_SHIFT, AIPS_PACRM_AC2_WIDTH))

/*! @brief Set the AC2 field to a new value. */
#define AIPS_WR_PACRM_AC2(base, value) (AIPS_RMW_PACRM(base, AIPS_PACRM_AC2_MASK, AIPS_PACRM_AC2(value)))
#define AIPS_BWR_PACRM_AC2(base, value) (BME_BFI32(&AIPS_PACRM_REG(base), ((uint32_t)(value) << AIPS_PACRM_AC2_SHIFT), AIPS_PACRM_AC2_SHIFT, AIPS_PACRM_AC2_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRM, field RO2[23] (RW)
 *
 * Indicates the lock status of this register's AC2 field. After this field is
 * set to 1, it cannot be changed and attempted writes to AC2 are ignored until
 * the next system reset clears this field.
 *
 * Values:
 * - 0b0 - Writes to corresponding AC field are allowed.
 * - 0b1 - Writes to corresponding AC field are ignored.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRM_RO2 field. */
#define AIPS_RD_PACRM_RO2(base) ((AIPS_PACRM_REG(base) & AIPS_PACRM_RO2_MASK) >> AIPS_PACRM_RO2_SHIFT)
#define AIPS_BRD_PACRM_RO2(base) (BME_UBFX32(&AIPS_PACRM_REG(base), AIPS_PACRM_RO2_SHIFT, AIPS_PACRM_RO2_WIDTH))

/*! @brief Set the RO2 field to a new value. */
#define AIPS_WR_PACRM_RO2(base, value) (AIPS_RMW_PACRM(base, AIPS_PACRM_RO2_MASK, AIPS_PACRM_RO2(value)))
#define AIPS_BWR_PACRM_RO2(base, value) (BME_BFI32(&AIPS_PACRM_REG(base), ((uint32_t)(value) << AIPS_PACRM_RO2_SHIFT), AIPS_PACRM_RO2_SHIFT, AIPS_PACRM_RO2_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRM, field AC1[26:24] (RW)
 *
 * Defines the attributes required to access the corresponding slave
 * peripheral's memory space. See #pacr_attributes , "Attribute check (AC) values" for
 * details.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRM_AC1 field. */
#define AIPS_RD_PACRM_AC1(base) ((AIPS_PACRM_REG(base) & AIPS_PACRM_AC1_MASK) >> AIPS_PACRM_AC1_SHIFT)
#define AIPS_BRD_PACRM_AC1(base) (BME_UBFX32(&AIPS_PACRM_REG(base), AIPS_PACRM_AC1_SHIFT, AIPS_PACRM_AC1_WIDTH))

/*! @brief Set the AC1 field to a new value. */
#define AIPS_WR_PACRM_AC1(base, value) (AIPS_RMW_PACRM(base, AIPS_PACRM_AC1_MASK, AIPS_PACRM_AC1(value)))
#define AIPS_BWR_PACRM_AC1(base, value) (BME_BFI32(&AIPS_PACRM_REG(base), ((uint32_t)(value) << AIPS_PACRM_AC1_SHIFT), AIPS_PACRM_AC1_SHIFT, AIPS_PACRM_AC1_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRM, field RO1[27] (RW)
 *
 * Indicates the lock status of this register's AC1 field. After this field is
 * set to 1, it cannot be changed and attempted writes to AC1 are ignored until
 * the next system reset clears this field.
 *
 * Values:
 * - 0b0 - Writes to corresponding AC field are allowed.
 * - 0b1 - Writes to corresponding AC field are ignored.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRM_RO1 field. */
#define AIPS_RD_PACRM_RO1(base) ((AIPS_PACRM_REG(base) & AIPS_PACRM_RO1_MASK) >> AIPS_PACRM_RO1_SHIFT)
#define AIPS_BRD_PACRM_RO1(base) (BME_UBFX32(&AIPS_PACRM_REG(base), AIPS_PACRM_RO1_SHIFT, AIPS_PACRM_RO1_WIDTH))

/*! @brief Set the RO1 field to a new value. */
#define AIPS_WR_PACRM_RO1(base, value) (AIPS_RMW_PACRM(base, AIPS_PACRM_RO1_MASK, AIPS_PACRM_RO1(value)))
#define AIPS_BWR_PACRM_RO1(base, value) (BME_BFI32(&AIPS_PACRM_REG(base), ((uint32_t)(value) << AIPS_PACRM_RO1_SHIFT), AIPS_PACRM_RO1_SHIFT, AIPS_PACRM_RO1_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRM, field AC0[30:28] (RW)
 *
 * Defines the attributes required to access the corresponding slave
 * peripheral's memory space. See #pacr_attributes , "Attribute check (AC) values" for
 * details.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRM_AC0 field. */
#define AIPS_RD_PACRM_AC0(base) ((AIPS_PACRM_REG(base) & AIPS_PACRM_AC0_MASK) >> AIPS_PACRM_AC0_SHIFT)
#define AIPS_BRD_PACRM_AC0(base) (BME_UBFX32(&AIPS_PACRM_REG(base), AIPS_PACRM_AC0_SHIFT, AIPS_PACRM_AC0_WIDTH))

/*! @brief Set the AC0 field to a new value. */
#define AIPS_WR_PACRM_AC0(base, value) (AIPS_RMW_PACRM(base, AIPS_PACRM_AC0_MASK, AIPS_PACRM_AC0(value)))
#define AIPS_BWR_PACRM_AC0(base, value) (BME_BFI32(&AIPS_PACRM_REG(base), ((uint32_t)(value) << AIPS_PACRM_AC0_SHIFT), AIPS_PACRM_AC0_SHIFT, AIPS_PACRM_AC0_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRM, field RO0[31] (RW)
 *
 * Indicates the lock status of this register's AC0 field. After this field is
 * set to 1, it cannot be changed and attempted writes to AC0 are ignored until
 * the next system reset clears this field.
 *
 * Values:
 * - 0b0 - Writes to corresponding AC field are allowed.
 * - 0b1 - Writes to corresponding AC field are ignored.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRM_RO0 field. */
#define AIPS_RD_PACRM_RO0(base) ((AIPS_PACRM_REG(base) & AIPS_PACRM_RO0_MASK) >> AIPS_PACRM_RO0_SHIFT)
#define AIPS_BRD_PACRM_RO0(base) (BME_UBFX32(&AIPS_PACRM_REG(base), AIPS_PACRM_RO0_SHIFT, AIPS_PACRM_RO0_WIDTH))

/*! @brief Set the RO0 field to a new value. */
#define AIPS_WR_PACRM_RO0(base, value) (AIPS_RMW_PACRM(base, AIPS_PACRM_RO0_MASK, AIPS_PACRM_RO0(value)))
#define AIPS_BWR_PACRM_RO0(base, value) (BME_BFI32(&AIPS_PACRM_REG(base), ((uint32_t)(value) << AIPS_PACRM_RO0_SHIFT), AIPS_PACRM_RO0_SHIFT, AIPS_PACRM_RO0_WIDTH))
/*@}*/

/*******************************************************************************
 * AIPS_PACRN - Peripheral Access Control Register
 ******************************************************************************/

/*!
 * @brief AIPS_PACRN - Peripheral Access Control Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * Each peripheral on this chip has a 4-bit PACR field which includes a
 * read-only "lock" bit plus a 3-bit attribute check field which defines the access
 * rights (privileged/user, secure/nonsecure) needed to reference the slave
 * peripheral's address space. Access to these registers is allowed using only 32-bit
 * privileged, secure reads and writes. Each 32-bit register controls eight
 * peripherals. PACRE-PACR P control access to the 96 off-platform peripherals. A
 * peripheral's assignment to a PACR field is defined by the memory map slot to which the
 * peripheral is assigned. See this device's peripheral bridge memory map
 * information for the assignment of a particular peripheral. The following table shows
 * the top-level structure of PACRs. Offset Register [31:28] [27:24] [23:20]
 * [19:16] [15:12] [11:8] [7:4] [3:0] 0x40 PACRE PACR32 PACR33 PACR34 PACR35 PACR36
 * PACR37 PACR38 PACR39 0x44 PACRF PACR40 PACR41 PACR42 PACR43 PACR44 PACR45
 * PACR46 PACR47 0x48 PACRG PACR48 PACR49 PACR50 PACR51 PACR52 PACR53 PACR54 PACR55
 * 0x4C PACRH PACR56 PACR57 PACR58 PACR59 PACR60 PACR61 PACR62 PACR63 0x50 PACRI
 * PACR64 PACR65 PACR66 PACR67 PACR68 PACR69 PACR70 PACR71 0x54 PACRJ PACR72 PACR73
 * PACR74 PACR75 PACR76 PACR77 PACR78 PACR79 0x58 PACRK PACR80 PACR81 PACR82
 * PACR83 PACR84 PACR85 PACR86 PACR87 0x5C PACRL PACR88 PACR89 PACR90 PACR91 PACR92
 * PACR93 PACR94 PACR95 0x60 PACRM PACR96 PACR97 PACR98 PACR99 PACR100 PACR101
 * PACR102 PACR103 0x64 PACRN PACR104 PACR105 PACR106 PACR107 PACR108 PACR109
 * PACR110 PACR111 0x68 PACRO PACR112 PACR113 PACR114 PACR115 PACR116 PACR117 PACR118
 * PACR119 0x6C PACRP PACR120 PACR121 PACR122 PACR123 PACR124 PACR125 PACR126
 * PACR127
 */
/*!
 * @name Constants and macros for entire AIPS_PACRN register
 */
/*@{*/
#define AIPS_RD_PACRN(base)      (AIPS_PACRN_REG(base))
#define AIPS_WR_PACRN(base, value) (AIPS_PACRN_REG(base) = (value))
#define AIPS_RMW_PACRN(base, mask, value) (AIPS_WR_PACRN(base, (AIPS_RD_PACRN(base) & ~(mask)) | (value)))
#define AIPS_SET_PACRN(base, value) (BME_OR32(&AIPS_PACRN_REG(base), (uint32_t)(value)))
#define AIPS_CLR_PACRN(base, value) (BME_AND32(&AIPS_PACRN_REG(base), (uint32_t)(~(value))))
#define AIPS_TOG_PACRN(base, value) (BME_XOR32(&AIPS_PACRN_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual AIPS_PACRN bitfields
 */

/*!
 * @name Register AIPS_PACRN, field AC7[2:0] (RW)
 *
 * Defines the attributes required to access the corresponding slave
 * peripheral's memory space. See #pacr_attributes , "Attribute check (AC) values" for
 * details.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRN_AC7 field. */
#define AIPS_RD_PACRN_AC7(base) ((AIPS_PACRN_REG(base) & AIPS_PACRN_AC7_MASK) >> AIPS_PACRN_AC7_SHIFT)
#define AIPS_BRD_PACRN_AC7(base) (BME_UBFX32(&AIPS_PACRN_REG(base), AIPS_PACRN_AC7_SHIFT, AIPS_PACRN_AC7_WIDTH))

/*! @brief Set the AC7 field to a new value. */
#define AIPS_WR_PACRN_AC7(base, value) (AIPS_RMW_PACRN(base, AIPS_PACRN_AC7_MASK, AIPS_PACRN_AC7(value)))
#define AIPS_BWR_PACRN_AC7(base, value) (BME_BFI32(&AIPS_PACRN_REG(base), ((uint32_t)(value) << AIPS_PACRN_AC7_SHIFT), AIPS_PACRN_AC7_SHIFT, AIPS_PACRN_AC7_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRN, field RO7[3] (RW)
 *
 * Indicates the lock status of this register's AC7 field. After this field is
 * set to 1, it cannot be changed and attempted writes to AC7 are ignored until
 * the next system reset clears this field.
 *
 * Values:
 * - 0b0 - Writes to corresponding AC field are allowed.
 * - 0b1 - Writes to corresponding AC field are ignored.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRN_RO7 field. */
#define AIPS_RD_PACRN_RO7(base) ((AIPS_PACRN_REG(base) & AIPS_PACRN_RO7_MASK) >> AIPS_PACRN_RO7_SHIFT)
#define AIPS_BRD_PACRN_RO7(base) (BME_UBFX32(&AIPS_PACRN_REG(base), AIPS_PACRN_RO7_SHIFT, AIPS_PACRN_RO7_WIDTH))

/*! @brief Set the RO7 field to a new value. */
#define AIPS_WR_PACRN_RO7(base, value) (AIPS_RMW_PACRN(base, AIPS_PACRN_RO7_MASK, AIPS_PACRN_RO7(value)))
#define AIPS_BWR_PACRN_RO7(base, value) (BME_BFI32(&AIPS_PACRN_REG(base), ((uint32_t)(value) << AIPS_PACRN_RO7_SHIFT), AIPS_PACRN_RO7_SHIFT, AIPS_PACRN_RO7_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRN, field AC6[6:4] (RW)
 *
 * Defines the attributes required to access the corresponding slave
 * peripheral's memory space. See #pacr_attributes , "Attribute check (AC) values" for
 * details.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRN_AC6 field. */
#define AIPS_RD_PACRN_AC6(base) ((AIPS_PACRN_REG(base) & AIPS_PACRN_AC6_MASK) >> AIPS_PACRN_AC6_SHIFT)
#define AIPS_BRD_PACRN_AC6(base) (BME_UBFX32(&AIPS_PACRN_REG(base), AIPS_PACRN_AC6_SHIFT, AIPS_PACRN_AC6_WIDTH))

/*! @brief Set the AC6 field to a new value. */
#define AIPS_WR_PACRN_AC6(base, value) (AIPS_RMW_PACRN(base, AIPS_PACRN_AC6_MASK, AIPS_PACRN_AC6(value)))
#define AIPS_BWR_PACRN_AC6(base, value) (BME_BFI32(&AIPS_PACRN_REG(base), ((uint32_t)(value) << AIPS_PACRN_AC6_SHIFT), AIPS_PACRN_AC6_SHIFT, AIPS_PACRN_AC6_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRN, field RO6[7] (RW)
 *
 * Indicates the lock status of this register's AC6 field. After this field is
 * set to 1, it cannot be changed and attempted writes to AC6 are ignored until
 * the next system reset clears this field.
 *
 * Values:
 * - 0b0 - Writes to corresponding AC field are allowed.
 * - 0b1 - Writes to corresponding AC field are ignored.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRN_RO6 field. */
#define AIPS_RD_PACRN_RO6(base) ((AIPS_PACRN_REG(base) & AIPS_PACRN_RO6_MASK) >> AIPS_PACRN_RO6_SHIFT)
#define AIPS_BRD_PACRN_RO6(base) (BME_UBFX32(&AIPS_PACRN_REG(base), AIPS_PACRN_RO6_SHIFT, AIPS_PACRN_RO6_WIDTH))

/*! @brief Set the RO6 field to a new value. */
#define AIPS_WR_PACRN_RO6(base, value) (AIPS_RMW_PACRN(base, AIPS_PACRN_RO6_MASK, AIPS_PACRN_RO6(value)))
#define AIPS_BWR_PACRN_RO6(base, value) (BME_BFI32(&AIPS_PACRN_REG(base), ((uint32_t)(value) << AIPS_PACRN_RO6_SHIFT), AIPS_PACRN_RO6_SHIFT, AIPS_PACRN_RO6_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRN, field AC5[10:8] (RW)
 *
 * Defines the attributes required to access the corresponding slave
 * peripheral's memory space. See #pacr_attributes , "Attribute check (AC) values" for
 * details.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRN_AC5 field. */
#define AIPS_RD_PACRN_AC5(base) ((AIPS_PACRN_REG(base) & AIPS_PACRN_AC5_MASK) >> AIPS_PACRN_AC5_SHIFT)
#define AIPS_BRD_PACRN_AC5(base) (BME_UBFX32(&AIPS_PACRN_REG(base), AIPS_PACRN_AC5_SHIFT, AIPS_PACRN_AC5_WIDTH))

/*! @brief Set the AC5 field to a new value. */
#define AIPS_WR_PACRN_AC5(base, value) (AIPS_RMW_PACRN(base, AIPS_PACRN_AC5_MASK, AIPS_PACRN_AC5(value)))
#define AIPS_BWR_PACRN_AC5(base, value) (BME_BFI32(&AIPS_PACRN_REG(base), ((uint32_t)(value) << AIPS_PACRN_AC5_SHIFT), AIPS_PACRN_AC5_SHIFT, AIPS_PACRN_AC5_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRN, field RO5[11] (RW)
 *
 * Indicates the lock status of this register's AC5 field. After this field is
 * set to 1, it cannot be changed and attempted writes to AC5 are ignored until
 * the next system reset clears this field.
 *
 * Values:
 * - 0b0 - Writes to corresponding AC field are allowed.
 * - 0b1 - Writes to corresponding AC field are ignored.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRN_RO5 field. */
#define AIPS_RD_PACRN_RO5(base) ((AIPS_PACRN_REG(base) & AIPS_PACRN_RO5_MASK) >> AIPS_PACRN_RO5_SHIFT)
#define AIPS_BRD_PACRN_RO5(base) (BME_UBFX32(&AIPS_PACRN_REG(base), AIPS_PACRN_RO5_SHIFT, AIPS_PACRN_RO5_WIDTH))

/*! @brief Set the RO5 field to a new value. */
#define AIPS_WR_PACRN_RO5(base, value) (AIPS_RMW_PACRN(base, AIPS_PACRN_RO5_MASK, AIPS_PACRN_RO5(value)))
#define AIPS_BWR_PACRN_RO5(base, value) (BME_BFI32(&AIPS_PACRN_REG(base), ((uint32_t)(value) << AIPS_PACRN_RO5_SHIFT), AIPS_PACRN_RO5_SHIFT, AIPS_PACRN_RO5_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRN, field AC4[14:12] (RW)
 *
 * Defines the attributes required to access the corresponding slave
 * peripheral's memory space. See #pacr_attributes , "Attribute check (AC) values" for
 * details.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRN_AC4 field. */
#define AIPS_RD_PACRN_AC4(base) ((AIPS_PACRN_REG(base) & AIPS_PACRN_AC4_MASK) >> AIPS_PACRN_AC4_SHIFT)
#define AIPS_BRD_PACRN_AC4(base) (BME_UBFX32(&AIPS_PACRN_REG(base), AIPS_PACRN_AC4_SHIFT, AIPS_PACRN_AC4_WIDTH))

/*! @brief Set the AC4 field to a new value. */
#define AIPS_WR_PACRN_AC4(base, value) (AIPS_RMW_PACRN(base, AIPS_PACRN_AC4_MASK, AIPS_PACRN_AC4(value)))
#define AIPS_BWR_PACRN_AC4(base, value) (BME_BFI32(&AIPS_PACRN_REG(base), ((uint32_t)(value) << AIPS_PACRN_AC4_SHIFT), AIPS_PACRN_AC4_SHIFT, AIPS_PACRN_AC4_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRN, field RO4[15] (RW)
 *
 * Indicates the lock status of this register's AC4 field. After this field is
 * set to 1, it cannot be changed and attempted writes to AC4 are ignored until
 * the next system reset clears this field.
 *
 * Values:
 * - 0b0 - Writes to corresponding AC field are allowed.
 * - 0b1 - Writes to corresponding AC field are ignored.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRN_RO4 field. */
#define AIPS_RD_PACRN_RO4(base) ((AIPS_PACRN_REG(base) & AIPS_PACRN_RO4_MASK) >> AIPS_PACRN_RO4_SHIFT)
#define AIPS_BRD_PACRN_RO4(base) (BME_UBFX32(&AIPS_PACRN_REG(base), AIPS_PACRN_RO4_SHIFT, AIPS_PACRN_RO4_WIDTH))

/*! @brief Set the RO4 field to a new value. */
#define AIPS_WR_PACRN_RO4(base, value) (AIPS_RMW_PACRN(base, AIPS_PACRN_RO4_MASK, AIPS_PACRN_RO4(value)))
#define AIPS_BWR_PACRN_RO4(base, value) (BME_BFI32(&AIPS_PACRN_REG(base), ((uint32_t)(value) << AIPS_PACRN_RO4_SHIFT), AIPS_PACRN_RO4_SHIFT, AIPS_PACRN_RO4_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRN, field AC3[18:16] (RW)
 *
 * Defines the attributes required to access the corresponding slave
 * peripheral's memory space. See #pacr_attributes , "Attribute check (AC) values" for
 * details.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRN_AC3 field. */
#define AIPS_RD_PACRN_AC3(base) ((AIPS_PACRN_REG(base) & AIPS_PACRN_AC3_MASK) >> AIPS_PACRN_AC3_SHIFT)
#define AIPS_BRD_PACRN_AC3(base) (BME_UBFX32(&AIPS_PACRN_REG(base), AIPS_PACRN_AC3_SHIFT, AIPS_PACRN_AC3_WIDTH))

/*! @brief Set the AC3 field to a new value. */
#define AIPS_WR_PACRN_AC3(base, value) (AIPS_RMW_PACRN(base, AIPS_PACRN_AC3_MASK, AIPS_PACRN_AC3(value)))
#define AIPS_BWR_PACRN_AC3(base, value) (BME_BFI32(&AIPS_PACRN_REG(base), ((uint32_t)(value) << AIPS_PACRN_AC3_SHIFT), AIPS_PACRN_AC3_SHIFT, AIPS_PACRN_AC3_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRN, field RO3[19] (RW)
 *
 * Indicates the lock status of this register's AC3 field. After this field is
 * set to 1, it cannot be changed and attempted writes to AC3 are ignored until
 * the next system reset clears this field.
 *
 * Values:
 * - 0b0 - Writes to corresponding AC field are allowed.
 * - 0b1 - Writes to corresponding AC field are ignored.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRN_RO3 field. */
#define AIPS_RD_PACRN_RO3(base) ((AIPS_PACRN_REG(base) & AIPS_PACRN_RO3_MASK) >> AIPS_PACRN_RO3_SHIFT)
#define AIPS_BRD_PACRN_RO3(base) (BME_UBFX32(&AIPS_PACRN_REG(base), AIPS_PACRN_RO3_SHIFT, AIPS_PACRN_RO3_WIDTH))

/*! @brief Set the RO3 field to a new value. */
#define AIPS_WR_PACRN_RO3(base, value) (AIPS_RMW_PACRN(base, AIPS_PACRN_RO3_MASK, AIPS_PACRN_RO3(value)))
#define AIPS_BWR_PACRN_RO3(base, value) (BME_BFI32(&AIPS_PACRN_REG(base), ((uint32_t)(value) << AIPS_PACRN_RO3_SHIFT), AIPS_PACRN_RO3_SHIFT, AIPS_PACRN_RO3_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRN, field AC2[22:20] (RW)
 *
 * Defines the attributes required to access the corresponding slave
 * peripheral's memory space. See #pacr_attributes , "Attribute check (AC) values" for
 * details.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRN_AC2 field. */
#define AIPS_RD_PACRN_AC2(base) ((AIPS_PACRN_REG(base) & AIPS_PACRN_AC2_MASK) >> AIPS_PACRN_AC2_SHIFT)
#define AIPS_BRD_PACRN_AC2(base) (BME_UBFX32(&AIPS_PACRN_REG(base), AIPS_PACRN_AC2_SHIFT, AIPS_PACRN_AC2_WIDTH))

/*! @brief Set the AC2 field to a new value. */
#define AIPS_WR_PACRN_AC2(base, value) (AIPS_RMW_PACRN(base, AIPS_PACRN_AC2_MASK, AIPS_PACRN_AC2(value)))
#define AIPS_BWR_PACRN_AC2(base, value) (BME_BFI32(&AIPS_PACRN_REG(base), ((uint32_t)(value) << AIPS_PACRN_AC2_SHIFT), AIPS_PACRN_AC2_SHIFT, AIPS_PACRN_AC2_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRN, field RO2[23] (RW)
 *
 * Indicates the lock status of this register's AC2 field. After this field is
 * set to 1, it cannot be changed and attempted writes to AC2 are ignored until
 * the next system reset clears this field.
 *
 * Values:
 * - 0b0 - Writes to corresponding AC field are allowed.
 * - 0b1 - Writes to corresponding AC field are ignored.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRN_RO2 field. */
#define AIPS_RD_PACRN_RO2(base) ((AIPS_PACRN_REG(base) & AIPS_PACRN_RO2_MASK) >> AIPS_PACRN_RO2_SHIFT)
#define AIPS_BRD_PACRN_RO2(base) (BME_UBFX32(&AIPS_PACRN_REG(base), AIPS_PACRN_RO2_SHIFT, AIPS_PACRN_RO2_WIDTH))

/*! @brief Set the RO2 field to a new value. */
#define AIPS_WR_PACRN_RO2(base, value) (AIPS_RMW_PACRN(base, AIPS_PACRN_RO2_MASK, AIPS_PACRN_RO2(value)))
#define AIPS_BWR_PACRN_RO2(base, value) (BME_BFI32(&AIPS_PACRN_REG(base), ((uint32_t)(value) << AIPS_PACRN_RO2_SHIFT), AIPS_PACRN_RO2_SHIFT, AIPS_PACRN_RO2_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRN, field AC1[26:24] (RW)
 *
 * Defines the attributes required to access the corresponding slave
 * peripheral's memory space. See #pacr_attributes , "Attribute check (AC) values" for
 * details.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRN_AC1 field. */
#define AIPS_RD_PACRN_AC1(base) ((AIPS_PACRN_REG(base) & AIPS_PACRN_AC1_MASK) >> AIPS_PACRN_AC1_SHIFT)
#define AIPS_BRD_PACRN_AC1(base) (BME_UBFX32(&AIPS_PACRN_REG(base), AIPS_PACRN_AC1_SHIFT, AIPS_PACRN_AC1_WIDTH))

/*! @brief Set the AC1 field to a new value. */
#define AIPS_WR_PACRN_AC1(base, value) (AIPS_RMW_PACRN(base, AIPS_PACRN_AC1_MASK, AIPS_PACRN_AC1(value)))
#define AIPS_BWR_PACRN_AC1(base, value) (BME_BFI32(&AIPS_PACRN_REG(base), ((uint32_t)(value) << AIPS_PACRN_AC1_SHIFT), AIPS_PACRN_AC1_SHIFT, AIPS_PACRN_AC1_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRN, field RO1[27] (RW)
 *
 * Indicates the lock status of this register's AC1 field. After this field is
 * set to 1, it cannot be changed and attempted writes to AC1 are ignored until
 * the next system reset clears this field.
 *
 * Values:
 * - 0b0 - Writes to corresponding AC field are allowed.
 * - 0b1 - Writes to corresponding AC field are ignored.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRN_RO1 field. */
#define AIPS_RD_PACRN_RO1(base) ((AIPS_PACRN_REG(base) & AIPS_PACRN_RO1_MASK) >> AIPS_PACRN_RO1_SHIFT)
#define AIPS_BRD_PACRN_RO1(base) (BME_UBFX32(&AIPS_PACRN_REG(base), AIPS_PACRN_RO1_SHIFT, AIPS_PACRN_RO1_WIDTH))

/*! @brief Set the RO1 field to a new value. */
#define AIPS_WR_PACRN_RO1(base, value) (AIPS_RMW_PACRN(base, AIPS_PACRN_RO1_MASK, AIPS_PACRN_RO1(value)))
#define AIPS_BWR_PACRN_RO1(base, value) (BME_BFI32(&AIPS_PACRN_REG(base), ((uint32_t)(value) << AIPS_PACRN_RO1_SHIFT), AIPS_PACRN_RO1_SHIFT, AIPS_PACRN_RO1_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRN, field AC0[30:28] (RW)
 *
 * Defines the attributes required to access the corresponding slave
 * peripheral's memory space. See #pacr_attributes , "Attribute check (AC) values" for
 * details.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRN_AC0 field. */
#define AIPS_RD_PACRN_AC0(base) ((AIPS_PACRN_REG(base) & AIPS_PACRN_AC0_MASK) >> AIPS_PACRN_AC0_SHIFT)
#define AIPS_BRD_PACRN_AC0(base) (BME_UBFX32(&AIPS_PACRN_REG(base), AIPS_PACRN_AC0_SHIFT, AIPS_PACRN_AC0_WIDTH))

/*! @brief Set the AC0 field to a new value. */
#define AIPS_WR_PACRN_AC0(base, value) (AIPS_RMW_PACRN(base, AIPS_PACRN_AC0_MASK, AIPS_PACRN_AC0(value)))
#define AIPS_BWR_PACRN_AC0(base, value) (BME_BFI32(&AIPS_PACRN_REG(base), ((uint32_t)(value) << AIPS_PACRN_AC0_SHIFT), AIPS_PACRN_AC0_SHIFT, AIPS_PACRN_AC0_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRN, field RO0[31] (RW)
 *
 * Indicates the lock status of this register's AC0 field. After this field is
 * set to 1, it cannot be changed and attempted writes to AC0 are ignored until
 * the next system reset clears this field.
 *
 * Values:
 * - 0b0 - Writes to corresponding AC field are allowed.
 * - 0b1 - Writes to corresponding AC field are ignored.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRN_RO0 field. */
#define AIPS_RD_PACRN_RO0(base) ((AIPS_PACRN_REG(base) & AIPS_PACRN_RO0_MASK) >> AIPS_PACRN_RO0_SHIFT)
#define AIPS_BRD_PACRN_RO0(base) (BME_UBFX32(&AIPS_PACRN_REG(base), AIPS_PACRN_RO0_SHIFT, AIPS_PACRN_RO0_WIDTH))

/*! @brief Set the RO0 field to a new value. */
#define AIPS_WR_PACRN_RO0(base, value) (AIPS_RMW_PACRN(base, AIPS_PACRN_RO0_MASK, AIPS_PACRN_RO0(value)))
#define AIPS_BWR_PACRN_RO0(base, value) (BME_BFI32(&AIPS_PACRN_REG(base), ((uint32_t)(value) << AIPS_PACRN_RO0_SHIFT), AIPS_PACRN_RO0_SHIFT, AIPS_PACRN_RO0_WIDTH))
/*@}*/

/*******************************************************************************
 * AIPS_PACRO - Peripheral Access Control Register
 ******************************************************************************/

/*!
 * @brief AIPS_PACRO - Peripheral Access Control Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * Each peripheral on this chip has a 4-bit PACR field which includes a
 * read-only "lock" bit plus a 3-bit attribute check field which defines the access
 * rights (privileged/user, secure/nonsecure) needed to reference the slave
 * peripheral's address space. Access to these registers is allowed using only 32-bit
 * privileged, secure reads and writes. Each 32-bit register controls eight
 * peripherals. PACRE-PACR P control access to the 96 off-platform peripherals. A
 * peripheral's assignment to a PACR field is defined by the memory map slot to which the
 * peripheral is assigned. See this device's peripheral bridge memory map
 * information for the assignment of a particular peripheral. The following table shows
 * the top-level structure of PACRs. Offset Register [31:28] [27:24] [23:20]
 * [19:16] [15:12] [11:8] [7:4] [3:0] 0x40 PACRE PACR32 PACR33 PACR34 PACR35 PACR36
 * PACR37 PACR38 PACR39 0x44 PACRF PACR40 PACR41 PACR42 PACR43 PACR44 PACR45
 * PACR46 PACR47 0x48 PACRG PACR48 PACR49 PACR50 PACR51 PACR52 PACR53 PACR54 PACR55
 * 0x4C PACRH PACR56 PACR57 PACR58 PACR59 PACR60 PACR61 PACR62 PACR63 0x50 PACRI
 * PACR64 PACR65 PACR66 PACR67 PACR68 PACR69 PACR70 PACR71 0x54 PACRJ PACR72 PACR73
 * PACR74 PACR75 PACR76 PACR77 PACR78 PACR79 0x58 PACRK PACR80 PACR81 PACR82
 * PACR83 PACR84 PACR85 PACR86 PACR87 0x5C PACRL PACR88 PACR89 PACR90 PACR91 PACR92
 * PACR93 PACR94 PACR95 0x60 PACRM PACR96 PACR97 PACR98 PACR99 PACR100 PACR101
 * PACR102 PACR103 0x64 PACRN PACR104 PACR105 PACR106 PACR107 PACR108 PACR109
 * PACR110 PACR111 0x68 PACRO PACR112 PACR113 PACR114 PACR115 PACR116 PACR117 PACR118
 * PACR119 0x6C PACRP PACR120 PACR121 PACR122 PACR123 PACR124 PACR125 PACR126
 * PACR127
 */
/*!
 * @name Constants and macros for entire AIPS_PACRO register
 */
/*@{*/
#define AIPS_RD_PACRO(base)      (AIPS_PACRO_REG(base))
#define AIPS_WR_PACRO(base, value) (AIPS_PACRO_REG(base) = (value))
#define AIPS_RMW_PACRO(base, mask, value) (AIPS_WR_PACRO(base, (AIPS_RD_PACRO(base) & ~(mask)) | (value)))
#define AIPS_SET_PACRO(base, value) (BME_OR32(&AIPS_PACRO_REG(base), (uint32_t)(value)))
#define AIPS_CLR_PACRO(base, value) (BME_AND32(&AIPS_PACRO_REG(base), (uint32_t)(~(value))))
#define AIPS_TOG_PACRO(base, value) (BME_XOR32(&AIPS_PACRO_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual AIPS_PACRO bitfields
 */

/*!
 * @name Register AIPS_PACRO, field AC7[2:0] (RW)
 *
 * Defines the attributes required to access the corresponding slave
 * peripheral's memory space. See #pacr_attributes , "Attribute check (AC) values" for
 * details.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRO_AC7 field. */
#define AIPS_RD_PACRO_AC7(base) ((AIPS_PACRO_REG(base) & AIPS_PACRO_AC7_MASK) >> AIPS_PACRO_AC7_SHIFT)
#define AIPS_BRD_PACRO_AC7(base) (BME_UBFX32(&AIPS_PACRO_REG(base), AIPS_PACRO_AC7_SHIFT, AIPS_PACRO_AC7_WIDTH))

/*! @brief Set the AC7 field to a new value. */
#define AIPS_WR_PACRO_AC7(base, value) (AIPS_RMW_PACRO(base, AIPS_PACRO_AC7_MASK, AIPS_PACRO_AC7(value)))
#define AIPS_BWR_PACRO_AC7(base, value) (BME_BFI32(&AIPS_PACRO_REG(base), ((uint32_t)(value) << AIPS_PACRO_AC7_SHIFT), AIPS_PACRO_AC7_SHIFT, AIPS_PACRO_AC7_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRO, field RO7[3] (RW)
 *
 * Indicates the lock status of this register's AC7 field. After this field is
 * set to 1, it cannot be changed and attempted writes to AC7 are ignored until
 * the next system reset clears this field.
 *
 * Values:
 * - 0b0 - Writes to corresponding AC field are allowed.
 * - 0b1 - Writes to corresponding AC field are ignored.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRO_RO7 field. */
#define AIPS_RD_PACRO_RO7(base) ((AIPS_PACRO_REG(base) & AIPS_PACRO_RO7_MASK) >> AIPS_PACRO_RO7_SHIFT)
#define AIPS_BRD_PACRO_RO7(base) (BME_UBFX32(&AIPS_PACRO_REG(base), AIPS_PACRO_RO7_SHIFT, AIPS_PACRO_RO7_WIDTH))

/*! @brief Set the RO7 field to a new value. */
#define AIPS_WR_PACRO_RO7(base, value) (AIPS_RMW_PACRO(base, AIPS_PACRO_RO7_MASK, AIPS_PACRO_RO7(value)))
#define AIPS_BWR_PACRO_RO7(base, value) (BME_BFI32(&AIPS_PACRO_REG(base), ((uint32_t)(value) << AIPS_PACRO_RO7_SHIFT), AIPS_PACRO_RO7_SHIFT, AIPS_PACRO_RO7_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRO, field AC6[6:4] (RW)
 *
 * Defines the attributes required to access the corresponding slave
 * peripheral's memory space. See #pacr_attributes , "Attribute check (AC) values" for
 * details.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRO_AC6 field. */
#define AIPS_RD_PACRO_AC6(base) ((AIPS_PACRO_REG(base) & AIPS_PACRO_AC6_MASK) >> AIPS_PACRO_AC6_SHIFT)
#define AIPS_BRD_PACRO_AC6(base) (BME_UBFX32(&AIPS_PACRO_REG(base), AIPS_PACRO_AC6_SHIFT, AIPS_PACRO_AC6_WIDTH))

/*! @brief Set the AC6 field to a new value. */
#define AIPS_WR_PACRO_AC6(base, value) (AIPS_RMW_PACRO(base, AIPS_PACRO_AC6_MASK, AIPS_PACRO_AC6(value)))
#define AIPS_BWR_PACRO_AC6(base, value) (BME_BFI32(&AIPS_PACRO_REG(base), ((uint32_t)(value) << AIPS_PACRO_AC6_SHIFT), AIPS_PACRO_AC6_SHIFT, AIPS_PACRO_AC6_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRO, field RO6[7] (RW)
 *
 * Indicates the lock status of this register's AC6 field. After this field is
 * set to 1, it cannot be changed and attempted writes to AC6 are ignored until
 * the next system reset clears this field.
 *
 * Values:
 * - 0b0 - Writes to corresponding AC field are allowed.
 * - 0b1 - Writes to corresponding AC field are ignored.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRO_RO6 field. */
#define AIPS_RD_PACRO_RO6(base) ((AIPS_PACRO_REG(base) & AIPS_PACRO_RO6_MASK) >> AIPS_PACRO_RO6_SHIFT)
#define AIPS_BRD_PACRO_RO6(base) (BME_UBFX32(&AIPS_PACRO_REG(base), AIPS_PACRO_RO6_SHIFT, AIPS_PACRO_RO6_WIDTH))

/*! @brief Set the RO6 field to a new value. */
#define AIPS_WR_PACRO_RO6(base, value) (AIPS_RMW_PACRO(base, AIPS_PACRO_RO6_MASK, AIPS_PACRO_RO6(value)))
#define AIPS_BWR_PACRO_RO6(base, value) (BME_BFI32(&AIPS_PACRO_REG(base), ((uint32_t)(value) << AIPS_PACRO_RO6_SHIFT), AIPS_PACRO_RO6_SHIFT, AIPS_PACRO_RO6_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRO, field AC5[10:8] (RW)
 *
 * Defines the attributes required to access the corresponding slave
 * peripheral's memory space. See #pacr_attributes , "Attribute check (AC) values" for
 * details.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRO_AC5 field. */
#define AIPS_RD_PACRO_AC5(base) ((AIPS_PACRO_REG(base) & AIPS_PACRO_AC5_MASK) >> AIPS_PACRO_AC5_SHIFT)
#define AIPS_BRD_PACRO_AC5(base) (BME_UBFX32(&AIPS_PACRO_REG(base), AIPS_PACRO_AC5_SHIFT, AIPS_PACRO_AC5_WIDTH))

/*! @brief Set the AC5 field to a new value. */
#define AIPS_WR_PACRO_AC5(base, value) (AIPS_RMW_PACRO(base, AIPS_PACRO_AC5_MASK, AIPS_PACRO_AC5(value)))
#define AIPS_BWR_PACRO_AC5(base, value) (BME_BFI32(&AIPS_PACRO_REG(base), ((uint32_t)(value) << AIPS_PACRO_AC5_SHIFT), AIPS_PACRO_AC5_SHIFT, AIPS_PACRO_AC5_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRO, field RO5[11] (RW)
 *
 * Indicates the lock status of this register's AC5 field. After this field is
 * set to 1, it cannot be changed and attempted writes to AC5 are ignored until
 * the next system reset clears this field.
 *
 * Values:
 * - 0b0 - Writes to corresponding AC field are allowed.
 * - 0b1 - Writes to corresponding AC field are ignored.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRO_RO5 field. */
#define AIPS_RD_PACRO_RO5(base) ((AIPS_PACRO_REG(base) & AIPS_PACRO_RO5_MASK) >> AIPS_PACRO_RO5_SHIFT)
#define AIPS_BRD_PACRO_RO5(base) (BME_UBFX32(&AIPS_PACRO_REG(base), AIPS_PACRO_RO5_SHIFT, AIPS_PACRO_RO5_WIDTH))

/*! @brief Set the RO5 field to a new value. */
#define AIPS_WR_PACRO_RO5(base, value) (AIPS_RMW_PACRO(base, AIPS_PACRO_RO5_MASK, AIPS_PACRO_RO5(value)))
#define AIPS_BWR_PACRO_RO5(base, value) (BME_BFI32(&AIPS_PACRO_REG(base), ((uint32_t)(value) << AIPS_PACRO_RO5_SHIFT), AIPS_PACRO_RO5_SHIFT, AIPS_PACRO_RO5_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRO, field AC4[14:12] (RW)
 *
 * Defines the attributes required to access the corresponding slave
 * peripheral's memory space. See #pacr_attributes , "Attribute check (AC) values" for
 * details.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRO_AC4 field. */
#define AIPS_RD_PACRO_AC4(base) ((AIPS_PACRO_REG(base) & AIPS_PACRO_AC4_MASK) >> AIPS_PACRO_AC4_SHIFT)
#define AIPS_BRD_PACRO_AC4(base) (BME_UBFX32(&AIPS_PACRO_REG(base), AIPS_PACRO_AC4_SHIFT, AIPS_PACRO_AC4_WIDTH))

/*! @brief Set the AC4 field to a new value. */
#define AIPS_WR_PACRO_AC4(base, value) (AIPS_RMW_PACRO(base, AIPS_PACRO_AC4_MASK, AIPS_PACRO_AC4(value)))
#define AIPS_BWR_PACRO_AC4(base, value) (BME_BFI32(&AIPS_PACRO_REG(base), ((uint32_t)(value) << AIPS_PACRO_AC4_SHIFT), AIPS_PACRO_AC4_SHIFT, AIPS_PACRO_AC4_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRO, field RO4[15] (RW)
 *
 * Indicates the lock status of this register's AC4 field. After this field is
 * set to 1, it cannot be changed and attempted writes to AC4 are ignored until
 * the next system reset clears this field.
 *
 * Values:
 * - 0b0 - Writes to corresponding AC field are allowed.
 * - 0b1 - Writes to corresponding AC field are ignored.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRO_RO4 field. */
#define AIPS_RD_PACRO_RO4(base) ((AIPS_PACRO_REG(base) & AIPS_PACRO_RO4_MASK) >> AIPS_PACRO_RO4_SHIFT)
#define AIPS_BRD_PACRO_RO4(base) (BME_UBFX32(&AIPS_PACRO_REG(base), AIPS_PACRO_RO4_SHIFT, AIPS_PACRO_RO4_WIDTH))

/*! @brief Set the RO4 field to a new value. */
#define AIPS_WR_PACRO_RO4(base, value) (AIPS_RMW_PACRO(base, AIPS_PACRO_RO4_MASK, AIPS_PACRO_RO4(value)))
#define AIPS_BWR_PACRO_RO4(base, value) (BME_BFI32(&AIPS_PACRO_REG(base), ((uint32_t)(value) << AIPS_PACRO_RO4_SHIFT), AIPS_PACRO_RO4_SHIFT, AIPS_PACRO_RO4_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRO, field AC3[18:16] (RW)
 *
 * Defines the attributes required to access the corresponding slave
 * peripheral's memory space. See #pacr_attributes , "Attribute check (AC) values" for
 * details.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRO_AC3 field. */
#define AIPS_RD_PACRO_AC3(base) ((AIPS_PACRO_REG(base) & AIPS_PACRO_AC3_MASK) >> AIPS_PACRO_AC3_SHIFT)
#define AIPS_BRD_PACRO_AC3(base) (BME_UBFX32(&AIPS_PACRO_REG(base), AIPS_PACRO_AC3_SHIFT, AIPS_PACRO_AC3_WIDTH))

/*! @brief Set the AC3 field to a new value. */
#define AIPS_WR_PACRO_AC3(base, value) (AIPS_RMW_PACRO(base, AIPS_PACRO_AC3_MASK, AIPS_PACRO_AC3(value)))
#define AIPS_BWR_PACRO_AC3(base, value) (BME_BFI32(&AIPS_PACRO_REG(base), ((uint32_t)(value) << AIPS_PACRO_AC3_SHIFT), AIPS_PACRO_AC3_SHIFT, AIPS_PACRO_AC3_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRO, field RO3[19] (RW)
 *
 * Indicates the lock status of this register's AC3 field. After this field is
 * set to 1, it cannot be changed and attempted writes to AC3 are ignored until
 * the next system reset clears this field.
 *
 * Values:
 * - 0b0 - Writes to corresponding AC field are allowed.
 * - 0b1 - Writes to corresponding AC field are ignored.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRO_RO3 field. */
#define AIPS_RD_PACRO_RO3(base) ((AIPS_PACRO_REG(base) & AIPS_PACRO_RO3_MASK) >> AIPS_PACRO_RO3_SHIFT)
#define AIPS_BRD_PACRO_RO3(base) (BME_UBFX32(&AIPS_PACRO_REG(base), AIPS_PACRO_RO3_SHIFT, AIPS_PACRO_RO3_WIDTH))

/*! @brief Set the RO3 field to a new value. */
#define AIPS_WR_PACRO_RO3(base, value) (AIPS_RMW_PACRO(base, AIPS_PACRO_RO3_MASK, AIPS_PACRO_RO3(value)))
#define AIPS_BWR_PACRO_RO3(base, value) (BME_BFI32(&AIPS_PACRO_REG(base), ((uint32_t)(value) << AIPS_PACRO_RO3_SHIFT), AIPS_PACRO_RO3_SHIFT, AIPS_PACRO_RO3_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRO, field AC2[22:20] (RW)
 *
 * Defines the attributes required to access the corresponding slave
 * peripheral's memory space. See #pacr_attributes , "Attribute check (AC) values" for
 * details.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRO_AC2 field. */
#define AIPS_RD_PACRO_AC2(base) ((AIPS_PACRO_REG(base) & AIPS_PACRO_AC2_MASK) >> AIPS_PACRO_AC2_SHIFT)
#define AIPS_BRD_PACRO_AC2(base) (BME_UBFX32(&AIPS_PACRO_REG(base), AIPS_PACRO_AC2_SHIFT, AIPS_PACRO_AC2_WIDTH))

/*! @brief Set the AC2 field to a new value. */
#define AIPS_WR_PACRO_AC2(base, value) (AIPS_RMW_PACRO(base, AIPS_PACRO_AC2_MASK, AIPS_PACRO_AC2(value)))
#define AIPS_BWR_PACRO_AC2(base, value) (BME_BFI32(&AIPS_PACRO_REG(base), ((uint32_t)(value) << AIPS_PACRO_AC2_SHIFT), AIPS_PACRO_AC2_SHIFT, AIPS_PACRO_AC2_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRO, field RO2[23] (RW)
 *
 * Indicates the lock status of this register's AC2 field. After this field is
 * set to 1, it cannot be changed and attempted writes to AC2 are ignored until
 * the next system reset clears this field.
 *
 * Values:
 * - 0b0 - Writes to corresponding AC field are allowed.
 * - 0b1 - Writes to corresponding AC field are ignored.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRO_RO2 field. */
#define AIPS_RD_PACRO_RO2(base) ((AIPS_PACRO_REG(base) & AIPS_PACRO_RO2_MASK) >> AIPS_PACRO_RO2_SHIFT)
#define AIPS_BRD_PACRO_RO2(base) (BME_UBFX32(&AIPS_PACRO_REG(base), AIPS_PACRO_RO2_SHIFT, AIPS_PACRO_RO2_WIDTH))

/*! @brief Set the RO2 field to a new value. */
#define AIPS_WR_PACRO_RO2(base, value) (AIPS_RMW_PACRO(base, AIPS_PACRO_RO2_MASK, AIPS_PACRO_RO2(value)))
#define AIPS_BWR_PACRO_RO2(base, value) (BME_BFI32(&AIPS_PACRO_REG(base), ((uint32_t)(value) << AIPS_PACRO_RO2_SHIFT), AIPS_PACRO_RO2_SHIFT, AIPS_PACRO_RO2_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRO, field AC1[26:24] (RW)
 *
 * Defines the attributes required to access the corresponding slave
 * peripheral's memory space. See #pacr_attributes , "Attribute check (AC) values" for
 * details.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRO_AC1 field. */
#define AIPS_RD_PACRO_AC1(base) ((AIPS_PACRO_REG(base) & AIPS_PACRO_AC1_MASK) >> AIPS_PACRO_AC1_SHIFT)
#define AIPS_BRD_PACRO_AC1(base) (BME_UBFX32(&AIPS_PACRO_REG(base), AIPS_PACRO_AC1_SHIFT, AIPS_PACRO_AC1_WIDTH))

/*! @brief Set the AC1 field to a new value. */
#define AIPS_WR_PACRO_AC1(base, value) (AIPS_RMW_PACRO(base, AIPS_PACRO_AC1_MASK, AIPS_PACRO_AC1(value)))
#define AIPS_BWR_PACRO_AC1(base, value) (BME_BFI32(&AIPS_PACRO_REG(base), ((uint32_t)(value) << AIPS_PACRO_AC1_SHIFT), AIPS_PACRO_AC1_SHIFT, AIPS_PACRO_AC1_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRO, field RO1[27] (RW)
 *
 * Indicates the lock status of this register's AC1 field. After this field is
 * set to 1, it cannot be changed and attempted writes to AC1 are ignored until
 * the next system reset clears this field.
 *
 * Values:
 * - 0b0 - Writes to corresponding AC field are allowed.
 * - 0b1 - Writes to corresponding AC field are ignored.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRO_RO1 field. */
#define AIPS_RD_PACRO_RO1(base) ((AIPS_PACRO_REG(base) & AIPS_PACRO_RO1_MASK) >> AIPS_PACRO_RO1_SHIFT)
#define AIPS_BRD_PACRO_RO1(base) (BME_UBFX32(&AIPS_PACRO_REG(base), AIPS_PACRO_RO1_SHIFT, AIPS_PACRO_RO1_WIDTH))

/*! @brief Set the RO1 field to a new value. */
#define AIPS_WR_PACRO_RO1(base, value) (AIPS_RMW_PACRO(base, AIPS_PACRO_RO1_MASK, AIPS_PACRO_RO1(value)))
#define AIPS_BWR_PACRO_RO1(base, value) (BME_BFI32(&AIPS_PACRO_REG(base), ((uint32_t)(value) << AIPS_PACRO_RO1_SHIFT), AIPS_PACRO_RO1_SHIFT, AIPS_PACRO_RO1_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRO, field AC0[30:28] (RW)
 *
 * Defines the attributes required to access the corresponding slave
 * peripheral's memory space. See #pacr_attributes , "Attribute check (AC) values" for
 * details.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRO_AC0 field. */
#define AIPS_RD_PACRO_AC0(base) ((AIPS_PACRO_REG(base) & AIPS_PACRO_AC0_MASK) >> AIPS_PACRO_AC0_SHIFT)
#define AIPS_BRD_PACRO_AC0(base) (BME_UBFX32(&AIPS_PACRO_REG(base), AIPS_PACRO_AC0_SHIFT, AIPS_PACRO_AC0_WIDTH))

/*! @brief Set the AC0 field to a new value. */
#define AIPS_WR_PACRO_AC0(base, value) (AIPS_RMW_PACRO(base, AIPS_PACRO_AC0_MASK, AIPS_PACRO_AC0(value)))
#define AIPS_BWR_PACRO_AC0(base, value) (BME_BFI32(&AIPS_PACRO_REG(base), ((uint32_t)(value) << AIPS_PACRO_AC0_SHIFT), AIPS_PACRO_AC0_SHIFT, AIPS_PACRO_AC0_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRO, field RO0[31] (RW)
 *
 * Indicates the lock status of this register's AC0 field. After this field is
 * set to 1, it cannot be changed and attempted writes to AC0 are ignored until
 * the next system reset clears this field.
 *
 * Values:
 * - 0b0 - Writes to corresponding AC field are allowed.
 * - 0b1 - Writes to corresponding AC field are ignored.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRO_RO0 field. */
#define AIPS_RD_PACRO_RO0(base) ((AIPS_PACRO_REG(base) & AIPS_PACRO_RO0_MASK) >> AIPS_PACRO_RO0_SHIFT)
#define AIPS_BRD_PACRO_RO0(base) (BME_UBFX32(&AIPS_PACRO_REG(base), AIPS_PACRO_RO0_SHIFT, AIPS_PACRO_RO0_WIDTH))

/*! @brief Set the RO0 field to a new value. */
#define AIPS_WR_PACRO_RO0(base, value) (AIPS_RMW_PACRO(base, AIPS_PACRO_RO0_MASK, AIPS_PACRO_RO0(value)))
#define AIPS_BWR_PACRO_RO0(base, value) (BME_BFI32(&AIPS_PACRO_REG(base), ((uint32_t)(value) << AIPS_PACRO_RO0_SHIFT), AIPS_PACRO_RO0_SHIFT, AIPS_PACRO_RO0_WIDTH))
/*@}*/

/*******************************************************************************
 * AIPS_PACRP - Peripheral Access Control Register
 ******************************************************************************/

/*!
 * @brief AIPS_PACRP - Peripheral Access Control Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * Each peripheral on this chip has a 4-bit PACR field which includes a
 * read-only "lock" bit plus a 3-bit attribute check field which defines the access
 * rights (privileged/user, secure/nonsecure) needed to reference the slave
 * peripheral's address space. Access to these registers is allowed using only 32-bit
 * privileged, secure reads and writes. Each 32-bit register controls eight
 * peripherals. PACRE-PACR P control access to the 96 off-platform peripherals. A
 * peripheral's assignment to a PACR field is defined by the memory map slot to which the
 * peripheral is assigned. See this device's peripheral bridge memory map
 * information for the assignment of a particular peripheral. The following table shows
 * the top-level structure of PACRs. Offset Register [31:28] [27:24] [23:20]
 * [19:16] [15:12] [11:8] [7:4] [3:0] 0x40 PACRE PACR32 PACR33 PACR34 PACR35 PACR36
 * PACR37 PACR38 PACR39 0x44 PACRF PACR40 PACR41 PACR42 PACR43 PACR44 PACR45
 * PACR46 PACR47 0x48 PACRG PACR48 PACR49 PACR50 PACR51 PACR52 PACR53 PACR54 PACR55
 * 0x4C PACRH PACR56 PACR57 PACR58 PACR59 PACR60 PACR61 PACR62 PACR63 0x50 PACRI
 * PACR64 PACR65 PACR66 PACR67 PACR68 PACR69 PACR70 PACR71 0x54 PACRJ PACR72 PACR73
 * PACR74 PACR75 PACR76 PACR77 PACR78 PACR79 0x58 PACRK PACR80 PACR81 PACR82
 * PACR83 PACR84 PACR85 PACR86 PACR87 0x5C PACRL PACR88 PACR89 PACR90 PACR91 PACR92
 * PACR93 PACR94 PACR95 0x60 PACRM PACR96 PACR97 PACR98 PACR99 PACR100 PACR101
 * PACR102 PACR103 0x64 PACRN PACR104 PACR105 PACR106 PACR107 PACR108 PACR109
 * PACR110 PACR111 0x68 PACRO PACR112 PACR113 PACR114 PACR115 PACR116 PACR117 PACR118
 * PACR119 0x6C PACRP PACR120 PACR121 PACR122 PACR123 PACR124 PACR125 PACR126
 * PACR127
 */
/*!
 * @name Constants and macros for entire AIPS_PACRP register
 */
/*@{*/
#define AIPS_RD_PACRP(base)      (AIPS_PACRP_REG(base))
#define AIPS_WR_PACRP(base, value) (AIPS_PACRP_REG(base) = (value))
#define AIPS_RMW_PACRP(base, mask, value) (AIPS_WR_PACRP(base, (AIPS_RD_PACRP(base) & ~(mask)) | (value)))
#define AIPS_SET_PACRP(base, value) (BME_OR32(&AIPS_PACRP_REG(base), (uint32_t)(value)))
#define AIPS_CLR_PACRP(base, value) (BME_AND32(&AIPS_PACRP_REG(base), (uint32_t)(~(value))))
#define AIPS_TOG_PACRP(base, value) (BME_XOR32(&AIPS_PACRP_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual AIPS_PACRP bitfields
 */

/*!
 * @name Register AIPS_PACRP, field AC7[2:0] (RW)
 *
 * Defines the attributes required to access the corresponding slave
 * peripheral's memory space. See #pacr_attributes , "Attribute check (AC) values" for
 * details.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRP_AC7 field. */
#define AIPS_RD_PACRP_AC7(base) ((AIPS_PACRP_REG(base) & AIPS_PACRP_AC7_MASK) >> AIPS_PACRP_AC7_SHIFT)
#define AIPS_BRD_PACRP_AC7(base) (BME_UBFX32(&AIPS_PACRP_REG(base), AIPS_PACRP_AC7_SHIFT, AIPS_PACRP_AC7_WIDTH))

/*! @brief Set the AC7 field to a new value. */
#define AIPS_WR_PACRP_AC7(base, value) (AIPS_RMW_PACRP(base, AIPS_PACRP_AC7_MASK, AIPS_PACRP_AC7(value)))
#define AIPS_BWR_PACRP_AC7(base, value) (BME_BFI32(&AIPS_PACRP_REG(base), ((uint32_t)(value) << AIPS_PACRP_AC7_SHIFT), AIPS_PACRP_AC7_SHIFT, AIPS_PACRP_AC7_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRP, field RO7[3] (RW)
 *
 * Indicates the lock status of this register's AC7 field. After this field is
 * set to 1, it cannot be changed and attempted writes to AC7 are ignored until
 * the next system reset clears this field.
 *
 * Values:
 * - 0b0 - Writes to corresponding AC field are allowed.
 * - 0b1 - Writes to corresponding AC field are ignored.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRP_RO7 field. */
#define AIPS_RD_PACRP_RO7(base) ((AIPS_PACRP_REG(base) & AIPS_PACRP_RO7_MASK) >> AIPS_PACRP_RO7_SHIFT)
#define AIPS_BRD_PACRP_RO7(base) (BME_UBFX32(&AIPS_PACRP_REG(base), AIPS_PACRP_RO7_SHIFT, AIPS_PACRP_RO7_WIDTH))

/*! @brief Set the RO7 field to a new value. */
#define AIPS_WR_PACRP_RO7(base, value) (AIPS_RMW_PACRP(base, AIPS_PACRP_RO7_MASK, AIPS_PACRP_RO7(value)))
#define AIPS_BWR_PACRP_RO7(base, value) (BME_BFI32(&AIPS_PACRP_REG(base), ((uint32_t)(value) << AIPS_PACRP_RO7_SHIFT), AIPS_PACRP_RO7_SHIFT, AIPS_PACRP_RO7_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRP, field AC6[6:4] (RW)
 *
 * Defines the attributes required to access the corresponding slave
 * peripheral's memory space. See #pacr_attributes , "Attribute check (AC) values" for
 * details.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRP_AC6 field. */
#define AIPS_RD_PACRP_AC6(base) ((AIPS_PACRP_REG(base) & AIPS_PACRP_AC6_MASK) >> AIPS_PACRP_AC6_SHIFT)
#define AIPS_BRD_PACRP_AC6(base) (BME_UBFX32(&AIPS_PACRP_REG(base), AIPS_PACRP_AC6_SHIFT, AIPS_PACRP_AC6_WIDTH))

/*! @brief Set the AC6 field to a new value. */
#define AIPS_WR_PACRP_AC6(base, value) (AIPS_RMW_PACRP(base, AIPS_PACRP_AC6_MASK, AIPS_PACRP_AC6(value)))
#define AIPS_BWR_PACRP_AC6(base, value) (BME_BFI32(&AIPS_PACRP_REG(base), ((uint32_t)(value) << AIPS_PACRP_AC6_SHIFT), AIPS_PACRP_AC6_SHIFT, AIPS_PACRP_AC6_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRP, field RO6[7] (RW)
 *
 * Indicates the lock status of this register's AC6 field. After this field is
 * set to 1, it cannot be changed and attempted writes to AC6 are ignored until
 * the next system reset clears this field.
 *
 * Values:
 * - 0b0 - Writes to corresponding AC field are allowed.
 * - 0b1 - Writes to corresponding AC field are ignored.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRP_RO6 field. */
#define AIPS_RD_PACRP_RO6(base) ((AIPS_PACRP_REG(base) & AIPS_PACRP_RO6_MASK) >> AIPS_PACRP_RO6_SHIFT)
#define AIPS_BRD_PACRP_RO6(base) (BME_UBFX32(&AIPS_PACRP_REG(base), AIPS_PACRP_RO6_SHIFT, AIPS_PACRP_RO6_WIDTH))

/*! @brief Set the RO6 field to a new value. */
#define AIPS_WR_PACRP_RO6(base, value) (AIPS_RMW_PACRP(base, AIPS_PACRP_RO6_MASK, AIPS_PACRP_RO6(value)))
#define AIPS_BWR_PACRP_RO6(base, value) (BME_BFI32(&AIPS_PACRP_REG(base), ((uint32_t)(value) << AIPS_PACRP_RO6_SHIFT), AIPS_PACRP_RO6_SHIFT, AIPS_PACRP_RO6_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRP, field AC5[10:8] (RW)
 *
 * Defines the attributes required to access the corresponding slave
 * peripheral's memory space. See #pacr_attributes , "Attribute check (AC) values" for
 * details.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRP_AC5 field. */
#define AIPS_RD_PACRP_AC5(base) ((AIPS_PACRP_REG(base) & AIPS_PACRP_AC5_MASK) >> AIPS_PACRP_AC5_SHIFT)
#define AIPS_BRD_PACRP_AC5(base) (BME_UBFX32(&AIPS_PACRP_REG(base), AIPS_PACRP_AC5_SHIFT, AIPS_PACRP_AC5_WIDTH))

/*! @brief Set the AC5 field to a new value. */
#define AIPS_WR_PACRP_AC5(base, value) (AIPS_RMW_PACRP(base, AIPS_PACRP_AC5_MASK, AIPS_PACRP_AC5(value)))
#define AIPS_BWR_PACRP_AC5(base, value) (BME_BFI32(&AIPS_PACRP_REG(base), ((uint32_t)(value) << AIPS_PACRP_AC5_SHIFT), AIPS_PACRP_AC5_SHIFT, AIPS_PACRP_AC5_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRP, field RO5[11] (RW)
 *
 * Indicates the lock status of this register's AC5 field. After this field is
 * set to 1, it cannot be changed and attempted writes to AC5 are ignored until
 * the next system reset clears this field.
 *
 * Values:
 * - 0b0 - Writes to corresponding AC field are allowed.
 * - 0b1 - Writes to corresponding AC field are ignored.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRP_RO5 field. */
#define AIPS_RD_PACRP_RO5(base) ((AIPS_PACRP_REG(base) & AIPS_PACRP_RO5_MASK) >> AIPS_PACRP_RO5_SHIFT)
#define AIPS_BRD_PACRP_RO5(base) (BME_UBFX32(&AIPS_PACRP_REG(base), AIPS_PACRP_RO5_SHIFT, AIPS_PACRP_RO5_WIDTH))

/*! @brief Set the RO5 field to a new value. */
#define AIPS_WR_PACRP_RO5(base, value) (AIPS_RMW_PACRP(base, AIPS_PACRP_RO5_MASK, AIPS_PACRP_RO5(value)))
#define AIPS_BWR_PACRP_RO5(base, value) (BME_BFI32(&AIPS_PACRP_REG(base), ((uint32_t)(value) << AIPS_PACRP_RO5_SHIFT), AIPS_PACRP_RO5_SHIFT, AIPS_PACRP_RO5_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRP, field AC4[14:12] (RW)
 *
 * Defines the attributes required to access the corresponding slave
 * peripheral's memory space. See #pacr_attributes , "Attribute check (AC) values" for
 * details.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRP_AC4 field. */
#define AIPS_RD_PACRP_AC4(base) ((AIPS_PACRP_REG(base) & AIPS_PACRP_AC4_MASK) >> AIPS_PACRP_AC4_SHIFT)
#define AIPS_BRD_PACRP_AC4(base) (BME_UBFX32(&AIPS_PACRP_REG(base), AIPS_PACRP_AC4_SHIFT, AIPS_PACRP_AC4_WIDTH))

/*! @brief Set the AC4 field to a new value. */
#define AIPS_WR_PACRP_AC4(base, value) (AIPS_RMW_PACRP(base, AIPS_PACRP_AC4_MASK, AIPS_PACRP_AC4(value)))
#define AIPS_BWR_PACRP_AC4(base, value) (BME_BFI32(&AIPS_PACRP_REG(base), ((uint32_t)(value) << AIPS_PACRP_AC4_SHIFT), AIPS_PACRP_AC4_SHIFT, AIPS_PACRP_AC4_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRP, field RO4[15] (RW)
 *
 * Indicates the lock status of this register's AC4 field. After this field is
 * set to 1, it cannot be changed and attempted writes to AC4 are ignored until
 * the next system reset clears this field.
 *
 * Values:
 * - 0b0 - Writes to corresponding AC field are allowed.
 * - 0b1 - Writes to corresponding AC field are ignored.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRP_RO4 field. */
#define AIPS_RD_PACRP_RO4(base) ((AIPS_PACRP_REG(base) & AIPS_PACRP_RO4_MASK) >> AIPS_PACRP_RO4_SHIFT)
#define AIPS_BRD_PACRP_RO4(base) (BME_UBFX32(&AIPS_PACRP_REG(base), AIPS_PACRP_RO4_SHIFT, AIPS_PACRP_RO4_WIDTH))

/*! @brief Set the RO4 field to a new value. */
#define AIPS_WR_PACRP_RO4(base, value) (AIPS_RMW_PACRP(base, AIPS_PACRP_RO4_MASK, AIPS_PACRP_RO4(value)))
#define AIPS_BWR_PACRP_RO4(base, value) (BME_BFI32(&AIPS_PACRP_REG(base), ((uint32_t)(value) << AIPS_PACRP_RO4_SHIFT), AIPS_PACRP_RO4_SHIFT, AIPS_PACRP_RO4_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRP, field AC3[18:16] (RW)
 *
 * Defines the attributes required to access the corresponding slave
 * peripheral's memory space. See #pacr_attributes , "Attribute check (AC) values" for
 * details.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRP_AC3 field. */
#define AIPS_RD_PACRP_AC3(base) ((AIPS_PACRP_REG(base) & AIPS_PACRP_AC3_MASK) >> AIPS_PACRP_AC3_SHIFT)
#define AIPS_BRD_PACRP_AC3(base) (BME_UBFX32(&AIPS_PACRP_REG(base), AIPS_PACRP_AC3_SHIFT, AIPS_PACRP_AC3_WIDTH))

/*! @brief Set the AC3 field to a new value. */
#define AIPS_WR_PACRP_AC3(base, value) (AIPS_RMW_PACRP(base, AIPS_PACRP_AC3_MASK, AIPS_PACRP_AC3(value)))
#define AIPS_BWR_PACRP_AC3(base, value) (BME_BFI32(&AIPS_PACRP_REG(base), ((uint32_t)(value) << AIPS_PACRP_AC3_SHIFT), AIPS_PACRP_AC3_SHIFT, AIPS_PACRP_AC3_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRP, field RO3[19] (RW)
 *
 * Indicates the lock status of this register's AC3 field. After this field is
 * set to 1, it cannot be changed and attempted writes to AC3 are ignored until
 * the next system reset clears this field.
 *
 * Values:
 * - 0b0 - Writes to corresponding AC field are allowed.
 * - 0b1 - Writes to corresponding AC field are ignored.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRP_RO3 field. */
#define AIPS_RD_PACRP_RO3(base) ((AIPS_PACRP_REG(base) & AIPS_PACRP_RO3_MASK) >> AIPS_PACRP_RO3_SHIFT)
#define AIPS_BRD_PACRP_RO3(base) (BME_UBFX32(&AIPS_PACRP_REG(base), AIPS_PACRP_RO3_SHIFT, AIPS_PACRP_RO3_WIDTH))

/*! @brief Set the RO3 field to a new value. */
#define AIPS_WR_PACRP_RO3(base, value) (AIPS_RMW_PACRP(base, AIPS_PACRP_RO3_MASK, AIPS_PACRP_RO3(value)))
#define AIPS_BWR_PACRP_RO3(base, value) (BME_BFI32(&AIPS_PACRP_REG(base), ((uint32_t)(value) << AIPS_PACRP_RO3_SHIFT), AIPS_PACRP_RO3_SHIFT, AIPS_PACRP_RO3_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRP, field AC2[22:20] (RW)
 *
 * Defines the attributes required to access the corresponding slave
 * peripheral's memory space. See #pacr_attributes , "Attribute check (AC) values" for
 * details.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRP_AC2 field. */
#define AIPS_RD_PACRP_AC2(base) ((AIPS_PACRP_REG(base) & AIPS_PACRP_AC2_MASK) >> AIPS_PACRP_AC2_SHIFT)
#define AIPS_BRD_PACRP_AC2(base) (BME_UBFX32(&AIPS_PACRP_REG(base), AIPS_PACRP_AC2_SHIFT, AIPS_PACRP_AC2_WIDTH))

/*! @brief Set the AC2 field to a new value. */
#define AIPS_WR_PACRP_AC2(base, value) (AIPS_RMW_PACRP(base, AIPS_PACRP_AC2_MASK, AIPS_PACRP_AC2(value)))
#define AIPS_BWR_PACRP_AC2(base, value) (BME_BFI32(&AIPS_PACRP_REG(base), ((uint32_t)(value) << AIPS_PACRP_AC2_SHIFT), AIPS_PACRP_AC2_SHIFT, AIPS_PACRP_AC2_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRP, field RO2[23] (RW)
 *
 * Indicates the lock status of this register's AC2 field. After this field is
 * set to 1, it cannot be changed and attempted writes to AC2 are ignored until
 * the next system reset clears this field.
 *
 * Values:
 * - 0b0 - Writes to corresponding AC field are allowed.
 * - 0b1 - Writes to corresponding AC field are ignored.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRP_RO2 field. */
#define AIPS_RD_PACRP_RO2(base) ((AIPS_PACRP_REG(base) & AIPS_PACRP_RO2_MASK) >> AIPS_PACRP_RO2_SHIFT)
#define AIPS_BRD_PACRP_RO2(base) (BME_UBFX32(&AIPS_PACRP_REG(base), AIPS_PACRP_RO2_SHIFT, AIPS_PACRP_RO2_WIDTH))

/*! @brief Set the RO2 field to a new value. */
#define AIPS_WR_PACRP_RO2(base, value) (AIPS_RMW_PACRP(base, AIPS_PACRP_RO2_MASK, AIPS_PACRP_RO2(value)))
#define AIPS_BWR_PACRP_RO2(base, value) (BME_BFI32(&AIPS_PACRP_REG(base), ((uint32_t)(value) << AIPS_PACRP_RO2_SHIFT), AIPS_PACRP_RO2_SHIFT, AIPS_PACRP_RO2_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRP, field AC1[26:24] (RW)
 *
 * Defines the attributes required to access the corresponding slave
 * peripheral's memory space. See #pacr_attributes , "Attribute check (AC) values" for
 * details.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRP_AC1 field. */
#define AIPS_RD_PACRP_AC1(base) ((AIPS_PACRP_REG(base) & AIPS_PACRP_AC1_MASK) >> AIPS_PACRP_AC1_SHIFT)
#define AIPS_BRD_PACRP_AC1(base) (BME_UBFX32(&AIPS_PACRP_REG(base), AIPS_PACRP_AC1_SHIFT, AIPS_PACRP_AC1_WIDTH))

/*! @brief Set the AC1 field to a new value. */
#define AIPS_WR_PACRP_AC1(base, value) (AIPS_RMW_PACRP(base, AIPS_PACRP_AC1_MASK, AIPS_PACRP_AC1(value)))
#define AIPS_BWR_PACRP_AC1(base, value) (BME_BFI32(&AIPS_PACRP_REG(base), ((uint32_t)(value) << AIPS_PACRP_AC1_SHIFT), AIPS_PACRP_AC1_SHIFT, AIPS_PACRP_AC1_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRP, field RO1[27] (RW)
 *
 * Indicates the lock status of this register's AC1 field. After this field is
 * set to 1, it cannot be changed and attempted writes to AC1 are ignored until
 * the next system reset clears this field.
 *
 * Values:
 * - 0b0 - Writes to corresponding AC field are allowed.
 * - 0b1 - Writes to corresponding AC field are ignored.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRP_RO1 field. */
#define AIPS_RD_PACRP_RO1(base) ((AIPS_PACRP_REG(base) & AIPS_PACRP_RO1_MASK) >> AIPS_PACRP_RO1_SHIFT)
#define AIPS_BRD_PACRP_RO1(base) (BME_UBFX32(&AIPS_PACRP_REG(base), AIPS_PACRP_RO1_SHIFT, AIPS_PACRP_RO1_WIDTH))

/*! @brief Set the RO1 field to a new value. */
#define AIPS_WR_PACRP_RO1(base, value) (AIPS_RMW_PACRP(base, AIPS_PACRP_RO1_MASK, AIPS_PACRP_RO1(value)))
#define AIPS_BWR_PACRP_RO1(base, value) (BME_BFI32(&AIPS_PACRP_REG(base), ((uint32_t)(value) << AIPS_PACRP_RO1_SHIFT), AIPS_PACRP_RO1_SHIFT, AIPS_PACRP_RO1_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRP, field AC0[30:28] (RW)
 *
 * Defines the attributes required to access the corresponding slave
 * peripheral's memory space. See #pacr_attributes , "Attribute check (AC) values" for
 * details.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRP_AC0 field. */
#define AIPS_RD_PACRP_AC0(base) ((AIPS_PACRP_REG(base) & AIPS_PACRP_AC0_MASK) >> AIPS_PACRP_AC0_SHIFT)
#define AIPS_BRD_PACRP_AC0(base) (BME_UBFX32(&AIPS_PACRP_REG(base), AIPS_PACRP_AC0_SHIFT, AIPS_PACRP_AC0_WIDTH))

/*! @brief Set the AC0 field to a new value. */
#define AIPS_WR_PACRP_AC0(base, value) (AIPS_RMW_PACRP(base, AIPS_PACRP_AC0_MASK, AIPS_PACRP_AC0(value)))
#define AIPS_BWR_PACRP_AC0(base, value) (BME_BFI32(&AIPS_PACRP_REG(base), ((uint32_t)(value) << AIPS_PACRP_AC0_SHIFT), AIPS_PACRP_AC0_SHIFT, AIPS_PACRP_AC0_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRP, field RO0[31] (RW)
 *
 * Indicates the lock status of this register's AC0 field. After this field is
 * set to 1, it cannot be changed and attempted writes to AC0 are ignored until
 * the next system reset clears this field.
 *
 * Values:
 * - 0b0 - Writes to corresponding AC field are allowed.
 * - 0b1 - Writes to corresponding AC field are ignored.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRP_RO0 field. */
#define AIPS_RD_PACRP_RO0(base) ((AIPS_PACRP_REG(base) & AIPS_PACRP_RO0_MASK) >> AIPS_PACRP_RO0_SHIFT)
#define AIPS_BRD_PACRP_RO0(base) (BME_UBFX32(&AIPS_PACRP_REG(base), AIPS_PACRP_RO0_SHIFT, AIPS_PACRP_RO0_WIDTH))

/*! @brief Set the RO0 field to a new value. */
#define AIPS_WR_PACRP_RO0(base, value) (AIPS_RMW_PACRP(base, AIPS_PACRP_RO0_MASK, AIPS_PACRP_RO0(value)))
#define AIPS_BWR_PACRP_RO0(base, value) (BME_BFI32(&AIPS_PACRP_REG(base), ((uint32_t)(value) << AIPS_PACRP_RO0_SHIFT), AIPS_PACRP_RO0_SHIFT, AIPS_PACRP_RO0_WIDTH))
/*@}*/

/*
 * MKM34Z7 CAU
 *
 * Memory Mapped Cryptographic Acceleration Unit (MMCAU)
 *
 * Registers defined in this header file:
 * - CAU_DIRECT - Direct access register 0
 * - CAU_LDR_CASR - Status register - Load Register command
 * - CAU_LDR_CAA - Accumulator register - Load Register command
 * - CAU_LDR_CA - General Purpose Register 0 - Load Register command
 * - CAU_STR_CASR - Status register - Store Register command
 * - CAU_STR_CAA - Accumulator register - Store Register command
 * - CAU_STR_CA - General Purpose Register 0 - Store Register command
 * - CAU_ADR_CASR - Status register - Add Register command
 * - CAU_ADR_CAA - Accumulator register - Add to register command
 * - CAU_ADR_CA - General Purpose Register 0 - Add to register command
 * - CAU_RADR_CASR - Status register - Reverse and Add to Register command
 * - CAU_RADR_CAA - Accumulator register - Reverse and Add to Register command
 * - CAU_RADR_CA - General Purpose Register 0 - Reverse and Add to Register command
 * - CAU_XOR_CASR - Status register - Exclusive Or command
 * - CAU_XOR_CAA - Accumulator register - Exclusive Or command
 * - CAU_XOR_CA - General Purpose Register 0 - Exclusive Or command
 * - CAU_ROTL_CASR - Status register - Rotate Left command
 * - CAU_ROTL_CAA - Accumulator register - Rotate Left command
 * - CAU_ROTL_CA - General Purpose Register 0 - Rotate Left command
 * - CAU_AESC_CASR - Status register - AES Column Operation command
 * - CAU_AESC_CAA - Accumulator register - AES Column Operation command
 * - CAU_AESC_CA - General Purpose Register 0 - AES Column Operation command
 * - CAU_AESIC_CASR - Status register - AES Inverse Column Operation command
 * - CAU_AESIC_CAA - Accumulator register - AES Inverse Column Operation command
 * - CAU_AESIC_CA - General Purpose Register 0 - AES Inverse Column Operation command
 */

#define CAU_INSTANCE_COUNT (1U) /*!< Number of instances of the CAU module. */
#define CAU_IDX (0U) /*!< Instance number for CAU. */

/*******************************************************************************
 * CAU_DIRECT - Direct access register 0
 ******************************************************************************/

/*!
 * @brief CAU_DIRECT - Direct access register 0 (WO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire CAU_DIRECT register
 */
/*@{*/
#define CAU_WR_DIRECT(base, index, value) (CAU_DIRECT_REG(base, index) = (value))
/*@}*/

/*******************************************************************************
 * CAU_LDR_CASR - Status register - Load Register command
 ******************************************************************************/

/*!
 * @brief CAU_LDR_CASR - Status register - Load Register command (WO)
 *
 * Reset value: 0x20000000U
 */
/*!
 * @name Constants and macros for entire CAU_LDR_CASR register
 */
/*@{*/
#define CAU_WR_LDR_CASR(base, value) (CAU_LDR_CASR_REG(base) = (value))
/*@}*/

/*
 * Constants & macros for individual CAU_LDR_CASR bitfields
 */

/*!
 * @name Register CAU_LDR_CASR, field IC[0] (WO)
 *
 * Values:
 * - 0b0 - No illegal commands issued
 * - 0b1 - Illegal command issued
 */
/*@{*/
/*! @brief Set the IC field to a new value. */
#define CAU_WR_LDR_CASR_IC(base, value) (CAU_WR_LDR_CASR(base, CAU_LDR_CASR_IC(value)))
#define CAU_BWR_LDR_CASR_IC(base, value) (CAU_WR_LDR_CASR_IC(base, value))
/*@}*/

/*!
 * @name Register CAU_LDR_CASR, field DPE[1] (WO)
 *
 * Values:
 * - 0b0 - No error detected
 * - 0b1 - DES key parity error detected
 */
/*@{*/
/*! @brief Set the DPE field to a new value. */
#define CAU_WR_LDR_CASR_DPE(base, value) (CAU_WR_LDR_CASR(base, CAU_LDR_CASR_DPE(value)))
#define CAU_BWR_LDR_CASR_DPE(base, value) (CAU_WR_LDR_CASR_DPE(base, value))
/*@}*/

/*!
 * @name Register CAU_LDR_CASR, field VER[31:28] (WO)
 *
 * Values:
 * - 0b0001 - Initial CAU version
 * - 0b0010 - Second version, added support for SHA-256 algorithm.(This is the
 *     value on this device)
 */
/*@{*/
/*! @brief Set the VER field to a new value. */
#define CAU_WR_LDR_CASR_VER(base, value) (CAU_WR_LDR_CASR(base, CAU_LDR_CASR_VER(value)))
#define CAU_BWR_LDR_CASR_VER(base, value) (CAU_WR_LDR_CASR_VER(base, value))
/*@}*/

/*******************************************************************************
 * CAU_LDR_CAA - Accumulator register - Load Register command
 ******************************************************************************/

/*!
 * @brief CAU_LDR_CAA - Accumulator register - Load Register command (WO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire CAU_LDR_CAA register
 */
/*@{*/
#define CAU_WR_LDR_CAA(base, value) (CAU_LDR_CAA_REG(base) = (value))
/*@}*/

/*******************************************************************************
 * CAU_LDR_CA - General Purpose Register 0 - Load Register command
 ******************************************************************************/

/*!
 * @brief CAU_LDR_CA - General Purpose Register 0 - Load Register command (WO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire CAU_LDR_CA register
 */
/*@{*/
#define CAU_WR_LDR_CA(base, index, value) (CAU_LDR_CA_REG(base, index) = (value))
/*@}*/

/*******************************************************************************
 * CAU_STR_CASR - Status register - Store Register command
 ******************************************************************************/

/*!
 * @brief CAU_STR_CASR - Status register - Store Register command (RO)
 *
 * Reset value: 0x20000000U
 */
/*!
 * @name Constants and macros for entire CAU_STR_CASR register
 */
/*@{*/
#define CAU_RD_STR_CASR(base)    (CAU_STR_CASR_REG(base))
/*@}*/

/*
 * Constants & macros for individual CAU_STR_CASR bitfields
 */

/*!
 * @name Register CAU_STR_CASR, field IC[0] (RO)
 *
 * Values:
 * - 0b0 - No illegal commands issued
 * - 0b1 - Illegal command issued
 */
/*@{*/
/*! @brief Read current value of the CAU_STR_CASR_IC field. */
#define CAU_RD_STR_CASR_IC(base) ((CAU_STR_CASR_REG(base) & CAU_STR_CASR_IC_MASK) >> CAU_STR_CASR_IC_SHIFT)
#define CAU_BRD_STR_CASR_IC(base) (CAU_RD_STR_CASR_IC(base))
/*@}*/

/*!
 * @name Register CAU_STR_CASR, field DPE[1] (RO)
 *
 * Values:
 * - 0b0 - No error detected
 * - 0b1 - DES key parity error detected
 */
/*@{*/
/*! @brief Read current value of the CAU_STR_CASR_DPE field. */
#define CAU_RD_STR_CASR_DPE(base) ((CAU_STR_CASR_REG(base) & CAU_STR_CASR_DPE_MASK) >> CAU_STR_CASR_DPE_SHIFT)
#define CAU_BRD_STR_CASR_DPE(base) (CAU_RD_STR_CASR_DPE(base))
/*@}*/

/*!
 * @name Register CAU_STR_CASR, field VER[31:28] (RO)
 *
 * Values:
 * - 0b0001 - Initial CAU version
 * - 0b0010 - Second version, added support for SHA-256 algorithm.(This is the
 *     value on this device)
 */
/*@{*/
/*! @brief Read current value of the CAU_STR_CASR_VER field. */
#define CAU_RD_STR_CASR_VER(base) ((CAU_STR_CASR_REG(base) & CAU_STR_CASR_VER_MASK) >> CAU_STR_CASR_VER_SHIFT)
#define CAU_BRD_STR_CASR_VER(base) (CAU_RD_STR_CASR_VER(base))
/*@}*/

/*******************************************************************************
 * CAU_STR_CAA - Accumulator register - Store Register command
 ******************************************************************************/

/*!
 * @brief CAU_STR_CAA - Accumulator register - Store Register command (RO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire CAU_STR_CAA register
 */
/*@{*/
#define CAU_RD_STR_CAA(base)     (CAU_STR_CAA_REG(base))
/*@}*/

/*******************************************************************************
 * CAU_STR_CA - General Purpose Register 0 - Store Register command
 ******************************************************************************/

/*!
 * @brief CAU_STR_CA - General Purpose Register 0 - Store Register command (RO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire CAU_STR_CA register
 */
/*@{*/
#define CAU_RD_STR_CA(base, index) (CAU_STR_CA_REG(base, index))
/*@}*/

/*******************************************************************************
 * CAU_ADR_CASR - Status register - Add Register command
 ******************************************************************************/

/*!
 * @brief CAU_ADR_CASR - Status register - Add Register command (WO)
 *
 * Reset value: 0x20000000U
 */
/*!
 * @name Constants and macros for entire CAU_ADR_CASR register
 */
/*@{*/
#define CAU_WR_ADR_CASR(base, value) (CAU_ADR_CASR_REG(base) = (value))
/*@}*/

/*
 * Constants & macros for individual CAU_ADR_CASR bitfields
 */

/*!
 * @name Register CAU_ADR_CASR, field IC[0] (WO)
 *
 * Values:
 * - 0b0 - No illegal commands issued
 * - 0b1 - Illegal command issued
 */
/*@{*/
/*! @brief Set the IC field to a new value. */
#define CAU_WR_ADR_CASR_IC(base, value) (CAU_WR_ADR_CASR(base, CAU_ADR_CASR_IC(value)))
#define CAU_BWR_ADR_CASR_IC(base, value) (CAU_WR_ADR_CASR_IC(base, value))
/*@}*/

/*!
 * @name Register CAU_ADR_CASR, field DPE[1] (WO)
 *
 * Values:
 * - 0b0 - No error detected
 * - 0b1 - DES key parity error detected
 */
/*@{*/
/*! @brief Set the DPE field to a new value. */
#define CAU_WR_ADR_CASR_DPE(base, value) (CAU_WR_ADR_CASR(base, CAU_ADR_CASR_DPE(value)))
#define CAU_BWR_ADR_CASR_DPE(base, value) (CAU_WR_ADR_CASR_DPE(base, value))
/*@}*/

/*!
 * @name Register CAU_ADR_CASR, field VER[31:28] (WO)
 *
 * Values:
 * - 0b0001 - Initial CAU version
 * - 0b0010 - Second version, added support for SHA-256 algorithm.(This is the
 *     value on this device)
 */
/*@{*/
/*! @brief Set the VER field to a new value. */
#define CAU_WR_ADR_CASR_VER(base, value) (CAU_WR_ADR_CASR(base, CAU_ADR_CASR_VER(value)))
#define CAU_BWR_ADR_CASR_VER(base, value) (CAU_WR_ADR_CASR_VER(base, value))
/*@}*/

/*******************************************************************************
 * CAU_ADR_CAA - Accumulator register - Add to register command
 ******************************************************************************/

/*!
 * @brief CAU_ADR_CAA - Accumulator register - Add to register command (WO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire CAU_ADR_CAA register
 */
/*@{*/
#define CAU_WR_ADR_CAA(base, value) (CAU_ADR_CAA_REG(base) = (value))
/*@}*/

/*******************************************************************************
 * CAU_ADR_CA - General Purpose Register 0 - Add to register command
 ******************************************************************************/

/*!
 * @brief CAU_ADR_CA - General Purpose Register 0 - Add to register command (WO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire CAU_ADR_CA register
 */
/*@{*/
#define CAU_WR_ADR_CA(base, index, value) (CAU_ADR_CA_REG(base, index) = (value))
/*@}*/

/*******************************************************************************
 * CAU_RADR_CASR - Status register - Reverse and Add to Register command
 ******************************************************************************/

/*!
 * @brief CAU_RADR_CASR - Status register - Reverse and Add to Register command (WO)
 *
 * Reset value: 0x20000000U
 */
/*!
 * @name Constants and macros for entire CAU_RADR_CASR register
 */
/*@{*/
#define CAU_WR_RADR_CASR(base, value) (CAU_RADR_CASR_REG(base) = (value))
/*@}*/

/*
 * Constants & macros for individual CAU_RADR_CASR bitfields
 */

/*!
 * @name Register CAU_RADR_CASR, field IC[0] (WO)
 *
 * Values:
 * - 0b0 - No illegal commands issued
 * - 0b1 - Illegal command issued
 */
/*@{*/
/*! @brief Set the IC field to a new value. */
#define CAU_WR_RADR_CASR_IC(base, value) (CAU_WR_RADR_CASR(base, CAU_RADR_CASR_IC(value)))
#define CAU_BWR_RADR_CASR_IC(base, value) (CAU_WR_RADR_CASR_IC(base, value))
/*@}*/

/*!
 * @name Register CAU_RADR_CASR, field DPE[1] (WO)
 *
 * Values:
 * - 0b0 - No error detected
 * - 0b1 - DES key parity error detected
 */
/*@{*/
/*! @brief Set the DPE field to a new value. */
#define CAU_WR_RADR_CASR_DPE(base, value) (CAU_WR_RADR_CASR(base, CAU_RADR_CASR_DPE(value)))
#define CAU_BWR_RADR_CASR_DPE(base, value) (CAU_WR_RADR_CASR_DPE(base, value))
/*@}*/

/*!
 * @name Register CAU_RADR_CASR, field VER[31:28] (WO)
 *
 * Values:
 * - 0b0001 - Initial CAU version
 * - 0b0010 - Second version, added support for SHA-256 algorithm.(This is the
 *     value on this device)
 */
/*@{*/
/*! @brief Set the VER field to a new value. */
#define CAU_WR_RADR_CASR_VER(base, value) (CAU_WR_RADR_CASR(base, CAU_RADR_CASR_VER(value)))
#define CAU_BWR_RADR_CASR_VER(base, value) (CAU_WR_RADR_CASR_VER(base, value))
/*@}*/

/*******************************************************************************
 * CAU_RADR_CAA - Accumulator register - Reverse and Add to Register command
 ******************************************************************************/

/*!
 * @brief CAU_RADR_CAA - Accumulator register - Reverse and Add to Register command (WO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire CAU_RADR_CAA register
 */
/*@{*/
#define CAU_WR_RADR_CAA(base, value) (CAU_RADR_CAA_REG(base) = (value))
/*@}*/

/*******************************************************************************
 * CAU_RADR_CA - General Purpose Register 0 - Reverse and Add to Register command
 ******************************************************************************/

/*!
 * @brief CAU_RADR_CA - General Purpose Register 0 - Reverse and Add to Register command (WO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire CAU_RADR_CA register
 */
/*@{*/
#define CAU_WR_RADR_CA(base, index, value) (CAU_RADR_CA_REG(base, index) = (value))
/*@}*/

/*******************************************************************************
 * CAU_XOR_CASR - Status register - Exclusive Or command
 ******************************************************************************/

/*!
 * @brief CAU_XOR_CASR - Status register - Exclusive Or command (WO)
 *
 * Reset value: 0x20000000U
 */
/*!
 * @name Constants and macros for entire CAU_XOR_CASR register
 */
/*@{*/
#define CAU_WR_XOR_CASR(base, value) (CAU_XOR_CASR_REG(base) = (value))
/*@}*/

/*
 * Constants & macros for individual CAU_XOR_CASR bitfields
 */

/*!
 * @name Register CAU_XOR_CASR, field IC[0] (WO)
 *
 * Values:
 * - 0b0 - No illegal commands issued
 * - 0b1 - Illegal command issued
 */
/*@{*/
/*! @brief Set the IC field to a new value. */
#define CAU_WR_XOR_CASR_IC(base, value) (CAU_WR_XOR_CASR(base, CAU_XOR_CASR_IC(value)))
#define CAU_BWR_XOR_CASR_IC(base, value) (CAU_WR_XOR_CASR_IC(base, value))
/*@}*/

/*!
 * @name Register CAU_XOR_CASR, field DPE[1] (WO)
 *
 * Values:
 * - 0b0 - No error detected
 * - 0b1 - DES key parity error detected
 */
/*@{*/
/*! @brief Set the DPE field to a new value. */
#define CAU_WR_XOR_CASR_DPE(base, value) (CAU_WR_XOR_CASR(base, CAU_XOR_CASR_DPE(value)))
#define CAU_BWR_XOR_CASR_DPE(base, value) (CAU_WR_XOR_CASR_DPE(base, value))
/*@}*/

/*!
 * @name Register CAU_XOR_CASR, field VER[31:28] (WO)
 *
 * Values:
 * - 0b0001 - Initial CAU version
 * - 0b0010 - Second version, added support for SHA-256 algorithm.(This is the
 *     value on this device)
 */
/*@{*/
/*! @brief Set the VER field to a new value. */
#define CAU_WR_XOR_CASR_VER(base, value) (CAU_WR_XOR_CASR(base, CAU_XOR_CASR_VER(value)))
#define CAU_BWR_XOR_CASR_VER(base, value) (CAU_WR_XOR_CASR_VER(base, value))
/*@}*/

/*******************************************************************************
 * CAU_XOR_CAA - Accumulator register - Exclusive Or command
 ******************************************************************************/

/*!
 * @brief CAU_XOR_CAA - Accumulator register - Exclusive Or command (WO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire CAU_XOR_CAA register
 */
/*@{*/
#define CAU_WR_XOR_CAA(base, value) (CAU_XOR_CAA_REG(base) = (value))
/*@}*/

/*******************************************************************************
 * CAU_XOR_CA - General Purpose Register 0 - Exclusive Or command
 ******************************************************************************/

/*!
 * @brief CAU_XOR_CA - General Purpose Register 0 - Exclusive Or command (WO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire CAU_XOR_CA register
 */
/*@{*/
#define CAU_WR_XOR_CA(base, index, value) (CAU_XOR_CA_REG(base, index) = (value))
/*@}*/

/*******************************************************************************
 * CAU_ROTL_CASR - Status register - Rotate Left command
 ******************************************************************************/

/*!
 * @brief CAU_ROTL_CASR - Status register - Rotate Left command (WO)
 *
 * Reset value: 0x20000000U
 */
/*!
 * @name Constants and macros for entire CAU_ROTL_CASR register
 */
/*@{*/
#define CAU_WR_ROTL_CASR(base, value) (CAU_ROTL_CASR_REG(base) = (value))
/*@}*/

/*
 * Constants & macros for individual CAU_ROTL_CASR bitfields
 */

/*!
 * @name Register CAU_ROTL_CASR, field IC[0] (WO)
 *
 * Values:
 * - 0b0 - No illegal commands issued
 * - 0b1 - Illegal command issued
 */
/*@{*/
/*! @brief Set the IC field to a new value. */
#define CAU_WR_ROTL_CASR_IC(base, value) (CAU_WR_ROTL_CASR(base, CAU_ROTL_CASR_IC(value)))
#define CAU_BWR_ROTL_CASR_IC(base, value) (CAU_WR_ROTL_CASR_IC(base, value))
/*@}*/

/*!
 * @name Register CAU_ROTL_CASR, field DPE[1] (WO)
 *
 * Values:
 * - 0b0 - No error detected
 * - 0b1 - DES key parity error detected
 */
/*@{*/
/*! @brief Set the DPE field to a new value. */
#define CAU_WR_ROTL_CASR_DPE(base, value) (CAU_WR_ROTL_CASR(base, CAU_ROTL_CASR_DPE(value)))
#define CAU_BWR_ROTL_CASR_DPE(base, value) (CAU_WR_ROTL_CASR_DPE(base, value))
/*@}*/

/*!
 * @name Register CAU_ROTL_CASR, field VER[31:28] (WO)
 *
 * Values:
 * - 0b0001 - Initial CAU version
 * - 0b0010 - Second version, added support for SHA-256 algorithm.(This is the
 *     value on this device)
 */
/*@{*/
/*! @brief Set the VER field to a new value. */
#define CAU_WR_ROTL_CASR_VER(base, value) (CAU_WR_ROTL_CASR(base, CAU_ROTL_CASR_VER(value)))
#define CAU_BWR_ROTL_CASR_VER(base, value) (CAU_WR_ROTL_CASR_VER(base, value))
/*@}*/

/*******************************************************************************
 * CAU_ROTL_CAA - Accumulator register - Rotate Left command
 ******************************************************************************/

/*!
 * @brief CAU_ROTL_CAA - Accumulator register - Rotate Left command (WO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire CAU_ROTL_CAA register
 */
/*@{*/
#define CAU_WR_ROTL_CAA(base, value) (CAU_ROTL_CAA_REG(base) = (value))
/*@}*/

/*******************************************************************************
 * CAU_ROTL_CA - General Purpose Register 0 - Rotate Left command
 ******************************************************************************/

/*!
 * @brief CAU_ROTL_CA - General Purpose Register 0 - Rotate Left command (WO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire CAU_ROTL_CA register
 */
/*@{*/
#define CAU_WR_ROTL_CA(base, index, value) (CAU_ROTL_CA_REG(base, index) = (value))
/*@}*/

/*******************************************************************************
 * CAU_AESC_CASR - Status register - AES Column Operation command
 ******************************************************************************/

/*!
 * @brief CAU_AESC_CASR - Status register - AES Column Operation command (WO)
 *
 * Reset value: 0x20000000U
 */
/*!
 * @name Constants and macros for entire CAU_AESC_CASR register
 */
/*@{*/
#define CAU_WR_AESC_CASR(base, value) (CAU_AESC_CASR_REG(base) = (value))
/*@}*/

/*
 * Constants & macros for individual CAU_AESC_CASR bitfields
 */

/*!
 * @name Register CAU_AESC_CASR, field IC[0] (WO)
 *
 * Values:
 * - 0b0 - No illegal commands issued
 * - 0b1 - Illegal command issued
 */
/*@{*/
/*! @brief Set the IC field to a new value. */
#define CAU_WR_AESC_CASR_IC(base, value) (CAU_WR_AESC_CASR(base, CAU_AESC_CASR_IC(value)))
#define CAU_BWR_AESC_CASR_IC(base, value) (CAU_WR_AESC_CASR_IC(base, value))
/*@}*/

/*!
 * @name Register CAU_AESC_CASR, field DPE[1] (WO)
 *
 * Values:
 * - 0b0 - No error detected
 * - 0b1 - DES key parity error detected
 */
/*@{*/
/*! @brief Set the DPE field to a new value. */
#define CAU_WR_AESC_CASR_DPE(base, value) (CAU_WR_AESC_CASR(base, CAU_AESC_CASR_DPE(value)))
#define CAU_BWR_AESC_CASR_DPE(base, value) (CAU_WR_AESC_CASR_DPE(base, value))
/*@}*/

/*!
 * @name Register CAU_AESC_CASR, field VER[31:28] (WO)
 *
 * Values:
 * - 0b0001 - Initial CAU version
 * - 0b0010 - Second version, added support for SHA-256 algorithm.(This is the
 *     value on this device)
 */
/*@{*/
/*! @brief Set the VER field to a new value. */
#define CAU_WR_AESC_CASR_VER(base, value) (CAU_WR_AESC_CASR(base, CAU_AESC_CASR_VER(value)))
#define CAU_BWR_AESC_CASR_VER(base, value) (CAU_WR_AESC_CASR_VER(base, value))
/*@}*/

/*******************************************************************************
 * CAU_AESC_CAA - Accumulator register - AES Column Operation command
 ******************************************************************************/

/*!
 * @brief CAU_AESC_CAA - Accumulator register - AES Column Operation command (WO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire CAU_AESC_CAA register
 */
/*@{*/
#define CAU_WR_AESC_CAA(base, value) (CAU_AESC_CAA_REG(base) = (value))
/*@}*/

/*******************************************************************************
 * CAU_AESC_CA - General Purpose Register 0 - AES Column Operation command
 ******************************************************************************/

/*!
 * @brief CAU_AESC_CA - General Purpose Register 0 - AES Column Operation command (WO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire CAU_AESC_CA register
 */
/*@{*/
#define CAU_WR_AESC_CA(base, index, value) (CAU_AESC_CA_REG(base, index) = (value))
/*@}*/

/*******************************************************************************
 * CAU_AESIC_CASR - Status register - AES Inverse Column Operation command
 ******************************************************************************/

/*!
 * @brief CAU_AESIC_CASR - Status register - AES Inverse Column Operation command (WO)
 *
 * Reset value: 0x20000000U
 */
/*!
 * @name Constants and macros for entire CAU_AESIC_CASR register
 */
/*@{*/
#define CAU_WR_AESIC_CASR(base, value) (CAU_AESIC_CASR_REG(base) = (value))
/*@}*/

/*
 * Constants & macros for individual CAU_AESIC_CASR bitfields
 */

/*!
 * @name Register CAU_AESIC_CASR, field IC[0] (WO)
 *
 * Values:
 * - 0b0 - No illegal commands issued
 * - 0b1 - Illegal command issued
 */
/*@{*/
/*! @brief Set the IC field to a new value. */
#define CAU_WR_AESIC_CASR_IC(base, value) (CAU_WR_AESIC_CASR(base, CAU_AESIC_CASR_IC(value)))
#define CAU_BWR_AESIC_CASR_IC(base, value) (CAU_WR_AESIC_CASR_IC(base, value))
/*@}*/

/*!
 * @name Register CAU_AESIC_CASR, field DPE[1] (WO)
 *
 * Values:
 * - 0b0 - No error detected
 * - 0b1 - DES key parity error detected
 */
/*@{*/
/*! @brief Set the DPE field to a new value. */
#define CAU_WR_AESIC_CASR_DPE(base, value) (CAU_WR_AESIC_CASR(base, CAU_AESIC_CASR_DPE(value)))
#define CAU_BWR_AESIC_CASR_DPE(base, value) (CAU_WR_AESIC_CASR_DPE(base, value))
/*@}*/

/*!
 * @name Register CAU_AESIC_CASR, field VER[31:28] (WO)
 *
 * Values:
 * - 0b0001 - Initial CAU version
 * - 0b0010 - Second version, added support for SHA-256 algorithm.(This is the
 *     value on this device)
 */
/*@{*/
/*! @brief Set the VER field to a new value. */
#define CAU_WR_AESIC_CASR_VER(base, value) (CAU_WR_AESIC_CASR(base, CAU_AESIC_CASR_VER(value)))
#define CAU_BWR_AESIC_CASR_VER(base, value) (CAU_WR_AESIC_CASR_VER(base, value))
/*@}*/

/*******************************************************************************
 * CAU_AESIC_CAA - Accumulator register - AES Inverse Column Operation command
 ******************************************************************************/

/*!
 * @brief CAU_AESIC_CAA - Accumulator register - AES Inverse Column Operation command (WO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire CAU_AESIC_CAA register
 */
/*@{*/
#define CAU_WR_AESIC_CAA(base, value) (CAU_AESIC_CAA_REG(base) = (value))
/*@}*/

/*******************************************************************************
 * CAU_AESIC_CA - General Purpose Register 0 - AES Inverse Column Operation command
 ******************************************************************************/

/*!
 * @brief CAU_AESIC_CA - General Purpose Register 0 - AES Inverse Column Operation command (WO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire CAU_AESIC_CA register
 */
/*@{*/
#define CAU_WR_AESIC_CA(base, index, value) (CAU_AESIC_CA_REG(base, index) = (value))
/*@}*/

/*
 * MKM34Z7 CMP
 *
 * High-Speed Comparator (CMP), Voltage Reference (VREF) Digital-to-Analog Converter (DAC), and Analog Mux (ANMUX)
 *
 * Registers defined in this header file:
 * - CMP_CR0 - CMP Control Register 0
 * - CMP_CR1 - CMP Control Register 1
 * - CMP_FPR - CMP Filter Period Register
 * - CMP_SCR - CMP Status and Control Register
 * - CMP_DACCR - DAC Control Register
 * - CMP_MUXCR - MUX Control Register
 */

#define CMP_INSTANCE_COUNT (3U) /*!< Number of instances of the CMP module. */
#define CMP0_IDX (0U) /*!< Instance number for CMP0. */
#define CMP1_IDX (1U) /*!< Instance number for CMP1. */
#define CMP2_IDX (2U) /*!< Instance number for CMP2. */

/*******************************************************************************
 * CMP_CR0 - CMP Control Register 0
 ******************************************************************************/

/*!
 * @brief CMP_CR0 - CMP Control Register 0 (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire CMP_CR0 register
 */
/*@{*/
#define CMP_RD_CR0(base)         (CMP_CR0_REG(base))
#define CMP_WR_CR0(base, value)  (CMP_CR0_REG(base) = (value))
#define CMP_RMW_CR0(base, mask, value) (CMP_WR_CR0(base, (CMP_RD_CR0(base) & ~(mask)) | (value)))
#define CMP_SET_CR0(base, value) (BME_OR8(&CMP_CR0_REG(base), (uint8_t)(value)))
#define CMP_CLR_CR0(base, value) (BME_AND8(&CMP_CR0_REG(base), (uint8_t)(~(value))))
#define CMP_TOG_CR0(base, value) (BME_XOR8(&CMP_CR0_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual CMP_CR0 bitfields
 */

/*!
 * @name Register CMP_CR0, field HYSTCTR[1:0] (RW)
 *
 * Defines the programmable hysteresis level. The hysteresis values associated
 * with each level are device-specific. See the Data Sheet of the device for the
 * exact values.
 *
 * Values:
 * - 0b00 - Level 0
 * - 0b01 - Level 1
 * - 0b10 - Level 2
 * - 0b11 - Level 3
 */
/*@{*/
/*! @brief Read current value of the CMP_CR0_HYSTCTR field. */
#define CMP_RD_CR0_HYSTCTR(base) ((CMP_CR0_REG(base) & CMP_CR0_HYSTCTR_MASK) >> CMP_CR0_HYSTCTR_SHIFT)
#define CMP_BRD_CR0_HYSTCTR(base) (BME_UBFX8(&CMP_CR0_REG(base), CMP_CR0_HYSTCTR_SHIFT, CMP_CR0_HYSTCTR_WIDTH))

/*! @brief Set the HYSTCTR field to a new value. */
#define CMP_WR_CR0_HYSTCTR(base, value) (CMP_RMW_CR0(base, CMP_CR0_HYSTCTR_MASK, CMP_CR0_HYSTCTR(value)))
#define CMP_BWR_CR0_HYSTCTR(base, value) (BME_BFI8(&CMP_CR0_REG(base), ((uint8_t)(value) << CMP_CR0_HYSTCTR_SHIFT), CMP_CR0_HYSTCTR_SHIFT, CMP_CR0_HYSTCTR_WIDTH))
/*@}*/

/*!
 * @name Register CMP_CR0, field FILTER_CNT[6:4] (RW)
 *
 * Represents the number of consecutive samples that must agree prior to the
 * comparator ouput filter accepting a new output state. For information regarding
 * filter programming and latency, see the Functional descriptionThe CMP module
 * can be used to compare two analog input voltages applied to INP and INM. .
 *
 * Values:
 * - 0b000 - Filter is disabled. If SE = 1, then COUT is a logic 0. This is not
 *     a legal state, and is not recommended. If SE = 0, COUT = COUTA.
 * - 0b001 - One sample must agree. The comparator output is simply sampled.
 * - 0b010 - 2 consecutive samples must agree.
 * - 0b011 - 3 consecutive samples must agree.
 * - 0b100 - 4 consecutive samples must agree.
 * - 0b101 - 5 consecutive samples must agree.
 * - 0b110 - 6 consecutive samples must agree.
 * - 0b111 - 7 consecutive samples must agree.
 */
/*@{*/
/*! @brief Read current value of the CMP_CR0_FILTER_CNT field. */
#define CMP_RD_CR0_FILTER_CNT(base) ((CMP_CR0_REG(base) & CMP_CR0_FILTER_CNT_MASK) >> CMP_CR0_FILTER_CNT_SHIFT)
#define CMP_BRD_CR0_FILTER_CNT(base) (BME_UBFX8(&CMP_CR0_REG(base), CMP_CR0_FILTER_CNT_SHIFT, CMP_CR0_FILTER_CNT_WIDTH))

/*! @brief Set the FILTER_CNT field to a new value. */
#define CMP_WR_CR0_FILTER_CNT(base, value) (CMP_RMW_CR0(base, CMP_CR0_FILTER_CNT_MASK, CMP_CR0_FILTER_CNT(value)))
#define CMP_BWR_CR0_FILTER_CNT(base, value) (BME_BFI8(&CMP_CR0_REG(base), ((uint8_t)(value) << CMP_CR0_FILTER_CNT_SHIFT), CMP_CR0_FILTER_CNT_SHIFT, CMP_CR0_FILTER_CNT_WIDTH))
/*@}*/

/*******************************************************************************
 * CMP_CR1 - CMP Control Register 1
 ******************************************************************************/

/*!
 * @brief CMP_CR1 - CMP Control Register 1 (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire CMP_CR1 register
 */
/*@{*/
#define CMP_RD_CR1(base)         (CMP_CR1_REG(base))
#define CMP_WR_CR1(base, value)  (CMP_CR1_REG(base) = (value))
#define CMP_RMW_CR1(base, mask, value) (CMP_WR_CR1(base, (CMP_RD_CR1(base) & ~(mask)) | (value)))
#define CMP_SET_CR1(base, value) (BME_OR8(&CMP_CR1_REG(base), (uint8_t)(value)))
#define CMP_CLR_CR1(base, value) (BME_AND8(&CMP_CR1_REG(base), (uint8_t)(~(value))))
#define CMP_TOG_CR1(base, value) (BME_XOR8(&CMP_CR1_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual CMP_CR1 bitfields
 */

/*!
 * @name Register CMP_CR1, field EN[0] (RW)
 *
 * Enables the Analog Comparator module. When the module is not enabled, it
 * remains in the off state, and consumes no power. When the user selects the same
 * input from analog mux to the positive and negative port, the comparator is
 * disabled automatically.
 *
 * Values:
 * - 0b0 - Analog Comparator is disabled.
 * - 0b1 - Analog Comparator is enabled.
 */
/*@{*/
/*! @brief Read current value of the CMP_CR1_EN field. */
#define CMP_RD_CR1_EN(base)  ((CMP_CR1_REG(base) & CMP_CR1_EN_MASK) >> CMP_CR1_EN_SHIFT)
#define CMP_BRD_CR1_EN(base) (BME_UBFX8(&CMP_CR1_REG(base), CMP_CR1_EN_SHIFT, CMP_CR1_EN_WIDTH))

/*! @brief Set the EN field to a new value. */
#define CMP_WR_CR1_EN(base, value) (CMP_RMW_CR1(base, CMP_CR1_EN_MASK, CMP_CR1_EN(value)))
#define CMP_BWR_CR1_EN(base, value) (BME_BFI8(&CMP_CR1_REG(base), ((uint8_t)(value) << CMP_CR1_EN_SHIFT), CMP_CR1_EN_SHIFT, CMP_CR1_EN_WIDTH))
/*@}*/

/*!
 * @name Register CMP_CR1, field OPE[1] (RW)
 *
 * Values:
 * - 0b0 - CMPO is not available on the associated CMPO output pin.
 * - 0b1 - CMPO is available on the associated CMPO output pin.
 */
/*@{*/
/*! @brief Read current value of the CMP_CR1_OPE field. */
#define CMP_RD_CR1_OPE(base) ((CMP_CR1_REG(base) & CMP_CR1_OPE_MASK) >> CMP_CR1_OPE_SHIFT)
#define CMP_BRD_CR1_OPE(base) (BME_UBFX8(&CMP_CR1_REG(base), CMP_CR1_OPE_SHIFT, CMP_CR1_OPE_WIDTH))

/*! @brief Set the OPE field to a new value. */
#define CMP_WR_CR1_OPE(base, value) (CMP_RMW_CR1(base, CMP_CR1_OPE_MASK, CMP_CR1_OPE(value)))
#define CMP_BWR_CR1_OPE(base, value) (BME_BFI8(&CMP_CR1_REG(base), ((uint8_t)(value) << CMP_CR1_OPE_SHIFT), CMP_CR1_OPE_SHIFT, CMP_CR1_OPE_WIDTH))
/*@}*/

/*!
 * @name Register CMP_CR1, field COS[2] (RW)
 *
 * Values:
 * - 0b0 - Set the filtered comparator output (CMPO) to equal COUT.
 * - 0b1 - Set the unfiltered comparator output (CMPO) to equal COUTA.
 */
/*@{*/
/*! @brief Read current value of the CMP_CR1_COS field. */
#define CMP_RD_CR1_COS(base) ((CMP_CR1_REG(base) & CMP_CR1_COS_MASK) >> CMP_CR1_COS_SHIFT)
#define CMP_BRD_CR1_COS(base) (BME_UBFX8(&CMP_CR1_REG(base), CMP_CR1_COS_SHIFT, CMP_CR1_COS_WIDTH))

/*! @brief Set the COS field to a new value. */
#define CMP_WR_CR1_COS(base, value) (CMP_RMW_CR1(base, CMP_CR1_COS_MASK, CMP_CR1_COS(value)))
#define CMP_BWR_CR1_COS(base, value) (BME_BFI8(&CMP_CR1_REG(base), ((uint8_t)(value) << CMP_CR1_COS_SHIFT), CMP_CR1_COS_SHIFT, CMP_CR1_COS_WIDTH))
/*@}*/

/*!
 * @name Register CMP_CR1, field INV[3] (RW)
 *
 * Allows selection of the polarity of the analog comparator function. It is
 * also driven to the COUT output, on both the device pin and as SCR[COUT], when
 * OPE=0.
 *
 * Values:
 * - 0b0 - Does not invert the comparator output.
 * - 0b1 - Inverts the comparator output.
 */
/*@{*/
/*! @brief Read current value of the CMP_CR1_INV field. */
#define CMP_RD_CR1_INV(base) ((CMP_CR1_REG(base) & CMP_CR1_INV_MASK) >> CMP_CR1_INV_SHIFT)
#define CMP_BRD_CR1_INV(base) (BME_UBFX8(&CMP_CR1_REG(base), CMP_CR1_INV_SHIFT, CMP_CR1_INV_WIDTH))

/*! @brief Set the INV field to a new value. */
#define CMP_WR_CR1_INV(base, value) (CMP_RMW_CR1(base, CMP_CR1_INV_MASK, CMP_CR1_INV(value)))
#define CMP_BWR_CR1_INV(base, value) (BME_BFI8(&CMP_CR1_REG(base), ((uint8_t)(value) << CMP_CR1_INV_SHIFT), CMP_CR1_INV_SHIFT, CMP_CR1_INV_WIDTH))
/*@}*/

/*!
 * @name Register CMP_CR1, field PMODE[4] (RW)
 *
 * See the electrical specifications table in the device Data Sheet for details.
 *
 * Values:
 * - 0b0 - Low-Speed (LS) Comparison mode selected. In this mode, CMP has slower
 *     output propagation delay and lower current consumption.
 * - 0b1 - High-Speed (HS) Comparison mode selected. In this mode, CMP has
 *     faster output propagation delay and higher current consumption.
 */
/*@{*/
/*! @brief Read current value of the CMP_CR1_PMODE field. */
#define CMP_RD_CR1_PMODE(base) ((CMP_CR1_REG(base) & CMP_CR1_PMODE_MASK) >> CMP_CR1_PMODE_SHIFT)
#define CMP_BRD_CR1_PMODE(base) (BME_UBFX8(&CMP_CR1_REG(base), CMP_CR1_PMODE_SHIFT, CMP_CR1_PMODE_WIDTH))

/*! @brief Set the PMODE field to a new value. */
#define CMP_WR_CR1_PMODE(base, value) (CMP_RMW_CR1(base, CMP_CR1_PMODE_MASK, CMP_CR1_PMODE(value)))
#define CMP_BWR_CR1_PMODE(base, value) (BME_BFI8(&CMP_CR1_REG(base), ((uint8_t)(value) << CMP_CR1_PMODE_SHIFT), CMP_CR1_PMODE_SHIFT, CMP_CR1_PMODE_WIDTH))
/*@}*/

/*!
 * @name Register CMP_CR1, field TRIGM[5] (RW)
 *
 * CMP and DAC are configured to CMP Trigger mode when CMP_CR1[TRIGM] is set to
 * 1. In addition, the CMP should be enabled. If the DAC is to be used as a
 * reference to the CMP, it should also be enabled. CMP Trigger mode depends on an
 * external timer resource to periodically enable the CMP and 6-bit DAC in order to
 * generate a triggered compare. Upon setting TRIGM, the CMP and DAC are placed
 * in a standby state until an external timer resource trigger is received. See
 * the chip configuration for details about the external timer resource.
 *
 * Values:
 * - 0b0 - Trigger mode is disabled.
 * - 0b1 - Trigger mode is enabled.
 */
/*@{*/
/*! @brief Read current value of the CMP_CR1_TRIGM field. */
#define CMP_RD_CR1_TRIGM(base) ((CMP_CR1_REG(base) & CMP_CR1_TRIGM_MASK) >> CMP_CR1_TRIGM_SHIFT)
#define CMP_BRD_CR1_TRIGM(base) (BME_UBFX8(&CMP_CR1_REG(base), CMP_CR1_TRIGM_SHIFT, CMP_CR1_TRIGM_WIDTH))

/*! @brief Set the TRIGM field to a new value. */
#define CMP_WR_CR1_TRIGM(base, value) (CMP_RMW_CR1(base, CMP_CR1_TRIGM_MASK, CMP_CR1_TRIGM(value)))
#define CMP_BWR_CR1_TRIGM(base, value) (BME_BFI8(&CMP_CR1_REG(base), ((uint8_t)(value) << CMP_CR1_TRIGM_SHIFT), CMP_CR1_TRIGM_SHIFT, CMP_CR1_TRIGM_WIDTH))
/*@}*/

/*!
 * @name Register CMP_CR1, field WE[6] (RW)
 *
 * At any given time, either SE or WE can be set.
 *
 * Values:
 * - 0b0 - Windowing mode is not selected.
 * - 0b1 - Windowing mode is selected.
 */
/*@{*/
/*! @brief Read current value of the CMP_CR1_WE field. */
#define CMP_RD_CR1_WE(base)  ((CMP_CR1_REG(base) & CMP_CR1_WE_MASK) >> CMP_CR1_WE_SHIFT)
#define CMP_BRD_CR1_WE(base) (BME_UBFX8(&CMP_CR1_REG(base), CMP_CR1_WE_SHIFT, CMP_CR1_WE_WIDTH))

/*! @brief Set the WE field to a new value. */
#define CMP_WR_CR1_WE(base, value) (CMP_RMW_CR1(base, CMP_CR1_WE_MASK, CMP_CR1_WE(value)))
#define CMP_BWR_CR1_WE(base, value) (BME_BFI8(&CMP_CR1_REG(base), ((uint8_t)(value) << CMP_CR1_WE_SHIFT), CMP_CR1_WE_SHIFT, CMP_CR1_WE_WIDTH))
/*@}*/

/*!
 * @name Register CMP_CR1, field SE[7] (RW)
 *
 * At any given time, either SE or WE can be set.
 *
 * Values:
 * - 0b0 - Sampling mode is not selected.
 * - 0b1 - Sampling mode is selected.
 */
/*@{*/
/*! @brief Read current value of the CMP_CR1_SE field. */
#define CMP_RD_CR1_SE(base)  ((CMP_CR1_REG(base) & CMP_CR1_SE_MASK) >> CMP_CR1_SE_SHIFT)
#define CMP_BRD_CR1_SE(base) (BME_UBFX8(&CMP_CR1_REG(base), CMP_CR1_SE_SHIFT, CMP_CR1_SE_WIDTH))

/*! @brief Set the SE field to a new value. */
#define CMP_WR_CR1_SE(base, value) (CMP_RMW_CR1(base, CMP_CR1_SE_MASK, CMP_CR1_SE(value)))
#define CMP_BWR_CR1_SE(base, value) (BME_BFI8(&CMP_CR1_REG(base), ((uint8_t)(value) << CMP_CR1_SE_SHIFT), CMP_CR1_SE_SHIFT, CMP_CR1_SE_WIDTH))
/*@}*/

/*******************************************************************************
 * CMP_FPR - CMP Filter Period Register
 ******************************************************************************/

/*!
 * @brief CMP_FPR - CMP Filter Period Register (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire CMP_FPR register
 */
/*@{*/
#define CMP_RD_FPR(base)         (CMP_FPR_REG(base))
#define CMP_WR_FPR(base, value)  (CMP_FPR_REG(base) = (value))
#define CMP_RMW_FPR(base, mask, value) (CMP_WR_FPR(base, (CMP_RD_FPR(base) & ~(mask)) | (value)))
#define CMP_SET_FPR(base, value) (BME_OR8(&CMP_FPR_REG(base), (uint8_t)(value)))
#define CMP_CLR_FPR(base, value) (BME_AND8(&CMP_FPR_REG(base), (uint8_t)(~(value))))
#define CMP_TOG_FPR(base, value) (BME_XOR8(&CMP_FPR_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * CMP_SCR - CMP Status and Control Register
 ******************************************************************************/

/*!
 * @brief CMP_SCR - CMP Status and Control Register (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire CMP_SCR register
 */
/*@{*/
#define CMP_RD_SCR(base)         (CMP_SCR_REG(base))
#define CMP_WR_SCR(base, value)  (CMP_SCR_REG(base) = (value))
#define CMP_RMW_SCR(base, mask, value) (CMP_WR_SCR(base, (CMP_RD_SCR(base) & ~(mask)) | (value)))
#define CMP_SET_SCR(base, value) (BME_OR8(&CMP_SCR_REG(base), (uint8_t)(value)))
#define CMP_CLR_SCR(base, value) (BME_AND8(&CMP_SCR_REG(base), (uint8_t)(~(value))))
#define CMP_TOG_SCR(base, value) (BME_XOR8(&CMP_SCR_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual CMP_SCR bitfields
 */

/*!
 * @name Register CMP_SCR, field COUT[0] (RO)
 *
 * Returns the current value of the Analog Comparator output, when read. The
 * field is reset to 0 and will read as CR1[INV] when the Analog Comparator module
 * is disabled, that is, when CR1[EN] = 0. Writes to this field are ignored.
 */
/*@{*/
/*! @brief Read current value of the CMP_SCR_COUT field. */
#define CMP_RD_SCR_COUT(base) ((CMP_SCR_REG(base) & CMP_SCR_COUT_MASK) >> CMP_SCR_COUT_SHIFT)
#define CMP_BRD_SCR_COUT(base) (BME_UBFX8(&CMP_SCR_REG(base), CMP_SCR_COUT_SHIFT, CMP_SCR_COUT_WIDTH))
/*@}*/

/*!
 * @name Register CMP_SCR, field CFF[1] (W1C)
 *
 * Detects a falling-edge on COUT, when set, during normal operation. CFF is
 * cleared by writing 1 to it. During Stop modes, CFF is level sensitive .
 *
 * Values:
 * - 0b0 - Falling-edge on COUT has not been detected.
 * - 0b1 - Falling-edge on COUT has occurred.
 */
/*@{*/
/*! @brief Read current value of the CMP_SCR_CFF field. */
#define CMP_RD_SCR_CFF(base) ((CMP_SCR_REG(base) & CMP_SCR_CFF_MASK) >> CMP_SCR_CFF_SHIFT)
#define CMP_BRD_SCR_CFF(base) (BME_UBFX8(&CMP_SCR_REG(base), CMP_SCR_CFF_SHIFT, CMP_SCR_CFF_WIDTH))

/*! @brief Set the CFF field to a new value. */
#define CMP_WR_SCR_CFF(base, value) (CMP_RMW_SCR(base, (CMP_SCR_CFF_MASK | CMP_SCR_CFR_MASK), CMP_SCR_CFF(value)))
#define CMP_BWR_SCR_CFF(base, value) (BME_BFI8(&CMP_SCR_REG(base), ((uint8_t)(value) << CMP_SCR_CFF_SHIFT), CMP_SCR_CFF_SHIFT, CMP_SCR_CFF_WIDTH))
/*@}*/

/*!
 * @name Register CMP_SCR, field CFR[2] (W1C)
 *
 * Detects a rising-edge on COUT, when set, during normal operation. CFR is
 * cleared by writing 1 to it. During Stop modes, CFR is level sensitive .
 *
 * Values:
 * - 0b0 - Rising-edge on COUT has not been detected.
 * - 0b1 - Rising-edge on COUT has occurred.
 */
/*@{*/
/*! @brief Read current value of the CMP_SCR_CFR field. */
#define CMP_RD_SCR_CFR(base) ((CMP_SCR_REG(base) & CMP_SCR_CFR_MASK) >> CMP_SCR_CFR_SHIFT)
#define CMP_BRD_SCR_CFR(base) (BME_UBFX8(&CMP_SCR_REG(base), CMP_SCR_CFR_SHIFT, CMP_SCR_CFR_WIDTH))

/*! @brief Set the CFR field to a new value. */
#define CMP_WR_SCR_CFR(base, value) (CMP_RMW_SCR(base, (CMP_SCR_CFR_MASK | CMP_SCR_CFF_MASK), CMP_SCR_CFR(value)))
#define CMP_BWR_SCR_CFR(base, value) (BME_BFI8(&CMP_SCR_REG(base), ((uint8_t)(value) << CMP_SCR_CFR_SHIFT), CMP_SCR_CFR_SHIFT, CMP_SCR_CFR_WIDTH))
/*@}*/

/*!
 * @name Register CMP_SCR, field IEF[3] (RW)
 *
 * Enables the CFF interrupt from the CMP. When this field is set, an interrupt
 * will be asserted when CFF is set.
 *
 * Values:
 * - 0b0 - Interrupt is disabled.
 * - 0b1 - Interrupt is enabled.
 */
/*@{*/
/*! @brief Read current value of the CMP_SCR_IEF field. */
#define CMP_RD_SCR_IEF(base) ((CMP_SCR_REG(base) & CMP_SCR_IEF_MASK) >> CMP_SCR_IEF_SHIFT)
#define CMP_BRD_SCR_IEF(base) (BME_UBFX8(&CMP_SCR_REG(base), CMP_SCR_IEF_SHIFT, CMP_SCR_IEF_WIDTH))

/*! @brief Set the IEF field to a new value. */
#define CMP_WR_SCR_IEF(base, value) (CMP_RMW_SCR(base, (CMP_SCR_IEF_MASK | CMP_SCR_CFF_MASK | CMP_SCR_CFR_MASK), CMP_SCR_IEF(value)))
#define CMP_BWR_SCR_IEF(base, value) (BME_BFI8(&CMP_SCR_REG(base), ((uint8_t)(value) << CMP_SCR_IEF_SHIFT), CMP_SCR_IEF_SHIFT, CMP_SCR_IEF_WIDTH))
/*@}*/

/*!
 * @name Register CMP_SCR, field IER[4] (RW)
 *
 * Enables the CFR interrupt from the CMP. When this field is set, an interrupt
 * will be asserted when CFR is set.
 *
 * Values:
 * - 0b0 - Interrupt is disabled.
 * - 0b1 - Interrupt is enabled.
 */
/*@{*/
/*! @brief Read current value of the CMP_SCR_IER field. */
#define CMP_RD_SCR_IER(base) ((CMP_SCR_REG(base) & CMP_SCR_IER_MASK) >> CMP_SCR_IER_SHIFT)
#define CMP_BRD_SCR_IER(base) (BME_UBFX8(&CMP_SCR_REG(base), CMP_SCR_IER_SHIFT, CMP_SCR_IER_WIDTH))

/*! @brief Set the IER field to a new value. */
#define CMP_WR_SCR_IER(base, value) (CMP_RMW_SCR(base, (CMP_SCR_IER_MASK | CMP_SCR_CFF_MASK | CMP_SCR_CFR_MASK), CMP_SCR_IER(value)))
#define CMP_BWR_SCR_IER(base, value) (BME_BFI8(&CMP_SCR_REG(base), ((uint8_t)(value) << CMP_SCR_IER_SHIFT), CMP_SCR_IER_SHIFT, CMP_SCR_IER_WIDTH))
/*@}*/

/*!
 * @name Register CMP_SCR, field DMAEN[6] (RW)
 *
 * Enables the DMA transfer triggered from the CMP module. When this field is
 * set, a DMA request is asserted when CFR or CFF is set.
 *
 * Values:
 * - 0b0 - DMA is disabled.
 * - 0b1 - DMA is enabled.
 */
/*@{*/
/*! @brief Read current value of the CMP_SCR_DMAEN field. */
#define CMP_RD_SCR_DMAEN(base) ((CMP_SCR_REG(base) & CMP_SCR_DMAEN_MASK) >> CMP_SCR_DMAEN_SHIFT)
#define CMP_BRD_SCR_DMAEN(base) (BME_UBFX8(&CMP_SCR_REG(base), CMP_SCR_DMAEN_SHIFT, CMP_SCR_DMAEN_WIDTH))

/*! @brief Set the DMAEN field to a new value. */
#define CMP_WR_SCR_DMAEN(base, value) (CMP_RMW_SCR(base, (CMP_SCR_DMAEN_MASK | CMP_SCR_CFF_MASK | CMP_SCR_CFR_MASK), CMP_SCR_DMAEN(value)))
#define CMP_BWR_SCR_DMAEN(base, value) (BME_BFI8(&CMP_SCR_REG(base), ((uint8_t)(value) << CMP_SCR_DMAEN_SHIFT), CMP_SCR_DMAEN_SHIFT, CMP_SCR_DMAEN_WIDTH))
/*@}*/

/*******************************************************************************
 * CMP_DACCR - DAC Control Register
 ******************************************************************************/

/*!
 * @brief CMP_DACCR - DAC Control Register (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire CMP_DACCR register
 */
/*@{*/
#define CMP_RD_DACCR(base)       (CMP_DACCR_REG(base))
#define CMP_WR_DACCR(base, value) (CMP_DACCR_REG(base) = (value))
#define CMP_RMW_DACCR(base, mask, value) (CMP_WR_DACCR(base, (CMP_RD_DACCR(base) & ~(mask)) | (value)))
#define CMP_SET_DACCR(base, value) (BME_OR8(&CMP_DACCR_REG(base), (uint8_t)(value)))
#define CMP_CLR_DACCR(base, value) (BME_AND8(&CMP_DACCR_REG(base), (uint8_t)(~(value))))
#define CMP_TOG_DACCR(base, value) (BME_XOR8(&CMP_DACCR_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual CMP_DACCR bitfields
 */

/*!
 * @name Register CMP_DACCR, field VOSEL[5:0] (RW)
 *
 * Selects an output voltage from one of 64 distinct levels. DACO = (V in /64) *
 * (VOSEL[5:0] + 1) , so the DACO range is from V in /64 to V in .
 */
/*@{*/
/*! @brief Read current value of the CMP_DACCR_VOSEL field. */
#define CMP_RD_DACCR_VOSEL(base) ((CMP_DACCR_REG(base) & CMP_DACCR_VOSEL_MASK) >> CMP_DACCR_VOSEL_SHIFT)
#define CMP_BRD_DACCR_VOSEL(base) (BME_UBFX8(&CMP_DACCR_REG(base), CMP_DACCR_VOSEL_SHIFT, CMP_DACCR_VOSEL_WIDTH))

/*! @brief Set the VOSEL field to a new value. */
#define CMP_WR_DACCR_VOSEL(base, value) (CMP_RMW_DACCR(base, CMP_DACCR_VOSEL_MASK, CMP_DACCR_VOSEL(value)))
#define CMP_BWR_DACCR_VOSEL(base, value) (BME_BFI8(&CMP_DACCR_REG(base), ((uint8_t)(value) << CMP_DACCR_VOSEL_SHIFT), CMP_DACCR_VOSEL_SHIFT, CMP_DACCR_VOSEL_WIDTH))
/*@}*/

/*!
 * @name Register CMP_DACCR, field VRSEL[6] (RW)
 *
 * Values:
 * - 0b0 - Vin1 is selected as resistor ladder network supply reference.
 * - 0b1 - Vin2 is selected as resistor ladder network supply reference.
 */
/*@{*/
/*! @brief Read current value of the CMP_DACCR_VRSEL field. */
#define CMP_RD_DACCR_VRSEL(base) ((CMP_DACCR_REG(base) & CMP_DACCR_VRSEL_MASK) >> CMP_DACCR_VRSEL_SHIFT)
#define CMP_BRD_DACCR_VRSEL(base) (BME_UBFX8(&CMP_DACCR_REG(base), CMP_DACCR_VRSEL_SHIFT, CMP_DACCR_VRSEL_WIDTH))

/*! @brief Set the VRSEL field to a new value. */
#define CMP_WR_DACCR_VRSEL(base, value) (CMP_RMW_DACCR(base, CMP_DACCR_VRSEL_MASK, CMP_DACCR_VRSEL(value)))
#define CMP_BWR_DACCR_VRSEL(base, value) (BME_BFI8(&CMP_DACCR_REG(base), ((uint8_t)(value) << CMP_DACCR_VRSEL_SHIFT), CMP_DACCR_VRSEL_SHIFT, CMP_DACCR_VRSEL_WIDTH))
/*@}*/

/*!
 * @name Register CMP_DACCR, field DACEN[7] (RW)
 *
 * Enables the DAC. When the DAC is disabled, it is powered down to conserve
 * power.
 *
 * Values:
 * - 0b0 - DAC is disabled.
 * - 0b1 - DAC is enabled.
 */
/*@{*/
/*! @brief Read current value of the CMP_DACCR_DACEN field. */
#define CMP_RD_DACCR_DACEN(base) ((CMP_DACCR_REG(base) & CMP_DACCR_DACEN_MASK) >> CMP_DACCR_DACEN_SHIFT)
#define CMP_BRD_DACCR_DACEN(base) (BME_UBFX8(&CMP_DACCR_REG(base), CMP_DACCR_DACEN_SHIFT, CMP_DACCR_DACEN_WIDTH))

/*! @brief Set the DACEN field to a new value. */
#define CMP_WR_DACCR_DACEN(base, value) (CMP_RMW_DACCR(base, CMP_DACCR_DACEN_MASK, CMP_DACCR_DACEN(value)))
#define CMP_BWR_DACCR_DACEN(base, value) (BME_BFI8(&CMP_DACCR_REG(base), ((uint8_t)(value) << CMP_DACCR_DACEN_SHIFT), CMP_DACCR_DACEN_SHIFT, CMP_DACCR_DACEN_WIDTH))
/*@}*/

/*******************************************************************************
 * CMP_MUXCR - MUX Control Register
 ******************************************************************************/

/*!
 * @brief CMP_MUXCR - MUX Control Register (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire CMP_MUXCR register
 */
/*@{*/
#define CMP_RD_MUXCR(base)       (CMP_MUXCR_REG(base))
#define CMP_WR_MUXCR(base, value) (CMP_MUXCR_REG(base) = (value))
#define CMP_RMW_MUXCR(base, mask, value) (CMP_WR_MUXCR(base, (CMP_RD_MUXCR(base) & ~(mask)) | (value)))
#define CMP_SET_MUXCR(base, value) (BME_OR8(&CMP_MUXCR_REG(base), (uint8_t)(value)))
#define CMP_CLR_MUXCR(base, value) (BME_AND8(&CMP_MUXCR_REG(base), (uint8_t)(~(value))))
#define CMP_TOG_MUXCR(base, value) (BME_XOR8(&CMP_MUXCR_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual CMP_MUXCR bitfields
 */

/*!
 * @name Register CMP_MUXCR, field MSEL[2:0] (RW)
 *
 * Determines which input is selected for the minus input of the comparator. For
 * INx inputs, see CMP, DAC, and ANMUX block diagrams. When an inappropriate
 * operation selects the same input for both muxes, the comparator automatically
 * shuts down to prevent itself from becoming a noise generator.
 *
 * Values:
 * - 0b000 - IN0
 * - 0b001 - IN1
 * - 0b010 - IN2
 * - 0b011 - IN3
 * - 0b100 - IN4
 * - 0b101 - IN5
 * - 0b110 - IN6
 * - 0b111 - IN7
 */
/*@{*/
/*! @brief Read current value of the CMP_MUXCR_MSEL field. */
#define CMP_RD_MUXCR_MSEL(base) ((CMP_MUXCR_REG(base) & CMP_MUXCR_MSEL_MASK) >> CMP_MUXCR_MSEL_SHIFT)
#define CMP_BRD_MUXCR_MSEL(base) (BME_UBFX8(&CMP_MUXCR_REG(base), CMP_MUXCR_MSEL_SHIFT, CMP_MUXCR_MSEL_WIDTH))

/*! @brief Set the MSEL field to a new value. */
#define CMP_WR_MUXCR_MSEL(base, value) (CMP_RMW_MUXCR(base, CMP_MUXCR_MSEL_MASK, CMP_MUXCR_MSEL(value)))
#define CMP_BWR_MUXCR_MSEL(base, value) (BME_BFI8(&CMP_MUXCR_REG(base), ((uint8_t)(value) << CMP_MUXCR_MSEL_SHIFT), CMP_MUXCR_MSEL_SHIFT, CMP_MUXCR_MSEL_WIDTH))
/*@}*/

/*!
 * @name Register CMP_MUXCR, field PSEL[5:3] (RW)
 *
 * Determines which input is selected for the plus input of the comparator. For
 * INx inputs, see CMP, DAC, and ANMUX block diagrams. When an inappropriate
 * operation selects the same input for both muxes, the comparator automatically
 * shuts down to prevent itself from becoming a noise generator.
 *
 * Values:
 * - 0b000 - IN0
 * - 0b001 - IN1
 * - 0b010 - IN2
 * - 0b011 - IN3
 * - 0b100 - IN4
 * - 0b101 - IN5
 * - 0b110 - IN6
 * - 0b111 - IN7
 */
/*@{*/
/*! @brief Read current value of the CMP_MUXCR_PSEL field. */
#define CMP_RD_MUXCR_PSEL(base) ((CMP_MUXCR_REG(base) & CMP_MUXCR_PSEL_MASK) >> CMP_MUXCR_PSEL_SHIFT)
#define CMP_BRD_MUXCR_PSEL(base) (BME_UBFX8(&CMP_MUXCR_REG(base), CMP_MUXCR_PSEL_SHIFT, CMP_MUXCR_PSEL_WIDTH))

/*! @brief Set the PSEL field to a new value. */
#define CMP_WR_MUXCR_PSEL(base, value) (CMP_RMW_MUXCR(base, CMP_MUXCR_PSEL_MASK, CMP_MUXCR_PSEL(value)))
#define CMP_BWR_MUXCR_PSEL(base, value) (BME_BFI8(&CMP_MUXCR_REG(base), ((uint8_t)(value) << CMP_MUXCR_PSEL_SHIFT), CMP_MUXCR_PSEL_SHIFT, CMP_MUXCR_PSEL_WIDTH))
/*@}*/

/*
 * MKM34Z7 CRC
 *
 * Cyclic Redundancy Check
 *
 * Registers defined in this header file:
 * - CRC_DATAL - CRC_DATAL register.
 * - CRC_DATAH - CRC_DATAH register.
 * - CRC_DATALL - CRC_DATALL register.
 * - CRC_DATALU - CRC_DATALU register.
 * - CRC_DATAHL - CRC_DATAHL register.
 * - CRC_DATAHU - CRC_DATAHU register.
 * - CRC_DATA - CRC Data register
 * - CRC_GPOLY - CRC Polynomial register
 * - CRC_GPOLYL - CRC_GPOLYL register.
 * - CRC_GPOLYH - CRC_GPOLYH register.
 * - CRC_GPOLYLL - CRC_GPOLYLL register.
 * - CRC_GPOLYLU - CRC_GPOLYLU register.
 * - CRC_GPOLYHL - CRC_GPOLYHL register.
 * - CRC_GPOLYHU - CRC_GPOLYHU register.
 * - CRC_CTRL - CRC Control register
 * - CRC_CTRLHU - CRC_CTRLHU register.
 */

#define CRC_INSTANCE_COUNT (1U) /*!< Number of instances of the CRC module. */
#define CRC_IDX (0U) /*!< Instance number for CRC. */

/*******************************************************************************
 * CRC_DATALL - CRC_DATALL register.
 ******************************************************************************/

/*!
 * @brief CRC_DATALL - CRC_DATALL register. (RW)
 *
 * Reset value: 0xFFU
 */
/*!
 * @name Constants and macros for entire CRC_DATALL register
 */
/*@{*/
#define CRC_RD_DATALL(base)      (CRC_DATALL_REG(base))
#define CRC_WR_DATALL(base, value) (CRC_DATALL_REG(base) = (value))
#define CRC_RMW_DATALL(base, mask, value) (CRC_WR_DATALL(base, (CRC_RD_DATALL(base) & ~(mask)) | (value)))
#define CRC_SET_DATALL(base, value) (BME_OR8(&CRC_DATALL_REG(base), (uint8_t)(value)))
#define CRC_CLR_DATALL(base, value) (BME_AND8(&CRC_DATALL_REG(base), (uint8_t)(~(value))))
#define CRC_TOG_DATALL(base, value) (BME_XOR8(&CRC_DATALL_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * CRC_DATAL - CRC_DATAL register.
 ******************************************************************************/

/*!
 * @brief CRC_DATAL - CRC_DATAL register. (RW)
 *
 * Reset value: 0xFFFFU
 */
/*!
 * @name Constants and macros for entire CRC_DATAL register
 */
/*@{*/
#define CRC_RD_DATAL(base)       (CRC_DATAL_REG(base))
#define CRC_WR_DATAL(base, value) (CRC_DATAL_REG(base) = (value))
#define CRC_RMW_DATAL(base, mask, value) (CRC_WR_DATAL(base, (CRC_RD_DATAL(base) & ~(mask)) | (value)))
#define CRC_SET_DATAL(base, value) (BME_OR16(&CRC_DATAL_REG(base), (uint16_t)(value)))
#define CRC_CLR_DATAL(base, value) (BME_AND16(&CRC_DATAL_REG(base), (uint16_t)(~(value))))
#define CRC_TOG_DATAL(base, value) (BME_XOR16(&CRC_DATAL_REG(base), (uint16_t)(value)))
/*@}*/

/*******************************************************************************
 * CRC_DATA - CRC Data register
 ******************************************************************************/

/*!
 * @brief CRC_DATA - CRC Data register (RW)
 *
 * Reset value: 0xFFFFFFFFU
 *
 * The CRC Data register contains the value of the seed, data, and checksum.
 * When CTRL[WAS] is set, any write to the data register is regarded as the seed
 * value. When CTRL[WAS] is cleared, any write to the data register is regarded as
 * data for general CRC computation. In 16-bit CRC mode, the HU and HL fields are
 * not used for programming the seed value, and reads of these fields return an
 * indeterminate value. In 32-bit CRC mode, all fields are used for programming
 * the seed value. When programming data values, the values can be written 8 bits,
 * 16 bits, or 32 bits at a time, provided all bytes are contiguous; with MSB of
 * data value written first. After all data values are written, the CRC result
 * can be read from this data register. In 16-bit CRC mode, the CRC result is
 * available in the LU and LL fields. In 32-bit CRC mode, all fields contain the
 * result. Reads of this register at any time return the intermediate CRC value,
 * provided the CRC module is configured.
 */
/*!
 * @name Constants and macros for entire CRC_DATA register
 */
/*@{*/
#define CRC_RD_DATA(base)        (CRC_DATA_REG(base))
#define CRC_WR_DATA(base, value) (CRC_DATA_REG(base) = (value))
#define CRC_RMW_DATA(base, mask, value) (CRC_WR_DATA(base, (CRC_RD_DATA(base) & ~(mask)) | (value)))
#define CRC_SET_DATA(base, value) (BME_OR32(&CRC_DATA_REG(base), (uint32_t)(value)))
#define CRC_CLR_DATA(base, value) (BME_AND32(&CRC_DATA_REG(base), (uint32_t)(~(value))))
#define CRC_TOG_DATA(base, value) (BME_XOR32(&CRC_DATA_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual CRC_DATA bitfields
 */

/*!
 * @name Register CRC_DATA, field LL[7:0] (RW)
 *
 * When CTRL[WAS] is 1, values written to this field are part of the seed value.
 * When CTRL[WAS] is 0, data written to this field is used for CRC checksum
 * generation.
 */
/*@{*/
/*! @brief Read current value of the CRC_DATA_LL field. */
#define CRC_RD_DATA_LL(base) ((CRC_DATA_REG(base) & CRC_DATA_LL_MASK) >> CRC_DATA_LL_SHIFT)
#define CRC_BRD_DATA_LL(base) (BME_UBFX32(&CRC_DATA_REG(base), CRC_DATA_LL_SHIFT, CRC_DATA_LL_WIDTH))

/*! @brief Set the LL field to a new value. */
#define CRC_WR_DATA_LL(base, value) (CRC_RMW_DATA(base, CRC_DATA_LL_MASK, CRC_DATA_LL(value)))
#define CRC_BWR_DATA_LL(base, value) (BME_BFI32(&CRC_DATA_REG(base), ((uint32_t)(value) << CRC_DATA_LL_SHIFT), CRC_DATA_LL_SHIFT, CRC_DATA_LL_WIDTH))
/*@}*/

/*!
 * @name Register CRC_DATA, field LU[15:8] (RW)
 *
 * When CTRL[WAS] is 1, values written to this field are part of the seed value.
 * When CTRL[WAS] is 0, data written to this field is used for CRC checksum
 * generation.
 */
/*@{*/
/*! @brief Read current value of the CRC_DATA_LU field. */
#define CRC_RD_DATA_LU(base) ((CRC_DATA_REG(base) & CRC_DATA_LU_MASK) >> CRC_DATA_LU_SHIFT)
#define CRC_BRD_DATA_LU(base) (BME_UBFX32(&CRC_DATA_REG(base), CRC_DATA_LU_SHIFT, CRC_DATA_LU_WIDTH))

/*! @brief Set the LU field to a new value. */
#define CRC_WR_DATA_LU(base, value) (CRC_RMW_DATA(base, CRC_DATA_LU_MASK, CRC_DATA_LU(value)))
#define CRC_BWR_DATA_LU(base, value) (BME_BFI32(&CRC_DATA_REG(base), ((uint32_t)(value) << CRC_DATA_LU_SHIFT), CRC_DATA_LU_SHIFT, CRC_DATA_LU_WIDTH))
/*@}*/

/*!
 * @name Register CRC_DATA, field HL[23:16] (RW)
 *
 * In 16-bit CRC mode (CTRL[TCRC] is 0), this field is not used for programming
 * a seed value. In 32-bit CRC mode (CTRL[TCRC] is 1), values written to this
 * field are part of the seed value when CTRL[WAS] is 1. When CTRL[WAS] is 0, data
 * written to this field is used for CRC checksum generation in both 16-bit and
 * 32-bit CRC modes.
 */
/*@{*/
/*! @brief Read current value of the CRC_DATA_HL field. */
#define CRC_RD_DATA_HL(base) ((CRC_DATA_REG(base) & CRC_DATA_HL_MASK) >> CRC_DATA_HL_SHIFT)
#define CRC_BRD_DATA_HL(base) (BME_UBFX32(&CRC_DATA_REG(base), CRC_DATA_HL_SHIFT, CRC_DATA_HL_WIDTH))

/*! @brief Set the HL field to a new value. */
#define CRC_WR_DATA_HL(base, value) (CRC_RMW_DATA(base, CRC_DATA_HL_MASK, CRC_DATA_HL(value)))
#define CRC_BWR_DATA_HL(base, value) (BME_BFI32(&CRC_DATA_REG(base), ((uint32_t)(value) << CRC_DATA_HL_SHIFT), CRC_DATA_HL_SHIFT, CRC_DATA_HL_WIDTH))
/*@}*/

/*!
 * @name Register CRC_DATA, field HU[31:24] (RW)
 *
 * In 16-bit CRC mode (CTRL[TCRC] is 0), this field is not used for programming
 * a seed value. In 32-bit CRC mode (CTRL[TCRC] is 1), values written to this
 * field are part of the seed value when CTRL[WAS] is 1. When CTRL[WAS] is 0, data
 * written to this field is used for CRC checksum generation in both 16-bit and
 * 32-bit CRC modes.
 */
/*@{*/
/*! @brief Read current value of the CRC_DATA_HU field. */
#define CRC_RD_DATA_HU(base) ((CRC_DATA_REG(base) & CRC_DATA_HU_MASK) >> CRC_DATA_HU_SHIFT)
#define CRC_BRD_DATA_HU(base) (BME_UBFX32(&CRC_DATA_REG(base), CRC_DATA_HU_SHIFT, CRC_DATA_HU_WIDTH))

/*! @brief Set the HU field to a new value. */
#define CRC_WR_DATA_HU(base, value) (CRC_RMW_DATA(base, CRC_DATA_HU_MASK, CRC_DATA_HU(value)))
#define CRC_BWR_DATA_HU(base, value) (BME_BFI32(&CRC_DATA_REG(base), ((uint32_t)(value) << CRC_DATA_HU_SHIFT), CRC_DATA_HU_SHIFT, CRC_DATA_HU_WIDTH))
/*@}*/

/*******************************************************************************
 * CRC_DATALU - CRC_DATALU register.
 ******************************************************************************/

/*!
 * @brief CRC_DATALU - CRC_DATALU register. (RW)
 *
 * Reset value: 0xFFU
 */
/*!
 * @name Constants and macros for entire CRC_DATALU register
 */
/*@{*/
#define CRC_RD_DATALU(base)      (CRC_DATALU_REG(base))
#define CRC_WR_DATALU(base, value) (CRC_DATALU_REG(base) = (value))
#define CRC_RMW_DATALU(base, mask, value) (CRC_WR_DATALU(base, (CRC_RD_DATALU(base) & ~(mask)) | (value)))
#define CRC_SET_DATALU(base, value) (BME_OR8(&CRC_DATALU_REG(base), (uint8_t)(value)))
#define CRC_CLR_DATALU(base, value) (BME_AND8(&CRC_DATALU_REG(base), (uint8_t)(~(value))))
#define CRC_TOG_DATALU(base, value) (BME_XOR8(&CRC_DATALU_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * CRC_DATAHL - CRC_DATAHL register.
 ******************************************************************************/

/*!
 * @brief CRC_DATAHL - CRC_DATAHL register. (RW)
 *
 * Reset value: 0xFFU
 */
/*!
 * @name Constants and macros for entire CRC_DATAHL register
 */
/*@{*/
#define CRC_RD_DATAHL(base)      (CRC_DATAHL_REG(base))
#define CRC_WR_DATAHL(base, value) (CRC_DATAHL_REG(base) = (value))
#define CRC_RMW_DATAHL(base, mask, value) (CRC_WR_DATAHL(base, (CRC_RD_DATAHL(base) & ~(mask)) | (value)))
#define CRC_SET_DATAHL(base, value) (BME_OR8(&CRC_DATAHL_REG(base), (uint8_t)(value)))
#define CRC_CLR_DATAHL(base, value) (BME_AND8(&CRC_DATAHL_REG(base), (uint8_t)(~(value))))
#define CRC_TOG_DATAHL(base, value) (BME_XOR8(&CRC_DATAHL_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * CRC_DATAH - CRC_DATAH register.
 ******************************************************************************/

/*!
 * @brief CRC_DATAH - CRC_DATAH register. (RW)
 *
 * Reset value: 0xFFFFU
 */
/*!
 * @name Constants and macros for entire CRC_DATAH register
 */
/*@{*/
#define CRC_RD_DATAH(base)       (CRC_DATAH_REG(base))
#define CRC_WR_DATAH(base, value) (CRC_DATAH_REG(base) = (value))
#define CRC_RMW_DATAH(base, mask, value) (CRC_WR_DATAH(base, (CRC_RD_DATAH(base) & ~(mask)) | (value)))
#define CRC_SET_DATAH(base, value) (BME_OR16(&CRC_DATAH_REG(base), (uint16_t)(value)))
#define CRC_CLR_DATAH(base, value) (BME_AND16(&CRC_DATAH_REG(base), (uint16_t)(~(value))))
#define CRC_TOG_DATAH(base, value) (BME_XOR16(&CRC_DATAH_REG(base), (uint16_t)(value)))
/*@}*/

/*******************************************************************************
 * CRC_DATAHU - CRC_DATAHU register.
 ******************************************************************************/

/*!
 * @brief CRC_DATAHU - CRC_DATAHU register. (RW)
 *
 * Reset value: 0xFFU
 */
/*!
 * @name Constants and macros for entire CRC_DATAHU register
 */
/*@{*/
#define CRC_RD_DATAHU(base)      (CRC_DATAHU_REG(base))
#define CRC_WR_DATAHU(base, value) (CRC_DATAHU_REG(base) = (value))
#define CRC_RMW_DATAHU(base, mask, value) (CRC_WR_DATAHU(base, (CRC_RD_DATAHU(base) & ~(mask)) | (value)))
#define CRC_SET_DATAHU(base, value) (BME_OR8(&CRC_DATAHU_REG(base), (uint8_t)(value)))
#define CRC_CLR_DATAHU(base, value) (BME_AND8(&CRC_DATAHU_REG(base), (uint8_t)(~(value))))
#define CRC_TOG_DATAHU(base, value) (BME_XOR8(&CRC_DATAHU_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * CRC_GPOLYLL - CRC_GPOLYLL register.
 ******************************************************************************/

/*!
 * @brief CRC_GPOLYLL - CRC_GPOLYLL register. (RW)
 *
 * Reset value: 0xFFU
 */
/*!
 * @name Constants and macros for entire CRC_GPOLYLL register
 */
/*@{*/
#define CRC_RD_GPOLYLL(base)     (CRC_GPOLYLL_REG(base))
#define CRC_WR_GPOLYLL(base, value) (CRC_GPOLYLL_REG(base) = (value))
#define CRC_RMW_GPOLYLL(base, mask, value) (CRC_WR_GPOLYLL(base, (CRC_RD_GPOLYLL(base) & ~(mask)) | (value)))
#define CRC_SET_GPOLYLL(base, value) (BME_OR8(&CRC_GPOLYLL_REG(base), (uint8_t)(value)))
#define CRC_CLR_GPOLYLL(base, value) (BME_AND8(&CRC_GPOLYLL_REG(base), (uint8_t)(~(value))))
#define CRC_TOG_GPOLYLL(base, value) (BME_XOR8(&CRC_GPOLYLL_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * CRC_GPOLY - CRC Polynomial register
 ******************************************************************************/

/*!
 * @brief CRC_GPOLY - CRC Polynomial register (RW)
 *
 * Reset value: 0x00001021U
 *
 * This register contains the value of the polynomial for the CRC calculation.
 * The HIGH field contains the upper 16 bits of the CRC polynomial, which are used
 * only in 32-bit CRC mode. Writes to the HIGH field are ignored in 16-bit CRC
 * mode. The LOW field contains the lower 16 bits of the CRC polynomial, which are
 * used in both 16- and 32-bit CRC modes.
 */
/*!
 * @name Constants and macros for entire CRC_GPOLY register
 */
/*@{*/
#define CRC_RD_GPOLY(base)       (CRC_GPOLY_REG(base))
#define CRC_WR_GPOLY(base, value) (CRC_GPOLY_REG(base) = (value))
#define CRC_RMW_GPOLY(base, mask, value) (CRC_WR_GPOLY(base, (CRC_RD_GPOLY(base) & ~(mask)) | (value)))
#define CRC_SET_GPOLY(base, value) (BME_OR32(&CRC_GPOLY_REG(base), (uint32_t)(value)))
#define CRC_CLR_GPOLY(base, value) (BME_AND32(&CRC_GPOLY_REG(base), (uint32_t)(~(value))))
#define CRC_TOG_GPOLY(base, value) (BME_XOR32(&CRC_GPOLY_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual CRC_GPOLY bitfields
 */

/*!
 * @name Register CRC_GPOLY, field LOW[15:0] (RW)
 *
 * Writable and readable in both 32-bit and 16-bit CRC modes.
 */
/*@{*/
/*! @brief Read current value of the CRC_GPOLY_LOW field. */
#define CRC_RD_GPOLY_LOW(base) ((CRC_GPOLY_REG(base) & CRC_GPOLY_LOW_MASK) >> CRC_GPOLY_LOW_SHIFT)
#define CRC_BRD_GPOLY_LOW(base) (BME_UBFX32(&CRC_GPOLY_REG(base), CRC_GPOLY_LOW_SHIFT, CRC_GPOLY_LOW_WIDTH))

/*! @brief Set the LOW field to a new value. */
#define CRC_WR_GPOLY_LOW(base, value) (CRC_RMW_GPOLY(base, CRC_GPOLY_LOW_MASK, CRC_GPOLY_LOW(value)))
#define CRC_BWR_GPOLY_LOW(base, value) (BME_BFI32(&CRC_GPOLY_REG(base), ((uint32_t)(value) << CRC_GPOLY_LOW_SHIFT), CRC_GPOLY_LOW_SHIFT, CRC_GPOLY_LOW_WIDTH))
/*@}*/

/*!
 * @name Register CRC_GPOLY, field HIGH[31:16] (RW)
 *
 * Writable and readable in 32-bit CRC mode (CTRL[TCRC] is 1). This field is not
 * writable in 16-bit CRC mode (CTRL[TCRC] is 0).
 */
/*@{*/
/*! @brief Read current value of the CRC_GPOLY_HIGH field. */
#define CRC_RD_GPOLY_HIGH(base) ((CRC_GPOLY_REG(base) & CRC_GPOLY_HIGH_MASK) >> CRC_GPOLY_HIGH_SHIFT)
#define CRC_BRD_GPOLY_HIGH(base) (BME_UBFX32(&CRC_GPOLY_REG(base), CRC_GPOLY_HIGH_SHIFT, CRC_GPOLY_HIGH_WIDTH))

/*! @brief Set the HIGH field to a new value. */
#define CRC_WR_GPOLY_HIGH(base, value) (CRC_RMW_GPOLY(base, CRC_GPOLY_HIGH_MASK, CRC_GPOLY_HIGH(value)))
#define CRC_BWR_GPOLY_HIGH(base, value) (BME_BFI32(&CRC_GPOLY_REG(base), ((uint32_t)(value) << CRC_GPOLY_HIGH_SHIFT), CRC_GPOLY_HIGH_SHIFT, CRC_GPOLY_HIGH_WIDTH))
/*@}*/

/*******************************************************************************
 * CRC_GPOLYL - CRC_GPOLYL register.
 ******************************************************************************/

/*!
 * @brief CRC_GPOLYL - CRC_GPOLYL register. (RW)
 *
 * Reset value: 0xFFFFU
 */
/*!
 * @name Constants and macros for entire CRC_GPOLYL register
 */
/*@{*/
#define CRC_RD_GPOLYL(base)      (CRC_GPOLYL_REG(base))
#define CRC_WR_GPOLYL(base, value) (CRC_GPOLYL_REG(base) = (value))
#define CRC_RMW_GPOLYL(base, mask, value) (CRC_WR_GPOLYL(base, (CRC_RD_GPOLYL(base) & ~(mask)) | (value)))
#define CRC_SET_GPOLYL(base, value) (BME_OR16(&CRC_GPOLYL_REG(base), (uint16_t)(value)))
#define CRC_CLR_GPOLYL(base, value) (BME_AND16(&CRC_GPOLYL_REG(base), (uint16_t)(~(value))))
#define CRC_TOG_GPOLYL(base, value) (BME_XOR16(&CRC_GPOLYL_REG(base), (uint16_t)(value)))
/*@}*/

/*******************************************************************************
 * CRC_GPOLYLU - CRC_GPOLYLU register.
 ******************************************************************************/

/*!
 * @brief CRC_GPOLYLU - CRC_GPOLYLU register. (RW)
 *
 * Reset value: 0xFFU
 */
/*!
 * @name Constants and macros for entire CRC_GPOLYLU register
 */
/*@{*/
#define CRC_RD_GPOLYLU(base)     (CRC_GPOLYLU_REG(base))
#define CRC_WR_GPOLYLU(base, value) (CRC_GPOLYLU_REG(base) = (value))
#define CRC_RMW_GPOLYLU(base, mask, value) (CRC_WR_GPOLYLU(base, (CRC_RD_GPOLYLU(base) & ~(mask)) | (value)))
#define CRC_SET_GPOLYLU(base, value) (BME_OR8(&CRC_GPOLYLU_REG(base), (uint8_t)(value)))
#define CRC_CLR_GPOLYLU(base, value) (BME_AND8(&CRC_GPOLYLU_REG(base), (uint8_t)(~(value))))
#define CRC_TOG_GPOLYLU(base, value) (BME_XOR8(&CRC_GPOLYLU_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * CRC_GPOLYH - CRC_GPOLYH register.
 ******************************************************************************/

/*!
 * @brief CRC_GPOLYH - CRC_GPOLYH register. (RW)
 *
 * Reset value: 0xFFFFU
 */
/*!
 * @name Constants and macros for entire CRC_GPOLYH register
 */
/*@{*/
#define CRC_RD_GPOLYH(base)      (CRC_GPOLYH_REG(base))
#define CRC_WR_GPOLYH(base, value) (CRC_GPOLYH_REG(base) = (value))
#define CRC_RMW_GPOLYH(base, mask, value) (CRC_WR_GPOLYH(base, (CRC_RD_GPOLYH(base) & ~(mask)) | (value)))
#define CRC_SET_GPOLYH(base, value) (BME_OR16(&CRC_GPOLYH_REG(base), (uint16_t)(value)))
#define CRC_CLR_GPOLYH(base, value) (BME_AND16(&CRC_GPOLYH_REG(base), (uint16_t)(~(value))))
#define CRC_TOG_GPOLYH(base, value) (BME_XOR16(&CRC_GPOLYH_REG(base), (uint16_t)(value)))
/*@}*/

/*******************************************************************************
 * CRC_GPOLYHL - CRC_GPOLYHL register.
 ******************************************************************************/

/*!
 * @brief CRC_GPOLYHL - CRC_GPOLYHL register. (RW)
 *
 * Reset value: 0xFFU
 */
/*!
 * @name Constants and macros for entire CRC_GPOLYHL register
 */
/*@{*/
#define CRC_RD_GPOLYHL(base)     (CRC_GPOLYHL_REG(base))
#define CRC_WR_GPOLYHL(base, value) (CRC_GPOLYHL_REG(base) = (value))
#define CRC_RMW_GPOLYHL(base, mask, value) (CRC_WR_GPOLYHL(base, (CRC_RD_GPOLYHL(base) & ~(mask)) | (value)))
#define CRC_SET_GPOLYHL(base, value) (BME_OR8(&CRC_GPOLYHL_REG(base), (uint8_t)(value)))
#define CRC_CLR_GPOLYHL(base, value) (BME_AND8(&CRC_GPOLYHL_REG(base), (uint8_t)(~(value))))
#define CRC_TOG_GPOLYHL(base, value) (BME_XOR8(&CRC_GPOLYHL_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * CRC_GPOLYHU - CRC_GPOLYHU register.
 ******************************************************************************/

/*!
 * @brief CRC_GPOLYHU - CRC_GPOLYHU register. (RW)
 *
 * Reset value: 0xFFU
 */
/*!
 * @name Constants and macros for entire CRC_GPOLYHU register
 */
/*@{*/
#define CRC_RD_GPOLYHU(base)     (CRC_GPOLYHU_REG(base))
#define CRC_WR_GPOLYHU(base, value) (CRC_GPOLYHU_REG(base) = (value))
#define CRC_RMW_GPOLYHU(base, mask, value) (CRC_WR_GPOLYHU(base, (CRC_RD_GPOLYHU(base) & ~(mask)) | (value)))
#define CRC_SET_GPOLYHU(base, value) (BME_OR8(&CRC_GPOLYHU_REG(base), (uint8_t)(value)))
#define CRC_CLR_GPOLYHU(base, value) (BME_AND8(&CRC_GPOLYHU_REG(base), (uint8_t)(~(value))))
#define CRC_TOG_GPOLYHU(base, value) (BME_XOR8(&CRC_GPOLYHU_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * CRC_CTRL - CRC Control register
 ******************************************************************************/

/*!
 * @brief CRC_CTRL - CRC Control register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register controls the configuration and working of the CRC module.
 * Appropriate bits must be set before starting a new CRC calculation. A new CRC
 * calculation is initialized by asserting CTRL[WAS] and then writing the seed into
 * the CRC data register.
 */
/*!
 * @name Constants and macros for entire CRC_CTRL register
 */
/*@{*/
#define CRC_RD_CTRL(base)        (CRC_CTRL_REG(base))
#define CRC_WR_CTRL(base, value) (CRC_CTRL_REG(base) = (value))
#define CRC_RMW_CTRL(base, mask, value) (CRC_WR_CTRL(base, (CRC_RD_CTRL(base) & ~(mask)) | (value)))
#define CRC_SET_CTRL(base, value) (BME_OR32(&CRC_CTRL_REG(base), (uint32_t)(value)))
#define CRC_CLR_CTRL(base, value) (BME_AND32(&CRC_CTRL_REG(base), (uint32_t)(~(value))))
#define CRC_TOG_CTRL(base, value) (BME_XOR32(&CRC_CTRL_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual CRC_CTRL bitfields
 */

/*!
 * @name Register CRC_CTRL, field TCRC[24] (RW)
 *
 * Width of CRC protocol.
 *
 * Values:
 * - 0b0 - 16-bit CRC protocol.
 * - 0b1 - 32-bit CRC protocol.
 */
/*@{*/
/*! @brief Read current value of the CRC_CTRL_TCRC field. */
#define CRC_RD_CTRL_TCRC(base) ((CRC_CTRL_REG(base) & CRC_CTRL_TCRC_MASK) >> CRC_CTRL_TCRC_SHIFT)
#define CRC_BRD_CTRL_TCRC(base) (BME_UBFX32(&CRC_CTRL_REG(base), CRC_CTRL_TCRC_SHIFT, CRC_CTRL_TCRC_WIDTH))

/*! @brief Set the TCRC field to a new value. */
#define CRC_WR_CTRL_TCRC(base, value) (CRC_RMW_CTRL(base, CRC_CTRL_TCRC_MASK, CRC_CTRL_TCRC(value)))
#define CRC_BWR_CTRL_TCRC(base, value) (BME_BFI32(&CRC_CTRL_REG(base), ((uint32_t)(value) << CRC_CTRL_TCRC_SHIFT), CRC_CTRL_TCRC_SHIFT, CRC_CTRL_TCRC_WIDTH))
/*@}*/

/*!
 * @name Register CRC_CTRL, field WAS[25] (RW)
 *
 * When asserted, a value written to the CRC data register is considered a seed
 * value. When deasserted, a value written to the CRC data register is taken as
 * data for CRC computation.
 *
 * Values:
 * - 0b0 - Writes to the CRC data register are data values.
 * - 0b1 - Writes to the CRC data register are seed values.
 */
/*@{*/
/*! @brief Read current value of the CRC_CTRL_WAS field. */
#define CRC_RD_CTRL_WAS(base) ((CRC_CTRL_REG(base) & CRC_CTRL_WAS_MASK) >> CRC_CTRL_WAS_SHIFT)
#define CRC_BRD_CTRL_WAS(base) (BME_UBFX32(&CRC_CTRL_REG(base), CRC_CTRL_WAS_SHIFT, CRC_CTRL_WAS_WIDTH))

/*! @brief Set the WAS field to a new value. */
#define CRC_WR_CTRL_WAS(base, value) (CRC_RMW_CTRL(base, CRC_CTRL_WAS_MASK, CRC_CTRL_WAS(value)))
#define CRC_BWR_CTRL_WAS(base, value) (BME_BFI32(&CRC_CTRL_REG(base), ((uint32_t)(value) << CRC_CTRL_WAS_SHIFT), CRC_CTRL_WAS_SHIFT, CRC_CTRL_WAS_WIDTH))
/*@}*/

/*!
 * @name Register CRC_CTRL, field FXOR[26] (RW)
 *
 * Some CRC protocols require the final checksum to be XORed with 0xFFFFFFFF or
 * 0xFFFF. Asserting this bit enables on the fly complementing of read data.
 *
 * Values:
 * - 0b0 - No XOR on reading.
 * - 0b1 - Invert or complement the read value of the CRC Data register.
 */
/*@{*/
/*! @brief Read current value of the CRC_CTRL_FXOR field. */
#define CRC_RD_CTRL_FXOR(base) ((CRC_CTRL_REG(base) & CRC_CTRL_FXOR_MASK) >> CRC_CTRL_FXOR_SHIFT)
#define CRC_BRD_CTRL_FXOR(base) (BME_UBFX32(&CRC_CTRL_REG(base), CRC_CTRL_FXOR_SHIFT, CRC_CTRL_FXOR_WIDTH))

/*! @brief Set the FXOR field to a new value. */
#define CRC_WR_CTRL_FXOR(base, value) (CRC_RMW_CTRL(base, CRC_CTRL_FXOR_MASK, CRC_CTRL_FXOR(value)))
#define CRC_BWR_CTRL_FXOR(base, value) (BME_BFI32(&CRC_CTRL_REG(base), ((uint32_t)(value) << CRC_CTRL_FXOR_SHIFT), CRC_CTRL_FXOR_SHIFT, CRC_CTRL_FXOR_WIDTH))
/*@}*/

/*!
 * @name Register CRC_CTRL, field TOTR[29:28] (RW)
 *
 * Identifies the transpose configuration of the value read from the CRC Data
 * register. See the description of the transpose feature for the available
 * transpose options.
 *
 * Values:
 * - 0b00 - No transposition.
 * - 0b01 - Bits in bytes are transposed; bytes are not transposed.
 * - 0b10 - Both bits in bytes and bytes are transposed.
 * - 0b11 - Only bytes are transposed; no bits in a byte are transposed.
 */
/*@{*/
/*! @brief Read current value of the CRC_CTRL_TOTR field. */
#define CRC_RD_CTRL_TOTR(base) ((CRC_CTRL_REG(base) & CRC_CTRL_TOTR_MASK) >> CRC_CTRL_TOTR_SHIFT)
#define CRC_BRD_CTRL_TOTR(base) (BME_UBFX32(&CRC_CTRL_REG(base), CRC_CTRL_TOTR_SHIFT, CRC_CTRL_TOTR_WIDTH))

/*! @brief Set the TOTR field to a new value. */
#define CRC_WR_CTRL_TOTR(base, value) (CRC_RMW_CTRL(base, CRC_CTRL_TOTR_MASK, CRC_CTRL_TOTR(value)))
#define CRC_BWR_CTRL_TOTR(base, value) (BME_BFI32(&CRC_CTRL_REG(base), ((uint32_t)(value) << CRC_CTRL_TOTR_SHIFT), CRC_CTRL_TOTR_SHIFT, CRC_CTRL_TOTR_WIDTH))
/*@}*/

/*!
 * @name Register CRC_CTRL, field TOT[31:30] (RW)
 *
 * Defines the transpose configuration of the data written to the CRC data
 * register. See the description of the transpose feature for the available transpose
 * options.
 *
 * Values:
 * - 0b00 - No transposition.
 * - 0b01 - Bits in bytes are transposed; bytes are not transposed.
 * - 0b10 - Both bits in bytes and bytes are transposed.
 * - 0b11 - Only bytes are transposed; no bits in a byte are transposed.
 */
/*@{*/
/*! @brief Read current value of the CRC_CTRL_TOT field. */
#define CRC_RD_CTRL_TOT(base) ((CRC_CTRL_REG(base) & CRC_CTRL_TOT_MASK) >> CRC_CTRL_TOT_SHIFT)
#define CRC_BRD_CTRL_TOT(base) (BME_UBFX32(&CRC_CTRL_REG(base), CRC_CTRL_TOT_SHIFT, CRC_CTRL_TOT_WIDTH))

/*! @brief Set the TOT field to a new value. */
#define CRC_WR_CTRL_TOT(base, value) (CRC_RMW_CTRL(base, CRC_CTRL_TOT_MASK, CRC_CTRL_TOT(value)))
#define CRC_BWR_CTRL_TOT(base, value) (BME_BFI32(&CRC_CTRL_REG(base), ((uint32_t)(value) << CRC_CTRL_TOT_SHIFT), CRC_CTRL_TOT_SHIFT, CRC_CTRL_TOT_WIDTH))
/*@}*/

/*******************************************************************************
 * CRC_CTRLHU - CRC_CTRLHU register.
 ******************************************************************************/

/*!
 * @brief CRC_CTRLHU - CRC_CTRLHU register. (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire CRC_CTRLHU register
 */
/*@{*/
#define CRC_RD_CTRLHU(base)      (CRC_CTRLHU_REG(base))
#define CRC_WR_CTRLHU(base, value) (CRC_CTRLHU_REG(base) = (value))
#define CRC_RMW_CTRLHU(base, mask, value) (CRC_WR_CTRLHU(base, (CRC_RD_CTRLHU(base) & ~(mask)) | (value)))
#define CRC_SET_CTRLHU(base, value) (BME_OR8(&CRC_CTRLHU_REG(base), (uint8_t)(value)))
#define CRC_CLR_CTRLHU(base, value) (BME_AND8(&CRC_CTRLHU_REG(base), (uint8_t)(~(value))))
#define CRC_TOG_CTRLHU(base, value) (BME_XOR8(&CRC_CTRLHU_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual CRC_CTRLHU bitfields
 */

/*!
 * @name Register CRC_CTRLHU, field TCRC[0] (RW)
 *
 * Values:
 * - 0b0 - 16-bit CRC protocol.
 * - 0b1 - 32-bit CRC protocol.
 */
/*@{*/
/*! @brief Read current value of the CRC_CTRLHU_TCRC field. */
#define CRC_RD_CTRLHU_TCRC(base) ((CRC_CTRLHU_REG(base) & CRC_CTRLHU_TCRC_MASK) >> CRC_CTRLHU_TCRC_SHIFT)
#define CRC_BRD_CTRLHU_TCRC(base) (BME_UBFX8(&CRC_CTRLHU_REG(base), CRC_CTRLHU_TCRC_SHIFT, CRC_CTRLHU_TCRC_WIDTH))

/*! @brief Set the TCRC field to a new value. */
#define CRC_WR_CTRLHU_TCRC(base, value) (CRC_RMW_CTRLHU(base, CRC_CTRLHU_TCRC_MASK, CRC_CTRLHU_TCRC(value)))
#define CRC_BWR_CTRLHU_TCRC(base, value) (BME_BFI8(&CRC_CTRLHU_REG(base), ((uint8_t)(value) << CRC_CTRLHU_TCRC_SHIFT), CRC_CTRLHU_TCRC_SHIFT, CRC_CTRLHU_TCRC_WIDTH))
/*@}*/

/*!
 * @name Register CRC_CTRLHU, field WAS[1] (RW)
 *
 * Values:
 * - 0b0 - Writes to CRC data register are data values.
 * - 0b1 - Writes to CRC data reguster are seed values.
 */
/*@{*/
/*! @brief Read current value of the CRC_CTRLHU_WAS field. */
#define CRC_RD_CTRLHU_WAS(base) ((CRC_CTRLHU_REG(base) & CRC_CTRLHU_WAS_MASK) >> CRC_CTRLHU_WAS_SHIFT)
#define CRC_BRD_CTRLHU_WAS(base) (BME_UBFX8(&CRC_CTRLHU_REG(base), CRC_CTRLHU_WAS_SHIFT, CRC_CTRLHU_WAS_WIDTH))

/*! @brief Set the WAS field to a new value. */
#define CRC_WR_CTRLHU_WAS(base, value) (CRC_RMW_CTRLHU(base, CRC_CTRLHU_WAS_MASK, CRC_CTRLHU_WAS(value)))
#define CRC_BWR_CTRLHU_WAS(base, value) (BME_BFI8(&CRC_CTRLHU_REG(base), ((uint8_t)(value) << CRC_CTRLHU_WAS_SHIFT), CRC_CTRLHU_WAS_SHIFT, CRC_CTRLHU_WAS_WIDTH))
/*@}*/

/*!
 * @name Register CRC_CTRLHU, field FXOR[2] (RW)
 *
 * Values:
 * - 0b0 - No XOR on reading.
 * - 0b1 - Invert or complement the read value of CRC data register.
 */
/*@{*/
/*! @brief Read current value of the CRC_CTRLHU_FXOR field. */
#define CRC_RD_CTRLHU_FXOR(base) ((CRC_CTRLHU_REG(base) & CRC_CTRLHU_FXOR_MASK) >> CRC_CTRLHU_FXOR_SHIFT)
#define CRC_BRD_CTRLHU_FXOR(base) (BME_UBFX8(&CRC_CTRLHU_REG(base), CRC_CTRLHU_FXOR_SHIFT, CRC_CTRLHU_FXOR_WIDTH))

/*! @brief Set the FXOR field to a new value. */
#define CRC_WR_CTRLHU_FXOR(base, value) (CRC_RMW_CTRLHU(base, CRC_CTRLHU_FXOR_MASK, CRC_CTRLHU_FXOR(value)))
#define CRC_BWR_CTRLHU_FXOR(base, value) (BME_BFI8(&CRC_CTRLHU_REG(base), ((uint8_t)(value) << CRC_CTRLHU_FXOR_SHIFT), CRC_CTRLHU_FXOR_SHIFT, CRC_CTRLHU_FXOR_WIDTH))
/*@}*/

/*!
 * @name Register CRC_CTRLHU, field TOTR[5:4] (RW)
 *
 * Values:
 * - 0b00 - No Transposition.
 * - 0b01 - Bits in bytes are transposed, bytes are not transposed.
 * - 0b10 - Both bits in bytes and bytes are transposed.
 * - 0b11 - Only bytes are transposed; no bits in a byte are transposed.
 */
/*@{*/
/*! @brief Read current value of the CRC_CTRLHU_TOTR field. */
#define CRC_RD_CTRLHU_TOTR(base) ((CRC_CTRLHU_REG(base) & CRC_CTRLHU_TOTR_MASK) >> CRC_CTRLHU_TOTR_SHIFT)
#define CRC_BRD_CTRLHU_TOTR(base) (BME_UBFX8(&CRC_CTRLHU_REG(base), CRC_CTRLHU_TOTR_SHIFT, CRC_CTRLHU_TOTR_WIDTH))

/*! @brief Set the TOTR field to a new value. */
#define CRC_WR_CTRLHU_TOTR(base, value) (CRC_RMW_CTRLHU(base, CRC_CTRLHU_TOTR_MASK, CRC_CTRLHU_TOTR(value)))
#define CRC_BWR_CTRLHU_TOTR(base, value) (BME_BFI8(&CRC_CTRLHU_REG(base), ((uint8_t)(value) << CRC_CTRLHU_TOTR_SHIFT), CRC_CTRLHU_TOTR_SHIFT, CRC_CTRLHU_TOTR_WIDTH))
/*@}*/

/*!
 * @name Register CRC_CTRLHU, field TOT[7:6] (RW)
 *
 * Values:
 * - 0b00 - No Transposition.
 * - 0b01 - Bits in bytes are transposed, bytes are not transposed.
 * - 0b10 - Both bits in bytes and bytes are transposed.
 * - 0b11 - Only bytes are transposed; no bits in a byte are transposed.
 */
/*@{*/
/*! @brief Read current value of the CRC_CTRLHU_TOT field. */
#define CRC_RD_CTRLHU_TOT(base) ((CRC_CTRLHU_REG(base) & CRC_CTRLHU_TOT_MASK) >> CRC_CTRLHU_TOT_SHIFT)
#define CRC_BRD_CTRLHU_TOT(base) (BME_UBFX8(&CRC_CTRLHU_REG(base), CRC_CTRLHU_TOT_SHIFT, CRC_CTRLHU_TOT_WIDTH))

/*! @brief Set the TOT field to a new value. */
#define CRC_WR_CTRLHU_TOT(base, value) (CRC_RMW_CTRLHU(base, CRC_CTRLHU_TOT_MASK, CRC_CTRLHU_TOT(value)))
#define CRC_BWR_CTRLHU_TOT(base, value) (BME_BFI8(&CRC_CTRLHU_REG(base), ((uint8_t)(value) << CRC_CTRLHU_TOT_SHIFT), CRC_CTRLHU_TOT_SHIFT, CRC_CTRLHU_TOT_WIDTH))
/*@}*/

/*
 * MKM34Z7 DMA
 *
 * DMA Controller
 *
 * Registers defined in this header file:
 * - DMA_SAR - Source Address Register
 * - DMA_DAR - Destination Address Register
 * - DMA_DSR - DMA_DSR0 register.
 * - DMA_DSR_BCR - DMA Status Register / Byte Count Register
 * - DMA_DCR - DMA Control Register
 */

#define DMA_INSTANCE_COUNT (1U) /*!< Number of instances of the DMA module. */
#define DMA_IDX (0U) /*!< Instance number for DMA. */

/*******************************************************************************
 * DMA_SAR - Source Address Register
 ******************************************************************************/

/*!
 * @brief DMA_SAR - Source Address Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * For this register: Only 32-bit writes are allowed. 16-bit and 8-bit writes
 * result in a bus error. Only several values are allowed to be written to bits
 * 31-20 of this register, see the value list in the field description. A write of
 * any other value to these bits causes a configuration error when the channel
 * starts to execute. For more information about the configuration error, see the
 * description of the CEConfiguration Error field of DSR.
 */
/*!
 * @name Constants and macros for entire DMA_SAR register
 */
/*@{*/
#define DMA_RD_SAR(base, index)  (DMA_SAR_REG(base, index))
#define DMA_WR_SAR(base, index, value) (DMA_SAR_REG(base, index) = (value))
#define DMA_RMW_SAR(base, index, mask, value) (DMA_WR_SAR(base, index, (DMA_RD_SAR(base, index) & ~(mask)) | (value)))
#define DMA_SET_SAR(base, index, value) (BME_OR32(&DMA_SAR_REG(base, index), (uint32_t)(value)))
#define DMA_CLR_SAR(base, index, value) (BME_AND32(&DMA_SAR_REG(base, index), (uint32_t)(~(value))))
#define DMA_TOG_SAR(base, index, value) (BME_XOR32(&DMA_SAR_REG(base, index), (uint32_t)(value)))
/*@}*/

/*******************************************************************************
 * DMA_DAR - Destination Address Register
 ******************************************************************************/

/*!
 * @brief DMA_DAR - Destination Address Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * For this register: Only 32-bit writes are allowed. 16-bit and 8-bit writes
 * result in a bus error. Only several values are allowed to be written to bits
 * 31-20 of this register, see the value list in the field description. A write of
 * any other value to these bits causes a configuration error when the channel
 * starts to execute. For more information about the configuration error, see the
 * description of the CEConfiguration Error field of DSR.
 */
/*!
 * @name Constants and macros for entire DMA_DAR register
 */
/*@{*/
#define DMA_RD_DAR(base, index)  (DMA_DAR_REG(base, index))
#define DMA_WR_DAR(base, index, value) (DMA_DAR_REG(base, index) = (value))
#define DMA_RMW_DAR(base, index, mask, value) (DMA_WR_DAR(base, index, (DMA_RD_DAR(base, index) & ~(mask)) | (value)))
#define DMA_SET_DAR(base, index, value) (BME_OR32(&DMA_DAR_REG(base, index), (uint32_t)(value)))
#define DMA_CLR_DAR(base, index, value) (BME_AND32(&DMA_DAR_REG(base, index), (uint32_t)(~(value))))
#define DMA_TOG_DAR(base, index, value) (BME_XOR32(&DMA_DAR_REG(base, index), (uint32_t)(value)))
/*@}*/

/*******************************************************************************
 * DMA_DSR_BCR - DMA Status Register / Byte Count Register
 ******************************************************************************/

/*!
 * @brief DMA_DSR_BCR - DMA Status Register / Byte Count Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * DSR and BCR are two logical registers that occupy one 32-bit address. DSRn
 * occupies bits 31-24, and BCRn occupies bits 23-0. DSRn contains flags indicating
 * the channel status, and BCRn contains the number of bytes yet to be
 * transferred for a given block. On the successful completion of the write transfer, BCRn
 * decrements by 1, 2, or 4 for 8-bit, 16-bit, or 32-bit accesses, respectively.
 * BCRn is cleared if a 1 is written to DSR[DONE]. In response to an event, the
 * DMA controller writes to the appropriate DSRn bit. Only a write to DSRn[DONE]
 * results in action. DSRn[DONE] is set when the block transfer is complete. When
 * a transfer sequence is initiated and BCRn[BCR] is not a multiple of 4 or 2
 * when the DMA is configured for 32-bit or 16-bit transfers, respectively,
 * DSRn[CE] is set and no transfer occurs.
 */
/*!
 * @name Constants and macros for entire DMA_DSR_BCR register
 */
/*@{*/
#define DMA_RD_DSR_BCR(base, index) (DMA_DSR_BCR_REG(base, index))
#define DMA_WR_DSR_BCR(base, index, value) (DMA_DSR_BCR_REG(base, index) = (value))
#define DMA_RMW_DSR_BCR(base, index, mask, value) (DMA_WR_DSR_BCR(base, index, (DMA_RD_DSR_BCR(base, index) & ~(mask)) | (value)))
#define DMA_SET_DSR_BCR(base, index, value) (BME_OR32(&DMA_DSR_BCR_REG(base, index), (uint32_t)(value)))
#define DMA_CLR_DSR_BCR(base, index, value) (BME_AND32(&DMA_DSR_BCR_REG(base, index), (uint32_t)(~(value))))
#define DMA_TOG_DSR_BCR(base, index, value) (BME_XOR32(&DMA_DSR_BCR_REG(base, index), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual DMA_DSR_BCR bitfields
 */

/*!
 * @name Register DMA_DSR_BCR, field BCR[23:0] (RW)
 *
 * This field contains the number of bytes yet to be transferred for a given
 * block. BCR must be written with a value equal to or less than 0F_FFFFh. After
 * being written with a value in this range, bits 23-20 of BCR read back as 0000b. A
 * write to BCR of a value greater than 0F_FFFFh causes a configuration error
 * when the channel starts to execute. After being written with a value in this
 * range, bits 23-20 of BCR read back as 0001b.
 */
/*@{*/
/*! @brief Read current value of the DMA_DSR_BCR_BCR field. */
#define DMA_RD_DSR_BCR_BCR(base, index) ((DMA_DSR_BCR_REG(base, index) & DMA_DSR_BCR_BCR_MASK) >> DMA_DSR_BCR_BCR_SHIFT)
#define DMA_BRD_DSR_BCR_BCR(base, index) (DMA_RD_DSR_BCR_BCR(base, index))

/*! @brief Set the BCR field to a new value. */
#define DMA_WR_DSR_BCR_BCR(base, index, value) (DMA_RMW_DSR_BCR(base, index, (DMA_DSR_BCR_BCR_MASK | DMA_DSR_BCR_DONE_MASK), DMA_DSR_BCR_BCR(value)))
#define DMA_BWR_DSR_BCR_BCR(base, index, value) (DMA_WR_DSR_BCR_BCR(base, index, value))
/*@}*/

/*!
 * @name Register DMA_DSR_BCR, field DONE[24] (W1C)
 *
 * Set when all DMA controller transactions complete as determined by transfer
 * count, or based on error conditions. When BCR reaches 0, DONE is set when the
 * final transfer completes successfully. DONE can also be used to abort a
 * transfer by resetting the status bits. When a transfer completes, software must clear
 * DONE before reprogramming the DMA.
 *
 * Values:
 * - 0b0 - DMA transfer is not yet complete. Writing a 0 has no effect.
 * - 0b1 - DMA transfer completed. Writing a 1 to this bit clears all DMA status
 *     bits and should be used in an interrupt service routine to clear the DMA
 *     interrupt and error bits.
 */
/*@{*/
/*! @brief Read current value of the DMA_DSR_BCR_DONE field. */
#define DMA_RD_DSR_BCR_DONE(base, index) ((DMA_DSR_BCR_REG(base, index) & DMA_DSR_BCR_DONE_MASK) >> DMA_DSR_BCR_DONE_SHIFT)
#define DMA_BRD_DSR_BCR_DONE(base, index) (BME_UBFX32(&DMA_DSR_BCR_REG(base, index), DMA_DSR_BCR_DONE_SHIFT, DMA_DSR_BCR_DONE_WIDTH))

/*! @brief Set the DONE field to a new value. */
#define DMA_WR_DSR_BCR_DONE(base, index, value) (DMA_RMW_DSR_BCR(base, index, DMA_DSR_BCR_DONE_MASK, DMA_DSR_BCR_DONE(value)))
#define DMA_BWR_DSR_BCR_DONE(base, index, value) (BME_BFI32(&DMA_DSR_BCR_REG(base, index), ((uint32_t)(value) << DMA_DSR_BCR_DONE_SHIFT), DMA_DSR_BCR_DONE_SHIFT, DMA_DSR_BCR_DONE_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DSR_BCR, field BSY[25] (RO)
 *
 * Values:
 * - 0b0 - DMA channel is inactive. Cleared when the DMA has finished the last
 *     transaction.
 * - 0b1 - BSY is set the first time the channel is enabled after a transfer is
 *     initiated.
 */
/*@{*/
/*! @brief Read current value of the DMA_DSR_BCR_BSY field. */
#define DMA_RD_DSR_BCR_BSY(base, index) ((DMA_DSR_BCR_REG(base, index) & DMA_DSR_BCR_BSY_MASK) >> DMA_DSR_BCR_BSY_SHIFT)
#define DMA_BRD_DSR_BCR_BSY(base, index) (BME_UBFX32(&DMA_DSR_BCR_REG(base, index), DMA_DSR_BCR_BSY_SHIFT, DMA_DSR_BCR_BSY_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DSR_BCR, field REQ[26] (RO)
 *
 * Values:
 * - 0b0 - No request is pending or the channel is currently active. Cleared
 *     when the channel is selected.
 * - 0b1 - The DMA channel has a transfer remaining and the channel is not
 *     selected.
 */
/*@{*/
/*! @brief Read current value of the DMA_DSR_BCR_REQ field. */
#define DMA_RD_DSR_BCR_REQ(base, index) ((DMA_DSR_BCR_REG(base, index) & DMA_DSR_BCR_REQ_MASK) >> DMA_DSR_BCR_REQ_SHIFT)
#define DMA_BRD_DSR_BCR_REQ(base, index) (BME_UBFX32(&DMA_DSR_BCR_REG(base, index), DMA_DSR_BCR_REQ_SHIFT, DMA_DSR_BCR_REQ_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DSR_BCR, field BED[28] (RO)
 *
 * BED is cleared at hardware reset or by writing a 1 to DONE.
 *
 * Values:
 * - 0b0 - No bus error occurred.
 * - 0b1 - The DMA channel terminated with a bus error during the write portion
 *     of a transfer.
 */
/*@{*/
/*! @brief Read current value of the DMA_DSR_BCR_BED field. */
#define DMA_RD_DSR_BCR_BED(base, index) ((DMA_DSR_BCR_REG(base, index) & DMA_DSR_BCR_BED_MASK) >> DMA_DSR_BCR_BED_SHIFT)
#define DMA_BRD_DSR_BCR_BED(base, index) (BME_UBFX32(&DMA_DSR_BCR_REG(base, index), DMA_DSR_BCR_BED_SHIFT, DMA_DSR_BCR_BED_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DSR_BCR, field BES[29] (RO)
 *
 * BES is cleared at hardware reset or by writing a 1 to DONE.
 *
 * Values:
 * - 0b0 - No bus error occurred.
 * - 0b1 - The DMA channel terminated with a bus error during the read portion
 *     of a transfer.
 */
/*@{*/
/*! @brief Read current value of the DMA_DSR_BCR_BES field. */
#define DMA_RD_DSR_BCR_BES(base, index) ((DMA_DSR_BCR_REG(base, index) & DMA_DSR_BCR_BES_MASK) >> DMA_DSR_BCR_BES_SHIFT)
#define DMA_BRD_DSR_BCR_BES(base, index) (BME_UBFX32(&DMA_DSR_BCR_REG(base, index), DMA_DSR_BCR_BES_SHIFT, DMA_DSR_BCR_BES_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DSR_BCR, field CE[30] (RO)
 *
 * Any of the following conditions causes a configuration error: BCR, SAR, or
 * DAR does not match the requested transfer size. A value greater than 0F_FFFFh is
 * written to BCR. Bits 31-20 of SAR or DAR are written with a value other than
 * one of the allowed values. See SARSAR and DARDAR . SSIZE or DSIZE is set to an
 * unsupported value. BCR equals 0 when the DMA receives a start condition. CE
 * is cleared at hardware reset or by writing a 1 to DONE.
 *
 * Values:
 * - 0b0 - No configuration error exists.
 * - 0b1 - A configuration error has occurred.
 */
/*@{*/
/*! @brief Read current value of the DMA_DSR_BCR_CE field. */
#define DMA_RD_DSR_BCR_CE(base, index) ((DMA_DSR_BCR_REG(base, index) & DMA_DSR_BCR_CE_MASK) >> DMA_DSR_BCR_CE_SHIFT)
#define DMA_BRD_DSR_BCR_CE(base, index) (BME_UBFX32(&DMA_DSR_BCR_REG(base, index), DMA_DSR_BCR_CE_SHIFT, DMA_DSR_BCR_CE_WIDTH))
/*@}*/

/*******************************************************************************
 * DMA_DSR - DMA_DSR0 register.
 ******************************************************************************/

/*!
 * @brief DMA_DSR - DMA_DSR0 register. (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire DMA_DSR register
 */
/*@{*/
#define DMA_RD_DSR(base, index)  (DMA_DSR_REG(base, index))
#define DMA_WR_DSR(base, index, value) (DMA_DSR_REG(base, index) = (value))
#define DMA_RMW_DSR(base, index, mask, value) (DMA_WR_DSR(base, index, (DMA_RD_DSR(base, index) & ~(mask)) | (value)))
#define DMA_SET_DSR(base, index, value) (BME_OR8(&DMA_DSR_REG(base, index), (uint8_t)(value)))
#define DMA_CLR_DSR(base, index, value) (BME_AND8(&DMA_DSR_REG(base, index), (uint8_t)(~(value))))
#define DMA_TOG_DSR(base, index, value) (BME_XOR8(&DMA_DSR_REG(base, index), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * DMA_DCR - DMA Control Register
 ******************************************************************************/

/*!
 * @brief DMA_DCR - DMA Control Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire DMA_DCR register
 */
/*@{*/
#define DMA_RD_DCR(base, index)  (DMA_DCR_REG(base, index))
#define DMA_WR_DCR(base, index, value) (DMA_DCR_REG(base, index) = (value))
#define DMA_RMW_DCR(base, index, mask, value) (DMA_WR_DCR(base, index, (DMA_RD_DCR(base, index) & ~(mask)) | (value)))
#define DMA_SET_DCR(base, index, value) (BME_OR32(&DMA_DCR_REG(base, index), (uint32_t)(value)))
#define DMA_CLR_DCR(base, index, value) (BME_AND32(&DMA_DCR_REG(base, index), (uint32_t)(~(value))))
#define DMA_TOG_DCR(base, index, value) (BME_XOR32(&DMA_DCR_REG(base, index), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual DMA_DCR bitfields
 */

/*!
 * @name Register DMA_DCR, field LCH2[1:0] (RW)
 *
 * Indicates the DMA channel assigned as link channel 2. The link channel number
 * cannot be the same as the currently executing channel, and generates a
 * configuration error if this is attempted (DSRn[CE] is set).
 *
 * Values:
 * - 0b00 - DMA Channel 0
 * - 0b01 - DMA Channel 1
 * - 0b10 - DMA Channel 2
 * - 0b11 - DMA Channel 3
 */
/*@{*/
/*! @brief Read current value of the DMA_DCR_LCH2 field. */
#define DMA_RD_DCR_LCH2(base, index) ((DMA_DCR_REG(base, index) & DMA_DCR_LCH2_MASK) >> DMA_DCR_LCH2_SHIFT)
#define DMA_BRD_DCR_LCH2(base, index) (BME_UBFX32(&DMA_DCR_REG(base, index), DMA_DCR_LCH2_SHIFT, DMA_DCR_LCH2_WIDTH))

/*! @brief Set the LCH2 field to a new value. */
#define DMA_WR_DCR_LCH2(base, index, value) (DMA_RMW_DCR(base, index, DMA_DCR_LCH2_MASK, DMA_DCR_LCH2(value)))
#define DMA_BWR_DCR_LCH2(base, index, value) (BME_BFI32(&DMA_DCR_REG(base, index), ((uint32_t)(value) << DMA_DCR_LCH2_SHIFT), DMA_DCR_LCH2_SHIFT, DMA_DCR_LCH2_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DCR, field LCH1[3:2] (RW)
 *
 * Indicates the DMA channel assigned as link channel 1. The link channel number
 * cannot be the same as the currently executing channel, and generates a
 * configuration error if this is attempted (DSRn[CE] is set).
 *
 * Values:
 * - 0b00 - DMA Channel 0
 * - 0b01 - DMA Channel 1
 * - 0b10 - DMA Channel 2
 * - 0b11 - DMA Channel 3
 */
/*@{*/
/*! @brief Read current value of the DMA_DCR_LCH1 field. */
#define DMA_RD_DCR_LCH1(base, index) ((DMA_DCR_REG(base, index) & DMA_DCR_LCH1_MASK) >> DMA_DCR_LCH1_SHIFT)
#define DMA_BRD_DCR_LCH1(base, index) (BME_UBFX32(&DMA_DCR_REG(base, index), DMA_DCR_LCH1_SHIFT, DMA_DCR_LCH1_WIDTH))

/*! @brief Set the LCH1 field to a new value. */
#define DMA_WR_DCR_LCH1(base, index, value) (DMA_RMW_DCR(base, index, DMA_DCR_LCH1_MASK, DMA_DCR_LCH1(value)))
#define DMA_BWR_DCR_LCH1(base, index, value) (BME_BFI32(&DMA_DCR_REG(base, index), ((uint32_t)(value) << DMA_DCR_LCH1_SHIFT), DMA_DCR_LCH1_SHIFT, DMA_DCR_LCH1_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DCR, field LINKCC[5:4] (RW)
 *
 * Allows DMA channels to have their transfers linked. The current DMA channel
 * triggers a DMA request to the linked channels (LCH1 or LCH2) depending on the
 * condition described by the LINKCC bits. If not in cycle steal mode (DCRn[CS]=0)
 * and LINKCC equals 01 or 10, no link to LCH1 occurs. If LINKCC equals 01, a
 * link to LCH1 is created after each cycle-steal transfer performed by the current
 * DMA channel is completed. As the last cycle-steal is performed and the BCR
 * reaches zero, then the link to LCH1 is closed and a link to LCH2 is created.
 *
 * Values:
 * - 0b00 - No channel-to-channel linking
 * - 0b01 - Perform a link to channel LCH1 after each cycle-steal transfer
 *     followed by a link to LCH2 after the BCR decrements to 0.
 * - 0b10 - Perform a link to channel LCH1 after each cycle-steal transfer
 * - 0b11 - Perform a link to channel LCH1 after the BCR decrements to 0.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCR_LINKCC field. */
#define DMA_RD_DCR_LINKCC(base, index) ((DMA_DCR_REG(base, index) & DMA_DCR_LINKCC_MASK) >> DMA_DCR_LINKCC_SHIFT)
#define DMA_BRD_DCR_LINKCC(base, index) (BME_UBFX32(&DMA_DCR_REG(base, index), DMA_DCR_LINKCC_SHIFT, DMA_DCR_LINKCC_WIDTH))

/*! @brief Set the LINKCC field to a new value. */
#define DMA_WR_DCR_LINKCC(base, index, value) (DMA_RMW_DCR(base, index, DMA_DCR_LINKCC_MASK, DMA_DCR_LINKCC(value)))
#define DMA_BWR_DCR_LINKCC(base, index, value) (BME_BFI32(&DMA_DCR_REG(base, index), ((uint32_t)(value) << DMA_DCR_LINKCC_SHIFT), DMA_DCR_LINKCC_SHIFT, DMA_DCR_LINKCC_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DCR, field D_REQ[7] (RW)
 *
 * DMA hardware automatically clears the corresponding DCRn[ERQ] bit when the
 * byte count register reaches 0.
 *
 * Values:
 * - 0b0 - ERQ bit is not affected.
 * - 0b1 - ERQ bit is cleared when the BCR is exhausted.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCR_D_REQ field. */
#define DMA_RD_DCR_D_REQ(base, index) ((DMA_DCR_REG(base, index) & DMA_DCR_D_REQ_MASK) >> DMA_DCR_D_REQ_SHIFT)
#define DMA_BRD_DCR_D_REQ(base, index) (BME_UBFX32(&DMA_DCR_REG(base, index), DMA_DCR_D_REQ_SHIFT, DMA_DCR_D_REQ_WIDTH))

/*! @brief Set the D_REQ field to a new value. */
#define DMA_WR_DCR_D_REQ(base, index, value) (DMA_RMW_DCR(base, index, DMA_DCR_D_REQ_MASK, DMA_DCR_D_REQ(value)))
#define DMA_BWR_DCR_D_REQ(base, index, value) (BME_BFI32(&DMA_DCR_REG(base, index), ((uint32_t)(value) << DMA_DCR_D_REQ_SHIFT), DMA_DCR_D_REQ_SHIFT, DMA_DCR_D_REQ_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DCR, field DMOD[11:8] (RW)
 *
 * Defines the size of the destination data circular buffer used by the DMA
 * Controller. If enabled (DMOD value is non-zero), the buffer base address is
 * located on a boundary of the buffer size. The value of this boundary depends on the
 * initial destination address (DAR). The base address should be aligned to a
 * 0-modulo-(circular buffer size) boundary. Misaligned buffers are not possible.
 * The boundary is forced to the value determined by the upper address bits in the
 * field selection.
 *
 * Values:
 * - 0b0000 - Buffer disabled
 * - 0b0001 - Circular buffer size is 16 bytes
 * - 0b0010 - Circular buffer size is 32 bytes
 * - 0b0011 - Circular buffer size is 64 bytes
 * - 0b0100 - Circular buffer size is 128 bytes
 * - 0b0101 - Circular buffer size is 256 bytes
 * - 0b0110 - Circular buffer size is 512 bytes
 * - 0b0111 - Circular buffer size is 1 KB
 * - 0b1000 - Circular buffer size is 2 KB
 * - 0b1001 - Circular buffer size is 4 KB
 * - 0b1010 - Circular buffer size is 8 KB
 * - 0b1011 - Circular buffer size is 16 KB
 * - 0b1100 - Circular buffer size is 32 KB
 * - 0b1101 - Circular buffer size is 64 KB
 * - 0b1110 - Circular buffer size is 128 KB
 * - 0b1111 - Circular buffer size is 256 KB
 */
/*@{*/
/*! @brief Read current value of the DMA_DCR_DMOD field. */
#define DMA_RD_DCR_DMOD(base, index) ((DMA_DCR_REG(base, index) & DMA_DCR_DMOD_MASK) >> DMA_DCR_DMOD_SHIFT)
#define DMA_BRD_DCR_DMOD(base, index) (BME_UBFX32(&DMA_DCR_REG(base, index), DMA_DCR_DMOD_SHIFT, DMA_DCR_DMOD_WIDTH))

/*! @brief Set the DMOD field to a new value. */
#define DMA_WR_DCR_DMOD(base, index, value) (DMA_RMW_DCR(base, index, DMA_DCR_DMOD_MASK, DMA_DCR_DMOD(value)))
#define DMA_BWR_DCR_DMOD(base, index, value) (BME_BFI32(&DMA_DCR_REG(base, index), ((uint32_t)(value) << DMA_DCR_DMOD_SHIFT), DMA_DCR_DMOD_SHIFT, DMA_DCR_DMOD_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DCR, field SMOD[15:12] (RW)
 *
 * Defines the size of the source data circular buffer used by the DMA
 * Controller. If enabled (SMOD is non-zero), the buffer base address is located on a
 * boundary of the buffer size. The value of this boundary is based upon the initial
 * source address (SAR). The base address should be aligned to a
 * 0-modulo-(circular buffer size) boundary. Misaligned buffers are not possible. The boundary is
 * forced to the value determined by the upper address bits in the field
 * selection.
 *
 * Values:
 * - 0b0000 - Buffer disabled
 * - 0b0001 - Circular buffer size is 16 bytes.
 * - 0b0010 - Circular buffer size is 32 bytes.
 * - 0b0011 - Circular buffer size is 64 bytes.
 * - 0b0100 - Circular buffer size is 128 bytes.
 * - 0b0101 - Circular buffer size is 256 bytes.
 * - 0b0110 - Circular buffer size is 512 bytes.
 * - 0b0111 - Circular buffer size is 1 KB.
 * - 0b1000 - Circular buffer size is 2 KB.
 * - 0b1001 - Circular buffer size is 4 KB.
 * - 0b1010 - Circular buffer size is 8 KB.
 * - 0b1011 - Circular buffer size is 16 KB.
 * - 0b1100 - Circular buffer size is 32 KB.
 * - 0b1101 - Circular buffer size is 64 KB.
 * - 0b1110 - Circular buffer size is 128 KB.
 * - 0b1111 - Circular buffer size is 256 KB.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCR_SMOD field. */
#define DMA_RD_DCR_SMOD(base, index) ((DMA_DCR_REG(base, index) & DMA_DCR_SMOD_MASK) >> DMA_DCR_SMOD_SHIFT)
#define DMA_BRD_DCR_SMOD(base, index) (BME_UBFX32(&DMA_DCR_REG(base, index), DMA_DCR_SMOD_SHIFT, DMA_DCR_SMOD_WIDTH))

/*! @brief Set the SMOD field to a new value. */
#define DMA_WR_DCR_SMOD(base, index, value) (DMA_RMW_DCR(base, index, DMA_DCR_SMOD_MASK, DMA_DCR_SMOD(value)))
#define DMA_BWR_DCR_SMOD(base, index, value) (BME_BFI32(&DMA_DCR_REG(base, index), ((uint32_t)(value) << DMA_DCR_SMOD_SHIFT), DMA_DCR_SMOD_SHIFT, DMA_DCR_SMOD_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DCR, field START[16] (WORZ)
 *
 * Values:
 * - 0b0 - DMA inactive
 * - 0b1 - The DMA begins the transfer in accordance to the values in the TCDn.
 *     START is cleared automatically after one module clock and always reads as
 *     logic 0.
 */
/*@{*/
/*! @brief Set the START field to a new value. */
#define DMA_WR_DCR_START(base, index, value) (DMA_RMW_DCR(base, index, DMA_DCR_START_MASK, DMA_DCR_START(value)))
#define DMA_BWR_DCR_START(base, index, value) (BME_BFI32(&DMA_DCR_REG(base, index), ((uint32_t)(value) << DMA_DCR_START_SHIFT), DMA_DCR_START_SHIFT, DMA_DCR_START_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DCR, field DSIZE[18:17] (RW)
 *
 * Determines the data size of the destination bus cycle for the DMA controller.
 *
 * Values:
 * - 0b00 - 32-bit
 * - 0b01 - 8-bit
 * - 0b10 - 16-bit
 * - 0b11 - Reserved (generates a configuration error (DSRn[CE]) if incorrectly
 *     specified at time of channel activation)
 */
/*@{*/
/*! @brief Read current value of the DMA_DCR_DSIZE field. */
#define DMA_RD_DCR_DSIZE(base, index) ((DMA_DCR_REG(base, index) & DMA_DCR_DSIZE_MASK) >> DMA_DCR_DSIZE_SHIFT)
#define DMA_BRD_DCR_DSIZE(base, index) (BME_UBFX32(&DMA_DCR_REG(base, index), DMA_DCR_DSIZE_SHIFT, DMA_DCR_DSIZE_WIDTH))

/*! @brief Set the DSIZE field to a new value. */
#define DMA_WR_DCR_DSIZE(base, index, value) (DMA_RMW_DCR(base, index, DMA_DCR_DSIZE_MASK, DMA_DCR_DSIZE(value)))
#define DMA_BWR_DCR_DSIZE(base, index, value) (BME_BFI32(&DMA_DCR_REG(base, index), ((uint32_t)(value) << DMA_DCR_DSIZE_SHIFT), DMA_DCR_DSIZE_SHIFT, DMA_DCR_DSIZE_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DCR, field DINC[19] (RW)
 *
 * Controls whether the destination address increments after each successful
 * transfer.
 *
 * Values:
 * - 0b0 - No change to the DAR after a successful transfer.
 * - 0b1 - The DAR increments by 1, 2, 4 depending upon the size of the transfer.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCR_DINC field. */
#define DMA_RD_DCR_DINC(base, index) ((DMA_DCR_REG(base, index) & DMA_DCR_DINC_MASK) >> DMA_DCR_DINC_SHIFT)
#define DMA_BRD_DCR_DINC(base, index) (BME_UBFX32(&DMA_DCR_REG(base, index), DMA_DCR_DINC_SHIFT, DMA_DCR_DINC_WIDTH))

/*! @brief Set the DINC field to a new value. */
#define DMA_WR_DCR_DINC(base, index, value) (DMA_RMW_DCR(base, index, DMA_DCR_DINC_MASK, DMA_DCR_DINC(value)))
#define DMA_BWR_DCR_DINC(base, index, value) (BME_BFI32(&DMA_DCR_REG(base, index), ((uint32_t)(value) << DMA_DCR_DINC_SHIFT), DMA_DCR_DINC_SHIFT, DMA_DCR_DINC_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DCR, field SSIZE[21:20] (RW)
 *
 * Determines the data size of the source bus cycle for the DMA controller.
 *
 * Values:
 * - 0b00 - 32-bit
 * - 0b01 - 8-bit
 * - 0b10 - 16-bit
 * - 0b11 - Reserved (generates a configuration error (DSRn[CE]) if incorrectly
 *     specified at time of channel activation)
 */
/*@{*/
/*! @brief Read current value of the DMA_DCR_SSIZE field. */
#define DMA_RD_DCR_SSIZE(base, index) ((DMA_DCR_REG(base, index) & DMA_DCR_SSIZE_MASK) >> DMA_DCR_SSIZE_SHIFT)
#define DMA_BRD_DCR_SSIZE(base, index) (BME_UBFX32(&DMA_DCR_REG(base, index), DMA_DCR_SSIZE_SHIFT, DMA_DCR_SSIZE_WIDTH))

/*! @brief Set the SSIZE field to a new value. */
#define DMA_WR_DCR_SSIZE(base, index, value) (DMA_RMW_DCR(base, index, DMA_DCR_SSIZE_MASK, DMA_DCR_SSIZE(value)))
#define DMA_BWR_DCR_SSIZE(base, index, value) (BME_BFI32(&DMA_DCR_REG(base, index), ((uint32_t)(value) << DMA_DCR_SSIZE_SHIFT), DMA_DCR_SSIZE_SHIFT, DMA_DCR_SSIZE_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DCR, field SINC[22] (RW)
 *
 * Controls whether the source address increments after each successful transfer.
 *
 * Values:
 * - 0b0 - No change to SAR after a successful transfer.
 * - 0b1 - The SAR increments by 1, 2, 4 as determined by the transfer size.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCR_SINC field. */
#define DMA_RD_DCR_SINC(base, index) ((DMA_DCR_REG(base, index) & DMA_DCR_SINC_MASK) >> DMA_DCR_SINC_SHIFT)
#define DMA_BRD_DCR_SINC(base, index) (BME_UBFX32(&DMA_DCR_REG(base, index), DMA_DCR_SINC_SHIFT, DMA_DCR_SINC_WIDTH))

/*! @brief Set the SINC field to a new value. */
#define DMA_WR_DCR_SINC(base, index, value) (DMA_RMW_DCR(base, index, DMA_DCR_SINC_MASK, DMA_DCR_SINC(value)))
#define DMA_BWR_DCR_SINC(base, index, value) (BME_BFI32(&DMA_DCR_REG(base, index), ((uint32_t)(value) << DMA_DCR_SINC_SHIFT), DMA_DCR_SINC_SHIFT, DMA_DCR_SINC_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DCR, field EADREQ[23] (RW)
 *
 * Enables the channel to support asynchronous DREQs while the MCU is in Stop
 * mode.
 *
 * Values:
 * - 0b0 - Disabled
 * - 0b1 - Enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_DCR_EADREQ field. */
#define DMA_RD_DCR_EADREQ(base, index) ((DMA_DCR_REG(base, index) & DMA_DCR_EADREQ_MASK) >> DMA_DCR_EADREQ_SHIFT)
#define DMA_BRD_DCR_EADREQ(base, index) (BME_UBFX32(&DMA_DCR_REG(base, index), DMA_DCR_EADREQ_SHIFT, DMA_DCR_EADREQ_WIDTH))

/*! @brief Set the EADREQ field to a new value. */
#define DMA_WR_DCR_EADREQ(base, index, value) (DMA_RMW_DCR(base, index, DMA_DCR_EADREQ_MASK, DMA_DCR_EADREQ(value)))
#define DMA_BWR_DCR_EADREQ(base, index, value) (BME_BFI32(&DMA_DCR_REG(base, index), ((uint32_t)(value) << DMA_DCR_EADREQ_SHIFT), DMA_DCR_EADREQ_SHIFT, DMA_DCR_EADREQ_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DCR, field UMNSM[25:24] (RW)
 *
 * This 2-bit field defines the privileged/user and secure/nonsecure attributes
 * for the DMA channel as it executes. The contents of the write data operand
 * selects how the value is to be loaded into this field. When a given channel is
 * activated and executes, the DMA generates the appropriate privileged/user and
 * secure/nonsecure attributes for all source reads and destination writes using
 * UMNSM. The following table defines the association between the write data
 * operand, the initial system mode, and the resulting "next state" of UMNSM. Write to
 * UMNSM field Initial processor mode and result of UMNSM write Privileged,
 * Secure User, Secure User, Nonsecure 00 00 = {Privileged, Secure} 10 = {User,
 * Secure} 11 = {User, Nonsecure} 01 00 = {Privileged, Secure} No change; error
 * terminated No change; error terminated 10 10 = {User, Secure} 10 = {User, Secure} No
 * change; error terminated 11 11 = {User, Nonsecure} 11 = {User, Nonsecure} 11 =
 * {User, Nonsecure}
 *
 * Values:
 * - 0b00 - Channel attributes are set to the current mode.
 * - 0b01 - If the current mode is privileged and secure, then attributes are
 *     set to {privileged, secure}. Otherwise, writing this value terminates in an
 *     error.
 * - 0b10 - If the current mode is privileged and secure or if the current mode
 *     is user and secure, then attributes are set to {user, secure}. Otherwise,
 *     writing this value terminates in an error.
 * - 0b11 - If the current mode is privileged and secure, user and secure, or
 *     user and nonsecure, then attributes are set to {user, nonsecure}.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCR_UMNSM field. */
#define DMA_RD_DCR_UMNSM(base, index) ((DMA_DCR_REG(base, index) & DMA_DCR_UMNSM_MASK) >> DMA_DCR_UMNSM_SHIFT)
#define DMA_BRD_DCR_UMNSM(base, index) (BME_UBFX32(&DMA_DCR_REG(base, index), DMA_DCR_UMNSM_SHIFT, DMA_DCR_UMNSM_WIDTH))

/*! @brief Set the UMNSM field to a new value. */
#define DMA_WR_DCR_UMNSM(base, index, value) (DMA_RMW_DCR(base, index, DMA_DCR_UMNSM_MASK, DMA_DCR_UMNSM(value)))
#define DMA_BWR_DCR_UMNSM(base, index, value) (BME_BFI32(&DMA_DCR_REG(base, index), ((uint32_t)(value) << DMA_DCR_UMNSM_SHIFT), DMA_DCR_UMNSM_SHIFT, DMA_DCR_UMNSM_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DCR, field CHACR[27:26] (RW)
 *
 * This 2-bit field defines the access control mode needed to reference the
 * channel's transfer channel descriptor (TCDn). When a read or write access occurs
 * to any fields in the TCDn, if the system mode has sufficient privileges as
 * defined by CHACR, the access completes. Otherwise, the access aborts and
 * terminates in an error. The CHACR field can be changed only during operation in
 * privileged secure mode. In any other mode, attempted changes to this field are not
 * performed, and the access terminates with an error. The following table defines
 * the access of each mode for each value of CHACR. CHACR field Access allowed to
 * each processor mode Privileged, Secure User, Secure User, Nonsecure 00 Read +
 * Write Read + Write Read + Write 01 Read + Write Read + Write - (none) 1x Read
 * + Write - (none) - (none)
 */
/*@{*/
/*! @brief Read current value of the DMA_DCR_CHACR field. */
#define DMA_RD_DCR_CHACR(base, index) ((DMA_DCR_REG(base, index) & DMA_DCR_CHACR_MASK) >> DMA_DCR_CHACR_SHIFT)
#define DMA_BRD_DCR_CHACR(base, index) (BME_UBFX32(&DMA_DCR_REG(base, index), DMA_DCR_CHACR_SHIFT, DMA_DCR_CHACR_WIDTH))

/*! @brief Set the CHACR field to a new value. */
#define DMA_WR_DCR_CHACR(base, index, value) (DMA_RMW_DCR(base, index, DMA_DCR_CHACR_MASK, DMA_DCR_CHACR(value)))
#define DMA_BWR_DCR_CHACR(base, index, value) (BME_BFI32(&DMA_DCR_REG(base, index), ((uint32_t)(value) << DMA_DCR_CHACR_SHIFT), DMA_DCR_CHACR_SHIFT, DMA_DCR_CHACR_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DCR, field AA[28] (RW)
 *
 * AA and SIZE bits determine whether the source or destination is auto-aligned;
 * that is, transfers are optimized based on the address and size.
 *
 * Values:
 * - 0b0 - Auto-align disabled
 * - 0b1 - If SSIZE indicates a transfer no smaller than DSIZE, source accesses
 *     are auto-aligned; otherwise, destination accesses are auto-aligned. Source
 *     alignment takes precedence over destination alignment. If auto-alignment
 *     is enabled, the appropriate address register increments, regardless of
 *     DINC or SINC.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCR_AA field. */
#define DMA_RD_DCR_AA(base, index) ((DMA_DCR_REG(base, index) & DMA_DCR_AA_MASK) >> DMA_DCR_AA_SHIFT)
#define DMA_BRD_DCR_AA(base, index) (BME_UBFX32(&DMA_DCR_REG(base, index), DMA_DCR_AA_SHIFT, DMA_DCR_AA_WIDTH))

/*! @brief Set the AA field to a new value. */
#define DMA_WR_DCR_AA(base, index, value) (DMA_RMW_DCR(base, index, DMA_DCR_AA_MASK, DMA_DCR_AA(value)))
#define DMA_BWR_DCR_AA(base, index, value) (BME_BFI32(&DMA_DCR_REG(base, index), ((uint32_t)(value) << DMA_DCR_AA_SHIFT), DMA_DCR_AA_SHIFT, DMA_DCR_AA_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DCR, field CS[29] (RW)
 *
 * Values:
 * - 0b0 - DMA continuously makes read/write transfers until the BCR decrements
 *     to 0.
 * - 0b1 - Forces a single read/write transfer per request.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCR_CS field. */
#define DMA_RD_DCR_CS(base, index) ((DMA_DCR_REG(base, index) & DMA_DCR_CS_MASK) >> DMA_DCR_CS_SHIFT)
#define DMA_BRD_DCR_CS(base, index) (BME_UBFX32(&DMA_DCR_REG(base, index), DMA_DCR_CS_SHIFT, DMA_DCR_CS_WIDTH))

/*! @brief Set the CS field to a new value. */
#define DMA_WR_DCR_CS(base, index, value) (DMA_RMW_DCR(base, index, DMA_DCR_CS_MASK, DMA_DCR_CS(value)))
#define DMA_BWR_DCR_CS(base, index, value) (BME_BFI32(&DMA_DCR_REG(base, index), ((uint32_t)(value) << DMA_DCR_CS_SHIFT), DMA_DCR_CS_SHIFT, DMA_DCR_CS_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DCR, field ERQ[30] (RW)
 *
 * Be careful: a collision can occur between START and D_REQ when ERQ is 1.
 *
 * Values:
 * - 0b0 - Peripheral request is ignored.
 * - 0b1 - Enables peripheral request to initiate transfer. A software-initiated
 *     request (setting START) is always enabled.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCR_ERQ field. */
#define DMA_RD_DCR_ERQ(base, index) ((DMA_DCR_REG(base, index) & DMA_DCR_ERQ_MASK) >> DMA_DCR_ERQ_SHIFT)
#define DMA_BRD_DCR_ERQ(base, index) (BME_UBFX32(&DMA_DCR_REG(base, index), DMA_DCR_ERQ_SHIFT, DMA_DCR_ERQ_WIDTH))

/*! @brief Set the ERQ field to a new value. */
#define DMA_WR_DCR_ERQ(base, index, value) (DMA_RMW_DCR(base, index, DMA_DCR_ERQ_MASK, DMA_DCR_ERQ(value)))
#define DMA_BWR_DCR_ERQ(base, index, value) (BME_BFI32(&DMA_DCR_REG(base, index), ((uint32_t)(value) << DMA_DCR_ERQ_SHIFT), DMA_DCR_ERQ_SHIFT, DMA_DCR_ERQ_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DCR, field EINT[31] (RW)
 *
 * Determines whether an interrupt is generated by completing a transfer or by
 * the occurrence of an error condition.
 *
 * Values:
 * - 0b0 - No interrupt is generated.
 * - 0b1 - Interrupt signal is enabled.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCR_EINT field. */
#define DMA_RD_DCR_EINT(base, index) ((DMA_DCR_REG(base, index) & DMA_DCR_EINT_MASK) >> DMA_DCR_EINT_SHIFT)
#define DMA_BRD_DCR_EINT(base, index) (BME_UBFX32(&DMA_DCR_REG(base, index), DMA_DCR_EINT_SHIFT, DMA_DCR_EINT_WIDTH))

/*! @brief Set the EINT field to a new value. */
#define DMA_WR_DCR_EINT(base, index, value) (DMA_RMW_DCR(base, index, DMA_DCR_EINT_MASK, DMA_DCR_EINT(value)))
#define DMA_BWR_DCR_EINT(base, index, value) (BME_BFI32(&DMA_DCR_REG(base, index), ((uint32_t)(value) << DMA_DCR_EINT_SHIFT), DMA_DCR_EINT_SHIFT, DMA_DCR_EINT_WIDTH))
/*@}*/

/*
 * MKM34Z7 DMAMUX
 *
 * DMA channel multiplexor
 *
 * Registers defined in this header file:
 * - DMAMUX_CHCFG - Channel Configuration register
 */

#define DMAMUX_INSTANCE_COUNT (1U) /*!< Number of instances of the DMAMUX module. */
#define DMAMUX0_IDX (0U) /*!< Instance number for DMAMUX0. */

/*******************************************************************************
 * DMAMUX_CHCFG - Channel Configuration register
 ******************************************************************************/

/*!
 * @brief DMAMUX_CHCFG - Channel Configuration register (RW)
 *
 * Reset value: 0x00U
 *
 * Each of the DMA channels can be independently enabled/disabled and associated
 * with one of the DMA slots (peripheral slots or always-on slots) in the
 * system. Setting multiple CHCFG registers with the same source value will result in
 * unpredictable behavior. This is true, even if a channel is disabled (ENBL==0).
 * Before changing the trigger or source settings, a DMA channel must be disabled
 * via CHCFGn[ENBL].
 */
/*!
 * @name Constants and macros for entire DMAMUX_CHCFG register
 */
/*@{*/
#define DMAMUX_RD_CHCFG(base, index) (DMAMUX_CHCFG_REG(base, index))
#define DMAMUX_WR_CHCFG(base, index, value) (DMAMUX_CHCFG_REG(base, index) = (value))
#define DMAMUX_RMW_CHCFG(base, index, mask, value) (DMAMUX_WR_CHCFG(base, index, (DMAMUX_RD_CHCFG(base, index) & ~(mask)) | (value)))
#define DMAMUX_SET_CHCFG(base, index, value) (BME_OR8(&DMAMUX_CHCFG_REG(base, index), (uint8_t)(value)))
#define DMAMUX_CLR_CHCFG(base, index, value) (BME_AND8(&DMAMUX_CHCFG_REG(base, index), (uint8_t)(~(value))))
#define DMAMUX_TOG_CHCFG(base, index, value) (BME_XOR8(&DMAMUX_CHCFG_REG(base, index), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual DMAMUX_CHCFG bitfields
 */

/*!
 * @name Register DMAMUX_CHCFG, field SOURCE[5:0] (RW)
 *
 * Specifies which DMA source, if any, is routed to a particular DMA channel.
 * See the chip-specific DMAMUX information for details about the peripherals and
 * their slot numbers.
 */
/*@{*/
/*! @brief Read current value of the DMAMUX_CHCFG_SOURCE field. */
#define DMAMUX_RD_CHCFG_SOURCE(base, index) ((DMAMUX_CHCFG_REG(base, index) & DMAMUX_CHCFG_SOURCE_MASK) >> DMAMUX_CHCFG_SOURCE_SHIFT)
#define DMAMUX_BRD_CHCFG_SOURCE(base, index) (BME_UBFX8(&DMAMUX_CHCFG_REG(base, index), DMAMUX_CHCFG_SOURCE_SHIFT, DMAMUX_CHCFG_SOURCE_WIDTH))

/*! @brief Set the SOURCE field to a new value. */
#define DMAMUX_WR_CHCFG_SOURCE(base, index, value) (DMAMUX_RMW_CHCFG(base, index, DMAMUX_CHCFG_SOURCE_MASK, DMAMUX_CHCFG_SOURCE(value)))
#define DMAMUX_BWR_CHCFG_SOURCE(base, index, value) (BME_BFI8(&DMAMUX_CHCFG_REG(base, index), ((uint8_t)(value) << DMAMUX_CHCFG_SOURCE_SHIFT), DMAMUX_CHCFG_SOURCE_SHIFT, DMAMUX_CHCFG_SOURCE_WIDTH))
/*@}*/

/*!
 * @name Register DMAMUX_CHCFG, field TRIG[6] (RW)
 *
 * Enables the periodic trigger capability for the triggered DMA channel.
 *
 * Values:
 * - 0b0 - Triggering is disabled. If triggering is disabled and ENBL is set,
 *     the DMA Channel will simply route the specified source to the DMA channel.
 *     (Normal mode)
 * - 0b1 - Triggering is enabled. If triggering is enabled and ENBL is set, the
 *     DMAMUX is in Periodic Trigger mode.
 */
/*@{*/
/*! @brief Read current value of the DMAMUX_CHCFG_TRIG field. */
#define DMAMUX_RD_CHCFG_TRIG(base, index) ((DMAMUX_CHCFG_REG(base, index) & DMAMUX_CHCFG_TRIG_MASK) >> DMAMUX_CHCFG_TRIG_SHIFT)
#define DMAMUX_BRD_CHCFG_TRIG(base, index) (BME_UBFX8(&DMAMUX_CHCFG_REG(base, index), DMAMUX_CHCFG_TRIG_SHIFT, DMAMUX_CHCFG_TRIG_WIDTH))

/*! @brief Set the TRIG field to a new value. */
#define DMAMUX_WR_CHCFG_TRIG(base, index, value) (DMAMUX_RMW_CHCFG(base, index, DMAMUX_CHCFG_TRIG_MASK, DMAMUX_CHCFG_TRIG(value)))
#define DMAMUX_BWR_CHCFG_TRIG(base, index, value) (BME_BFI8(&DMAMUX_CHCFG_REG(base, index), ((uint8_t)(value) << DMAMUX_CHCFG_TRIG_SHIFT), DMAMUX_CHCFG_TRIG_SHIFT, DMAMUX_CHCFG_TRIG_WIDTH))
/*@}*/

/*!
 * @name Register DMAMUX_CHCFG, field ENBL[7] (RW)
 *
 * Enables the DMA channel.
 *
 * Values:
 * - 0b0 - DMA channel is disabled. This mode is primarily used during
 *     configuration of the DMAMux. The DMA has separate channel enables/disables, which
 *     should be used to disable or reconfigure a DMA channel.
 * - 0b1 - DMA channel is enabled
 */
/*@{*/
/*! @brief Read current value of the DMAMUX_CHCFG_ENBL field. */
#define DMAMUX_RD_CHCFG_ENBL(base, index) ((DMAMUX_CHCFG_REG(base, index) & DMAMUX_CHCFG_ENBL_MASK) >> DMAMUX_CHCFG_ENBL_SHIFT)
#define DMAMUX_BRD_CHCFG_ENBL(base, index) (BME_UBFX8(&DMAMUX_CHCFG_REG(base, index), DMAMUX_CHCFG_ENBL_SHIFT, DMAMUX_CHCFG_ENBL_WIDTH))

/*! @brief Set the ENBL field to a new value. */
#define DMAMUX_WR_CHCFG_ENBL(base, index, value) (DMAMUX_RMW_CHCFG(base, index, DMAMUX_CHCFG_ENBL_MASK, DMAMUX_CHCFG_ENBL(value)))
#define DMAMUX_BWR_CHCFG_ENBL(base, index, value) (BME_BFI8(&DMAMUX_CHCFG_REG(base, index), ((uint8_t)(value) << DMAMUX_CHCFG_ENBL_SHIFT), DMAMUX_CHCFG_ENBL_SHIFT, DMAMUX_CHCFG_ENBL_WIDTH))
/*@}*/

/*
 * MKM34Z7 EWM
 *
 * External Watchdog Monitor
 *
 * Registers defined in this header file:
 * - EWM_CTRL - Control Register
 * - EWM_SERV - Service Register
 * - EWM_CMPL - Compare Low Register
 * - EWM_CMPH - Compare High Register
 * - EWM_CLKCTRL - Clock Control Register
 * - EWM_CLKPRESCALER - Clock Prescaler Register
 */

#define EWM_INSTANCE_COUNT (1U) /*!< Number of instances of the EWM module. */
#define EWM_IDX (0U) /*!< Instance number for EWM. */

/*******************************************************************************
 * EWM_CTRL - Control Register
 ******************************************************************************/

/*!
 * @brief EWM_CTRL - Control Register (RW)
 *
 * Reset value: 0x00U
 *
 * The CTRL register is cleared by any reset. INEN, ASSIN and EWMEN bits can be
 * written once after a CPU reset. Modifying these bits more than once, generates
 * a bus transfer error.
 */
/*!
 * @name Constants and macros for entire EWM_CTRL register
 */
/*@{*/
#define EWM_RD_CTRL(base)        (EWM_CTRL_REG(base))
#define EWM_WR_CTRL(base, value) (EWM_CTRL_REG(base) = (value))
#define EWM_RMW_CTRL(base, mask, value) (EWM_WR_CTRL(base, (EWM_RD_CTRL(base) & ~(mask)) | (value)))
#define EWM_SET_CTRL(base, value) (BME_OR8(&EWM_CTRL_REG(base), (uint8_t)(value)))
#define EWM_CLR_CTRL(base, value) (BME_AND8(&EWM_CTRL_REG(base), (uint8_t)(~(value))))
#define EWM_TOG_CTRL(base, value) (BME_XOR8(&EWM_CTRL_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual EWM_CTRL bitfields
 */

/*!
 * @name Register EWM_CTRL, field EWMEN[0] (RW)
 *
 * This bit when set, enables the EWM module. This resets the EWM counter to
 * zero and deasserts the EWM_out signal. Clearing EWMEN bit disables the EWM, and
 * therefore it cannot be enabled until a reset occurs, due to the write-once
 * nature of this bit.
 */
/*@{*/
/*! @brief Read current value of the EWM_CTRL_EWMEN field. */
#define EWM_RD_CTRL_EWMEN(base) ((EWM_CTRL_REG(base) & EWM_CTRL_EWMEN_MASK) >> EWM_CTRL_EWMEN_SHIFT)
#define EWM_BRD_CTRL_EWMEN(base) (BME_UBFX8(&EWM_CTRL_REG(base), EWM_CTRL_EWMEN_SHIFT, EWM_CTRL_EWMEN_WIDTH))

/*! @brief Set the EWMEN field to a new value. */
#define EWM_WR_CTRL_EWMEN(base, value) (EWM_RMW_CTRL(base, EWM_CTRL_EWMEN_MASK, EWM_CTRL_EWMEN(value)))
#define EWM_BWR_CTRL_EWMEN(base, value) (BME_BFI8(&EWM_CTRL_REG(base), ((uint8_t)(value) << EWM_CTRL_EWMEN_SHIFT), EWM_CTRL_EWMEN_SHIFT, EWM_CTRL_EWMEN_WIDTH))
/*@}*/

/*!
 * @name Register EWM_CTRL, field ASSIN[1] (RW)
 *
 * Default assert state of the EWM_in signal is logic zero. Setting ASSIN bit
 * inverts the assert state to a logic one.
 */
/*@{*/
/*! @brief Read current value of the EWM_CTRL_ASSIN field. */
#define EWM_RD_CTRL_ASSIN(base) ((EWM_CTRL_REG(base) & EWM_CTRL_ASSIN_MASK) >> EWM_CTRL_ASSIN_SHIFT)
#define EWM_BRD_CTRL_ASSIN(base) (BME_UBFX8(&EWM_CTRL_REG(base), EWM_CTRL_ASSIN_SHIFT, EWM_CTRL_ASSIN_WIDTH))

/*! @brief Set the ASSIN field to a new value. */
#define EWM_WR_CTRL_ASSIN(base, value) (EWM_RMW_CTRL(base, EWM_CTRL_ASSIN_MASK, EWM_CTRL_ASSIN(value)))
#define EWM_BWR_CTRL_ASSIN(base, value) (BME_BFI8(&EWM_CTRL_REG(base), ((uint8_t)(value) << EWM_CTRL_ASSIN_SHIFT), EWM_CTRL_ASSIN_SHIFT, EWM_CTRL_ASSIN_WIDTH))
/*@}*/

/*!
 * @name Register EWM_CTRL, field INEN[2] (RW)
 *
 * This bit when set, enables the EWM_in port.
 */
/*@{*/
/*! @brief Read current value of the EWM_CTRL_INEN field. */
#define EWM_RD_CTRL_INEN(base) ((EWM_CTRL_REG(base) & EWM_CTRL_INEN_MASK) >> EWM_CTRL_INEN_SHIFT)
#define EWM_BRD_CTRL_INEN(base) (BME_UBFX8(&EWM_CTRL_REG(base), EWM_CTRL_INEN_SHIFT, EWM_CTRL_INEN_WIDTH))

/*! @brief Set the INEN field to a new value. */
#define EWM_WR_CTRL_INEN(base, value) (EWM_RMW_CTRL(base, EWM_CTRL_INEN_MASK, EWM_CTRL_INEN(value)))
#define EWM_BWR_CTRL_INEN(base, value) (BME_BFI8(&EWM_CTRL_REG(base), ((uint8_t)(value) << EWM_CTRL_INEN_SHIFT), EWM_CTRL_INEN_SHIFT, EWM_CTRL_INEN_WIDTH))
/*@}*/

/*!
 * @name Register EWM_CTRL, field INTEN[3] (RW)
 *
 * This bit when set and EWM_out is asserted, an interrupt request is generated.
 * To de-assert interrupt request, user should clear this bit by writing 0.
 */
/*@{*/
/*! @brief Read current value of the EWM_CTRL_INTEN field. */
#define EWM_RD_CTRL_INTEN(base) ((EWM_CTRL_REG(base) & EWM_CTRL_INTEN_MASK) >> EWM_CTRL_INTEN_SHIFT)
#define EWM_BRD_CTRL_INTEN(base) (BME_UBFX8(&EWM_CTRL_REG(base), EWM_CTRL_INTEN_SHIFT, EWM_CTRL_INTEN_WIDTH))

/*! @brief Set the INTEN field to a new value. */
#define EWM_WR_CTRL_INTEN(base, value) (EWM_RMW_CTRL(base, EWM_CTRL_INTEN_MASK, EWM_CTRL_INTEN(value)))
#define EWM_BWR_CTRL_INTEN(base, value) (BME_BFI8(&EWM_CTRL_REG(base), ((uint8_t)(value) << EWM_CTRL_INTEN_SHIFT), EWM_CTRL_INTEN_SHIFT, EWM_CTRL_INTEN_WIDTH))
/*@}*/

/*******************************************************************************
 * EWM_SERV - Service Register
 ******************************************************************************/

/*!
 * @brief EWM_SERV - Service Register (WORZ)
 *
 * Reset value: 0x00U
 *
 * The SERV register provides the interface from the CPU to the EWM module. It
 * is write-only and reads of this register return zero.
 */
/*!
 * @name Constants and macros for entire EWM_SERV register
 */
/*@{*/
#define EWM_RD_SERV(base)        (EWM_SERV_REG(base))
#define EWM_WR_SERV(base, value) (EWM_SERV_REG(base) = (value))
#define EWM_RMW_SERV(base, mask, value) (EWM_WR_SERV(base, (EWM_RD_SERV(base) & ~(mask)) | (value)))
/*@}*/

/*******************************************************************************
 * EWM_CMPL - Compare Low Register
 ******************************************************************************/

/*!
 * @brief EWM_CMPL - Compare Low Register (RW)
 *
 * Reset value: 0x00U
 *
 * The CMPL register is reset to zero after a CPU reset. This provides no
 * minimum time for the CPU to service the EWM counter. This register can be written
 * only once after a CPU reset. Writing this register more than once generates a
 * bus transfer error.
 */
/*!
 * @name Constants and macros for entire EWM_CMPL register
 */
/*@{*/
#define EWM_RD_CMPL(base)        (EWM_CMPL_REG(base))
#define EWM_WR_CMPL(base, value) (EWM_CMPL_REG(base) = (value))
#define EWM_RMW_CMPL(base, mask, value) (EWM_WR_CMPL(base, (EWM_RD_CMPL(base) & ~(mask)) | (value)))
#define EWM_SET_CMPL(base, value) (BME_OR8(&EWM_CMPL_REG(base), (uint8_t)(value)))
#define EWM_CLR_CMPL(base, value) (BME_AND8(&EWM_CMPL_REG(base), (uint8_t)(~(value))))
#define EWM_TOG_CMPL(base, value) (BME_XOR8(&EWM_CMPL_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * EWM_CMPH - Compare High Register
 ******************************************************************************/

/*!
 * @brief EWM_CMPH - Compare High Register (RW)
 *
 * Reset value: 0xFFU
 *
 * The CMPH register is reset to 0xFF after a CPU reset. This provides a maximum
 * of 256 clocks time, for the CPU to service the EWM counter. This register can
 * be written only once after a CPU reset. Writing this register more than once
 * generates a bus transfer error. The valid values for CMPH are up to 0xFE
 * because the EWM counter never expires when CMPH = 0xFF. The expiration happens only
 * if EWM counter is greater than CMPH.
 */
/*!
 * @name Constants and macros for entire EWM_CMPH register
 */
/*@{*/
#define EWM_RD_CMPH(base)        (EWM_CMPH_REG(base))
#define EWM_WR_CMPH(base, value) (EWM_CMPH_REG(base) = (value))
#define EWM_RMW_CMPH(base, mask, value) (EWM_WR_CMPH(base, (EWM_RD_CMPH(base) & ~(mask)) | (value)))
#define EWM_SET_CMPH(base, value) (BME_OR8(&EWM_CMPH_REG(base), (uint8_t)(value)))
#define EWM_CLR_CMPH(base, value) (BME_AND8(&EWM_CMPH_REG(base), (uint8_t)(~(value))))
#define EWM_TOG_CMPH(base, value) (BME_XOR8(&EWM_CMPH_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * EWM_CLKCTRL - Clock Control Register
 ******************************************************************************/

/*!
 * @brief EWM_CLKCTRL - Clock Control Register (RW)
 *
 * Reset value: 0x00U
 *
 * This CLKCTRL register is reset to 0x00 after a CPU reset. This register can
 * be written only once after a CPU reset. Writing this register more than once
 * generates a bus transfer error. User should select the required low power clock
 * before enabling the EWM.
 */
/*!
 * @name Constants and macros for entire EWM_CLKCTRL register
 */
/*@{*/
#define EWM_RD_CLKCTRL(base)     (EWM_CLKCTRL_REG(base))
#define EWM_WR_CLKCTRL(base, value) (EWM_CLKCTRL_REG(base) = (value))
#define EWM_RMW_CLKCTRL(base, mask, value) (EWM_WR_CLKCTRL(base, (EWM_RD_CLKCTRL(base) & ~(mask)) | (value)))
#define EWM_SET_CLKCTRL(base, value) (BME_OR8(&EWM_CLKCTRL_REG(base), (uint8_t)(value)))
#define EWM_CLR_CLKCTRL(base, value) (BME_AND8(&EWM_CLKCTRL_REG(base), (uint8_t)(~(value))))
#define EWM_TOG_CLKCTRL(base, value) (BME_XOR8(&EWM_CLKCTRL_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual EWM_CLKCTRL bitfields
 */

/*!
 * @name Register EWM_CLKCTRL, field CLKSEL[1:0] (RW)
 *
 * EWM has 4 possible low power clock sources for running EWM counter. One of
 * the clock source can be selected by writing into this field. 00 - lpo_clk[0]
 * will be selected for running EWM counter. 01 - lpo_clk[1] will be selected for
 * running EWM counter. 10 - lpo_clk[2] will be selected for running EWM counter.
 * 11 - lpo_clk[3] will be selected for running EWM counter.
 */
/*@{*/
/*! @brief Read current value of the EWM_CLKCTRL_CLKSEL field. */
#define EWM_RD_CLKCTRL_CLKSEL(base) ((EWM_CLKCTRL_REG(base) & EWM_CLKCTRL_CLKSEL_MASK) >> EWM_CLKCTRL_CLKSEL_SHIFT)
#define EWM_BRD_CLKCTRL_CLKSEL(base) (BME_UBFX8(&EWM_CLKCTRL_REG(base), EWM_CLKCTRL_CLKSEL_SHIFT, EWM_CLKCTRL_CLKSEL_WIDTH))

/*! @brief Set the CLKSEL field to a new value. */
#define EWM_WR_CLKCTRL_CLKSEL(base, value) (EWM_RMW_CLKCTRL(base, EWM_CLKCTRL_CLKSEL_MASK, EWM_CLKCTRL_CLKSEL(value)))
#define EWM_BWR_CLKCTRL_CLKSEL(base, value) (BME_BFI8(&EWM_CLKCTRL_REG(base), ((uint8_t)(value) << EWM_CLKCTRL_CLKSEL_SHIFT), EWM_CLKCTRL_CLKSEL_SHIFT, EWM_CLKCTRL_CLKSEL_WIDTH))
/*@}*/

/*******************************************************************************
 * EWM_CLKPRESCALER - Clock Prescaler Register
 ******************************************************************************/

/*!
 * @brief EWM_CLKPRESCALER - Clock Prescaler Register (RW)
 *
 * Reset value: 0x00U
 *
 * This CLKPRESCALER register is reset to 0x00 after a CPU reset. This register
 * can be written only once after a CPU reset. Writing this register more than
 * once generates a bus transfer error. Write the required prescaler value before
 * enabling the EWM. The implementation of this register is chip-specific. See the
 * Chip Configuration details.
 */
/*!
 * @name Constants and macros for entire EWM_CLKPRESCALER register
 */
/*@{*/
#define EWM_RD_CLKPRESCALER(base) (EWM_CLKPRESCALER_REG(base))
#define EWM_WR_CLKPRESCALER(base, value) (EWM_CLKPRESCALER_REG(base) = (value))
#define EWM_RMW_CLKPRESCALER(base, mask, value) (EWM_WR_CLKPRESCALER(base, (EWM_RD_CLKPRESCALER(base) & ~(mask)) | (value)))
#define EWM_SET_CLKPRESCALER(base, value) (BME_OR8(&EWM_CLKPRESCALER_REG(base), (uint8_t)(value)))
#define EWM_CLR_CLKPRESCALER(base, value) (BME_AND8(&EWM_CLKPRESCALER_REG(base), (uint8_t)(~(value))))
#define EWM_TOG_CLKPRESCALER(base, value) (BME_XOR8(&EWM_CLKPRESCALER_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * MKM34Z7 FTFA
 *
 * Flash Memory Interface
 *
 * Registers defined in this header file:
 * - FTFA_FSTAT - Flash Status Register
 * - FTFA_FCNFG - Flash Configuration Register
 * - FTFA_FSEC - Flash Security Register
 * - FTFA_FOPT - Flash Option Register
 * - FTFA_FCCOB3 - Flash Common Command Object Registers
 * - FTFA_FCCOB2 - Flash Common Command Object Registers
 * - FTFA_FCCOB1 - Flash Common Command Object Registers
 * - FTFA_FCCOB0 - Flash Common Command Object Registers
 * - FTFA_FCCOB7 - Flash Common Command Object Registers
 * - FTFA_FCCOB6 - Flash Common Command Object Registers
 * - FTFA_FCCOB5 - Flash Common Command Object Registers
 * - FTFA_FCCOB4 - Flash Common Command Object Registers
 * - FTFA_FCCOBB - Flash Common Command Object Registers
 * - FTFA_FCCOBA - Flash Common Command Object Registers
 * - FTFA_FCCOB9 - Flash Common Command Object Registers
 * - FTFA_FCCOB8 - Flash Common Command Object Registers
 * - FTFA_FPROT3 - Program Flash Protection Registers
 * - FTFA_FPROT2 - Program Flash Protection Registers
 * - FTFA_FPROT1 - Program Flash Protection Registers
 * - FTFA_FPROT0 - Program Flash Protection Registers
 */

#define FTFA_INSTANCE_COUNT (1U) /*!< Number of instances of the FTFA module. */
#define FTFA_IDX (0U) /*!< Instance number for FTFA. */

/*******************************************************************************
 * FTFA_FSTAT - Flash Status Register
 ******************************************************************************/

/*!
 * @brief FTFA_FSTAT - Flash Status Register (RW)
 *
 * Reset value: 0x00U
 *
 * The FSTAT register reports the operational status of the flash memory module.
 * The CCIF, RDCOLERR, ACCERR, and FPVIOL bits are readable and writable. The
 * MGSTAT0 bit is read only. The unassigned bits read 0 and are not writable. When
 * set, the Access Error (ACCERR) and Flash Protection Violation (FPVIOL) bits in
 * this register prevent the launch of any more commands until the flag is
 * cleared (by writing a one to it).
 */
/*!
 * @name Constants and macros for entire FTFA_FSTAT register
 */
/*@{*/
#define FTFA_RD_FSTAT(base)      (FTFA_FSTAT_REG(base))
#define FTFA_WR_FSTAT(base, value) (FTFA_FSTAT_REG(base) = (value))
#define FTFA_RMW_FSTAT(base, mask, value) (FTFA_WR_FSTAT(base, (FTFA_RD_FSTAT(base) & ~(mask)) | (value)))
#define FTFA_SET_FSTAT(base, value) (BME_OR8(&FTFA_FSTAT_REG(base), (uint8_t)(value)))
#define FTFA_CLR_FSTAT(base, value) (BME_AND8(&FTFA_FSTAT_REG(base), (uint8_t)(~(value))))
#define FTFA_TOG_FSTAT(base, value) (BME_XOR8(&FTFA_FSTAT_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual FTFA_FSTAT bitfields
 */

/*!
 * @name Register FTFA_FSTAT, field MGSTAT0[0] (RO)
 *
 * The MGSTAT0 status flag is set if an error is detected during execution of a
 * flash command or during the flash reset sequence. As a status flag, this field
 * cannot (and need not) be cleared by the user like the other error flags in
 * this register. The value of the MGSTAT0 bit for "command-N" is valid only at the
 * end of the "command-N" execution when CCIF=1 and before the next command has
 * been launched. At some point during the execution of "command-N+1," the
 * previous result is discarded and any previous error is cleared.
 */
/*@{*/
/*! @brief Read current value of the FTFA_FSTAT_MGSTAT0 field. */
#define FTFA_RD_FSTAT_MGSTAT0(base) ((FTFA_FSTAT_REG(base) & FTFA_FSTAT_MGSTAT0_MASK) >> FTFA_FSTAT_MGSTAT0_SHIFT)
#define FTFA_BRD_FSTAT_MGSTAT0(base) (BME_UBFX8(&FTFA_FSTAT_REG(base), FTFA_FSTAT_MGSTAT0_SHIFT, FTFA_FSTAT_MGSTAT0_WIDTH))
/*@}*/

/*!
 * @name Register FTFA_FSTAT, field FPVIOL[4] (W1C)
 *
 * Indicates an attempt was made to program or erase an address in a protected
 * area of program flash memory during a command write sequence . While FPVIOL is
 * set, the CCIF flag cannot be cleared to launch a command. The FPVIOL bit is
 * cleared by writing a 1 to FPVIOL while CCIF is set. Writing a 0 to the FPVIOL
 * bit has no effect.
 *
 * Values:
 * - 0b0 - No protection violation detected
 * - 0b1 - Protection violation detected
 */
/*@{*/
/*! @brief Read current value of the FTFA_FSTAT_FPVIOL field. */
#define FTFA_RD_FSTAT_FPVIOL(base) ((FTFA_FSTAT_REG(base) & FTFA_FSTAT_FPVIOL_MASK) >> FTFA_FSTAT_FPVIOL_SHIFT)
#define FTFA_BRD_FSTAT_FPVIOL(base) (BME_UBFX8(&FTFA_FSTAT_REG(base), FTFA_FSTAT_FPVIOL_SHIFT, FTFA_FSTAT_FPVIOL_WIDTH))

/*! @brief Set the FPVIOL field to a new value. */
#define FTFA_WR_FSTAT_FPVIOL(base, value) (FTFA_RMW_FSTAT(base, (FTFA_FSTAT_FPVIOL_MASK | FTFA_FSTAT_ACCERR_MASK | FTFA_FSTAT_RDCOLERR_MASK | FTFA_FSTAT_CCIF_MASK), FTFA_FSTAT_FPVIOL(value)))
#define FTFA_BWR_FSTAT_FPVIOL(base, value) (BME_BFI8(&FTFA_FSTAT_REG(base), ((uint8_t)(value) << FTFA_FSTAT_FPVIOL_SHIFT), FTFA_FSTAT_FPVIOL_SHIFT, FTFA_FSTAT_FPVIOL_WIDTH))
/*@}*/

/*!
 * @name Register FTFA_FSTAT, field ACCERR[5] (W1C)
 *
 * Indicates an illegal access has occurred to a flash memory resource caused by
 * a violation of the command write sequence or issuing an illegal flash
 * command. While ACCERR is set, the CCIF flag cannot be cleared to launch a command.
 * The ACCERR bit is cleared by writing a 1 to ACCERR while CCIF is set. Writing a
 * 0 to the ACCERR bit has no effect.
 *
 * Values:
 * - 0b0 - No access error detected
 * - 0b1 - Access error detected
 */
/*@{*/
/*! @brief Read current value of the FTFA_FSTAT_ACCERR field. */
#define FTFA_RD_FSTAT_ACCERR(base) ((FTFA_FSTAT_REG(base) & FTFA_FSTAT_ACCERR_MASK) >> FTFA_FSTAT_ACCERR_SHIFT)
#define FTFA_BRD_FSTAT_ACCERR(base) (BME_UBFX8(&FTFA_FSTAT_REG(base), FTFA_FSTAT_ACCERR_SHIFT, FTFA_FSTAT_ACCERR_WIDTH))

/*! @brief Set the ACCERR field to a new value. */
#define FTFA_WR_FSTAT_ACCERR(base, value) (FTFA_RMW_FSTAT(base, (FTFA_FSTAT_ACCERR_MASK | FTFA_FSTAT_FPVIOL_MASK | FTFA_FSTAT_RDCOLERR_MASK | FTFA_FSTAT_CCIF_MASK), FTFA_FSTAT_ACCERR(value)))
#define FTFA_BWR_FSTAT_ACCERR(base, value) (BME_BFI8(&FTFA_FSTAT_REG(base), ((uint8_t)(value) << FTFA_FSTAT_ACCERR_SHIFT), FTFA_FSTAT_ACCERR_SHIFT, FTFA_FSTAT_ACCERR_WIDTH))
/*@}*/

/*!
 * @name Register FTFA_FSTAT, field RDCOLERR[6] (W1C)
 *
 * Indicates that the MCU attempted a read from a flash memory resource that was
 * being manipulated by a flash command (CCIF=0). Any simultaneous access is
 * detected as a collision error by the block arbitration logic. The read data in
 * this case cannot be guaranteed. The RDCOLERR bit is cleared by writing a 1 to
 * it. Writing a 0 to RDCOLERR has no effect.
 *
 * Values:
 * - 0b0 - No collision error detected
 * - 0b1 - Collision error detected
 */
/*@{*/
/*! @brief Read current value of the FTFA_FSTAT_RDCOLERR field. */
#define FTFA_RD_FSTAT_RDCOLERR(base) ((FTFA_FSTAT_REG(base) & FTFA_FSTAT_RDCOLERR_MASK) >> FTFA_FSTAT_RDCOLERR_SHIFT)
#define FTFA_BRD_FSTAT_RDCOLERR(base) (BME_UBFX8(&FTFA_FSTAT_REG(base), FTFA_FSTAT_RDCOLERR_SHIFT, FTFA_FSTAT_RDCOLERR_WIDTH))

/*! @brief Set the RDCOLERR field to a new value. */
#define FTFA_WR_FSTAT_RDCOLERR(base, value) (FTFA_RMW_FSTAT(base, (FTFA_FSTAT_RDCOLERR_MASK | FTFA_FSTAT_FPVIOL_MASK | FTFA_FSTAT_ACCERR_MASK | FTFA_FSTAT_CCIF_MASK), FTFA_FSTAT_RDCOLERR(value)))
#define FTFA_BWR_FSTAT_RDCOLERR(base, value) (BME_BFI8(&FTFA_FSTAT_REG(base), ((uint8_t)(value) << FTFA_FSTAT_RDCOLERR_SHIFT), FTFA_FSTAT_RDCOLERR_SHIFT, FTFA_FSTAT_RDCOLERR_WIDTH))
/*@}*/

/*!
 * @name Register FTFA_FSTAT, field CCIF[7] (W1C)
 *
 * Indicates that a flash command has completed. The CCIF flag is cleared by
 * writing a 1 to CCIF to launch a command, and CCIF stays low until command
 * completion or command violation. CCIF is reset to 0 but is set to 1 by the memory
 * controller at the end of the reset initialization sequence. Depending on how
 * quickly the read occurs after reset release, the user may or may not see the 0
 * hardware reset value.
 *
 * Values:
 * - 0b0 - Flash command in progress
 * - 0b1 - Flash command has completed
 */
/*@{*/
/*! @brief Read current value of the FTFA_FSTAT_CCIF field. */
#define FTFA_RD_FSTAT_CCIF(base) ((FTFA_FSTAT_REG(base) & FTFA_FSTAT_CCIF_MASK) >> FTFA_FSTAT_CCIF_SHIFT)
#define FTFA_BRD_FSTAT_CCIF(base) (BME_UBFX8(&FTFA_FSTAT_REG(base), FTFA_FSTAT_CCIF_SHIFT, FTFA_FSTAT_CCIF_WIDTH))

/*! @brief Set the CCIF field to a new value. */
#define FTFA_WR_FSTAT_CCIF(base, value) (FTFA_RMW_FSTAT(base, (FTFA_FSTAT_CCIF_MASK | FTFA_FSTAT_FPVIOL_MASK | FTFA_FSTAT_ACCERR_MASK | FTFA_FSTAT_RDCOLERR_MASK), FTFA_FSTAT_CCIF(value)))
#define FTFA_BWR_FSTAT_CCIF(base, value) (BME_BFI8(&FTFA_FSTAT_REG(base), ((uint8_t)(value) << FTFA_FSTAT_CCIF_SHIFT), FTFA_FSTAT_CCIF_SHIFT, FTFA_FSTAT_CCIF_WIDTH))
/*@}*/

/*******************************************************************************
 * FTFA_FCNFG - Flash Configuration Register
 ******************************************************************************/

/*!
 * @brief FTFA_FCNFG - Flash Configuration Register (RW)
 *
 * Reset value: 0x00U
 *
 * This register provides information on the current functional state of the
 * flash memory module. The erase control bits (ERSAREQ and ERSSUSP) have write
 * restrictions. The unassigned bits read as noted and are not writable.
 */
/*!
 * @name Constants and macros for entire FTFA_FCNFG register
 */
/*@{*/
#define FTFA_RD_FCNFG(base)      (FTFA_FCNFG_REG(base))
#define FTFA_WR_FCNFG(base, value) (FTFA_FCNFG_REG(base) = (value))
#define FTFA_RMW_FCNFG(base, mask, value) (FTFA_WR_FCNFG(base, (FTFA_RD_FCNFG(base) & ~(mask)) | (value)))
#define FTFA_SET_FCNFG(base, value) (BME_OR8(&FTFA_FCNFG_REG(base), (uint8_t)(value)))
#define FTFA_CLR_FCNFG(base, value) (BME_AND8(&FTFA_FCNFG_REG(base), (uint8_t)(~(value))))
#define FTFA_TOG_FCNFG(base, value) (BME_XOR8(&FTFA_FCNFG_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual FTFA_FCNFG bitfields
 */

/*!
 * @name Register FTFA_FCNFG, field ERSSUSP[4] (RW)
 *
 * Allows the user to suspend (interrupt) the Erase Flash Sector command while
 * it is executing.
 *
 * Values:
 * - 0b0 - No suspend requested
 * - 0b1 - Suspend the current Erase Flash Sector command execution.
 */
/*@{*/
/*! @brief Read current value of the FTFA_FCNFG_ERSSUSP field. */
#define FTFA_RD_FCNFG_ERSSUSP(base) ((FTFA_FCNFG_REG(base) & FTFA_FCNFG_ERSSUSP_MASK) >> FTFA_FCNFG_ERSSUSP_SHIFT)
#define FTFA_BRD_FCNFG_ERSSUSP(base) (BME_UBFX8(&FTFA_FCNFG_REG(base), FTFA_FCNFG_ERSSUSP_SHIFT, FTFA_FCNFG_ERSSUSP_WIDTH))

/*! @brief Set the ERSSUSP field to a new value. */
#define FTFA_WR_FCNFG_ERSSUSP(base, value) (FTFA_RMW_FCNFG(base, FTFA_FCNFG_ERSSUSP_MASK, FTFA_FCNFG_ERSSUSP(value)))
#define FTFA_BWR_FCNFG_ERSSUSP(base, value) (BME_BFI8(&FTFA_FCNFG_REG(base), ((uint8_t)(value) << FTFA_FCNFG_ERSSUSP_SHIFT), FTFA_FCNFG_ERSSUSP_SHIFT, FTFA_FCNFG_ERSSUSP_WIDTH))
/*@}*/

/*!
 * @name Register FTFA_FCNFG, field ERSAREQ[5] (RO)
 *
 * Issues a request to the memory controller to execute the Erase All Blocks
 * command and release security. ERSAREQ is not directly writable but is under
 * indirect user control. Refer to the device's Chip Configuration details on how to
 * request this command. ERSAREQ sets when an erase all request is triggered
 * external to the flash memory module and CCIF is set (no command is currently being
 * executed). ERSAREQ is cleared by the flash memory module when the operation
 * completes.
 *
 * Values:
 * - 0b0 - No request or request complete
 * - 0b1 - Request to: run the Erase All Blocks command, verify the erased
 *     state, program the security byte in the Flash Configuration Field to the
 *     unsecure state, and release MCU security by setting the FSEC[SEC] field to the
 *     unsecure state.
 */
/*@{*/
/*! @brief Read current value of the FTFA_FCNFG_ERSAREQ field. */
#define FTFA_RD_FCNFG_ERSAREQ(base) ((FTFA_FCNFG_REG(base) & FTFA_FCNFG_ERSAREQ_MASK) >> FTFA_FCNFG_ERSAREQ_SHIFT)
#define FTFA_BRD_FCNFG_ERSAREQ(base) (BME_UBFX8(&FTFA_FCNFG_REG(base), FTFA_FCNFG_ERSAREQ_SHIFT, FTFA_FCNFG_ERSAREQ_WIDTH))
/*@}*/

/*!
 * @name Register FTFA_FCNFG, field RDCOLLIE[6] (RW)
 *
 * Controls interrupt generation when a flash memory read collision error occurs.
 *
 * Values:
 * - 0b0 - Read collision error interrupt disabled
 * - 0b1 - Read collision error interrupt enabled. An interrupt request is
 *     generated whenever a flash memory read collision error is detected (see the
 *     description of FSTAT[RDCOLERR]).
 */
/*@{*/
/*! @brief Read current value of the FTFA_FCNFG_RDCOLLIE field. */
#define FTFA_RD_FCNFG_RDCOLLIE(base) ((FTFA_FCNFG_REG(base) & FTFA_FCNFG_RDCOLLIE_MASK) >> FTFA_FCNFG_RDCOLLIE_SHIFT)
#define FTFA_BRD_FCNFG_RDCOLLIE(base) (BME_UBFX8(&FTFA_FCNFG_REG(base), FTFA_FCNFG_RDCOLLIE_SHIFT, FTFA_FCNFG_RDCOLLIE_WIDTH))

/*! @brief Set the RDCOLLIE field to a new value. */
#define FTFA_WR_FCNFG_RDCOLLIE(base, value) (FTFA_RMW_FCNFG(base, FTFA_FCNFG_RDCOLLIE_MASK, FTFA_FCNFG_RDCOLLIE(value)))
#define FTFA_BWR_FCNFG_RDCOLLIE(base, value) (BME_BFI8(&FTFA_FCNFG_REG(base), ((uint8_t)(value) << FTFA_FCNFG_RDCOLLIE_SHIFT), FTFA_FCNFG_RDCOLLIE_SHIFT, FTFA_FCNFG_RDCOLLIE_WIDTH))
/*@}*/

/*!
 * @name Register FTFA_FCNFG, field CCIE[7] (RW)
 *
 * Controls interrupt generation when a flash command completes.
 *
 * Values:
 * - 0b0 - Command complete interrupt disabled
 * - 0b1 - Command complete interrupt enabled. An interrupt request is generated
 *     whenever the FSTAT[CCIF] flag is set.
 */
/*@{*/
/*! @brief Read current value of the FTFA_FCNFG_CCIE field. */
#define FTFA_RD_FCNFG_CCIE(base) ((FTFA_FCNFG_REG(base) & FTFA_FCNFG_CCIE_MASK) >> FTFA_FCNFG_CCIE_SHIFT)
#define FTFA_BRD_FCNFG_CCIE(base) (BME_UBFX8(&FTFA_FCNFG_REG(base), FTFA_FCNFG_CCIE_SHIFT, FTFA_FCNFG_CCIE_WIDTH))

/*! @brief Set the CCIE field to a new value. */
#define FTFA_WR_FCNFG_CCIE(base, value) (FTFA_RMW_FCNFG(base, FTFA_FCNFG_CCIE_MASK, FTFA_FCNFG_CCIE(value)))
#define FTFA_BWR_FCNFG_CCIE(base, value) (BME_BFI8(&FTFA_FCNFG_REG(base), ((uint8_t)(value) << FTFA_FCNFG_CCIE_SHIFT), FTFA_FCNFG_CCIE_SHIFT, FTFA_FCNFG_CCIE_WIDTH))
/*@}*/

/*******************************************************************************
 * FTFA_FSEC - Flash Security Register
 ******************************************************************************/

/*!
 * @brief FTFA_FSEC - Flash Security Register (RO)
 *
 * Reset value: 0x00U
 *
 * This read-only register holds all bits associated with the security of the
 * MCU and flash memory module. During the reset sequence, the register is loaded
 * with the contents of the flash security byte in the Flash Configuration Field
 * located in program flash memory. The flash basis for the values is signified by
 * X in the reset value.
 */
/*!
 * @name Constants and macros for entire FTFA_FSEC register
 */
/*@{*/
#define FTFA_RD_FSEC(base)       (FTFA_FSEC_REG(base))
/*@}*/

/*
 * Constants & macros for individual FTFA_FSEC bitfields
 */

/*!
 * @name Register FTFA_FSEC, field SEC[1:0] (RO)
 *
 * Defines the security state of the MCU. In the secure state, the MCU limits
 * access to flash memory module resources. The limitations are defined per device
 * and are detailed in the Chip Configuration details. If the flash memory module
 * is unsecured using backdoor key access, SEC is forced to 10b.
 *
 * Values:
 * - 0b00 - MCU security status is secure.
 * - 0b01 - MCU security status is secure.
 * - 0b10 - MCU security status is unsecure. (The standard shipping condition of
 *     the flash memory module is unsecure.)
 * - 0b11 - MCU security status is secure.
 */
/*@{*/
/*! @brief Read current value of the FTFA_FSEC_SEC field. */
#define FTFA_RD_FSEC_SEC(base) ((FTFA_FSEC_REG(base) & FTFA_FSEC_SEC_MASK) >> FTFA_FSEC_SEC_SHIFT)
#define FTFA_BRD_FSEC_SEC(base) (BME_UBFX8(&FTFA_FSEC_REG(base), FTFA_FSEC_SEC_SHIFT, FTFA_FSEC_SEC_WIDTH))
/*@}*/

/*!
 * @name Register FTFA_FSEC, field FSLACC[3:2] (RO)
 *
 * Enables or disables access to the flash memory contents during returned part
 * failure analysis at Freescale. When SEC is secure and FSLACC is denied, access
 * to the program flash contents is denied and any failure analysis performed by
 * Freescale factory test must begin with a full erase to unsecure the part.
 * When access is granted (SEC is unsecure, or SEC is secure and FSLACC is granted),
 * Freescale factory testing has visibility of the current flash contents. The
 * state of the FSLACC bits is only relevant when SEC is set to secure. When SEC
 * is set to unsecure, the FSLACC setting does not matter.
 *
 * Values:
 * - 0b00 - Freescale factory access granted
 * - 0b01 - Freescale factory access denied
 * - 0b10 - Freescale factory access denied
 * - 0b11 - Freescale factory access granted
 */
/*@{*/
/*! @brief Read current value of the FTFA_FSEC_FSLACC field. */
#define FTFA_RD_FSEC_FSLACC(base) ((FTFA_FSEC_REG(base) & FTFA_FSEC_FSLACC_MASK) >> FTFA_FSEC_FSLACC_SHIFT)
#define FTFA_BRD_FSEC_FSLACC(base) (BME_UBFX8(&FTFA_FSEC_REG(base), FTFA_FSEC_FSLACC_SHIFT, FTFA_FSEC_FSLACC_WIDTH))
/*@}*/

/*!
 * @name Register FTFA_FSEC, field MEEN[5:4] (RO)
 *
 * Enables and disables mass erase capability of the flash memory module. When
 * SEC is set to unsecure, the MEEN setting does not matter.
 *
 * Values:
 * - 0b00 - Mass erase is enabled
 * - 0b01 - Mass erase is enabled
 * - 0b10 - Mass erase is disabled
 * - 0b11 - Mass erase is enabled
 */
/*@{*/
/*! @brief Read current value of the FTFA_FSEC_MEEN field. */
#define FTFA_RD_FSEC_MEEN(base) ((FTFA_FSEC_REG(base) & FTFA_FSEC_MEEN_MASK) >> FTFA_FSEC_MEEN_SHIFT)
#define FTFA_BRD_FSEC_MEEN(base) (BME_UBFX8(&FTFA_FSEC_REG(base), FTFA_FSEC_MEEN_SHIFT, FTFA_FSEC_MEEN_WIDTH))
/*@}*/

/*!
 * @name Register FTFA_FSEC, field KEYEN[7:6] (RO)
 *
 * Enables or disables backdoor key access to the flash memory module.
 *
 * Values:
 * - 0b00 - Backdoor key access disabled
 * - 0b01 - Backdoor key access disabled (preferred KEYEN state to disable
 *     backdoor key access)
 * - 0b10 - Backdoor key access enabled
 * - 0b11 - Backdoor key access disabled
 */
/*@{*/
/*! @brief Read current value of the FTFA_FSEC_KEYEN field. */
#define FTFA_RD_FSEC_KEYEN(base) ((FTFA_FSEC_REG(base) & FTFA_FSEC_KEYEN_MASK) >> FTFA_FSEC_KEYEN_SHIFT)
#define FTFA_BRD_FSEC_KEYEN(base) (BME_UBFX8(&FTFA_FSEC_REG(base), FTFA_FSEC_KEYEN_SHIFT, FTFA_FSEC_KEYEN_WIDTH))
/*@}*/

/*******************************************************************************
 * FTFA_FOPT - Flash Option Register
 ******************************************************************************/

/*!
 * @brief FTFA_FOPT - Flash Option Register (RO)
 *
 * Reset value: 0x00U
 *
 * The flash option register allows the MCU to customize its operations by
 * examining the state of these read-only bits, which are loaded from NVM at reset.
 * The function of the bits is defined in the device's Chip Configuration details.
 * All bits in the register are read-only . During the reset sequence, the
 * register is loaded from the flash nonvolatile option byte in the Flash Configuration
 * Field located in program flash memory. The flash basis for the values is
 * signified by X in the reset value. However, the register is written to 0xFF if the
 * contents of the flash nonvolatile option byte are 0x00.
 */
/*!
 * @name Constants and macros for entire FTFA_FOPT register
 */
/*@{*/
#define FTFA_RD_FOPT(base)       (FTFA_FOPT_REG(base))
/*@}*/

/*******************************************************************************
 * FTFA_FCCOB3 - Flash Common Command Object Registers
 ******************************************************************************/

/*!
 * @brief FTFA_FCCOB3 - Flash Common Command Object Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FCCOB register group provides 12 bytes for command codes and parameters.
 * The individual bytes within the set append a 0-B hex identifier to the FCCOB
 * register name: FCCOB0, FCCOB1, ..., FCCOBB.
 */
/*!
 * @name Constants and macros for entire FTFA_FCCOB3 register
 */
/*@{*/
#define FTFA_RD_FCCOB3(base)     (FTFA_FCCOB3_REG(base))
#define FTFA_WR_FCCOB3(base, value) (FTFA_FCCOB3_REG(base) = (value))
#define FTFA_RMW_FCCOB3(base, mask, value) (FTFA_WR_FCCOB3(base, (FTFA_RD_FCCOB3(base) & ~(mask)) | (value)))
#define FTFA_SET_FCCOB3(base, value) (BME_OR8(&FTFA_FCCOB3_REG(base), (uint8_t)(value)))
#define FTFA_CLR_FCCOB3(base, value) (BME_AND8(&FTFA_FCCOB3_REG(base), (uint8_t)(~(value))))
#define FTFA_TOG_FCCOB3(base, value) (BME_XOR8(&FTFA_FCCOB3_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * FTFA_FCCOB2 - Flash Common Command Object Registers
 ******************************************************************************/

/*!
 * @brief FTFA_FCCOB2 - Flash Common Command Object Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FCCOB register group provides 12 bytes for command codes and parameters.
 * The individual bytes within the set append a 0-B hex identifier to the FCCOB
 * register name: FCCOB0, FCCOB1, ..., FCCOBB.
 */
/*!
 * @name Constants and macros for entire FTFA_FCCOB2 register
 */
/*@{*/
#define FTFA_RD_FCCOB2(base)     (FTFA_FCCOB2_REG(base))
#define FTFA_WR_FCCOB2(base, value) (FTFA_FCCOB2_REG(base) = (value))
#define FTFA_RMW_FCCOB2(base, mask, value) (FTFA_WR_FCCOB2(base, (FTFA_RD_FCCOB2(base) & ~(mask)) | (value)))
#define FTFA_SET_FCCOB2(base, value) (BME_OR8(&FTFA_FCCOB2_REG(base), (uint8_t)(value)))
#define FTFA_CLR_FCCOB2(base, value) (BME_AND8(&FTFA_FCCOB2_REG(base), (uint8_t)(~(value))))
#define FTFA_TOG_FCCOB2(base, value) (BME_XOR8(&FTFA_FCCOB2_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * FTFA_FCCOB1 - Flash Common Command Object Registers
 ******************************************************************************/

/*!
 * @brief FTFA_FCCOB1 - Flash Common Command Object Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FCCOB register group provides 12 bytes for command codes and parameters.
 * The individual bytes within the set append a 0-B hex identifier to the FCCOB
 * register name: FCCOB0, FCCOB1, ..., FCCOBB.
 */
/*!
 * @name Constants and macros for entire FTFA_FCCOB1 register
 */
/*@{*/
#define FTFA_RD_FCCOB1(base)     (FTFA_FCCOB1_REG(base))
#define FTFA_WR_FCCOB1(base, value) (FTFA_FCCOB1_REG(base) = (value))
#define FTFA_RMW_FCCOB1(base, mask, value) (FTFA_WR_FCCOB1(base, (FTFA_RD_FCCOB1(base) & ~(mask)) | (value)))
#define FTFA_SET_FCCOB1(base, value) (BME_OR8(&FTFA_FCCOB1_REG(base), (uint8_t)(value)))
#define FTFA_CLR_FCCOB1(base, value) (BME_AND8(&FTFA_FCCOB1_REG(base), (uint8_t)(~(value))))
#define FTFA_TOG_FCCOB1(base, value) (BME_XOR8(&FTFA_FCCOB1_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * FTFA_FCCOB0 - Flash Common Command Object Registers
 ******************************************************************************/

/*!
 * @brief FTFA_FCCOB0 - Flash Common Command Object Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FCCOB register group provides 12 bytes for command codes and parameters.
 * The individual bytes within the set append a 0-B hex identifier to the FCCOB
 * register name: FCCOB0, FCCOB1, ..., FCCOBB.
 */
/*!
 * @name Constants and macros for entire FTFA_FCCOB0 register
 */
/*@{*/
#define FTFA_RD_FCCOB0(base)     (FTFA_FCCOB0_REG(base))
#define FTFA_WR_FCCOB0(base, value) (FTFA_FCCOB0_REG(base) = (value))
#define FTFA_RMW_FCCOB0(base, mask, value) (FTFA_WR_FCCOB0(base, (FTFA_RD_FCCOB0(base) & ~(mask)) | (value)))
#define FTFA_SET_FCCOB0(base, value) (BME_OR8(&FTFA_FCCOB0_REG(base), (uint8_t)(value)))
#define FTFA_CLR_FCCOB0(base, value) (BME_AND8(&FTFA_FCCOB0_REG(base), (uint8_t)(~(value))))
#define FTFA_TOG_FCCOB0(base, value) (BME_XOR8(&FTFA_FCCOB0_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * FTFA_FCCOB7 - Flash Common Command Object Registers
 ******************************************************************************/

/*!
 * @brief FTFA_FCCOB7 - Flash Common Command Object Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FCCOB register group provides 12 bytes for command codes and parameters.
 * The individual bytes within the set append a 0-B hex identifier to the FCCOB
 * register name: FCCOB0, FCCOB1, ..., FCCOBB.
 */
/*!
 * @name Constants and macros for entire FTFA_FCCOB7 register
 */
/*@{*/
#define FTFA_RD_FCCOB7(base)     (FTFA_FCCOB7_REG(base))
#define FTFA_WR_FCCOB7(base, value) (FTFA_FCCOB7_REG(base) = (value))
#define FTFA_RMW_FCCOB7(base, mask, value) (FTFA_WR_FCCOB7(base, (FTFA_RD_FCCOB7(base) & ~(mask)) | (value)))
#define FTFA_SET_FCCOB7(base, value) (BME_OR8(&FTFA_FCCOB7_REG(base), (uint8_t)(value)))
#define FTFA_CLR_FCCOB7(base, value) (BME_AND8(&FTFA_FCCOB7_REG(base), (uint8_t)(~(value))))
#define FTFA_TOG_FCCOB7(base, value) (BME_XOR8(&FTFA_FCCOB7_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * FTFA_FCCOB6 - Flash Common Command Object Registers
 ******************************************************************************/

/*!
 * @brief FTFA_FCCOB6 - Flash Common Command Object Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FCCOB register group provides 12 bytes for command codes and parameters.
 * The individual bytes within the set append a 0-B hex identifier to the FCCOB
 * register name: FCCOB0, FCCOB1, ..., FCCOBB.
 */
/*!
 * @name Constants and macros for entire FTFA_FCCOB6 register
 */
/*@{*/
#define FTFA_RD_FCCOB6(base)     (FTFA_FCCOB6_REG(base))
#define FTFA_WR_FCCOB6(base, value) (FTFA_FCCOB6_REG(base) = (value))
#define FTFA_RMW_FCCOB6(base, mask, value) (FTFA_WR_FCCOB6(base, (FTFA_RD_FCCOB6(base) & ~(mask)) | (value)))
#define FTFA_SET_FCCOB6(base, value) (BME_OR8(&FTFA_FCCOB6_REG(base), (uint8_t)(value)))
#define FTFA_CLR_FCCOB6(base, value) (BME_AND8(&FTFA_FCCOB6_REG(base), (uint8_t)(~(value))))
#define FTFA_TOG_FCCOB6(base, value) (BME_XOR8(&FTFA_FCCOB6_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * FTFA_FCCOB5 - Flash Common Command Object Registers
 ******************************************************************************/

/*!
 * @brief FTFA_FCCOB5 - Flash Common Command Object Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FCCOB register group provides 12 bytes for command codes and parameters.
 * The individual bytes within the set append a 0-B hex identifier to the FCCOB
 * register name: FCCOB0, FCCOB1, ..., FCCOBB.
 */
/*!
 * @name Constants and macros for entire FTFA_FCCOB5 register
 */
/*@{*/
#define FTFA_RD_FCCOB5(base)     (FTFA_FCCOB5_REG(base))
#define FTFA_WR_FCCOB5(base, value) (FTFA_FCCOB5_REG(base) = (value))
#define FTFA_RMW_FCCOB5(base, mask, value) (FTFA_WR_FCCOB5(base, (FTFA_RD_FCCOB5(base) & ~(mask)) | (value)))
#define FTFA_SET_FCCOB5(base, value) (BME_OR8(&FTFA_FCCOB5_REG(base), (uint8_t)(value)))
#define FTFA_CLR_FCCOB5(base, value) (BME_AND8(&FTFA_FCCOB5_REG(base), (uint8_t)(~(value))))
#define FTFA_TOG_FCCOB5(base, value) (BME_XOR8(&FTFA_FCCOB5_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * FTFA_FCCOB4 - Flash Common Command Object Registers
 ******************************************************************************/

/*!
 * @brief FTFA_FCCOB4 - Flash Common Command Object Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FCCOB register group provides 12 bytes for command codes and parameters.
 * The individual bytes within the set append a 0-B hex identifier to the FCCOB
 * register name: FCCOB0, FCCOB1, ..., FCCOBB.
 */
/*!
 * @name Constants and macros for entire FTFA_FCCOB4 register
 */
/*@{*/
#define FTFA_RD_FCCOB4(base)     (FTFA_FCCOB4_REG(base))
#define FTFA_WR_FCCOB4(base, value) (FTFA_FCCOB4_REG(base) = (value))
#define FTFA_RMW_FCCOB4(base, mask, value) (FTFA_WR_FCCOB4(base, (FTFA_RD_FCCOB4(base) & ~(mask)) | (value)))
#define FTFA_SET_FCCOB4(base, value) (BME_OR8(&FTFA_FCCOB4_REG(base), (uint8_t)(value)))
#define FTFA_CLR_FCCOB4(base, value) (BME_AND8(&FTFA_FCCOB4_REG(base), (uint8_t)(~(value))))
#define FTFA_TOG_FCCOB4(base, value) (BME_XOR8(&FTFA_FCCOB4_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * FTFA_FCCOBB - Flash Common Command Object Registers
 ******************************************************************************/

/*!
 * @brief FTFA_FCCOBB - Flash Common Command Object Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FCCOB register group provides 12 bytes for command codes and parameters.
 * The individual bytes within the set append a 0-B hex identifier to the FCCOB
 * register name: FCCOB0, FCCOB1, ..., FCCOBB.
 */
/*!
 * @name Constants and macros for entire FTFA_FCCOBB register
 */
/*@{*/
#define FTFA_RD_FCCOBB(base)     (FTFA_FCCOBB_REG(base))
#define FTFA_WR_FCCOBB(base, value) (FTFA_FCCOBB_REG(base) = (value))
#define FTFA_RMW_FCCOBB(base, mask, value) (FTFA_WR_FCCOBB(base, (FTFA_RD_FCCOBB(base) & ~(mask)) | (value)))
#define FTFA_SET_FCCOBB(base, value) (BME_OR8(&FTFA_FCCOBB_REG(base), (uint8_t)(value)))
#define FTFA_CLR_FCCOBB(base, value) (BME_AND8(&FTFA_FCCOBB_REG(base), (uint8_t)(~(value))))
#define FTFA_TOG_FCCOBB(base, value) (BME_XOR8(&FTFA_FCCOBB_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * FTFA_FCCOBA - Flash Common Command Object Registers
 ******************************************************************************/

/*!
 * @brief FTFA_FCCOBA - Flash Common Command Object Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FCCOB register group provides 12 bytes for command codes and parameters.
 * The individual bytes within the set append a 0-B hex identifier to the FCCOB
 * register name: FCCOB0, FCCOB1, ..., FCCOBB.
 */
/*!
 * @name Constants and macros for entire FTFA_FCCOBA register
 */
/*@{*/
#define FTFA_RD_FCCOBA(base)     (FTFA_FCCOBA_REG(base))
#define FTFA_WR_FCCOBA(base, value) (FTFA_FCCOBA_REG(base) = (value))
#define FTFA_RMW_FCCOBA(base, mask, value) (FTFA_WR_FCCOBA(base, (FTFA_RD_FCCOBA(base) & ~(mask)) | (value)))
#define FTFA_SET_FCCOBA(base, value) (BME_OR8(&FTFA_FCCOBA_REG(base), (uint8_t)(value)))
#define FTFA_CLR_FCCOBA(base, value) (BME_AND8(&FTFA_FCCOBA_REG(base), (uint8_t)(~(value))))
#define FTFA_TOG_FCCOBA(base, value) (BME_XOR8(&FTFA_FCCOBA_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * FTFA_FCCOB9 - Flash Common Command Object Registers
 ******************************************************************************/

/*!
 * @brief FTFA_FCCOB9 - Flash Common Command Object Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FCCOB register group provides 12 bytes for command codes and parameters.
 * The individual bytes within the set append a 0-B hex identifier to the FCCOB
 * register name: FCCOB0, FCCOB1, ..., FCCOBB.
 */
/*!
 * @name Constants and macros for entire FTFA_FCCOB9 register
 */
/*@{*/
#define FTFA_RD_FCCOB9(base)     (FTFA_FCCOB9_REG(base))
#define FTFA_WR_FCCOB9(base, value) (FTFA_FCCOB9_REG(base) = (value))
#define FTFA_RMW_FCCOB9(base, mask, value) (FTFA_WR_FCCOB9(base, (FTFA_RD_FCCOB9(base) & ~(mask)) | (value)))
#define FTFA_SET_FCCOB9(base, value) (BME_OR8(&FTFA_FCCOB9_REG(base), (uint8_t)(value)))
#define FTFA_CLR_FCCOB9(base, value) (BME_AND8(&FTFA_FCCOB9_REG(base), (uint8_t)(~(value))))
#define FTFA_TOG_FCCOB9(base, value) (BME_XOR8(&FTFA_FCCOB9_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * FTFA_FCCOB8 - Flash Common Command Object Registers
 ******************************************************************************/

/*!
 * @brief FTFA_FCCOB8 - Flash Common Command Object Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FCCOB register group provides 12 bytes for command codes and parameters.
 * The individual bytes within the set append a 0-B hex identifier to the FCCOB
 * register name: FCCOB0, FCCOB1, ..., FCCOBB.
 */
/*!
 * @name Constants and macros for entire FTFA_FCCOB8 register
 */
/*@{*/
#define FTFA_RD_FCCOB8(base)     (FTFA_FCCOB8_REG(base))
#define FTFA_WR_FCCOB8(base, value) (FTFA_FCCOB8_REG(base) = (value))
#define FTFA_RMW_FCCOB8(base, mask, value) (FTFA_WR_FCCOB8(base, (FTFA_RD_FCCOB8(base) & ~(mask)) | (value)))
#define FTFA_SET_FCCOB8(base, value) (BME_OR8(&FTFA_FCCOB8_REG(base), (uint8_t)(value)))
#define FTFA_CLR_FCCOB8(base, value) (BME_AND8(&FTFA_FCCOB8_REG(base), (uint8_t)(~(value))))
#define FTFA_TOG_FCCOB8(base, value) (BME_XOR8(&FTFA_FCCOB8_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * FTFA_FPROT3 - Program Flash Protection Registers
 ******************************************************************************/

/*!
 * @brief FTFA_FPROT3 - Program Flash Protection Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FPROT registers define which program flash regions are protected from
 * program and erase operations. Protected flash regions cannot have their content
 * changed; that is, these regions cannot be programmed and cannot be erased by
 * any flash command. Unprotected regions can be changed by program and erase
 * operations. The four FPROT registers allow up to 32 protectable regions. Each bit
 * protects a 1/32 region of the program flash memory except for memory
 * configurations with less than 32 KB of program flash where each assigned bit protects 1
 * KB . For configurations with 24 KB of program flash memory or less, FPROT0 is
 * not used. For configurations with 16 KB of program flash memory or less,
 * FPROT1 is not used. For configurations with 8 KB of program flash memory, FPROT2 is
 * not used. The bitfields are defined in each register as follows: Program
 * flash protection register Program flash protection bits FPROT0 PROT[31:24] FPROT1
 * PROT[23:16] FPROT2 PROT[15:8] FPROT3 PROT[7:0] During the reset sequence, the
 * FPROT registers are loaded with the contents of the program flash protection
 * bytes in the Flash Configuration Field as indicated in the following table.
 * Program flash protection register Flash Configuration Field offset address FPROT0
 * 0x000B FPROT1 0x000A FPROT2 0x0009 FPROT3 0x0008 To change the program flash
 * protection that is loaded during the reset sequence, unprotect the sector of
 * program flash memory that contains the Flash Configuration Field. Then,
 * reprogram the program flash protection byte.
 */
/*!
 * @name Constants and macros for entire FTFA_FPROT3 register
 */
/*@{*/
#define FTFA_RD_FPROT3(base)     (FTFA_FPROT3_REG(base))
#define FTFA_WR_FPROT3(base, value) (FTFA_FPROT3_REG(base) = (value))
#define FTFA_RMW_FPROT3(base, mask, value) (FTFA_WR_FPROT3(base, (FTFA_RD_FPROT3(base) & ~(mask)) | (value)))
#define FTFA_SET_FPROT3(base, value) (BME_OR8(&FTFA_FPROT3_REG(base), (uint8_t)(value)))
#define FTFA_CLR_FPROT3(base, value) (BME_AND8(&FTFA_FPROT3_REG(base), (uint8_t)(~(value))))
#define FTFA_TOG_FPROT3(base, value) (BME_XOR8(&FTFA_FPROT3_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * FTFA_FPROT2 - Program Flash Protection Registers
 ******************************************************************************/

/*!
 * @brief FTFA_FPROT2 - Program Flash Protection Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FPROT registers define which program flash regions are protected from
 * program and erase operations. Protected flash regions cannot have their content
 * changed; that is, these regions cannot be programmed and cannot be erased by
 * any flash command. Unprotected regions can be changed by program and erase
 * operations. The four FPROT registers allow up to 32 protectable regions. Each bit
 * protects a 1/32 region of the program flash memory except for memory
 * configurations with less than 32 KB of program flash where each assigned bit protects 1
 * KB . For configurations with 24 KB of program flash memory or less, FPROT0 is
 * not used. For configurations with 16 KB of program flash memory or less,
 * FPROT1 is not used. For configurations with 8 KB of program flash memory, FPROT2 is
 * not used. The bitfields are defined in each register as follows: Program
 * flash protection register Program flash protection bits FPROT0 PROT[31:24] FPROT1
 * PROT[23:16] FPROT2 PROT[15:8] FPROT3 PROT[7:0] During the reset sequence, the
 * FPROT registers are loaded with the contents of the program flash protection
 * bytes in the Flash Configuration Field as indicated in the following table.
 * Program flash protection register Flash Configuration Field offset address FPROT0
 * 0x000B FPROT1 0x000A FPROT2 0x0009 FPROT3 0x0008 To change the program flash
 * protection that is loaded during the reset sequence, unprotect the sector of
 * program flash memory that contains the Flash Configuration Field. Then,
 * reprogram the program flash protection byte.
 */
/*!
 * @name Constants and macros for entire FTFA_FPROT2 register
 */
/*@{*/
#define FTFA_RD_FPROT2(base)     (FTFA_FPROT2_REG(base))
#define FTFA_WR_FPROT2(base, value) (FTFA_FPROT2_REG(base) = (value))
#define FTFA_RMW_FPROT2(base, mask, value) (FTFA_WR_FPROT2(base, (FTFA_RD_FPROT2(base) & ~(mask)) | (value)))
#define FTFA_SET_FPROT2(base, value) (BME_OR8(&FTFA_FPROT2_REG(base), (uint8_t)(value)))
#define FTFA_CLR_FPROT2(base, value) (BME_AND8(&FTFA_FPROT2_REG(base), (uint8_t)(~(value))))
#define FTFA_TOG_FPROT2(base, value) (BME_XOR8(&FTFA_FPROT2_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * FTFA_FPROT1 - Program Flash Protection Registers
 ******************************************************************************/

/*!
 * @brief FTFA_FPROT1 - Program Flash Protection Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FPROT registers define which program flash regions are protected from
 * program and erase operations. Protected flash regions cannot have their content
 * changed; that is, these regions cannot be programmed and cannot be erased by
 * any flash command. Unprotected regions can be changed by program and erase
 * operations. The four FPROT registers allow up to 32 protectable regions. Each bit
 * protects a 1/32 region of the program flash memory except for memory
 * configurations with less than 32 KB of program flash where each assigned bit protects 1
 * KB . For configurations with 24 KB of program flash memory or less, FPROT0 is
 * not used. For configurations with 16 KB of program flash memory or less,
 * FPROT1 is not used. For configurations with 8 KB of program flash memory, FPROT2 is
 * not used. The bitfields are defined in each register as follows: Program
 * flash protection register Program flash protection bits FPROT0 PROT[31:24] FPROT1
 * PROT[23:16] FPROT2 PROT[15:8] FPROT3 PROT[7:0] During the reset sequence, the
 * FPROT registers are loaded with the contents of the program flash protection
 * bytes in the Flash Configuration Field as indicated in the following table.
 * Program flash protection register Flash Configuration Field offset address FPROT0
 * 0x000B FPROT1 0x000A FPROT2 0x0009 FPROT3 0x0008 To change the program flash
 * protection that is loaded during the reset sequence, unprotect the sector of
 * program flash memory that contains the Flash Configuration Field. Then,
 * reprogram the program flash protection byte.
 */
/*!
 * @name Constants and macros for entire FTFA_FPROT1 register
 */
/*@{*/
#define FTFA_RD_FPROT1(base)     (FTFA_FPROT1_REG(base))
#define FTFA_WR_FPROT1(base, value) (FTFA_FPROT1_REG(base) = (value))
#define FTFA_RMW_FPROT1(base, mask, value) (FTFA_WR_FPROT1(base, (FTFA_RD_FPROT1(base) & ~(mask)) | (value)))
#define FTFA_SET_FPROT1(base, value) (BME_OR8(&FTFA_FPROT1_REG(base), (uint8_t)(value)))
#define FTFA_CLR_FPROT1(base, value) (BME_AND8(&FTFA_FPROT1_REG(base), (uint8_t)(~(value))))
#define FTFA_TOG_FPROT1(base, value) (BME_XOR8(&FTFA_FPROT1_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * FTFA_FPROT0 - Program Flash Protection Registers
 ******************************************************************************/

/*!
 * @brief FTFA_FPROT0 - Program Flash Protection Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FPROT registers define which program flash regions are protected from
 * program and erase operations. Protected flash regions cannot have their content
 * changed; that is, these regions cannot be programmed and cannot be erased by
 * any flash command. Unprotected regions can be changed by program and erase
 * operations. The four FPROT registers allow up to 32 protectable regions. Each bit
 * protects a 1/32 region of the program flash memory except for memory
 * configurations with less than 32 KB of program flash where each assigned bit protects 1
 * KB . For configurations with 24 KB of program flash memory or less, FPROT0 is
 * not used. For configurations with 16 KB of program flash memory or less,
 * FPROT1 is not used. For configurations with 8 KB of program flash memory, FPROT2 is
 * not used. The bitfields are defined in each register as follows: Program
 * flash protection register Program flash protection bits FPROT0 PROT[31:24] FPROT1
 * PROT[23:16] FPROT2 PROT[15:8] FPROT3 PROT[7:0] During the reset sequence, the
 * FPROT registers are loaded with the contents of the program flash protection
 * bytes in the Flash Configuration Field as indicated in the following table.
 * Program flash protection register Flash Configuration Field offset address FPROT0
 * 0x000B FPROT1 0x000A FPROT2 0x0009 FPROT3 0x0008 To change the program flash
 * protection that is loaded during the reset sequence, unprotect the sector of
 * program flash memory that contains the Flash Configuration Field. Then,
 * reprogram the program flash protection byte.
 */
/*!
 * @name Constants and macros for entire FTFA_FPROT0 register
 */
/*@{*/
#define FTFA_RD_FPROT0(base)     (FTFA_FPROT0_REG(base))
#define FTFA_WR_FPROT0(base, value) (FTFA_FPROT0_REG(base) = (value))
#define FTFA_RMW_FPROT0(base, mask, value) (FTFA_WR_FPROT0(base, (FTFA_RD_FPROT0(base) & ~(mask)) | (value)))
#define FTFA_SET_FPROT0(base, value) (BME_OR8(&FTFA_FPROT0_REG(base), (uint8_t)(value)))
#define FTFA_CLR_FPROT0(base, value) (BME_AND8(&FTFA_FPROT0_REG(base), (uint8_t)(~(value))))
#define FTFA_TOG_FPROT0(base, value) (BME_XOR8(&FTFA_FPROT0_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * MKM34Z7 GPIO
 *
 * General Purpose Input/Output
 *
 * Registers defined in this header file:
 * - GPIO_PDOR - Port Data Output Register
 * - GPIO_PSOR - Port Set Output Register
 * - GPIO_PCOR - Port Clear Output Register
 * - GPIO_PTOR - Port Toggle Output Register
 * - GPIO_PDIR - Port Data Input Register
 * - GPIO_PDDR - Port Data Direction Register
 * - GPIO_GACR - GPIO Attribute Checker Register
 */

#define GPIO_INSTANCE_COUNT (13U) /*!< Number of instances of the GPIO module. */
#define GPIOA_IDX (0U) /*!< Instance number for GPIOA. */
#define GPIOB_IDX (1U) /*!< Instance number for GPIOB. */
#define GPIOC_IDX (2U) /*!< Instance number for GPIOC. */
#define GPIOD_IDX (3U) /*!< Instance number for GPIOD. */
#define GPIOE_IDX (4U) /*!< Instance number for GPIOE. */
#define GPIOF_IDX (5U) /*!< Instance number for GPIOF. */
#define GPIOG_IDX (6U) /*!< Instance number for GPIOG. */
#define GPIOH_IDX (7U) /*!< Instance number for GPIOH. */
#define GPIOI_IDX (8U) /*!< Instance number for GPIOI. */
#define GPIOJ_IDX (9U) /*!< Instance number for GPIOJ. */
#define GPIOK_IDX (10U) /*!< Instance number for GPIOK. */
#define GPIOL_IDX (11U) /*!< Instance number for GPIOL. */
#define GPIOM_IDX (12U) /*!< Instance number for GPIOM. */

/*******************************************************************************
 * GPIO_PDOR - Port Data Output Register
 ******************************************************************************/

/*!
 * @brief GPIO_PDOR - Port Data Output Register (RW)
 *
 * Reset value: 0x00U
 *
 * This register configures the logic levels that are driven on each
 * general-purpose output pins. Do not modify pin configuration registers associated with
 * pins not available in your selected package. All un-bonded pins not available in
 * your package will default to DISABLE state for lowest power consumption.
 */
/*!
 * @name Constants and macros for entire GPIO_PDOR register
 */
/*@{*/
#define GPIO_RD_PDOR(base)       (GPIO_PDOR_REG(base))
#define GPIO_WR_PDOR(base, value) (GPIO_PDOR_REG(base) = (value))
#define GPIO_RMW_PDOR(base, mask, value) (GPIO_WR_PDOR(base, (GPIO_RD_PDOR(base) & ~(mask)) | (value)))
#define GPIO_SET_PDOR(base, value) (BME_OR8(&GPIO_PDOR_REG(base), (uint8_t)(value)))
#define GPIO_CLR_PDOR(base, value) (BME_AND8(&GPIO_PDOR_REG(base), (uint8_t)(~(value))))
#define GPIO_TOG_PDOR(base, value) (BME_XOR8(&GPIO_PDOR_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * GPIO_PSOR - Port Set Output Register
 ******************************************************************************/

/*!
 * @brief GPIO_PSOR - Port Set Output Register (WORZ)
 *
 * Reset value: 0x00U
 *
 * This register configures whether to set the fields of the PDOR.
 */
/*!
 * @name Constants and macros for entire GPIO_PSOR register
 */
/*@{*/
#define GPIO_RD_PSOR(base)       (GPIO_PSOR_REG(base))
#define GPIO_WR_PSOR(base, value) (GPIO_PSOR_REG(base) = (value))
#define GPIO_RMW_PSOR(base, mask, value) (GPIO_WR_PSOR(base, (GPIO_RD_PSOR(base) & ~(mask)) | (value)))
/*@}*/

/*******************************************************************************
 * GPIO_PCOR - Port Clear Output Register
 ******************************************************************************/

/*!
 * @brief GPIO_PCOR - Port Clear Output Register (WORZ)
 *
 * Reset value: 0x00U
 *
 * This register configures whether to clear the fields of PDOR.
 */
/*!
 * @name Constants and macros for entire GPIO_PCOR register
 */
/*@{*/
#define GPIO_RD_PCOR(base)       (GPIO_PCOR_REG(base))
#define GPIO_WR_PCOR(base, value) (GPIO_PCOR_REG(base) = (value))
#define GPIO_RMW_PCOR(base, mask, value) (GPIO_WR_PCOR(base, (GPIO_RD_PCOR(base) & ~(mask)) | (value)))
/*@}*/

/*******************************************************************************
 * GPIO_PTOR - Port Toggle Output Register
 ******************************************************************************/

/*!
 * @brief GPIO_PTOR - Port Toggle Output Register (WORZ)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire GPIO_PTOR register
 */
/*@{*/
#define GPIO_RD_PTOR(base)       (GPIO_PTOR_REG(base))
#define GPIO_WR_PTOR(base, value) (GPIO_PTOR_REG(base) = (value))
#define GPIO_RMW_PTOR(base, mask, value) (GPIO_WR_PTOR(base, (GPIO_RD_PTOR(base) & ~(mask)) | (value)))
/*@}*/

/*******************************************************************************
 * GPIO_PDIR - Port Data Input Register
 ******************************************************************************/

/*!
 * @brief GPIO_PDIR - Port Data Input Register (RO)
 *
 * Reset value: 0x00U
 *
 * Do not modify pin configuration registers associated with pins not available
 * in your selected package. All un-bonded pins not available in your package
 * will default to DISABLE state for lowest power consumption.
 */
/*!
 * @name Constants and macros for entire GPIO_PDIR register
 */
/*@{*/
#define GPIO_RD_PDIR(base)       (GPIO_PDIR_REG(base))
/*@}*/

/*******************************************************************************
 * GPIO_PDDR - Port Data Direction Register
 ******************************************************************************/

/*!
 * @brief GPIO_PDDR - Port Data Direction Register (RW)
 *
 * Reset value: 0x00U
 *
 * The PDDR configures the individual port pins for input or output.
 */
/*!
 * @name Constants and macros for entire GPIO_PDDR register
 */
/*@{*/
#define GPIO_RD_PDDR(base)       (GPIO_PDDR_REG(base))
#define GPIO_WR_PDDR(base, value) (GPIO_PDDR_REG(base) = (value))
#define GPIO_RMW_PDDR(base, mask, value) (GPIO_WR_PDDR(base, (GPIO_RD_PDDR(base) & ~(mask)) | (value)))
#define GPIO_SET_PDDR(base, value) (BME_OR8(&GPIO_PDDR_REG(base), (uint8_t)(value)))
#define GPIO_CLR_PDDR(base, value) (BME_AND8(&GPIO_PDDR_REG(base), (uint8_t)(~(value))))
#define GPIO_TOG_PDDR(base, value) (BME_XOR8(&GPIO_PDDR_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * GPIO_GACR - GPIO Attribute Checker Register
 ******************************************************************************/

/*!
 * @brief GPIO_GACR - GPIO Attribute Checker Register (RW)
 *
 * Reset value: 0x00U
 *
 * The GPIO module supports a device-specific number of data ports GPIO supports
 * single-cycle accesses from the processor core IOPORT bus as well as
 * references from the PBRIDGE-mapped address space. Since the core's IOPORT does not
 * support any type of bus stalls or error terminations, if an IOPORT access fails
 * the attribute checks, it is treated as a RAZ/WI access, that is, reads-as-zero
 * and writes ignored. GPIO GACRn register is checked for PBRDIGE accesses only if
 * the corresponding PACRn register allowed the reference. The appropriate PACRn
 * controls access rights to the entire GPIO address space, while the GACRn
 * registers define the access rights down to the byte level for the actual data
 * ports.
 */
/*!
 * @name Constants and macros for entire GPIO_GACR register
 */
/*@{*/
#define GPIO_RD_GACR(base)       (GPIO_GACR_REG(base))
#define GPIO_WR_GACR(base, value) (GPIO_GACR_REG(base) = (value))
#define GPIO_RMW_GACR(base, mask, value) (GPIO_WR_GACR(base, (GPIO_RD_GACR(base) & ~(mask)) | (value)))
#define GPIO_SET_GACR(base, value) (BME_OR8(&GPIO_GACR_REG(base), (uint8_t)(value)))
#define GPIO_CLR_GACR(base, value) (BME_AND8(&GPIO_GACR_REG(base), (uint8_t)(~(value))))
#define GPIO_TOG_GACR(base, value) (BME_XOR8(&GPIO_GACR_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual GPIO_GACR bitfields
 */

/*!
 * @name Register GPIO_GACR, field ACB[2:0] (RW)
 *
 * This 3 bit field defines the attributes required to access the corresponding
 * GPIO port's programming model.
 *
 * Values:
 * - 0b000 - User nonsecure: Read + Write; User Secure: Read + Write; Privileged
 *     Secure: Read + Write
 * - 0b001 - User nonsecure: Read; User Secure: Read + Write; Privileged Secure:
 *     Read + Write
 * - 0b010 - User nonsecure: None; User Secure: Read + Write; Privileged Secure:
 *     Read + Write
 * - 0b011 - User nonsecure: Read; User Secure: Read; Privileged Secure: Read +
 *     Write
 * - 0b100 - User nonsecure: None; User Secure: Read; Privileged Secure: Read +
 *     Write
 * - 0b101 - User nonsecure: None; User Secure: None; Privileged Secure: Read +
 *     Write
 * - 0b110 - User nonsecure: None; User Secure: None; Privileged Secure: Read
 * - 0b111 - User nonsecure: None; User Secure: None; Privileged Secure: None
 */
/*@{*/
/*! @brief Read current value of the GPIO_GACR_ACB field. */
#define GPIO_RD_GACR_ACB(base) ((GPIO_GACR_REG(base) & GPIO_GACR_ACB_MASK) >> GPIO_GACR_ACB_SHIFT)
#define GPIO_BRD_GACR_ACB(base) (BME_UBFX8(&GPIO_GACR_REG(base), GPIO_GACR_ACB_SHIFT, GPIO_GACR_ACB_WIDTH))

/*! @brief Set the ACB field to a new value. */
#define GPIO_WR_GACR_ACB(base, value) (GPIO_RMW_GACR(base, GPIO_GACR_ACB_MASK, GPIO_GACR_ACB(value)))
#define GPIO_BWR_GACR_ACB(base, value) (BME_BFI8(&GPIO_GACR_REG(base), ((uint8_t)(value) << GPIO_GACR_ACB_SHIFT), GPIO_GACR_ACB_SHIFT, GPIO_GACR_ACB_WIDTH))
/*@}*/

/*!
 * @name Register GPIO_GACR, field ROB[7] (RW)
 *
 * This register bit provides a mechanism to "lock" the configuration state
 * defined by ACB. Once asserted, this bit remains set and attempted writes to the
 * ACB are ignored until the next system reset clears the flag.
 *
 * Values:
 * - 0b0 - Writes to the ACB are allowed.
 * - 0b1 - Writes to the ACB are ignored.
 */
/*@{*/
/*! @brief Read current value of the GPIO_GACR_ROB field. */
#define GPIO_RD_GACR_ROB(base) ((GPIO_GACR_REG(base) & GPIO_GACR_ROB_MASK) >> GPIO_GACR_ROB_SHIFT)
#define GPIO_BRD_GACR_ROB(base) (BME_UBFX8(&GPIO_GACR_REG(base), GPIO_GACR_ROB_SHIFT, GPIO_GACR_ROB_WIDTH))

/*! @brief Set the ROB field to a new value. */
#define GPIO_WR_GACR_ROB(base, value) (GPIO_RMW_GACR(base, GPIO_GACR_ROB_MASK, GPIO_GACR_ROB(value)))
#define GPIO_BWR_GACR_ROB(base, value) (BME_BFI8(&GPIO_GACR_REG(base), ((uint8_t)(value) << GPIO_GACR_ROB_SHIFT), GPIO_GACR_ROB_SHIFT, GPIO_GACR_ROB_WIDTH))
/*@}*/

/*
 * MKM34Z7 I2C
 *
 * Inter-Integrated Circuit
 *
 * Registers defined in this header file:
 * - I2C_A1 - I2C Address Register 1
 * - I2C_F - I2C Frequency Divider register
 * - I2C_C1 - I2C Control Register 1
 * - I2C_S - I2C Status register
 * - I2C_D - I2C Data I/O register
 * - I2C_C2 - I2C Control Register 2
 * - I2C_FLT - I2C Programmable Input Glitch Filter Register
 * - I2C_RA - I2C Range Address register
 * - I2C_SMB - I2C SMBus Control and Status register
 * - I2C_A2 - I2C Address Register 2
 * - I2C_SLTH - I2C SCL Low Timeout Register High
 * - I2C_SLTL - I2C SCL Low Timeout Register Low
 * - I2C_S2 - I2C Status register 2
 */

#define I2C_INSTANCE_COUNT (2U) /*!< Number of instances of the I2C module. */
#define I2C0_IDX (0U) /*!< Instance number for I2C0. */
#define I2C1_IDX (1U) /*!< Instance number for I2C1. */

/*******************************************************************************
 * I2C_A1 - I2C Address Register 1
 ******************************************************************************/

/*!
 * @brief I2C_A1 - I2C Address Register 1 (RW)
 *
 * Reset value: 0x00U
 *
 * This register contains the slave address to be used by the I2C module.
 */
/*!
 * @name Constants and macros for entire I2C_A1 register
 */
/*@{*/
#define I2C_RD_A1(base)          (I2C_A1_REG(base))
#define I2C_WR_A1(base, value)   (I2C_A1_REG(base) = (value))
#define I2C_RMW_A1(base, mask, value) (I2C_WR_A1(base, (I2C_RD_A1(base) & ~(mask)) | (value)))
#define I2C_SET_A1(base, value)  (BME_OR8(&I2C_A1_REG(base), (uint8_t)(value)))
#define I2C_CLR_A1(base, value)  (BME_AND8(&I2C_A1_REG(base), (uint8_t)(~(value))))
#define I2C_TOG_A1(base, value)  (BME_XOR8(&I2C_A1_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual I2C_A1 bitfields
 */

/*!
 * @name Register I2C_A1, field AD[7:1] (RW)
 *
 * Contains the primary slave address used by the I2C module when it is
 * addressed as a slave. This field is used in the 7-bit address scheme and the lower
 * seven bits in the 10-bit address scheme.
 */
/*@{*/
/*! @brief Read current value of the I2C_A1_AD field. */
#define I2C_RD_A1_AD(base)   ((I2C_A1_REG(base) & I2C_A1_AD_MASK) >> I2C_A1_AD_SHIFT)
#define I2C_BRD_A1_AD(base)  (BME_UBFX8(&I2C_A1_REG(base), I2C_A1_AD_SHIFT, I2C_A1_AD_WIDTH))

/*! @brief Set the AD field to a new value. */
#define I2C_WR_A1_AD(base, value) (I2C_RMW_A1(base, I2C_A1_AD_MASK, I2C_A1_AD(value)))
#define I2C_BWR_A1_AD(base, value) (BME_BFI8(&I2C_A1_REG(base), ((uint8_t)(value) << I2C_A1_AD_SHIFT), I2C_A1_AD_SHIFT, I2C_A1_AD_WIDTH))
/*@}*/

/*******************************************************************************
 * I2C_F - I2C Frequency Divider register
 ******************************************************************************/

/*!
 * @brief I2C_F - I2C Frequency Divider register (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire I2C_F register
 */
/*@{*/
#define I2C_RD_F(base)           (I2C_F_REG(base))
#define I2C_WR_F(base, value)    (I2C_F_REG(base) = (value))
#define I2C_RMW_F(base, mask, value) (I2C_WR_F(base, (I2C_RD_F(base) & ~(mask)) | (value)))
#define I2C_SET_F(base, value)   (BME_OR8(&I2C_F_REG(base), (uint8_t)(value)))
#define I2C_CLR_F(base, value)   (BME_AND8(&I2C_F_REG(base), (uint8_t)(~(value))))
#define I2C_TOG_F(base, value)   (BME_XOR8(&I2C_F_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual I2C_F bitfields
 */

/*!
 * @name Register I2C_F, field ICR[5:0] (RW)
 *
 * Prescales the I2C module clock for bit rate selection. This field and the
 * MULT field determine the I2C baud rate, the SDA hold time, the SCL start hold
 * time, and the SCL stop hold time. For a list of values corresponding to each ICR
 * setting, see I2C divider and hold values. The SCL divider multiplied by
 * multiplier factor (mul) determines the I2C baud rate. I2C baud rate = I2C module
 * clock speed (Hz)/(mul * SCL divider) The SDA hold time is the delay from the
 * falling edge of SCL (I2C clock) to the changing of SDA (I2C data). SDA hold time =
 * I2C module clock period (s) * mul * SDA hold value The SCL start hold time is
 * the delay from the falling edge of SDA (I2C data) while SCL is high (start
 * condition) to the falling edge of SCL (I2C clock). SCL start hold time = I2C
 * module clock period (s) * mul * SCL start hold value The SCL stop hold time is
 * the delay from the rising edge of SCL (I2C clock) to the rising edge of SDA (I2C
 * data) while SCL is high (stop condition). SCL stop hold time = I2C module
 * clock period (s) * mul * SCL stop hold value For example, if the I2C module clock
 * speed is 8 MHz, the following table shows the possible hold time values with
 * different ICR and MULT selections to achieve an I2C baud rate of 100 kbit/s.
 * MULT ICR Hold times (us) SDA SCL Start SCL Stop 2h 00h 3.500 3.000 5.500 1h 07h
 * 2.500 4.000 5.250 1h 0Bh 2.250 4.000 5.250 0h 14h 2.125 4.250 5.125 0h 18h
 * 1.125 4.750 5.125
 */
/*@{*/
/*! @brief Read current value of the I2C_F_ICR field. */
#define I2C_RD_F_ICR(base)   ((I2C_F_REG(base) & I2C_F_ICR_MASK) >> I2C_F_ICR_SHIFT)
#define I2C_BRD_F_ICR(base)  (BME_UBFX8(&I2C_F_REG(base), I2C_F_ICR_SHIFT, I2C_F_ICR_WIDTH))

/*! @brief Set the ICR field to a new value. */
#define I2C_WR_F_ICR(base, value) (I2C_RMW_F(base, I2C_F_ICR_MASK, I2C_F_ICR(value)))
#define I2C_BWR_F_ICR(base, value) (BME_BFI8(&I2C_F_REG(base), ((uint8_t)(value) << I2C_F_ICR_SHIFT), I2C_F_ICR_SHIFT, I2C_F_ICR_WIDTH))
/*@}*/

/*!
 * @name Register I2C_F, field MULT[7:6] (RW)
 *
 * Defines the multiplier factor (mul). This factor is used along with the SCL
 * divider to generate the I2C baud rate.
 *
 * Values:
 * - 0b00 - mul = 1
 * - 0b01 - mul = 2
 * - 0b10 - mul = 4
 * - 0b11 - Reserved
 */
/*@{*/
/*! @brief Read current value of the I2C_F_MULT field. */
#define I2C_RD_F_MULT(base)  ((I2C_F_REG(base) & I2C_F_MULT_MASK) >> I2C_F_MULT_SHIFT)
#define I2C_BRD_F_MULT(base) (BME_UBFX8(&I2C_F_REG(base), I2C_F_MULT_SHIFT, I2C_F_MULT_WIDTH))

/*! @brief Set the MULT field to a new value. */
#define I2C_WR_F_MULT(base, value) (I2C_RMW_F(base, I2C_F_MULT_MASK, I2C_F_MULT(value)))
#define I2C_BWR_F_MULT(base, value) (BME_BFI8(&I2C_F_REG(base), ((uint8_t)(value) << I2C_F_MULT_SHIFT), I2C_F_MULT_SHIFT, I2C_F_MULT_WIDTH))
/*@}*/

/*******************************************************************************
 * I2C_C1 - I2C Control Register 1
 ******************************************************************************/

/*!
 * @brief I2C_C1 - I2C Control Register 1 (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire I2C_C1 register
 */
/*@{*/
#define I2C_RD_C1(base)          (I2C_C1_REG(base))
#define I2C_WR_C1(base, value)   (I2C_C1_REG(base) = (value))
#define I2C_RMW_C1(base, mask, value) (I2C_WR_C1(base, (I2C_RD_C1(base) & ~(mask)) | (value)))
#define I2C_SET_C1(base, value)  (BME_OR8(&I2C_C1_REG(base), (uint8_t)(value)))
#define I2C_CLR_C1(base, value)  (BME_AND8(&I2C_C1_REG(base), (uint8_t)(~(value))))
#define I2C_TOG_C1(base, value)  (BME_XOR8(&I2C_C1_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual I2C_C1 bitfields
 */

/*!
 * @name Register I2C_C1, field DMAEN[0] (RW)
 *
 * Enables or disables the DMA function.
 *
 * Values:
 * - 0b0 - All DMA signalling disabled.
 * - 0b1 - DMA transfer is enabled. While SMB[FACK] = 0, the following
 *     conditions trigger the DMA request: a data byte is received, and either address or
 *     data is transmitted. (ACK/NACK is automatic) the first byte received
 *     matches the A1 register or is a general call address. If any address matching
 *     occurs, S[IAAS] and S[TCF] are set. If the direction of transfer is known
 *     from master to slave, then it is not required to check S[SRW]. With this
 *     assumption, DMA can also be used in this case. In other cases, if the master
 *     reads data from the slave, then it is required to rewrite the C1 register
 *     operation. With this assumption, DMA cannot be used. When FACK = 1, an
 *     address or a data byte is transmitted.
 */
/*@{*/
/*! @brief Read current value of the I2C_C1_DMAEN field. */
#define I2C_RD_C1_DMAEN(base) ((I2C_C1_REG(base) & I2C_C1_DMAEN_MASK) >> I2C_C1_DMAEN_SHIFT)
#define I2C_BRD_C1_DMAEN(base) (BME_UBFX8(&I2C_C1_REG(base), I2C_C1_DMAEN_SHIFT, I2C_C1_DMAEN_WIDTH))

/*! @brief Set the DMAEN field to a new value. */
#define I2C_WR_C1_DMAEN(base, value) (I2C_RMW_C1(base, I2C_C1_DMAEN_MASK, I2C_C1_DMAEN(value)))
#define I2C_BWR_C1_DMAEN(base, value) (BME_BFI8(&I2C_C1_REG(base), ((uint8_t)(value) << I2C_C1_DMAEN_SHIFT), I2C_C1_DMAEN_SHIFT, I2C_C1_DMAEN_WIDTH))
/*@}*/

/*!
 * @name Register I2C_C1, field WUEN[1] (RW)
 *
 * The I2C module can wake the MCU from low power mode with no peripheral bus
 * running when slave address matching occurs.
 *
 * Values:
 * - 0b0 - Normal operation. No interrupt generated when address matching in low
 *     power mode.
 * - 0b1 - Enables the wakeup function in low power mode.
 */
/*@{*/
/*! @brief Read current value of the I2C_C1_WUEN field. */
#define I2C_RD_C1_WUEN(base) ((I2C_C1_REG(base) & I2C_C1_WUEN_MASK) >> I2C_C1_WUEN_SHIFT)
#define I2C_BRD_C1_WUEN(base) (BME_UBFX8(&I2C_C1_REG(base), I2C_C1_WUEN_SHIFT, I2C_C1_WUEN_WIDTH))

/*! @brief Set the WUEN field to a new value. */
#define I2C_WR_C1_WUEN(base, value) (I2C_RMW_C1(base, I2C_C1_WUEN_MASK, I2C_C1_WUEN(value)))
#define I2C_BWR_C1_WUEN(base, value) (BME_BFI8(&I2C_C1_REG(base), ((uint8_t)(value) << I2C_C1_WUEN_SHIFT), I2C_C1_WUEN_SHIFT, I2C_C1_WUEN_WIDTH))
/*@}*/

/*!
 * @name Register I2C_C1, field RSTA[2] (WORZ)
 *
 * Writing 1 to this bit generates a repeated START condition provided it is the
 * current master. This bit will always be read as 0. Attempting a repeat at the
 * wrong time results in loss of arbitration.
 */
/*@{*/
/*! @brief Set the RSTA field to a new value. */
#define I2C_WR_C1_RSTA(base, value) (I2C_RMW_C1(base, I2C_C1_RSTA_MASK, I2C_C1_RSTA(value)))
#define I2C_BWR_C1_RSTA(base, value) (BME_BFI8(&I2C_C1_REG(base), ((uint8_t)(value) << I2C_C1_RSTA_SHIFT), I2C_C1_RSTA_SHIFT, I2C_C1_RSTA_WIDTH))
/*@}*/

/*!
 * @name Register I2C_C1, field TXAK[3] (RW)
 *
 * Specifies the value driven onto the SDA during data acknowledge cycles for
 * both master and slave receivers. The value of SMB[FACK] affects NACK/ACK
 * generation. SCL is held low until TXAK is written.
 *
 * Values:
 * - 0b0 - An acknowledge signal is sent to the bus on the following receiving
 *     byte (if FACK is cleared) or the current receiving byte (if FACK is set).
 * - 0b1 - No acknowledge signal is sent to the bus on the following receiving
 *     data byte (if FACK is cleared) or the current receiving data byte (if FACK
 *     is set).
 */
/*@{*/
/*! @brief Read current value of the I2C_C1_TXAK field. */
#define I2C_RD_C1_TXAK(base) ((I2C_C1_REG(base) & I2C_C1_TXAK_MASK) >> I2C_C1_TXAK_SHIFT)
#define I2C_BRD_C1_TXAK(base) (BME_UBFX8(&I2C_C1_REG(base), I2C_C1_TXAK_SHIFT, I2C_C1_TXAK_WIDTH))

/*! @brief Set the TXAK field to a new value. */
#define I2C_WR_C1_TXAK(base, value) (I2C_RMW_C1(base, I2C_C1_TXAK_MASK, I2C_C1_TXAK(value)))
#define I2C_BWR_C1_TXAK(base, value) (BME_BFI8(&I2C_C1_REG(base), ((uint8_t)(value) << I2C_C1_TXAK_SHIFT), I2C_C1_TXAK_SHIFT, I2C_C1_TXAK_WIDTH))
/*@}*/

/*!
 * @name Register I2C_C1, field TX[4] (RW)
 *
 * Selects the direction of master and slave transfers. In master mode this bit
 * must be set according to the type of transfer required. Therefore, for address
 * cycles, this bit is always set. When addressed as a slave this bit must be
 * set by software according to the SRW bit in the status register.
 *
 * Values:
 * - 0b0 - Receive
 * - 0b1 - Transmit
 */
/*@{*/
/*! @brief Read current value of the I2C_C1_TX field. */
#define I2C_RD_C1_TX(base)   ((I2C_C1_REG(base) & I2C_C1_TX_MASK) >> I2C_C1_TX_SHIFT)
#define I2C_BRD_C1_TX(base)  (BME_UBFX8(&I2C_C1_REG(base), I2C_C1_TX_SHIFT, I2C_C1_TX_WIDTH))

/*! @brief Set the TX field to a new value. */
#define I2C_WR_C1_TX(base, value) (I2C_RMW_C1(base, I2C_C1_TX_MASK, I2C_C1_TX(value)))
#define I2C_BWR_C1_TX(base, value) (BME_BFI8(&I2C_C1_REG(base), ((uint8_t)(value) << I2C_C1_TX_SHIFT), I2C_C1_TX_SHIFT, I2C_C1_TX_WIDTH))
/*@}*/

/*!
 * @name Register I2C_C1, field MST[5] (RW)
 *
 * When MST is changed from 0 to 1, a START signal is generated on the bus and
 * master mode is selected. When this bit changes from 1 to 0, a STOP signal is
 * generated and the mode of operation changes from master to slave.
 *
 * Values:
 * - 0b0 - Slave mode
 * - 0b1 - Master mode
 */
/*@{*/
/*! @brief Read current value of the I2C_C1_MST field. */
#define I2C_RD_C1_MST(base)  ((I2C_C1_REG(base) & I2C_C1_MST_MASK) >> I2C_C1_MST_SHIFT)
#define I2C_BRD_C1_MST(base) (BME_UBFX8(&I2C_C1_REG(base), I2C_C1_MST_SHIFT, I2C_C1_MST_WIDTH))

/*! @brief Set the MST field to a new value. */
#define I2C_WR_C1_MST(base, value) (I2C_RMW_C1(base, I2C_C1_MST_MASK, I2C_C1_MST(value)))
#define I2C_BWR_C1_MST(base, value) (BME_BFI8(&I2C_C1_REG(base), ((uint8_t)(value) << I2C_C1_MST_SHIFT), I2C_C1_MST_SHIFT, I2C_C1_MST_WIDTH))
/*@}*/

/*!
 * @name Register I2C_C1, field IICIE[6] (RW)
 *
 * Enables I2C interrupt requests.
 *
 * Values:
 * - 0b0 - Disabled
 * - 0b1 - Enabled
 */
/*@{*/
/*! @brief Read current value of the I2C_C1_IICIE field. */
#define I2C_RD_C1_IICIE(base) ((I2C_C1_REG(base) & I2C_C1_IICIE_MASK) >> I2C_C1_IICIE_SHIFT)
#define I2C_BRD_C1_IICIE(base) (BME_UBFX8(&I2C_C1_REG(base), I2C_C1_IICIE_SHIFT, I2C_C1_IICIE_WIDTH))

/*! @brief Set the IICIE field to a new value. */
#define I2C_WR_C1_IICIE(base, value) (I2C_RMW_C1(base, I2C_C1_IICIE_MASK, I2C_C1_IICIE(value)))
#define I2C_BWR_C1_IICIE(base, value) (BME_BFI8(&I2C_C1_REG(base), ((uint8_t)(value) << I2C_C1_IICIE_SHIFT), I2C_C1_IICIE_SHIFT, I2C_C1_IICIE_WIDTH))
/*@}*/

/*!
 * @name Register I2C_C1, field IICEN[7] (RW)
 *
 * Enables I2C module operation.
 *
 * Values:
 * - 0b0 - Disabled
 * - 0b1 - Enabled
 */
/*@{*/
/*! @brief Read current value of the I2C_C1_IICEN field. */
#define I2C_RD_C1_IICEN(base) ((I2C_C1_REG(base) & I2C_C1_IICEN_MASK) >> I2C_C1_IICEN_SHIFT)
#define I2C_BRD_C1_IICEN(base) (BME_UBFX8(&I2C_C1_REG(base), I2C_C1_IICEN_SHIFT, I2C_C1_IICEN_WIDTH))

/*! @brief Set the IICEN field to a new value. */
#define I2C_WR_C1_IICEN(base, value) (I2C_RMW_C1(base, I2C_C1_IICEN_MASK, I2C_C1_IICEN(value)))
#define I2C_BWR_C1_IICEN(base, value) (BME_BFI8(&I2C_C1_REG(base), ((uint8_t)(value) << I2C_C1_IICEN_SHIFT), I2C_C1_IICEN_SHIFT, I2C_C1_IICEN_WIDTH))
/*@}*/

/*******************************************************************************
 * I2C_S - I2C Status register
 ******************************************************************************/

/*!
 * @brief I2C_S - I2C Status register (RW)
 *
 * Reset value: 0x80U
 */
/*!
 * @name Constants and macros for entire I2C_S register
 */
/*@{*/
#define I2C_RD_S(base)           (I2C_S_REG(base))
#define I2C_WR_S(base, value)    (I2C_S_REG(base) = (value))
#define I2C_RMW_S(base, mask, value) (I2C_WR_S(base, (I2C_RD_S(base) & ~(mask)) | (value)))
#define I2C_SET_S(base, value)   (BME_OR8(&I2C_S_REG(base), (uint8_t)(value)))
#define I2C_CLR_S(base, value)   (BME_AND8(&I2C_S_REG(base), (uint8_t)(~(value))))
#define I2C_TOG_S(base, value)   (BME_XOR8(&I2C_S_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual I2C_S bitfields
 */

/*!
 * @name Register I2C_S, field RXAK[0] (RO)
 *
 * Values:
 * - 0b0 - Acknowledge signal was received after the completion of one byte of
 *     data transmission on the bus
 * - 0b1 - No acknowledge signal detected
 */
/*@{*/
/*! @brief Read current value of the I2C_S_RXAK field. */
#define I2C_RD_S_RXAK(base)  ((I2C_S_REG(base) & I2C_S_RXAK_MASK) >> I2C_S_RXAK_SHIFT)
#define I2C_BRD_S_RXAK(base) (BME_UBFX8(&I2C_S_REG(base), I2C_S_RXAK_SHIFT, I2C_S_RXAK_WIDTH))
/*@}*/

/*!
 * @name Register I2C_S, field IICIF[1] (W1C)
 *
 * This bit sets when an interrupt is pending. This bit must be cleared by
 * software by writing 1 to it, such as in the interrupt routine. One of the following
 * events can set this bit: One byte transfer, including ACK/NACK bit, completes
 * if FACK is 0. An ACK or NACK is sent on the bus by writing 0 or 1 to TXAK
 * after this bit is set in receive mode. One byte transfer, excluding ACK/NACK bit,
 * completes if FACK is 1. Match of slave address to calling address including
 * primary slave address, range slave address , alert response address, second
 * slave address, or general call address. Arbitration lost In SMBus mode, any
 * timeouts except SCL and SDA high timeouts I2C bus stop or start detection if the
 * SSIE bit in the Input Glitch Filter register is 1 To clear the I2C bus stop or
 * start detection interrupt: In the interrupt service routine, first clear the
 * STOPF or STARTF bit in the Input Glitch Filter register by writing 1 to it, and
 * then clear the IICIF bit. If this sequence is reversed, the IICIF bit is
 * asserted again.
 *
 * Values:
 * - 0b0 - No interrupt pending
 * - 0b1 - Interrupt pending
 */
/*@{*/
/*! @brief Read current value of the I2C_S_IICIF field. */
#define I2C_RD_S_IICIF(base) ((I2C_S_REG(base) & I2C_S_IICIF_MASK) >> I2C_S_IICIF_SHIFT)
#define I2C_BRD_S_IICIF(base) (BME_UBFX8(&I2C_S_REG(base), I2C_S_IICIF_SHIFT, I2C_S_IICIF_WIDTH))

/*! @brief Set the IICIF field to a new value. */
#define I2C_WR_S_IICIF(base, value) (I2C_RMW_S(base, (I2C_S_IICIF_MASK | I2C_S_ARBL_MASK), I2C_S_IICIF(value)))
#define I2C_BWR_S_IICIF(base, value) (BME_BFI8(&I2C_S_REG(base), ((uint8_t)(value) << I2C_S_IICIF_SHIFT), I2C_S_IICIF_SHIFT, I2C_S_IICIF_WIDTH))
/*@}*/

/*!
 * @name Register I2C_S, field SRW[2] (RO)
 *
 * When addressed as a slave, SRW indicates the value of the R/W command bit of
 * the calling address sent to the master.
 *
 * Values:
 * - 0b0 - Slave receive, master writing to slave
 * - 0b1 - Slave transmit, master reading from slave
 */
/*@{*/
/*! @brief Read current value of the I2C_S_SRW field. */
#define I2C_RD_S_SRW(base)   ((I2C_S_REG(base) & I2C_S_SRW_MASK) >> I2C_S_SRW_SHIFT)
#define I2C_BRD_S_SRW(base)  (BME_UBFX8(&I2C_S_REG(base), I2C_S_SRW_SHIFT, I2C_S_SRW_WIDTH))
/*@}*/

/*!
 * @name Register I2C_S, field RAM[3] (RW)
 *
 * This bit is set to 1 by any of the following conditions, if I2C_C2[RMEN] = 1:
 * Any nonzero calling address is received that matches the address in the RA
 * register. The calling address is within the range of values of the A1 and RA
 * registers. For the RAM bit to be set to 1 correctly, C1[IICIE] must be set to 1.
 * Writing the C1 register with any value clears this bit to 0.
 *
 * Values:
 * - 0b0 - Not addressed
 * - 0b1 - Addressed as a slave
 */
/*@{*/
/*! @brief Read current value of the I2C_S_RAM field. */
#define I2C_RD_S_RAM(base)   ((I2C_S_REG(base) & I2C_S_RAM_MASK) >> I2C_S_RAM_SHIFT)
#define I2C_BRD_S_RAM(base)  (BME_UBFX8(&I2C_S_REG(base), I2C_S_RAM_SHIFT, I2C_S_RAM_WIDTH))

/*! @brief Set the RAM field to a new value. */
#define I2C_WR_S_RAM(base, value) (I2C_RMW_S(base, (I2C_S_RAM_MASK | I2C_S_IICIF_MASK | I2C_S_ARBL_MASK), I2C_S_RAM(value)))
#define I2C_BWR_S_RAM(base, value) (BME_BFI8(&I2C_S_REG(base), ((uint8_t)(value) << I2C_S_RAM_SHIFT), I2C_S_RAM_SHIFT, I2C_S_RAM_WIDTH))
/*@}*/

/*!
 * @name Register I2C_S, field ARBL[4] (W1C)
 *
 * This bit is set by hardware when the arbitration procedure is lost. The ARBL
 * bit must be cleared by software, by writing 1 to it.
 *
 * Values:
 * - 0b0 - Standard bus operation.
 * - 0b1 - Loss of arbitration.
 */
/*@{*/
/*! @brief Read current value of the I2C_S_ARBL field. */
#define I2C_RD_S_ARBL(base)  ((I2C_S_REG(base) & I2C_S_ARBL_MASK) >> I2C_S_ARBL_SHIFT)
#define I2C_BRD_S_ARBL(base) (BME_UBFX8(&I2C_S_REG(base), I2C_S_ARBL_SHIFT, I2C_S_ARBL_WIDTH))

/*! @brief Set the ARBL field to a new value. */
#define I2C_WR_S_ARBL(base, value) (I2C_RMW_S(base, (I2C_S_ARBL_MASK | I2C_S_IICIF_MASK), I2C_S_ARBL(value)))
#define I2C_BWR_S_ARBL(base, value) (BME_BFI8(&I2C_S_REG(base), ((uint8_t)(value) << I2C_S_ARBL_SHIFT), I2C_S_ARBL_SHIFT, I2C_S_ARBL_WIDTH))
/*@}*/

/*!
 * @name Register I2C_S, field BUSY[5] (RO)
 *
 * Indicates the status of the bus regardless of slave or master mode. This bit
 * is set when a START signal is detected and cleared when a STOP signal is
 * detected.
 *
 * Values:
 * - 0b0 - Bus is idle
 * - 0b1 - Bus is busy
 */
/*@{*/
/*! @brief Read current value of the I2C_S_BUSY field. */
#define I2C_RD_S_BUSY(base)  ((I2C_S_REG(base) & I2C_S_BUSY_MASK) >> I2C_S_BUSY_SHIFT)
#define I2C_BRD_S_BUSY(base) (BME_UBFX8(&I2C_S_REG(base), I2C_S_BUSY_SHIFT, I2C_S_BUSY_WIDTH))
/*@}*/

/*!
 * @name Register I2C_S, field IAAS[6] (RW)
 *
 * This bit is set by one of the following conditions: The calling address
 * matches the programmed primary slave address in the A1 register, or matches the
 * range address in the RA register (which must be set to a nonzero value and under
 * the condition I2C_C2[RMEN] = 1). C2[GCAEN] is set and a general call is
 * received. SMB[SIICAEN] is set and the calling address matches the second programmed
 * slave address. ALERTEN is set and an SMBus alert response address is received
 * RMEN is set and an address is received that is within the range between the
 * values of the A1 and RA registers. IAAS sets before the ACK bit. The CPU must
 * check the SRW bit and set TX/RX accordingly. Writing the C1 register with any
 * value clears this bit.
 *
 * Values:
 * - 0b0 - Not addressed
 * - 0b1 - Addressed as a slave
 */
/*@{*/
/*! @brief Read current value of the I2C_S_IAAS field. */
#define I2C_RD_S_IAAS(base)  ((I2C_S_REG(base) & I2C_S_IAAS_MASK) >> I2C_S_IAAS_SHIFT)
#define I2C_BRD_S_IAAS(base) (BME_UBFX8(&I2C_S_REG(base), I2C_S_IAAS_SHIFT, I2C_S_IAAS_WIDTH))

/*! @brief Set the IAAS field to a new value. */
#define I2C_WR_S_IAAS(base, value) (I2C_RMW_S(base, (I2C_S_IAAS_MASK | I2C_S_IICIF_MASK | I2C_S_ARBL_MASK), I2C_S_IAAS(value)))
#define I2C_BWR_S_IAAS(base, value) (BME_BFI8(&I2C_S_REG(base), ((uint8_t)(value) << I2C_S_IAAS_SHIFT), I2C_S_IAAS_SHIFT, I2C_S_IAAS_WIDTH))
/*@}*/

/*!
 * @name Register I2C_S, field TCF[7] (RO)
 *
 * Acknowledges a byte transfer; TCF is set on the completion of a byte
 * transfer. This bit is valid only during or immediately following a transfer to or from
 * the I2C module. TCF is cleared by reading the I2C data register in receive
 * mode or by writing to the I2C data register in transmit mode.In the buffer mode,
 * TCF is cleared automatically by internal reading or writing the data register
 * I2C_D, with no need waiting for manually reading/writing the I2C data
 * register in Rx/Tx mode.
 *
 * Values:
 * - 0b0 - Transfer in progress
 * - 0b1 - Transfer complete
 */
/*@{*/
/*! @brief Read current value of the I2C_S_TCF field. */
#define I2C_RD_S_TCF(base)   ((I2C_S_REG(base) & I2C_S_TCF_MASK) >> I2C_S_TCF_SHIFT)
#define I2C_BRD_S_TCF(base)  (BME_UBFX8(&I2C_S_REG(base), I2C_S_TCF_SHIFT, I2C_S_TCF_WIDTH))
/*@}*/

/*******************************************************************************
 * I2C_D - I2C Data I/O register
 ******************************************************************************/

/*!
 * @brief I2C_D - I2C Data I/O register (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire I2C_D register
 */
/*@{*/
#define I2C_RD_D(base)           (I2C_D_REG(base))
#define I2C_WR_D(base, value)    (I2C_D_REG(base) = (value))
#define I2C_RMW_D(base, mask, value) (I2C_WR_D(base, (I2C_RD_D(base) & ~(mask)) | (value)))
#define I2C_SET_D(base, value)   (BME_OR8(&I2C_D_REG(base), (uint8_t)(value)))
#define I2C_CLR_D(base, value)   (BME_AND8(&I2C_D_REG(base), (uint8_t)(~(value))))
#define I2C_TOG_D(base, value)   (BME_XOR8(&I2C_D_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * I2C_C2 - I2C Control Register 2
 ******************************************************************************/

/*!
 * @brief I2C_C2 - I2C Control Register 2 (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire I2C_C2 register
 */
/*@{*/
#define I2C_RD_C2(base)          (I2C_C2_REG(base))
#define I2C_WR_C2(base, value)   (I2C_C2_REG(base) = (value))
#define I2C_RMW_C2(base, mask, value) (I2C_WR_C2(base, (I2C_RD_C2(base) & ~(mask)) | (value)))
#define I2C_SET_C2(base, value)  (BME_OR8(&I2C_C2_REG(base), (uint8_t)(value)))
#define I2C_CLR_C2(base, value)  (BME_AND8(&I2C_C2_REG(base), (uint8_t)(~(value))))
#define I2C_TOG_C2(base, value)  (BME_XOR8(&I2C_C2_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual I2C_C2 bitfields
 */

/*!
 * @name Register I2C_C2, field AD[2:0] (RW)
 *
 * Contains the upper three bits of the slave address in the 10-bit address
 * scheme. This field is valid only while the ADEXT bit is set.
 */
/*@{*/
/*! @brief Read current value of the I2C_C2_AD field. */
#define I2C_RD_C2_AD(base)   ((I2C_C2_REG(base) & I2C_C2_AD_MASK) >> I2C_C2_AD_SHIFT)
#define I2C_BRD_C2_AD(base)  (BME_UBFX8(&I2C_C2_REG(base), I2C_C2_AD_SHIFT, I2C_C2_AD_WIDTH))

/*! @brief Set the AD field to a new value. */
#define I2C_WR_C2_AD(base, value) (I2C_RMW_C2(base, I2C_C2_AD_MASK, I2C_C2_AD(value)))
#define I2C_BWR_C2_AD(base, value) (BME_BFI8(&I2C_C2_REG(base), ((uint8_t)(value) << I2C_C2_AD_SHIFT), I2C_C2_AD_SHIFT, I2C_C2_AD_WIDTH))
/*@}*/

/*!
 * @name Register I2C_C2, field RMEN[3] (RW)
 *
 * This bit controls the slave address matching for addresses between the values
 * of the A1 and RA registers. When this bit is set, a slave address matching
 * occurs for any address greater than the value of the A1 register and less than
 * or equal to the value of the RA register.
 *
 * Values:
 * - 0b0 - Range mode disabled. No address matching occurs for an address within
 *     the range of values of the A1 and RA registers.
 * - 0b1 - Range mode enabled. Address matching occurs when a slave receives an
 *     address within the range of values of the A1 and RA registers.
 */
/*@{*/
/*! @brief Read current value of the I2C_C2_RMEN field. */
#define I2C_RD_C2_RMEN(base) ((I2C_C2_REG(base) & I2C_C2_RMEN_MASK) >> I2C_C2_RMEN_SHIFT)
#define I2C_BRD_C2_RMEN(base) (BME_UBFX8(&I2C_C2_REG(base), I2C_C2_RMEN_SHIFT, I2C_C2_RMEN_WIDTH))

/*! @brief Set the RMEN field to a new value. */
#define I2C_WR_C2_RMEN(base, value) (I2C_RMW_C2(base, I2C_C2_RMEN_MASK, I2C_C2_RMEN(value)))
#define I2C_BWR_C2_RMEN(base, value) (BME_BFI8(&I2C_C2_REG(base), ((uint8_t)(value) << I2C_C2_RMEN_SHIFT), I2C_C2_RMEN_SHIFT, I2C_C2_RMEN_WIDTH))
/*@}*/

/*!
 * @name Register I2C_C2, field SBRC[4] (RW)
 *
 * Enables independent slave mode baud rate at maximum frequency, which forces
 * clock stretching on SCL in very fast I2C modes. To a slave, an example of a
 * "very fast" mode is when the master transfers at 40 kbit/s but the slave can
 * capture the master's data at only 10 kbit/s.
 *
 * Values:
 * - 0b0 - The slave baud rate follows the master baud rate and clock stretching
 *     may occur
 * - 0b1 - Slave baud rate is independent of the master baud rate
 */
/*@{*/
/*! @brief Read current value of the I2C_C2_SBRC field. */
#define I2C_RD_C2_SBRC(base) ((I2C_C2_REG(base) & I2C_C2_SBRC_MASK) >> I2C_C2_SBRC_SHIFT)
#define I2C_BRD_C2_SBRC(base) (BME_UBFX8(&I2C_C2_REG(base), I2C_C2_SBRC_SHIFT, I2C_C2_SBRC_WIDTH))

/*! @brief Set the SBRC field to a new value. */
#define I2C_WR_C2_SBRC(base, value) (I2C_RMW_C2(base, I2C_C2_SBRC_MASK, I2C_C2_SBRC(value)))
#define I2C_BWR_C2_SBRC(base, value) (BME_BFI8(&I2C_C2_REG(base), ((uint8_t)(value) << I2C_C2_SBRC_SHIFT), I2C_C2_SBRC_SHIFT, I2C_C2_SBRC_WIDTH))
/*@}*/

/*!
 * @name Register I2C_C2, field HDRS[5] (RW)
 *
 * Controls the drive capability of the I2C pads.
 *
 * Values:
 * - 0b0 - Normal drive mode
 * - 0b1 - High drive mode
 */
/*@{*/
/*! @brief Read current value of the I2C_C2_HDRS field. */
#define I2C_RD_C2_HDRS(base) ((I2C_C2_REG(base) & I2C_C2_HDRS_MASK) >> I2C_C2_HDRS_SHIFT)
#define I2C_BRD_C2_HDRS(base) (BME_UBFX8(&I2C_C2_REG(base), I2C_C2_HDRS_SHIFT, I2C_C2_HDRS_WIDTH))

/*! @brief Set the HDRS field to a new value. */
#define I2C_WR_C2_HDRS(base, value) (I2C_RMW_C2(base, I2C_C2_HDRS_MASK, I2C_C2_HDRS(value)))
#define I2C_BWR_C2_HDRS(base, value) (BME_BFI8(&I2C_C2_REG(base), ((uint8_t)(value) << I2C_C2_HDRS_SHIFT), I2C_C2_HDRS_SHIFT, I2C_C2_HDRS_WIDTH))
/*@}*/

/*!
 * @name Register I2C_C2, field ADEXT[6] (RW)
 *
 * Controls the number of bits used for the slave address.
 *
 * Values:
 * - 0b0 - 7-bit address scheme
 * - 0b1 - 10-bit address scheme
 */
/*@{*/
/*! @brief Read current value of the I2C_C2_ADEXT field. */
#define I2C_RD_C2_ADEXT(base) ((I2C_C2_REG(base) & I2C_C2_ADEXT_MASK) >> I2C_C2_ADEXT_SHIFT)
#define I2C_BRD_C2_ADEXT(base) (BME_UBFX8(&I2C_C2_REG(base), I2C_C2_ADEXT_SHIFT, I2C_C2_ADEXT_WIDTH))

/*! @brief Set the ADEXT field to a new value. */
#define I2C_WR_C2_ADEXT(base, value) (I2C_RMW_C2(base, I2C_C2_ADEXT_MASK, I2C_C2_ADEXT(value)))
#define I2C_BWR_C2_ADEXT(base, value) (BME_BFI8(&I2C_C2_REG(base), ((uint8_t)(value) << I2C_C2_ADEXT_SHIFT), I2C_C2_ADEXT_SHIFT, I2C_C2_ADEXT_WIDTH))
/*@}*/

/*!
 * @name Register I2C_C2, field GCAEN[7] (RW)
 *
 * Enables general call address.
 *
 * Values:
 * - 0b0 - Disabled
 * - 0b1 - Enabled
 */
/*@{*/
/*! @brief Read current value of the I2C_C2_GCAEN field. */
#define I2C_RD_C2_GCAEN(base) ((I2C_C2_REG(base) & I2C_C2_GCAEN_MASK) >> I2C_C2_GCAEN_SHIFT)
#define I2C_BRD_C2_GCAEN(base) (BME_UBFX8(&I2C_C2_REG(base), I2C_C2_GCAEN_SHIFT, I2C_C2_GCAEN_WIDTH))

/*! @brief Set the GCAEN field to a new value. */
#define I2C_WR_C2_GCAEN(base, value) (I2C_RMW_C2(base, I2C_C2_GCAEN_MASK, I2C_C2_GCAEN(value)))
#define I2C_BWR_C2_GCAEN(base, value) (BME_BFI8(&I2C_C2_REG(base), ((uint8_t)(value) << I2C_C2_GCAEN_SHIFT), I2C_C2_GCAEN_SHIFT, I2C_C2_GCAEN_WIDTH))
/*@}*/

/*******************************************************************************
 * I2C_FLT - I2C Programmable Input Glitch Filter Register
 ******************************************************************************/

/*!
 * @brief I2C_FLT - I2C Programmable Input Glitch Filter Register (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire I2C_FLT register
 */
/*@{*/
#define I2C_RD_FLT(base)         (I2C_FLT_REG(base))
#define I2C_WR_FLT(base, value)  (I2C_FLT_REG(base) = (value))
#define I2C_RMW_FLT(base, mask, value) (I2C_WR_FLT(base, (I2C_RD_FLT(base) & ~(mask)) | (value)))
#define I2C_SET_FLT(base, value) (BME_OR8(&I2C_FLT_REG(base), (uint8_t)(value)))
#define I2C_CLR_FLT(base, value) (BME_AND8(&I2C_FLT_REG(base), (uint8_t)(~(value))))
#define I2C_TOG_FLT(base, value) (BME_XOR8(&I2C_FLT_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual I2C_FLT bitfields
 */

/*!
 * @name Register I2C_FLT, field FLT[3:0] (RW)
 *
 * Controls the width of the glitch, in terms of I2C module clock cycles, that
 * the filter must absorb. For any glitch whose size is less than or equal to this
 * width setting, the filter does not allow the glitch to pass.
 *
 * Values:
 * - 0b0000 - No filter/bypass
 */
/*@{*/
/*! @brief Read current value of the I2C_FLT_FLT field. */
#define I2C_RD_FLT_FLT(base) ((I2C_FLT_REG(base) & I2C_FLT_FLT_MASK) >> I2C_FLT_FLT_SHIFT)
#define I2C_BRD_FLT_FLT(base) (BME_UBFX8(&I2C_FLT_REG(base), I2C_FLT_FLT_SHIFT, I2C_FLT_FLT_WIDTH))

/*! @brief Set the FLT field to a new value. */
#define I2C_WR_FLT_FLT(base, value) (I2C_RMW_FLT(base, (I2C_FLT_FLT_MASK | I2C_FLT_STARTF_MASK | I2C_FLT_STOPF_MASK), I2C_FLT_FLT(value)))
#define I2C_BWR_FLT_FLT(base, value) (BME_BFI8(&I2C_FLT_REG(base), ((uint8_t)(value) << I2C_FLT_FLT_SHIFT), I2C_FLT_FLT_SHIFT, I2C_FLT_FLT_WIDTH))
/*@}*/

/*!
 * @name Register I2C_FLT, field STARTF[4] (W1C)
 *
 * Hardware sets this bit when the I2C bus's start status is detected. The
 * STARTF bit must be cleared by writing 1 to it.
 *
 * Values:
 * - 0b0 - No start happens on I2C bus
 * - 0b1 - Start detected on I2C bus
 */
/*@{*/
/*! @brief Read current value of the I2C_FLT_STARTF field. */
#define I2C_RD_FLT_STARTF(base) ((I2C_FLT_REG(base) & I2C_FLT_STARTF_MASK) >> I2C_FLT_STARTF_SHIFT)
#define I2C_BRD_FLT_STARTF(base) (BME_UBFX8(&I2C_FLT_REG(base), I2C_FLT_STARTF_SHIFT, I2C_FLT_STARTF_WIDTH))

/*! @brief Set the STARTF field to a new value. */
#define I2C_WR_FLT_STARTF(base, value) (I2C_RMW_FLT(base, (I2C_FLT_STARTF_MASK | I2C_FLT_STOPF_MASK), I2C_FLT_STARTF(value)))
#define I2C_BWR_FLT_STARTF(base, value) (BME_BFI8(&I2C_FLT_REG(base), ((uint8_t)(value) << I2C_FLT_STARTF_SHIFT), I2C_FLT_STARTF_SHIFT, I2C_FLT_STARTF_WIDTH))
/*@}*/

/*!
 * @name Register I2C_FLT, field SSIE[5] (RW)
 *
 * This bit enables the interrupt for I2C bus stop or start detection. To clear
 * the I2C bus stop or start detection interrupt: In the interrupt service
 * routine, first clear the STOPF or STARTF bit by writing 1 to it, and then clear the
 * IICIF bit in the status register. If this sequence is reversed, the IICIF bit
 * is asserted again.
 *
 * Values:
 * - 0b0 - Stop or start detection interrupt is disabled
 * - 0b1 - Stop or start detection interrupt is enabled
 */
/*@{*/
/*! @brief Read current value of the I2C_FLT_SSIE field. */
#define I2C_RD_FLT_SSIE(base) ((I2C_FLT_REG(base) & I2C_FLT_SSIE_MASK) >> I2C_FLT_SSIE_SHIFT)
#define I2C_BRD_FLT_SSIE(base) (BME_UBFX8(&I2C_FLT_REG(base), I2C_FLT_SSIE_SHIFT, I2C_FLT_SSIE_WIDTH))

/*! @brief Set the SSIE field to a new value. */
#define I2C_WR_FLT_SSIE(base, value) (I2C_RMW_FLT(base, (I2C_FLT_SSIE_MASK | I2C_FLT_STARTF_MASK | I2C_FLT_STOPF_MASK), I2C_FLT_SSIE(value)))
#define I2C_BWR_FLT_SSIE(base, value) (BME_BFI8(&I2C_FLT_REG(base), ((uint8_t)(value) << I2C_FLT_SSIE_SHIFT), I2C_FLT_SSIE_SHIFT, I2C_FLT_SSIE_WIDTH))
/*@}*/

/*!
 * @name Register I2C_FLT, field STOPF[6] (W1C)
 *
 * Hardware sets this bit when the I2C bus's stop status is detected. The STOPF
 * bit must be cleared by writing 1 to it.
 *
 * Values:
 * - 0b0 - No stop happens on I2C bus
 * - 0b1 - Stop detected on I2C bus
 */
/*@{*/
/*! @brief Read current value of the I2C_FLT_STOPF field. */
#define I2C_RD_FLT_STOPF(base) ((I2C_FLT_REG(base) & I2C_FLT_STOPF_MASK) >> I2C_FLT_STOPF_SHIFT)
#define I2C_BRD_FLT_STOPF(base) (BME_UBFX8(&I2C_FLT_REG(base), I2C_FLT_STOPF_SHIFT, I2C_FLT_STOPF_WIDTH))

/*! @brief Set the STOPF field to a new value. */
#define I2C_WR_FLT_STOPF(base, value) (I2C_RMW_FLT(base, (I2C_FLT_STOPF_MASK | I2C_FLT_STARTF_MASK), I2C_FLT_STOPF(value)))
#define I2C_BWR_FLT_STOPF(base, value) (BME_BFI8(&I2C_FLT_REG(base), ((uint8_t)(value) << I2C_FLT_STOPF_SHIFT), I2C_FLT_STOPF_SHIFT, I2C_FLT_STOPF_WIDTH))
/*@}*/

/*!
 * @name Register I2C_FLT, field SHEN[7] (RW)
 *
 * Set this bit to hold off entry to stop mode when any data transmission or
 * reception is occurring. The following scenario explains the holdoff
 * functionality: The I2C module is configured for a basic transfer, and the SHEN bit is set
 * to 1. A transfer begins. The MCU signals the I2C module to enter stop mode. The
 * byte currently being transferred, including both address and data, completes
 * its transfer. The I2C slave or master acknowledges that the in-transfer byte
 * completed its transfer and acknowledges the request to enter stop mode. After
 * receiving the I2C module's acknowledgment of the request to enter stop mode,
 * the MCU determines whether to shut off the I2C module's clock. If the SHEN bit
 * is set to 1 and the I2C module is in an idle or disabled state when the MCU
 * signals to enter stop mode, the module immediately acknowledges the request to
 * enter stop mode. If SHEN is cleared to 0 and the overall data transmission or
 * reception that was suspended by stop mode entry was incomplete: To resume the
 * overall transmission or reception after the MCU exits stop mode, software must
 * reinitialize the transfer by resending the address of the slave. If the I2C
 * Control Register 1's IICIE bit was set to 1 before the MCU entered stop mode,
 * system software will receive the interrupt triggered by the I2C Status Register's
 * TCF bit after the MCU wakes from the stop mode.
 *
 * Values:
 * - 0b0 - Stop holdoff is disabled. The MCU's entry to stop mode is not gated.
 * - 0b1 - Stop holdoff is enabled.
 */
/*@{*/
/*! @brief Read current value of the I2C_FLT_SHEN field. */
#define I2C_RD_FLT_SHEN(base) ((I2C_FLT_REG(base) & I2C_FLT_SHEN_MASK) >> I2C_FLT_SHEN_SHIFT)
#define I2C_BRD_FLT_SHEN(base) (BME_UBFX8(&I2C_FLT_REG(base), I2C_FLT_SHEN_SHIFT, I2C_FLT_SHEN_WIDTH))

/*! @brief Set the SHEN field to a new value. */
#define I2C_WR_FLT_SHEN(base, value) (I2C_RMW_FLT(base, (I2C_FLT_SHEN_MASK | I2C_FLT_STARTF_MASK | I2C_FLT_STOPF_MASK), I2C_FLT_SHEN(value)))
#define I2C_BWR_FLT_SHEN(base, value) (BME_BFI8(&I2C_FLT_REG(base), ((uint8_t)(value) << I2C_FLT_SHEN_SHIFT), I2C_FLT_SHEN_SHIFT, I2C_FLT_SHEN_WIDTH))
/*@}*/

/*******************************************************************************
 * I2C_RA - I2C Range Address register
 ******************************************************************************/

/*!
 * @brief I2C_RA - I2C Range Address register (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire I2C_RA register
 */
/*@{*/
#define I2C_RD_RA(base)          (I2C_RA_REG(base))
#define I2C_WR_RA(base, value)   (I2C_RA_REG(base) = (value))
#define I2C_RMW_RA(base, mask, value) (I2C_WR_RA(base, (I2C_RD_RA(base) & ~(mask)) | (value)))
#define I2C_SET_RA(base, value)  (BME_OR8(&I2C_RA_REG(base), (uint8_t)(value)))
#define I2C_CLR_RA(base, value)  (BME_AND8(&I2C_RA_REG(base), (uint8_t)(~(value))))
#define I2C_TOG_RA(base, value)  (BME_XOR8(&I2C_RA_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual I2C_RA bitfields
 */

/*!
 * @name Register I2C_RA, field RAD[7:1] (RW)
 *
 * This field contains the slave address to be used by the I2C module. The field
 * is used in the 7-bit address scheme. If I2C_C2[RMEN] is set to 1, any nonzero
 * value write enables this register. This register value can be considered as a
 * maximum boundary in the range matching mode.
 */
/*@{*/
/*! @brief Read current value of the I2C_RA_RAD field. */
#define I2C_RD_RA_RAD(base)  ((I2C_RA_REG(base) & I2C_RA_RAD_MASK) >> I2C_RA_RAD_SHIFT)
#define I2C_BRD_RA_RAD(base) (BME_UBFX8(&I2C_RA_REG(base), I2C_RA_RAD_SHIFT, I2C_RA_RAD_WIDTH))

/*! @brief Set the RAD field to a new value. */
#define I2C_WR_RA_RAD(base, value) (I2C_RMW_RA(base, I2C_RA_RAD_MASK, I2C_RA_RAD(value)))
#define I2C_BWR_RA_RAD(base, value) (BME_BFI8(&I2C_RA_REG(base), ((uint8_t)(value) << I2C_RA_RAD_SHIFT), I2C_RA_RAD_SHIFT, I2C_RA_RAD_WIDTH))
/*@}*/

/*******************************************************************************
 * I2C_SMB - I2C SMBus Control and Status register
 ******************************************************************************/

/*!
 * @brief I2C_SMB - I2C SMBus Control and Status register (RW)
 *
 * Reset value: 0x00U
 *
 * When the SCL and SDA signals are held high for a length of time greater than
 * the high timeout period, the SHTF1 flag sets. Before reaching this threshold,
 * while the system is detecting how long these signals are being held high, a
 * master assumes that the bus is free. However, the SHTF1 bit is set to 1 in the
 * bus transmission process with the idle bus state. When the TCKSEL bit is set,
 * there is no need to monitor the SHTF1 bit because the bus speed is too high to
 * match the protocol of SMBus.
 */
/*!
 * @name Constants and macros for entire I2C_SMB register
 */
/*@{*/
#define I2C_RD_SMB(base)         (I2C_SMB_REG(base))
#define I2C_WR_SMB(base, value)  (I2C_SMB_REG(base) = (value))
#define I2C_RMW_SMB(base, mask, value) (I2C_WR_SMB(base, (I2C_RD_SMB(base) & ~(mask)) | (value)))
#define I2C_SET_SMB(base, value) (BME_OR8(&I2C_SMB_REG(base), (uint8_t)(value)))
#define I2C_CLR_SMB(base, value) (BME_AND8(&I2C_SMB_REG(base), (uint8_t)(~(value))))
#define I2C_TOG_SMB(base, value) (BME_XOR8(&I2C_SMB_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual I2C_SMB bitfields
 */

/*!
 * @name Register I2C_SMB, field SHTF2IE[0] (RW)
 *
 * Enables SCL high and SDA low timeout interrupt.
 *
 * Values:
 * - 0b0 - SHTF2 interrupt is disabled
 * - 0b1 - SHTF2 interrupt is enabled
 */
/*@{*/
/*! @brief Read current value of the I2C_SMB_SHTF2IE field. */
#define I2C_RD_SMB_SHTF2IE(base) ((I2C_SMB_REG(base) & I2C_SMB_SHTF2IE_MASK) >> I2C_SMB_SHTF2IE_SHIFT)
#define I2C_BRD_SMB_SHTF2IE(base) (BME_UBFX8(&I2C_SMB_REG(base), I2C_SMB_SHTF2IE_SHIFT, I2C_SMB_SHTF2IE_WIDTH))

/*! @brief Set the SHTF2IE field to a new value. */
#define I2C_WR_SMB_SHTF2IE(base, value) (I2C_RMW_SMB(base, (I2C_SMB_SHTF2IE_MASK | I2C_SMB_SHTF2_MASK | I2C_SMB_SLTF_MASK), I2C_SMB_SHTF2IE(value)))
#define I2C_BWR_SMB_SHTF2IE(base, value) (BME_BFI8(&I2C_SMB_REG(base), ((uint8_t)(value) << I2C_SMB_SHTF2IE_SHIFT), I2C_SMB_SHTF2IE_SHIFT, I2C_SMB_SHTF2IE_WIDTH))
/*@}*/

/*!
 * @name Register I2C_SMB, field SHTF2[1] (W1C)
 *
 * This bit sets when SCL is held high and SDA is held low more than clock *
 * LoValue / 512. Software clears this bit by writing 1 to it.
 *
 * Values:
 * - 0b0 - No SCL high and SDA low timeout occurs
 * - 0b1 - SCL high and SDA low timeout occurs
 */
/*@{*/
/*! @brief Read current value of the I2C_SMB_SHTF2 field. */
#define I2C_RD_SMB_SHTF2(base) ((I2C_SMB_REG(base) & I2C_SMB_SHTF2_MASK) >> I2C_SMB_SHTF2_SHIFT)
#define I2C_BRD_SMB_SHTF2(base) (BME_UBFX8(&I2C_SMB_REG(base), I2C_SMB_SHTF2_SHIFT, I2C_SMB_SHTF2_WIDTH))

/*! @brief Set the SHTF2 field to a new value. */
#define I2C_WR_SMB_SHTF2(base, value) (I2C_RMW_SMB(base, (I2C_SMB_SHTF2_MASK | I2C_SMB_SLTF_MASK), I2C_SMB_SHTF2(value)))
#define I2C_BWR_SMB_SHTF2(base, value) (BME_BFI8(&I2C_SMB_REG(base), ((uint8_t)(value) << I2C_SMB_SHTF2_SHIFT), I2C_SMB_SHTF2_SHIFT, I2C_SMB_SHTF2_WIDTH))
/*@}*/

/*!
 * @name Register I2C_SMB, field SHTF1[2] (RO)
 *
 * This read-only bit sets when SCL and SDA are held high more than clock *
 * LoValue / 512, which indicates the bus is free. This bit is cleared automatically.
 *
 * Values:
 * - 0b0 - No SCL high and SDA high timeout occurs
 * - 0b1 - SCL high and SDA high timeout occurs
 */
/*@{*/
/*! @brief Read current value of the I2C_SMB_SHTF1 field. */
#define I2C_RD_SMB_SHTF1(base) ((I2C_SMB_REG(base) & I2C_SMB_SHTF1_MASK) >> I2C_SMB_SHTF1_SHIFT)
#define I2C_BRD_SMB_SHTF1(base) (BME_UBFX8(&I2C_SMB_REG(base), I2C_SMB_SHTF1_SHIFT, I2C_SMB_SHTF1_WIDTH))
/*@}*/

/*!
 * @name Register I2C_SMB, field SLTF[3] (W1C)
 *
 * This bit is set when the SLT register (consisting of the SLTH and SLTL
 * registers) is loaded with a non-zero value (LoValue) and an SCL low timeout occurs.
 * Software clears this bit by writing a logic 1 to it. The low timeout function
 * is disabled when the SLT register's value is 0.
 *
 * Values:
 * - 0b0 - No low timeout occurs
 * - 0b1 - Low timeout occurs
 */
/*@{*/
/*! @brief Read current value of the I2C_SMB_SLTF field. */
#define I2C_RD_SMB_SLTF(base) ((I2C_SMB_REG(base) & I2C_SMB_SLTF_MASK) >> I2C_SMB_SLTF_SHIFT)
#define I2C_BRD_SMB_SLTF(base) (BME_UBFX8(&I2C_SMB_REG(base), I2C_SMB_SLTF_SHIFT, I2C_SMB_SLTF_WIDTH))

/*! @brief Set the SLTF field to a new value. */
#define I2C_WR_SMB_SLTF(base, value) (I2C_RMW_SMB(base, (I2C_SMB_SLTF_MASK | I2C_SMB_SHTF2_MASK), I2C_SMB_SLTF(value)))
#define I2C_BWR_SMB_SLTF(base, value) (BME_BFI8(&I2C_SMB_REG(base), ((uint8_t)(value) << I2C_SMB_SLTF_SHIFT), I2C_SMB_SLTF_SHIFT, I2C_SMB_SLTF_WIDTH))
/*@}*/

/*!
 * @name Register I2C_SMB, field TCKSEL[4] (RW)
 *
 * Selects the clock source of the timeout counter.
 *
 * Values:
 * - 0b0 - Timeout counter counts at the frequency of the I2C module clock / 64
 * - 0b1 - Timeout counter counts at the frequency of the I2C module clock
 */
/*@{*/
/*! @brief Read current value of the I2C_SMB_TCKSEL field. */
#define I2C_RD_SMB_TCKSEL(base) ((I2C_SMB_REG(base) & I2C_SMB_TCKSEL_MASK) >> I2C_SMB_TCKSEL_SHIFT)
#define I2C_BRD_SMB_TCKSEL(base) (BME_UBFX8(&I2C_SMB_REG(base), I2C_SMB_TCKSEL_SHIFT, I2C_SMB_TCKSEL_WIDTH))

/*! @brief Set the TCKSEL field to a new value. */
#define I2C_WR_SMB_TCKSEL(base, value) (I2C_RMW_SMB(base, (I2C_SMB_TCKSEL_MASK | I2C_SMB_SHTF2_MASK | I2C_SMB_SLTF_MASK), I2C_SMB_TCKSEL(value)))
#define I2C_BWR_SMB_TCKSEL(base, value) (BME_BFI8(&I2C_SMB_REG(base), ((uint8_t)(value) << I2C_SMB_TCKSEL_SHIFT), I2C_SMB_TCKSEL_SHIFT, I2C_SMB_TCKSEL_WIDTH))
/*@}*/

/*!
 * @name Register I2C_SMB, field SIICAEN[5] (RW)
 *
 * Enables or disables SMBus device default address.
 *
 * Values:
 * - 0b0 - I2C address register 2 matching is disabled
 * - 0b1 - I2C address register 2 matching is enabled
 */
/*@{*/
/*! @brief Read current value of the I2C_SMB_SIICAEN field. */
#define I2C_RD_SMB_SIICAEN(base) ((I2C_SMB_REG(base) & I2C_SMB_SIICAEN_MASK) >> I2C_SMB_SIICAEN_SHIFT)
#define I2C_BRD_SMB_SIICAEN(base) (BME_UBFX8(&I2C_SMB_REG(base), I2C_SMB_SIICAEN_SHIFT, I2C_SMB_SIICAEN_WIDTH))

/*! @brief Set the SIICAEN field to a new value. */
#define I2C_WR_SMB_SIICAEN(base, value) (I2C_RMW_SMB(base, (I2C_SMB_SIICAEN_MASK | I2C_SMB_SHTF2_MASK | I2C_SMB_SLTF_MASK), I2C_SMB_SIICAEN(value)))
#define I2C_BWR_SMB_SIICAEN(base, value) (BME_BFI8(&I2C_SMB_REG(base), ((uint8_t)(value) << I2C_SMB_SIICAEN_SHIFT), I2C_SMB_SIICAEN_SHIFT, I2C_SMB_SIICAEN_WIDTH))
/*@}*/

/*!
 * @name Register I2C_SMB, field ALERTEN[6] (RW)
 *
 * Enables or disables SMBus alert response address matching. After the host
 * responds to a device that used the alert response address, you must use software
 * to put the device's address on the bus. The alert protocol is described in the
 * SMBus specification.
 *
 * Values:
 * - 0b0 - SMBus alert response address matching is disabled
 * - 0b1 - SMBus alert response address matching is enabled
 */
/*@{*/
/*! @brief Read current value of the I2C_SMB_ALERTEN field. */
#define I2C_RD_SMB_ALERTEN(base) ((I2C_SMB_REG(base) & I2C_SMB_ALERTEN_MASK) >> I2C_SMB_ALERTEN_SHIFT)
#define I2C_BRD_SMB_ALERTEN(base) (BME_UBFX8(&I2C_SMB_REG(base), I2C_SMB_ALERTEN_SHIFT, I2C_SMB_ALERTEN_WIDTH))

/*! @brief Set the ALERTEN field to a new value. */
#define I2C_WR_SMB_ALERTEN(base, value) (I2C_RMW_SMB(base, (I2C_SMB_ALERTEN_MASK | I2C_SMB_SHTF2_MASK | I2C_SMB_SLTF_MASK), I2C_SMB_ALERTEN(value)))
#define I2C_BWR_SMB_ALERTEN(base, value) (BME_BFI8(&I2C_SMB_REG(base), ((uint8_t)(value) << I2C_SMB_ALERTEN_SHIFT), I2C_SMB_ALERTEN_SHIFT, I2C_SMB_ALERTEN_WIDTH))
/*@}*/

/*!
 * @name Register I2C_SMB, field FACK[7] (RW)
 *
 * For SMBus packet error checking, the CPU must be able to issue an ACK or NACK
 * according to the result of receiving data byte.
 *
 * Values:
 * - 0b0 - An ACK or NACK is sent on the following receiving data byte
 * - 0b1 - Writing 0 to TXAK after receiving a data byte generates an ACK.
 *     Writing 1 to TXAK after receiving a data byte generates a NACK.
 */
/*@{*/
/*! @brief Read current value of the I2C_SMB_FACK field. */
#define I2C_RD_SMB_FACK(base) ((I2C_SMB_REG(base) & I2C_SMB_FACK_MASK) >> I2C_SMB_FACK_SHIFT)
#define I2C_BRD_SMB_FACK(base) (BME_UBFX8(&I2C_SMB_REG(base), I2C_SMB_FACK_SHIFT, I2C_SMB_FACK_WIDTH))

/*! @brief Set the FACK field to a new value. */
#define I2C_WR_SMB_FACK(base, value) (I2C_RMW_SMB(base, (I2C_SMB_FACK_MASK | I2C_SMB_SHTF2_MASK | I2C_SMB_SLTF_MASK), I2C_SMB_FACK(value)))
#define I2C_BWR_SMB_FACK(base, value) (BME_BFI8(&I2C_SMB_REG(base), ((uint8_t)(value) << I2C_SMB_FACK_SHIFT), I2C_SMB_FACK_SHIFT, I2C_SMB_FACK_WIDTH))
/*@}*/

/*******************************************************************************
 * I2C_A2 - I2C Address Register 2
 ******************************************************************************/

/*!
 * @brief I2C_A2 - I2C Address Register 2 (RW)
 *
 * Reset value: 0xC2U
 */
/*!
 * @name Constants and macros for entire I2C_A2 register
 */
/*@{*/
#define I2C_RD_A2(base)          (I2C_A2_REG(base))
#define I2C_WR_A2(base, value)   (I2C_A2_REG(base) = (value))
#define I2C_RMW_A2(base, mask, value) (I2C_WR_A2(base, (I2C_RD_A2(base) & ~(mask)) | (value)))
#define I2C_SET_A2(base, value)  (BME_OR8(&I2C_A2_REG(base), (uint8_t)(value)))
#define I2C_CLR_A2(base, value)  (BME_AND8(&I2C_A2_REG(base), (uint8_t)(~(value))))
#define I2C_TOG_A2(base, value)  (BME_XOR8(&I2C_A2_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual I2C_A2 bitfields
 */

/*!
 * @name Register I2C_A2, field SAD[7:1] (RW)
 *
 * Contains the slave address used by the SMBus. This field is used on the
 * device default address or other related addresses.
 */
/*@{*/
/*! @brief Read current value of the I2C_A2_SAD field. */
#define I2C_RD_A2_SAD(base)  ((I2C_A2_REG(base) & I2C_A2_SAD_MASK) >> I2C_A2_SAD_SHIFT)
#define I2C_BRD_A2_SAD(base) (BME_UBFX8(&I2C_A2_REG(base), I2C_A2_SAD_SHIFT, I2C_A2_SAD_WIDTH))

/*! @brief Set the SAD field to a new value. */
#define I2C_WR_A2_SAD(base, value) (I2C_RMW_A2(base, I2C_A2_SAD_MASK, I2C_A2_SAD(value)))
#define I2C_BWR_A2_SAD(base, value) (BME_BFI8(&I2C_A2_REG(base), ((uint8_t)(value) << I2C_A2_SAD_SHIFT), I2C_A2_SAD_SHIFT, I2C_A2_SAD_WIDTH))
/*@}*/

/*******************************************************************************
 * I2C_SLTH - I2C SCL Low Timeout Register High
 ******************************************************************************/

/*!
 * @brief I2C_SLTH - I2C SCL Low Timeout Register High (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire I2C_SLTH register
 */
/*@{*/
#define I2C_RD_SLTH(base)        (I2C_SLTH_REG(base))
#define I2C_WR_SLTH(base, value) (I2C_SLTH_REG(base) = (value))
#define I2C_RMW_SLTH(base, mask, value) (I2C_WR_SLTH(base, (I2C_RD_SLTH(base) & ~(mask)) | (value)))
#define I2C_SET_SLTH(base, value) (BME_OR8(&I2C_SLTH_REG(base), (uint8_t)(value)))
#define I2C_CLR_SLTH(base, value) (BME_AND8(&I2C_SLTH_REG(base), (uint8_t)(~(value))))
#define I2C_TOG_SLTH(base, value) (BME_XOR8(&I2C_SLTH_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * I2C_SLTL - I2C SCL Low Timeout Register Low
 ******************************************************************************/

/*!
 * @brief I2C_SLTL - I2C SCL Low Timeout Register Low (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire I2C_SLTL register
 */
/*@{*/
#define I2C_RD_SLTL(base)        (I2C_SLTL_REG(base))
#define I2C_WR_SLTL(base, value) (I2C_SLTL_REG(base) = (value))
#define I2C_RMW_SLTL(base, mask, value) (I2C_WR_SLTL(base, (I2C_RD_SLTL(base) & ~(mask)) | (value)))
#define I2C_SET_SLTL(base, value) (BME_OR8(&I2C_SLTL_REG(base), (uint8_t)(value)))
#define I2C_CLR_SLTL(base, value) (BME_AND8(&I2C_SLTL_REG(base), (uint8_t)(~(value))))
#define I2C_TOG_SLTL(base, value) (BME_XOR8(&I2C_SLTL_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * I2C_S2 - I2C Status register 2
 ******************************************************************************/

/*!
 * @brief I2C_S2 - I2C Status register 2 (RW)
 *
 * Reset value: 0x01U
 */
/*!
 * @name Constants and macros for entire I2C_S2 register
 */
/*@{*/
#define I2C_RD_S2(base)          (I2C_S2_REG(base))
#define I2C_WR_S2(base, value)   (I2C_S2_REG(base) = (value))
#define I2C_RMW_S2(base, mask, value) (I2C_WR_S2(base, (I2C_RD_S2(base) & ~(mask)) | (value)))
#define I2C_SET_S2(base, value)  (BME_OR8(&I2C_S2_REG(base), (uint8_t)(value)))
#define I2C_CLR_S2(base, value)  (BME_AND8(&I2C_S2_REG(base), (uint8_t)(~(value))))
#define I2C_TOG_S2(base, value)  (BME_XOR8(&I2C_S2_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual I2C_S2 bitfields
 */

/*!
 * @name Register I2C_S2, field EMPTY[0] (RO)
 *
 * Indicates if the Tx or Rx buffer is empty.
 *
 * Values:
 * - 0b0 - Tx or Rx buffer is not empty and cannot be written to, that is new
 *     data cannot be loaded into the buffer.
 * - 0b1 - Tx or Rx buffer is empty and can be written to, that is new data can
 *     be loaded into the buffer.
 */
/*@{*/
/*! @brief Read current value of the I2C_S2_EMPTY field. */
#define I2C_RD_S2_EMPTY(base) ((I2C_S2_REG(base) & I2C_S2_EMPTY_MASK) >> I2C_S2_EMPTY_SHIFT)
#define I2C_BRD_S2_EMPTY(base) (BME_UBFX8(&I2C_S2_REG(base), I2C_S2_EMPTY_SHIFT, I2C_S2_EMPTY_WIDTH))
/*@}*/

/*!
 * @name Register I2C_S2, field ERROR[1] (W1C)
 *
 * Indicates if there are read or write errors with the Tx and Rx buffers.
 *
 * Values:
 * - 0b0 - The buffer is not full and all write/read operations have no errors.
 * - 0b1 - There are 3 or more write/read errors during the data transfer phase
 *     (when the Empty flag is not set and the buffer is busy).
 */
/*@{*/
/*! @brief Read current value of the I2C_S2_ERROR field. */
#define I2C_RD_S2_ERROR(base) ((I2C_S2_REG(base) & I2C_S2_ERROR_MASK) >> I2C_S2_ERROR_SHIFT)
#define I2C_BRD_S2_ERROR(base) (BME_UBFX8(&I2C_S2_REG(base), I2C_S2_ERROR_SHIFT, I2C_S2_ERROR_WIDTH))

/*! @brief Set the ERROR field to a new value. */
#define I2C_WR_S2_ERROR(base, value) (I2C_RMW_S2(base, I2C_S2_ERROR_MASK, I2C_S2_ERROR(value)))
#define I2C_BWR_S2_ERROR(base, value) (BME_BFI8(&I2C_S2_REG(base), ((uint8_t)(value) << I2C_S2_ERROR_SHIFT), I2C_S2_ERROR_SHIFT, I2C_S2_ERROR_WIDTH))
/*@}*/

/*
 * MKM34Z7 LCD
 *
 * Segment Liquid Crystal Display
 *
 * Registers defined in this header file:
 * - LCD_GCR - LCD General Control Register
 * - LCD_AR - LCD Auxiliary Register
 * - LCD_FDCR - LCD Fault Detect Control Register
 * - LCD_FDSR - LCD Fault Detect Status Register
 * - LCD_PEN - LCD Pin Enable register
 * - LCD_BPEN - LCD Back Plane Enable register
 * - LCD_WF - LCD Waveform register
 * - LCD_WF8B - LCD Waveform Register 0.
 */

#define LCD_INSTANCE_COUNT (1U) /*!< Number of instances of the LCD module. */
#define LCD_IDX (0U) /*!< Instance number for LCD. */

/*******************************************************************************
 * LCD_GCR - LCD General Control Register
 ******************************************************************************/

/*!
 * @brief LCD_GCR - LCD General Control Register (RW)
 *
 * Reset value: 0x08300003U
 *
 * Write: LCDEN anytime. Do not change SOURCE, LCLK, or DUTY while LCDEN = 1.
 * For proper operation, do not modify VSUPPLY while the LCDEN bit is asserted.
 * VSUPPLY must also be configured according to the external hardware power supply
 * configuration. The reset value of this register depends on the reset type: POR
 * -- 0x0830_0003
 */
/*!
 * @name Constants and macros for entire LCD_GCR register
 */
/*@{*/
#define LCD_RD_GCR(base)         (LCD_GCR_REG(base))
#define LCD_WR_GCR(base, value)  (LCD_GCR_REG(base) = (value))
#define LCD_RMW_GCR(base, mask, value) (LCD_WR_GCR(base, (LCD_RD_GCR(base) & ~(mask)) | (value)))
#define LCD_SET_GCR(base, value) (BME_OR32(&LCD_GCR_REG(base), (uint32_t)(value)))
#define LCD_CLR_GCR(base, value) (BME_AND32(&LCD_GCR_REG(base), (uint32_t)(~(value))))
#define LCD_TOG_GCR(base, value) (BME_XOR32(&LCD_GCR_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual LCD_GCR bitfields
 */

/*!
 * @name Register LCD_GCR, field DUTY[2:0] (RW)
 *
 * Selects the duty cycle of the LCD controller driver.
 *
 * Values:
 * - 0b000 - Use 1 BP (1/1 duty cycle).
 * - 0b001 - Use 2 BP (1/2 duty cycle).
 * - 0b010 - Use 3 BP (1/3 duty cycle).
 * - 0b011 - Use 4 BP (1/4 duty cycle). (Default)
 * - 0b100 - Use 5 BP (1/5 duty cycle).
 * - 0b101 - Use 6 BP (1/6 duty cycle).
 * - 0b110 - Use 7 BP (1/7 duty cycle).
 * - 0b111 - Use 8 BP (1/8 duty cycle).
 */
/*@{*/
/*! @brief Read current value of the LCD_GCR_DUTY field. */
#define LCD_RD_GCR_DUTY(base) ((LCD_GCR_REG(base) & LCD_GCR_DUTY_MASK) >> LCD_GCR_DUTY_SHIFT)
#define LCD_BRD_GCR_DUTY(base) (BME_UBFX32(&LCD_GCR_REG(base), LCD_GCR_DUTY_SHIFT, LCD_GCR_DUTY_WIDTH))

/*! @brief Set the DUTY field to a new value. */
#define LCD_WR_GCR_DUTY(base, value) (LCD_RMW_GCR(base, LCD_GCR_DUTY_MASK, LCD_GCR_DUTY(value)))
#define LCD_BWR_GCR_DUTY(base, value) (BME_BFI32(&LCD_GCR_REG(base), ((uint32_t)(value) << LCD_GCR_DUTY_SHIFT), LCD_GCR_DUTY_SHIFT, LCD_GCR_DUTY_WIDTH))
/*@}*/

/*!
 * @name Register LCD_GCR, field LCLK[5:3] (RW)
 *
 * Used as a clock divider to generate the SLCD frame frequency. LCD controller
 * duty cycle configuration is used to determine the LCD controller frame
 * frequency. LCD controller frame frequency calculations are provided in SLCD base
 * clock and frame frequency . LCD controller frame frequency = LCD clock/((DUTY + 1)
 * * 8 * (4 + LCLK[2:0]) * Y) where: 30 < LCD clock < 39.063 kHz Y = 2, 2, 3, 3,
 * 4, 5, 8, 16 chosen by module duty cycle configuration
 */
/*@{*/
/*! @brief Read current value of the LCD_GCR_LCLK field. */
#define LCD_RD_GCR_LCLK(base) ((LCD_GCR_REG(base) & LCD_GCR_LCLK_MASK) >> LCD_GCR_LCLK_SHIFT)
#define LCD_BRD_GCR_LCLK(base) (BME_UBFX32(&LCD_GCR_REG(base), LCD_GCR_LCLK_SHIFT, LCD_GCR_LCLK_WIDTH))

/*! @brief Set the LCLK field to a new value. */
#define LCD_WR_GCR_LCLK(base, value) (LCD_RMW_GCR(base, LCD_GCR_LCLK_MASK, LCD_GCR_LCLK(value)))
#define LCD_BWR_GCR_LCLK(base, value) (BME_BFI32(&LCD_GCR_REG(base), ((uint32_t)(value) << LCD_GCR_LCLK_SHIFT), LCD_GCR_LCLK_SHIFT, LCD_GCR_LCLK_WIDTH))
/*@}*/

/*!
 * @name Register LCD_GCR, field SOURCE[6] (RW)
 *
 * The LCD controller has two possible clock sources. This bit is used to select
 * which clock source is the basis for LCD clock. The clock sources are
 * chip-specific. For the clock source assignments, see the chapter that describes how
 * modules are configured. Alternate clock can be only MCGIRCLK, and therefore when
 * SOURCE=1, SIM_SOPT1[OSC32KSEL] bit plays no role. Default clock can be either
 * MCGIRCLK, ERCLK32K, OSC32KCLK, according to the selection in
 * SIM_SOPT1[OSC32KSEL].
 *
 * Values:
 * - 0b0 - Selects the default clock as the LCD clock source.
 * - 0b1 - Selects the alternate clock as the LCD clock source.
 */
/*@{*/
/*! @brief Read current value of the LCD_GCR_SOURCE field. */
#define LCD_RD_GCR_SOURCE(base) ((LCD_GCR_REG(base) & LCD_GCR_SOURCE_MASK) >> LCD_GCR_SOURCE_SHIFT)
#define LCD_BRD_GCR_SOURCE(base) (BME_UBFX32(&LCD_GCR_REG(base), LCD_GCR_SOURCE_SHIFT, LCD_GCR_SOURCE_WIDTH))

/*! @brief Set the SOURCE field to a new value. */
#define LCD_WR_GCR_SOURCE(base, value) (LCD_RMW_GCR(base, LCD_GCR_SOURCE_MASK, LCD_GCR_SOURCE(value)))
#define LCD_BWR_GCR_SOURCE(base, value) (BME_BFI32(&LCD_GCR_REG(base), ((uint32_t)(value) << LCD_GCR_SOURCE_SHIFT), LCD_GCR_SOURCE_SHIFT, LCD_GCR_SOURCE_WIDTH))
/*@}*/

/*!
 * @name Register LCD_GCR, field LCDEN[7] (RW)
 *
 * Starts LCD controller waveform generator.
 *
 * Values:
 * - 0b0 - All front plane and back plane pins are disabled. The LCD controller
 *     system is also disabled, and all LCD waveform generation clocks are
 *     stopped. V LL3 is connected to V DD internally.
 * - 0b1 - LCD controller driver system is enabled, and front plane and back
 *     plane waveforms are generated. All LCD pins, LCD_Pn, enabled using the LCD
 *     Pin Enable register, output an LCD driver waveform. The back plane pins
 *     output an LCD driver back plane waveform based on the settings of DUTY[2:0].
 *     Charge pump or resistor bias is enabled.
 */
/*@{*/
/*! @brief Read current value of the LCD_GCR_LCDEN field. */
#define LCD_RD_GCR_LCDEN(base) ((LCD_GCR_REG(base) & LCD_GCR_LCDEN_MASK) >> LCD_GCR_LCDEN_SHIFT)
#define LCD_BRD_GCR_LCDEN(base) (BME_UBFX32(&LCD_GCR_REG(base), LCD_GCR_LCDEN_SHIFT, LCD_GCR_LCDEN_WIDTH))

/*! @brief Set the LCDEN field to a new value. */
#define LCD_WR_GCR_LCDEN(base, value) (LCD_RMW_GCR(base, LCD_GCR_LCDEN_MASK, LCD_GCR_LCDEN(value)))
#define LCD_BWR_GCR_LCDEN(base, value) (BME_BFI32(&LCD_GCR_REG(base), ((uint32_t)(value) << LCD_GCR_LCDEN_SHIFT), LCD_GCR_LCDEN_SHIFT, LCD_GCR_LCDEN_WIDTH))
/*@}*/

/*!
 * @name Register LCD_GCR, field LCDSTP[8] (RW)
 *
 * LCD driver, charge pump, resistor bias network, and voltage regulator stop
 * while in Stop mode.
 *
 * Values:
 * - 0b0 - Allows the LCD driver, charge pump, resistor bias network, and
 *     voltage regulator to continue running during Stop mode.
 * - 0b1 - Disables the LCD driver, charge pump, resistor bias network, and
 *     voltage regulator when MCU enters Stop mode.
 */
/*@{*/
/*! @brief Read current value of the LCD_GCR_LCDSTP field. */
#define LCD_RD_GCR_LCDSTP(base) ((LCD_GCR_REG(base) & LCD_GCR_LCDSTP_MASK) >> LCD_GCR_LCDSTP_SHIFT)
#define LCD_BRD_GCR_LCDSTP(base) (BME_UBFX32(&LCD_GCR_REG(base), LCD_GCR_LCDSTP_SHIFT, LCD_GCR_LCDSTP_WIDTH))

/*! @brief Set the LCDSTP field to a new value. */
#define LCD_WR_GCR_LCDSTP(base, value) (LCD_RMW_GCR(base, LCD_GCR_LCDSTP_MASK, LCD_GCR_LCDSTP(value)))
#define LCD_BWR_GCR_LCDSTP(base, value) (BME_BFI32(&LCD_GCR_REG(base), ((uint32_t)(value) << LCD_GCR_LCDSTP_SHIFT), LCD_GCR_LCDSTP_SHIFT, LCD_GCR_LCDSTP_WIDTH))
/*@}*/

/*!
 * @name Register LCD_GCR, field LCDDOZE[9] (RW)
 *
 * LCD driver, charge pump, resistor bias network, and voltage regulator stop
 * while in Doze mode.
 *
 * Values:
 * - 0b0 - Allows the LCD driver, charge pump, resistor bias network, and
 *     voltage regulator to continue running during Doze mode.
 * - 0b1 - Disables the LCD driver, charge pump, resistor bias network, and
 *     voltage regulator when MCU enters Doze mode.
 */
/*@{*/
/*! @brief Read current value of the LCD_GCR_LCDDOZE field. */
#define LCD_RD_GCR_LCDDOZE(base) ((LCD_GCR_REG(base) & LCD_GCR_LCDDOZE_MASK) >> LCD_GCR_LCDDOZE_SHIFT)
#define LCD_BRD_GCR_LCDDOZE(base) (BME_UBFX32(&LCD_GCR_REG(base), LCD_GCR_LCDDOZE_SHIFT, LCD_GCR_LCDDOZE_WIDTH))

/*! @brief Set the LCDDOZE field to a new value. */
#define LCD_WR_GCR_LCDDOZE(base, value) (LCD_RMW_GCR(base, LCD_GCR_LCDDOZE_MASK, LCD_GCR_LCDDOZE(value)))
#define LCD_BWR_GCR_LCDDOZE(base, value) (BME_BFI32(&LCD_GCR_REG(base), ((uint32_t)(value) << LCD_GCR_LCDDOZE_SHIFT), LCD_GCR_LCDDOZE_SHIFT, LCD_GCR_LCDDOZE_WIDTH))
/*@}*/

/*!
 * @name Register LCD_GCR, field ALTDIV[13:12] (RW)
 *
 * Functions as a clock divider to divide the alternate clock before it is
 * selected as LCD clock source.
 *
 * Values:
 * - 0b00 - Divide factor = 1 (No divide)
 * - 0b01 - Divide factor = 64
 * - 0b10 - Divide factor = 256
 * - 0b11 - Divide factor = 512
 */
/*@{*/
/*! @brief Read current value of the LCD_GCR_ALTDIV field. */
#define LCD_RD_GCR_ALTDIV(base) ((LCD_GCR_REG(base) & LCD_GCR_ALTDIV_MASK) >> LCD_GCR_ALTDIV_SHIFT)
#define LCD_BRD_GCR_ALTDIV(base) (BME_UBFX32(&LCD_GCR_REG(base), LCD_GCR_ALTDIV_SHIFT, LCD_GCR_ALTDIV_WIDTH))

/*! @brief Set the ALTDIV field to a new value. */
#define LCD_WR_GCR_ALTDIV(base, value) (LCD_RMW_GCR(base, LCD_GCR_ALTDIV_MASK, LCD_GCR_ALTDIV(value)))
#define LCD_BWR_GCR_ALTDIV(base, value) (BME_BFI32(&LCD_GCR_REG(base), ((uint32_t)(value) << LCD_GCR_ALTDIV_SHIFT), LCD_GCR_ALTDIV_SHIFT, LCD_GCR_ALTDIV_WIDTH))
/*@}*/

/*!
 * @name Register LCD_GCR, field FDCIEN[14] (RW)
 *
 * Enables an LCD interrupt event when fault detection is completed.
 *
 * Values:
 * - 0b0 - No interrupt request is generated by this event.
 * - 0b1 - When a fault is detected and FDCF bit is set, this event causes an
 *     interrupt request.
 */
/*@{*/
/*! @brief Read current value of the LCD_GCR_FDCIEN field. */
#define LCD_RD_GCR_FDCIEN(base) ((LCD_GCR_REG(base) & LCD_GCR_FDCIEN_MASK) >> LCD_GCR_FDCIEN_SHIFT)
#define LCD_BRD_GCR_FDCIEN(base) (BME_UBFX32(&LCD_GCR_REG(base), LCD_GCR_FDCIEN_SHIFT, LCD_GCR_FDCIEN_WIDTH))

/*! @brief Set the FDCIEN field to a new value. */
#define LCD_WR_GCR_FDCIEN(base, value) (LCD_RMW_GCR(base, LCD_GCR_FDCIEN_MASK, LCD_GCR_FDCIEN(value)))
#define LCD_BWR_GCR_FDCIEN(base, value) (BME_BFI32(&LCD_GCR_REG(base), ((uint32_t)(value) << LCD_GCR_FDCIEN_SHIFT), LCD_GCR_FDCIEN_SHIFT, LCD_GCR_FDCIEN_WIDTH))
/*@}*/

/*!
 * @name Register LCD_GCR, field LCDIEN[15] (RW)
 *
 * Enables an LCD interrupt event that coincides with the LCD controller frame
 * frequency.
 *
 * Values:
 * - 0b0 - No interrupt request is generated by this event.
 * - 0b1 - When LCDIF bit is set, this event causes an interrupt request.
 */
/*@{*/
/*! @brief Read current value of the LCD_GCR_LCDIEN field. */
#define LCD_RD_GCR_LCDIEN(base) ((LCD_GCR_REG(base) & LCD_GCR_LCDIEN_MASK) >> LCD_GCR_LCDIEN_SHIFT)
#define LCD_BRD_GCR_LCDIEN(base) (BME_UBFX32(&LCD_GCR_REG(base), LCD_GCR_LCDIEN_SHIFT, LCD_GCR_LCDIEN_WIDTH))

/*! @brief Set the LCDIEN field to a new value. */
#define LCD_WR_GCR_LCDIEN(base, value) (LCD_RMW_GCR(base, LCD_GCR_LCDIEN_MASK, LCD_GCR_LCDIEN(value)))
#define LCD_BWR_GCR_LCDIEN(base, value) (BME_BFI32(&LCD_GCR_REG(base), ((uint32_t)(value) << LCD_GCR_LCDIEN_SHIFT), LCD_GCR_LCDIEN_SHIFT, LCD_GCR_LCDIEN_WIDTH))
/*@}*/

/*!
 * @name Register LCD_GCR, field VSUPPLY[17] (RW)
 *
 * Configures whether the LCD controller power supply is external or internal.
 * Avoid modifying this field while the LCD controller is enabled, for example, if
 * LCDEN = 1.
 *
 * Values:
 * - 0b0 - Drive VLL3 internally from VDD
 * - 0b1 - Drive VLL3 externally from VDD or drive VLL1 internally from vIREG
 */
/*@{*/
/*! @brief Read current value of the LCD_GCR_VSUPPLY field. */
#define LCD_RD_GCR_VSUPPLY(base) ((LCD_GCR_REG(base) & LCD_GCR_VSUPPLY_MASK) >> LCD_GCR_VSUPPLY_SHIFT)
#define LCD_BRD_GCR_VSUPPLY(base) (BME_UBFX32(&LCD_GCR_REG(base), LCD_GCR_VSUPPLY_SHIFT, LCD_GCR_VSUPPLY_WIDTH))

/*! @brief Set the VSUPPLY field to a new value. */
#define LCD_WR_GCR_VSUPPLY(base, value) (LCD_RMW_GCR(base, LCD_GCR_VSUPPLY_MASK, LCD_GCR_VSUPPLY(value)))
#define LCD_BWR_GCR_VSUPPLY(base, value) (BME_BFI32(&LCD_GCR_REG(base), ((uint32_t)(value) << LCD_GCR_VSUPPLY_SHIFT), LCD_GCR_VSUPPLY_SHIFT, LCD_GCR_VSUPPLY_WIDTH))
/*@}*/

/*!
 * @name Register LCD_GCR, field LADJ[21:20] (RW)
 *
 * Configures SLCD to handle different LCD glass capacitance. For CPSEL = 0
 * Adjust the resistor bias network for different LCD glass capacitance. 00 - Low
 * Load (LCD glass capacitance 2000 pF or lower). 01 - Low Load (LCD glass
 * capacitance 2000 pF or lower). 10 - High Load (LCD glass capacitance 8000 pF or lower)
 * . 11 - High Load (LCD glass capacitance 8000 pF or lower). For CPSEL = 1
 * Adjust the clock source for the charge pump. Higher loads require higher charge
 * pump clock rates. 00 - Fastest clock source for charge pump (LCD glass
 * capacitance 8000 pF or ). 01 - Intermediate clock source for charge pump (LCD glass
 * capacitance 4000 pF or ). 10 - Intermediate clock source for charge pump (LCD
 * glass capacitance 2000 pF or ). 11 - Slowest clock source for charge pump (LCD
 * glass capacitance 1000 pF or ).
 */
/*@{*/
/*! @brief Read current value of the LCD_GCR_LADJ field. */
#define LCD_RD_GCR_LADJ(base) ((LCD_GCR_REG(base) & LCD_GCR_LADJ_MASK) >> LCD_GCR_LADJ_SHIFT)
#define LCD_BRD_GCR_LADJ(base) (BME_UBFX32(&LCD_GCR_REG(base), LCD_GCR_LADJ_SHIFT, LCD_GCR_LADJ_WIDTH))

/*! @brief Set the LADJ field to a new value. */
#define LCD_WR_GCR_LADJ(base, value) (LCD_RMW_GCR(base, LCD_GCR_LADJ_MASK, LCD_GCR_LADJ(value)))
#define LCD_BWR_GCR_LADJ(base, value) (BME_BFI32(&LCD_GCR_REG(base), ((uint32_t)(value) << LCD_GCR_LADJ_SHIFT), LCD_GCR_LADJ_SHIFT, LCD_GCR_LADJ_WIDTH))
/*@}*/

/*!
 * @name Register LCD_GCR, field CPSEL[23] (RW)
 *
 * Selects the LCD controller charge pump or a resistor network to supply the
 * LCD voltages V LL1 , V LL2 , and V LL3 .
 *
 * Values:
 * - 0b0 - LCD charge pump is disabled. Resistor network selected. (The internal
 *     1/3-bias is forced.)
 * - 0b1 - LCD charge pump is selected. Resistor network disabled. (The internal
 *     1/3-bias is forced.)
 */
/*@{*/
/*! @brief Read current value of the LCD_GCR_CPSEL field. */
#define LCD_RD_GCR_CPSEL(base) ((LCD_GCR_REG(base) & LCD_GCR_CPSEL_MASK) >> LCD_GCR_CPSEL_SHIFT)
#define LCD_BRD_GCR_CPSEL(base) (BME_UBFX32(&LCD_GCR_REG(base), LCD_GCR_CPSEL_SHIFT, LCD_GCR_CPSEL_WIDTH))

/*! @brief Set the CPSEL field to a new value. */
#define LCD_WR_GCR_CPSEL(base, value) (LCD_RMW_GCR(base, LCD_GCR_CPSEL_MASK, LCD_GCR_CPSEL(value)))
#define LCD_BWR_GCR_CPSEL(base, value) (BME_BFI32(&LCD_GCR_REG(base), ((uint32_t)(value) << LCD_GCR_CPSEL_SHIFT), LCD_GCR_CPSEL_SHIFT, LCD_GCR_CPSEL_WIDTH))
/*@}*/

/*!
 * @name Register LCD_GCR, field RVTRIM[27:24] (RW)
 *
 * This 4-bit trim register is used to adjust the regulated input. Each bit in
 * the register has equal weight. The regulated input is changed by 1.5% for each
 * count.
 */
/*@{*/
/*! @brief Read current value of the LCD_GCR_RVTRIM field. */
#define LCD_RD_GCR_RVTRIM(base) ((LCD_GCR_REG(base) & LCD_GCR_RVTRIM_MASK) >> LCD_GCR_RVTRIM_SHIFT)
#define LCD_BRD_GCR_RVTRIM(base) (BME_UBFX32(&LCD_GCR_REG(base), LCD_GCR_RVTRIM_SHIFT, LCD_GCR_RVTRIM_WIDTH))

/*! @brief Set the RVTRIM field to a new value. */
#define LCD_WR_GCR_RVTRIM(base, value) (LCD_RMW_GCR(base, LCD_GCR_RVTRIM_MASK, LCD_GCR_RVTRIM(value)))
#define LCD_BWR_GCR_RVTRIM(base, value) (BME_BFI32(&LCD_GCR_REG(base), ((uint32_t)(value) << LCD_GCR_RVTRIM_SHIFT), LCD_GCR_RVTRIM_SHIFT, LCD_GCR_RVTRIM_WIDTH))
/*@}*/

/*!
 * @name Register LCD_GCR, field RVEN[31] (RW)
 *
 * Enables internal voltage regulator. It must have the charge pump enabled. See
 * for more information about this bitfield configuration.
 *
 * Values:
 * - 0b0 - Regulated voltage disabled.
 * - 0b1 - Regulated voltage enabled.
 */
/*@{*/
/*! @brief Read current value of the LCD_GCR_RVEN field. */
#define LCD_RD_GCR_RVEN(base) ((LCD_GCR_REG(base) & LCD_GCR_RVEN_MASK) >> LCD_GCR_RVEN_SHIFT)
#define LCD_BRD_GCR_RVEN(base) (BME_UBFX32(&LCD_GCR_REG(base), LCD_GCR_RVEN_SHIFT, LCD_GCR_RVEN_WIDTH))

/*! @brief Set the RVEN field to a new value. */
#define LCD_WR_GCR_RVEN(base, value) (LCD_RMW_GCR(base, LCD_GCR_RVEN_MASK, LCD_GCR_RVEN(value)))
#define LCD_BWR_GCR_RVEN(base, value) (BME_BFI32(&LCD_GCR_REG(base), ((uint32_t)(value) << LCD_GCR_RVEN_SHIFT), LCD_GCR_RVEN_SHIFT, LCD_GCR_RVEN_WIDTH))
/*@}*/

/*******************************************************************************
 * LCD_AR - LCD Auxiliary Register
 ******************************************************************************/

/*!
 * @brief LCD_AR - LCD Auxiliary Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The reset value of this register depends on the reset type: POR - 0x0000_0000
 */
/*!
 * @name Constants and macros for entire LCD_AR register
 */
/*@{*/
#define LCD_RD_AR(base)          (LCD_AR_REG(base))
#define LCD_WR_AR(base, value)   (LCD_AR_REG(base) = (value))
#define LCD_RMW_AR(base, mask, value) (LCD_WR_AR(base, (LCD_RD_AR(base) & ~(mask)) | (value)))
#define LCD_SET_AR(base, value)  (BME_OR32(&LCD_AR_REG(base), (uint32_t)(value)))
#define LCD_CLR_AR(base, value)  (BME_AND32(&LCD_AR_REG(base), (uint32_t)(~(value))))
#define LCD_TOG_AR(base, value)  (BME_XOR32(&LCD_AR_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual LCD_AR bitfields
 */

/*!
 * @name Register LCD_AR, field BRATE[2:0] (RW)
 *
 * Selects frequency at which the LCD blinks when the BLINK bit is asserted. The
 * following equation provides an expression for the LCD controller blink rate
 * and shows how BRATE field is used in the LCD blink-rate calculation. LCD
 * controller blink rate = LCD clock /2(12 + BRATE)
 */
/*@{*/
/*! @brief Read current value of the LCD_AR_BRATE field. */
#define LCD_RD_AR_BRATE(base) ((LCD_AR_REG(base) & LCD_AR_BRATE_MASK) >> LCD_AR_BRATE_SHIFT)
#define LCD_BRD_AR_BRATE(base) (BME_UBFX32(&LCD_AR_REG(base), LCD_AR_BRATE_SHIFT, LCD_AR_BRATE_WIDTH))

/*! @brief Set the BRATE field to a new value. */
#define LCD_WR_AR_BRATE(base, value) (LCD_RMW_AR(base, (LCD_AR_BRATE_MASK | LCD_AR_LCDIF_MASK), LCD_AR_BRATE(value)))
#define LCD_BWR_AR_BRATE(base, value) (BME_BFI32(&LCD_AR_REG(base), ((uint32_t)(value) << LCD_AR_BRATE_SHIFT), LCD_AR_BRATE_SHIFT, LCD_AR_BRATE_WIDTH))
/*@}*/

/*!
 * @name Register LCD_AR, field BMODE[3] (RW)
 *
 * Selects the blink mode displayed during the blink period.
 *
 * Values:
 * - 0b0 - Display blank during the blink period.
 * - 0b1 - Display alternate display during blink period (Ignored if duty is 5
 *     or greater).
 */
/*@{*/
/*! @brief Read current value of the LCD_AR_BMODE field. */
#define LCD_RD_AR_BMODE(base) ((LCD_AR_REG(base) & LCD_AR_BMODE_MASK) >> LCD_AR_BMODE_SHIFT)
#define LCD_BRD_AR_BMODE(base) (BME_UBFX32(&LCD_AR_REG(base), LCD_AR_BMODE_SHIFT, LCD_AR_BMODE_WIDTH))

/*! @brief Set the BMODE field to a new value. */
#define LCD_WR_AR_BMODE(base, value) (LCD_RMW_AR(base, (LCD_AR_BMODE_MASK | LCD_AR_LCDIF_MASK), LCD_AR_BMODE(value)))
#define LCD_BWR_AR_BMODE(base, value) (BME_BFI32(&LCD_AR_REG(base), ((uint32_t)(value) << LCD_AR_BMODE_SHIFT), LCD_AR_BMODE_SHIFT, LCD_AR_BMODE_WIDTH))
/*@}*/

/*!
 * @name Register LCD_AR, field BLANK[5] (RW)
 *
 * Asserting this bit clears all segments in the LCD.
 *
 * Values:
 * - 0b0 - Normal or alternate display mode.
 * - 0b1 - Blank display mode.
 */
/*@{*/
/*! @brief Read current value of the LCD_AR_BLANK field. */
#define LCD_RD_AR_BLANK(base) ((LCD_AR_REG(base) & LCD_AR_BLANK_MASK) >> LCD_AR_BLANK_SHIFT)
#define LCD_BRD_AR_BLANK(base) (BME_UBFX32(&LCD_AR_REG(base), LCD_AR_BLANK_SHIFT, LCD_AR_BLANK_WIDTH))

/*! @brief Set the BLANK field to a new value. */
#define LCD_WR_AR_BLANK(base, value) (LCD_RMW_AR(base, (LCD_AR_BLANK_MASK | LCD_AR_LCDIF_MASK), LCD_AR_BLANK(value)))
#define LCD_BWR_AR_BLANK(base, value) (BME_BFI32(&LCD_AR_REG(base), ((uint32_t)(value) << LCD_AR_BLANK_SHIFT), LCD_AR_BLANK_SHIFT, LCD_AR_BLANK_WIDTH))
/*@}*/

/*!
 * @name Register LCD_AR, field ALT[6] (RW)
 *
 * For four back planes or less, the LCD back plane sequencer changes to output
 * an alternate display. ALT bit is ignored if DUTY[2:0] is 100 or greater.
 *
 * Values:
 * - 0b0 - Normal display mode.
 * - 0b1 - Alternate display mode.
 */
/*@{*/
/*! @brief Read current value of the LCD_AR_ALT field. */
#define LCD_RD_AR_ALT(base)  ((LCD_AR_REG(base) & LCD_AR_ALT_MASK) >> LCD_AR_ALT_SHIFT)
#define LCD_BRD_AR_ALT(base) (BME_UBFX32(&LCD_AR_REG(base), LCD_AR_ALT_SHIFT, LCD_AR_ALT_WIDTH))

/*! @brief Set the ALT field to a new value. */
#define LCD_WR_AR_ALT(base, value) (LCD_RMW_AR(base, (LCD_AR_ALT_MASK | LCD_AR_LCDIF_MASK), LCD_AR_ALT(value)))
#define LCD_BWR_AR_ALT(base, value) (BME_BFI32(&LCD_AR_REG(base), ((uint32_t)(value) << LCD_AR_ALT_SHIFT), LCD_AR_ALT_SHIFT, LCD_AR_ALT_WIDTH))
/*@}*/

/*!
 * @name Register LCD_AR, field BLINK[7] (RW)
 *
 * Starts or stops SLCD blinking.
 *
 * Values:
 * - 0b0 - Disables blinking.
 * - 0b1 - Starts blinking at blinking frequency specified by LCD blink rate
 *     calculation.
 */
/*@{*/
/*! @brief Read current value of the LCD_AR_BLINK field. */
#define LCD_RD_AR_BLINK(base) ((LCD_AR_REG(base) & LCD_AR_BLINK_MASK) >> LCD_AR_BLINK_SHIFT)
#define LCD_BRD_AR_BLINK(base) (BME_UBFX32(&LCD_AR_REG(base), LCD_AR_BLINK_SHIFT, LCD_AR_BLINK_WIDTH))

/*! @brief Set the BLINK field to a new value. */
#define LCD_WR_AR_BLINK(base, value) (LCD_RMW_AR(base, (LCD_AR_BLINK_MASK | LCD_AR_LCDIF_MASK), LCD_AR_BLINK(value)))
#define LCD_BWR_AR_BLINK(base, value) (BME_BFI32(&LCD_AR_REG(base), ((uint32_t)(value) << LCD_AR_BLINK_SHIFT), LCD_AR_BLINK_SHIFT, LCD_AR_BLINK_WIDTH))
/*@}*/

/*!
 * @name Register LCD_AR, field LCDIF[15] (W1C)
 *
 * Indicates a frame frequency interrupt condition has occurred. To clear the
 * interrupt, write 1 to LCDIF.
 *
 * Values:
 * - 0b0 - Frame frequency interrupt condition has not occurred.
 * - 0b1 - Start of SLCD frame has occurred.
 */
/*@{*/
/*! @brief Read current value of the LCD_AR_LCDIF field. */
#define LCD_RD_AR_LCDIF(base) ((LCD_AR_REG(base) & LCD_AR_LCDIF_MASK) >> LCD_AR_LCDIF_SHIFT)
#define LCD_BRD_AR_LCDIF(base) (BME_UBFX32(&LCD_AR_REG(base), LCD_AR_LCDIF_SHIFT, LCD_AR_LCDIF_WIDTH))

/*! @brief Set the LCDIF field to a new value. */
#define LCD_WR_AR_LCDIF(base, value) (LCD_RMW_AR(base, LCD_AR_LCDIF_MASK, LCD_AR_LCDIF(value)))
#define LCD_BWR_AR_LCDIF(base, value) (BME_BFI32(&LCD_AR_REG(base), ((uint32_t)(value) << LCD_AR_LCDIF_SHIFT), LCD_AR_LCDIF_SHIFT, LCD_AR_LCDIF_WIDTH))
/*@}*/

/*******************************************************************************
 * LCD_FDCR - LCD Fault Detect Control Register
 ******************************************************************************/

/*!
 * @brief LCD_FDCR - LCD Fault Detect Control Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The reset value of this register depends on the reset type: POR - 0x0000_0000
 */
/*!
 * @name Constants and macros for entire LCD_FDCR register
 */
/*@{*/
#define LCD_RD_FDCR(base)        (LCD_FDCR_REG(base))
#define LCD_WR_FDCR(base, value) (LCD_FDCR_REG(base) = (value))
#define LCD_RMW_FDCR(base, mask, value) (LCD_WR_FDCR(base, (LCD_RD_FDCR(base) & ~(mask)) | (value)))
#define LCD_SET_FDCR(base, value) (BME_OR32(&LCD_FDCR_REG(base), (uint32_t)(value)))
#define LCD_CLR_FDCR(base, value) (BME_AND32(&LCD_FDCR_REG(base), (uint32_t)(~(value))))
#define LCD_TOG_FDCR(base, value) (BME_XOR32(&LCD_FDCR_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual LCD_FDCR bitfields
 */

/*!
 * @name Register LCD_FDCR, field FDPINID[5:0] (RW)
 *
 * Specifies the LCD pin to be checked by pullup fault detection.
 *
 * Values:
 * - 0b000000 - Fault detection for LCD_P0 pin.
 * - 0b000001 - Fault detection for LCD_P1 pin.
 */
/*@{*/
/*! @brief Read current value of the LCD_FDCR_FDPINID field. */
#define LCD_RD_FDCR_FDPINID(base) ((LCD_FDCR_REG(base) & LCD_FDCR_FDPINID_MASK) >> LCD_FDCR_FDPINID_SHIFT)
#define LCD_BRD_FDCR_FDPINID(base) (BME_UBFX32(&LCD_FDCR_REG(base), LCD_FDCR_FDPINID_SHIFT, LCD_FDCR_FDPINID_WIDTH))

/*! @brief Set the FDPINID field to a new value. */
#define LCD_WR_FDCR_FDPINID(base, value) (LCD_RMW_FDCR(base, LCD_FDCR_FDPINID_MASK, LCD_FDCR_FDPINID(value)))
#define LCD_BWR_FDCR_FDPINID(base, value) (BME_BFI32(&LCD_FDCR_REG(base), ((uint32_t)(value) << LCD_FDCR_FDPINID_SHIFT), LCD_FDCR_FDPINID_SHIFT, LCD_FDCR_FDPINID_WIDTH))
/*@}*/

/*!
 * @name Register LCD_FDCR, field FDBPEN[6] (RW)
 *
 * Enables "back plane" timing for the fault detect circuit. FDBPEN = 0
 * generates front plane timing. This bit specifies the type of pin selected under fault
 * detect test.
 *
 * Values:
 * - 0b0 - Type of the selected pin under fault detect test is front plane.
 * - 0b1 - Type of the selected pin under fault detect test is back plane.
 */
/*@{*/
/*! @brief Read current value of the LCD_FDCR_FDBPEN field. */
#define LCD_RD_FDCR_FDBPEN(base) ((LCD_FDCR_REG(base) & LCD_FDCR_FDBPEN_MASK) >> LCD_FDCR_FDBPEN_SHIFT)
#define LCD_BRD_FDCR_FDBPEN(base) (BME_UBFX32(&LCD_FDCR_REG(base), LCD_FDCR_FDBPEN_SHIFT, LCD_FDCR_FDBPEN_WIDTH))

/*! @brief Set the FDBPEN field to a new value. */
#define LCD_WR_FDCR_FDBPEN(base, value) (LCD_RMW_FDCR(base, LCD_FDCR_FDBPEN_MASK, LCD_FDCR_FDBPEN(value)))
#define LCD_BWR_FDCR_FDBPEN(base, value) (BME_BFI32(&LCD_FDCR_REG(base), ((uint32_t)(value) << LCD_FDCR_FDBPEN_SHIFT), LCD_FDCR_FDBPEN_SHIFT, LCD_FDCR_FDBPEN_WIDTH))
/*@}*/

/*!
 * @name Register LCD_FDCR, field FDEN[7] (RW)
 *
 * If LCDEN is 1, asserting FDEN inserts a test frame after normal LCD refresh
 * frame is completed. After the test frame is done, Fault detection complete flag
 * (FDCF) is set. When the test frame is done, a normal LCD refresh frame
 * starts. FDEN is one-shot register, it clears after FDCF is set. To initiate another
 * fault detection, FDEN must be set again.
 *
 * Values:
 * - 0b0 - Disable fault detection.
 * - 0b1 - Enable fault detection.
 */
/*@{*/
/*! @brief Read current value of the LCD_FDCR_FDEN field. */
#define LCD_RD_FDCR_FDEN(base) ((LCD_FDCR_REG(base) & LCD_FDCR_FDEN_MASK) >> LCD_FDCR_FDEN_SHIFT)
#define LCD_BRD_FDCR_FDEN(base) (BME_UBFX32(&LCD_FDCR_REG(base), LCD_FDCR_FDEN_SHIFT, LCD_FDCR_FDEN_WIDTH))

/*! @brief Set the FDEN field to a new value. */
#define LCD_WR_FDCR_FDEN(base, value) (LCD_RMW_FDCR(base, LCD_FDCR_FDEN_MASK, LCD_FDCR_FDEN(value)))
#define LCD_BWR_FDCR_FDEN(base, value) (BME_BFI32(&LCD_FDCR_REG(base), ((uint32_t)(value) << LCD_FDCR_FDEN_SHIFT), LCD_FDCR_FDEN_SHIFT, LCD_FDCR_FDEN_WIDTH))
/*@}*/

/*!
 * @name Register LCD_FDCR, field FDSWW[11:9] (RW)
 *
 * Specifies the sample window width of fault detection, in number of cycles in
 * the range from 4-512 (Sample window = 4*2 N ).
 *
 * Values:
 * - 0b000 - Sample window width is 4 sample clock cycles.
 * - 0b001 - Sample window width is 8 sample clock cycles.
 */
/*@{*/
/*! @brief Read current value of the LCD_FDCR_FDSWW field. */
#define LCD_RD_FDCR_FDSWW(base) ((LCD_FDCR_REG(base) & LCD_FDCR_FDSWW_MASK) >> LCD_FDCR_FDSWW_SHIFT)
#define LCD_BRD_FDCR_FDSWW(base) (BME_UBFX32(&LCD_FDCR_REG(base), LCD_FDCR_FDSWW_SHIFT, LCD_FDCR_FDSWW_WIDTH))

/*! @brief Set the FDSWW field to a new value. */
#define LCD_WR_FDCR_FDSWW(base, value) (LCD_RMW_FDCR(base, LCD_FDCR_FDSWW_MASK, LCD_FDCR_FDSWW(value)))
#define LCD_BWR_FDCR_FDSWW(base, value) (BME_BFI32(&LCD_FDCR_REG(base), ((uint32_t)(value) << LCD_FDCR_FDSWW_SHIFT), LCD_FDCR_FDSWW_SHIFT, LCD_FDCR_FDSWW_WIDTH))
/*@}*/

/*!
 * @name Register LCD_FDCR, field FDPRS[14:12] (RW)
 *
 * Fault detect sample clock frequency is:
 *
 * Values:
 * - 0b000 - 1/1 bus clock.
 * - 0b001 - 1/2 bus clock.
 */
/*@{*/
/*! @brief Read current value of the LCD_FDCR_FDPRS field. */
#define LCD_RD_FDCR_FDPRS(base) ((LCD_FDCR_REG(base) & LCD_FDCR_FDPRS_MASK) >> LCD_FDCR_FDPRS_SHIFT)
#define LCD_BRD_FDCR_FDPRS(base) (BME_UBFX32(&LCD_FDCR_REG(base), LCD_FDCR_FDPRS_SHIFT, LCD_FDCR_FDPRS_WIDTH))

/*! @brief Set the FDPRS field to a new value. */
#define LCD_WR_FDCR_FDPRS(base, value) (LCD_RMW_FDCR(base, LCD_FDCR_FDPRS_MASK, LCD_FDCR_FDPRS(value)))
#define LCD_BWR_FDCR_FDPRS(base, value) (BME_BFI32(&LCD_FDCR_REG(base), ((uint32_t)(value) << LCD_FDCR_FDPRS_SHIFT), LCD_FDCR_FDPRS_SHIFT, LCD_FDCR_FDPRS_WIDTH))
/*@}*/

/*******************************************************************************
 * LCD_FDSR - LCD Fault Detect Status Register
 ******************************************************************************/

/*!
 * @brief LCD_FDSR - LCD Fault Detect Status Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The reset value of this register depends on the reset type: POR - 0x0000_0000
 */
/*!
 * @name Constants and macros for entire LCD_FDSR register
 */
/*@{*/
#define LCD_RD_FDSR(base)        (LCD_FDSR_REG(base))
#define LCD_WR_FDSR(base, value) (LCD_FDSR_REG(base) = (value))
#define LCD_RMW_FDSR(base, mask, value) (LCD_WR_FDSR(base, (LCD_RD_FDSR(base) & ~(mask)) | (value)))
#define LCD_SET_FDSR(base, value) (BME_OR32(&LCD_FDSR_REG(base), (uint32_t)(value)))
#define LCD_CLR_FDSR(base, value) (BME_AND32(&LCD_FDSR_REG(base), (uint32_t)(~(value))))
#define LCD_TOG_FDSR(base, value) (BME_XOR32(&LCD_FDSR_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual LCD_FDSR bitfields
 */

/*!
 * @name Register LCD_FDSR, field FDCNT[7:0] (RO)
 *
 * Contains how many "one/high" are sampled inside the fault detect sample
 * window.
 *
 * Values:
 * - 0b00000000 - No "one" samples.
 * - 0b00000001 - 1 "one" samples.
 */
/*@{*/
/*! @brief Read current value of the LCD_FDSR_FDCNT field. */
#define LCD_RD_FDSR_FDCNT(base) ((LCD_FDSR_REG(base) & LCD_FDSR_FDCNT_MASK) >> LCD_FDSR_FDCNT_SHIFT)
#define LCD_BRD_FDSR_FDCNT(base) (BME_UBFX32(&LCD_FDSR_REG(base), LCD_FDSR_FDCNT_SHIFT, LCD_FDSR_FDCNT_WIDTH))
/*@}*/

/*!
 * @name Register LCD_FDSR, field FDCF[15] (W1C)
 *
 * FDCF indicates that the fault detection is completed. Writing 1 to this bit
 * clears it to zero. This bit also acts as an interrupt flag when FDCIEN is set.
 * Software can use either interrupt or polling to check whether one pin fault
 * detection is completed.
 *
 * Values:
 * - 0b0 - Fault detection is not completed.
 * - 0b1 - Fault detection is completed.
 */
/*@{*/
/*! @brief Read current value of the LCD_FDSR_FDCF field. */
#define LCD_RD_FDSR_FDCF(base) ((LCD_FDSR_REG(base) & LCD_FDSR_FDCF_MASK) >> LCD_FDSR_FDCF_SHIFT)
#define LCD_BRD_FDSR_FDCF(base) (BME_UBFX32(&LCD_FDSR_REG(base), LCD_FDSR_FDCF_SHIFT, LCD_FDSR_FDCF_WIDTH))

/*! @brief Set the FDCF field to a new value. */
#define LCD_WR_FDSR_FDCF(base, value) (LCD_RMW_FDSR(base, LCD_FDSR_FDCF_MASK, LCD_FDSR_FDCF(value)))
#define LCD_BWR_FDSR_FDCF(base, value) (BME_BFI32(&LCD_FDSR_REG(base), ((uint32_t)(value) << LCD_FDSR_FDCF_SHIFT), LCD_FDSR_FDCF_SHIFT, LCD_FDSR_FDCF_WIDTH))
/*@}*/

/*******************************************************************************
 * LCD_PEN - LCD Pin Enable register
 ******************************************************************************/

/*!
 * @brief LCD_PEN - LCD Pin Enable register (RW)
 *
 * Reset value: 0x00000000U
 *
 * When LCDEN = 1, each PEN bit enables the corresponding LCD pin (LCD_Pn) for
 * LCD waveform generation. Initialize these registers before enabling the LCD
 * controller. The reset value of this register depends on the reset type: POR -
 * 0x0000_0000
 */
/*!
 * @name Constants and macros for entire LCD_PEN register
 */
/*@{*/
#define LCD_RD_PEN(base, index)  (LCD_PEN_REG(base, index))
#define LCD_WR_PEN(base, index, value) (LCD_PEN_REG(base, index) = (value))
#define LCD_RMW_PEN(base, index, mask, value) (LCD_WR_PEN(base, index, (LCD_RD_PEN(base, index) & ~(mask)) | (value)))
#define LCD_SET_PEN(base, index, value) (BME_OR32(&LCD_PEN_REG(base, index), (uint32_t)(value)))
#define LCD_CLR_PEN(base, index, value) (BME_AND32(&LCD_PEN_REG(base, index), (uint32_t)(~(value))))
#define LCD_TOG_PEN(base, index, value) (BME_XOR32(&LCD_PEN_REG(base, index), (uint32_t)(value)))
/*@}*/

/*******************************************************************************
 * LCD_BPEN - LCD Back Plane Enable register
 ******************************************************************************/

/*!
 * @brief LCD_BPEN - LCD Back Plane Enable register (RW)
 *
 * Reset value: 0x00000000U
 *
 * When PEN[n] = 1, the BPEN[63:0] bits configure the corresponding LCD pin to
 * operate as an LCD back plane or an LCD front plane. Most applications set a
 * maximum of eight of these bits. Initialize these registers before enabling the
 * LCD controller. The reset value of this register depends on the reset type: POR
 * - 0x0000_0000
 */
/*!
 * @name Constants and macros for entire LCD_BPEN register
 */
/*@{*/
#define LCD_RD_BPEN(base, index) (LCD_BPEN_REG(base, index))
#define LCD_WR_BPEN(base, index, value) (LCD_BPEN_REG(base, index) = (value))
#define LCD_RMW_BPEN(base, index, mask, value) (LCD_WR_BPEN(base, index, (LCD_RD_BPEN(base, index) & ~(mask)) | (value)))
#define LCD_SET_BPEN(base, index, value) (BME_OR32(&LCD_BPEN_REG(base, index), (uint32_t)(value)))
#define LCD_CLR_BPEN(base, index, value) (BME_AND32(&LCD_BPEN_REG(base, index), (uint32_t)(~(value))))
#define LCD_TOG_BPEN(base, index, value) (BME_XOR32(&LCD_BPEN_REG(base, index), (uint32_t)(value)))
/*@}*/

/*******************************************************************************
 * LCD_WF - LCD Waveform register
 ******************************************************************************/

/*!
 * @brief LCD_WF - LCD Waveform register (RW)
 *
 * Reset value: 0x00000000U
 *
 * Each of the WFyTOx registers contains four waveform control (WFn) fields,
 * where x is the n index value of the WFn field in the least significant byte (bits
 * 7-0) and y is the n index value of the WFn field in the most significant byte
 * (bits 31-24). The bits in each WFn field control the front plane segments or
 * back plane phases connected to the LCD_Pn signal. In an LCD controller, each
 * element consists of a front plane segment and a back plane phase. These
 * segments and phases are labeled A through H (x8 multiplexing, 1/8 duty cycle). Each
 * LCD_Pn signal can be connected to one or more segments (in front plane
 * operation) or one or more phases (in back plane operation). An LCD element is turned
 * on when the associated back plane phase is activated and the front plane
 * segment is on. If LCD_Pn is configured for front plane operation, the bits in WFn
 * turn on or off each of the front plane segments connected to LCD_Pn: bit 0
 * controls segment A, bit 1 controls segment B, and so on. If LCD_Pn is configured
 * for back plane operation, the bits in WFn activate or deactivate each of the
 * back plane phases connected to LCD_Pn: bit 0 controls phase A, bit 1 controls
 * phase B, and so on. Software can write to this register with 8-bit, 16-bit, or
 * 32-bit writes. After reset, the WFyTOx register is cleared to 0. The reset value
 * of this register depends on the reset type: POR - 0x0000_0000
 */
/*!
 * @name Constants and macros for entire LCD_WF register
 */
/*@{*/
#define LCD_RD_WF(base, index)   (LCD_WF_REG(base, index))
#define LCD_WR_WF(base, index, value) (LCD_WF_REG(base, index) = (value))
#define LCD_RMW_WF(base, index, mask, value) (LCD_WR_WF(base, index, (LCD_RD_WF(base, index) & ~(mask)) | (value)))
#define LCD_SET_WF(base, index, value) (BME_OR32(&LCD_WF_REG(base, index), (uint32_t)(value)))
#define LCD_CLR_WF(base, index, value) (BME_AND32(&LCD_WF_REG(base, index), (uint32_t)(~(value))))
#define LCD_TOG_WF(base, index, value) (BME_XOR32(&LCD_WF_REG(base, index), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual LCD_WF bitfields
 */

/*!
 * @name Register LCD_WF, field WF0[7:0] (RW)
 *
 * Controls segments or phases connected to LCD_P0 as described above for WF3.
 */
/*@{*/
/*! @brief Read current value of the LCD_WF_WF0 field. */
#define LCD_RD_WF_WF0(base, index) ((LCD_WF_REG(base, index) & LCD_WF_WF0_MASK) >> LCD_WF_WF0_SHIFT)
#define LCD_BRD_WF_WF0(base, index) (BME_UBFX32(&LCD_WF_REG(base, index), LCD_WF_WF0_SHIFT, LCD_WF_WF0_WIDTH))

/*! @brief Set the WF0 field to a new value. */
#define LCD_WR_WF_WF0(base, index, value) (LCD_RMW_WF(base, index, LCD_WF_WF0_MASK, LCD_WF_WF0(value)))
#define LCD_BWR_WF_WF0(base, index, value) (BME_BFI32(&LCD_WF_REG(base, index), ((uint32_t)(value) << LCD_WF_WF0_SHIFT), LCD_WF_WF0_SHIFT, LCD_WF_WF0_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF, field WF60[7:0] (RW)
 *
 * Controls segments or phases connected to LCD_P60 as described above for
 * WF3TO0[WF3].
 */
/*@{*/
/*! @brief Read current value of the LCD_WF_WF60 field. */
#define LCD_RD_WF_WF60(base, index) ((LCD_WF_REG(base, index) & LCD_WF_WF60_MASK) >> LCD_WF_WF60_SHIFT)
#define LCD_BRD_WF_WF60(base, index) (BME_UBFX32(&LCD_WF_REG(base, index), LCD_WF_WF60_SHIFT, LCD_WF_WF60_WIDTH))

/*! @brief Set the WF60 field to a new value. */
#define LCD_WR_WF_WF60(base, index, value) (LCD_RMW_WF(base, index, LCD_WF_WF60_MASK, LCD_WF_WF60(value)))
#define LCD_BWR_WF_WF60(base, index, value) (BME_BFI32(&LCD_WF_REG(base, index), ((uint32_t)(value) << LCD_WF_WF60_SHIFT), LCD_WF_WF60_SHIFT, LCD_WF_WF60_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF, field WF56[7:0] (RW)
 *
 * Controls segments or phases connected to LCD_P56 as described above for
 * WF3TO0[WF3].
 */
/*@{*/
/*! @brief Read current value of the LCD_WF_WF56 field. */
#define LCD_RD_WF_WF56(base, index) ((LCD_WF_REG(base, index) & LCD_WF_WF56_MASK) >> LCD_WF_WF56_SHIFT)
#define LCD_BRD_WF_WF56(base, index) (BME_UBFX32(&LCD_WF_REG(base, index), LCD_WF_WF56_SHIFT, LCD_WF_WF56_WIDTH))

/*! @brief Set the WF56 field to a new value. */
#define LCD_WR_WF_WF56(base, index, value) (LCD_RMW_WF(base, index, LCD_WF_WF56_MASK, LCD_WF_WF56(value)))
#define LCD_BWR_WF_WF56(base, index, value) (BME_BFI32(&LCD_WF_REG(base, index), ((uint32_t)(value) << LCD_WF_WF56_SHIFT), LCD_WF_WF56_SHIFT, LCD_WF_WF56_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF, field WF52[7:0] (RW)
 *
 * Controls segments or phases connected to LCD_P52 as described above for
 * WF3TO0[WF3].
 */
/*@{*/
/*! @brief Read current value of the LCD_WF_WF52 field. */
#define LCD_RD_WF_WF52(base, index) ((LCD_WF_REG(base, index) & LCD_WF_WF52_MASK) >> LCD_WF_WF52_SHIFT)
#define LCD_BRD_WF_WF52(base, index) (BME_UBFX32(&LCD_WF_REG(base, index), LCD_WF_WF52_SHIFT, LCD_WF_WF52_WIDTH))

/*! @brief Set the WF52 field to a new value. */
#define LCD_WR_WF_WF52(base, index, value) (LCD_RMW_WF(base, index, LCD_WF_WF52_MASK, LCD_WF_WF52(value)))
#define LCD_BWR_WF_WF52(base, index, value) (BME_BFI32(&LCD_WF_REG(base, index), ((uint32_t)(value) << LCD_WF_WF52_SHIFT), LCD_WF_WF52_SHIFT, LCD_WF_WF52_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF, field WF4[7:0] (RW)
 *
 * Controls segments or phases connected to LCD_P4 as described above for
 * WF3TO0[WF3].
 */
/*@{*/
/*! @brief Read current value of the LCD_WF_WF4 field. */
#define LCD_RD_WF_WF4(base, index) ((LCD_WF_REG(base, index) & LCD_WF_WF4_MASK) >> LCD_WF_WF4_SHIFT)
#define LCD_BRD_WF_WF4(base, index) (BME_UBFX32(&LCD_WF_REG(base, index), LCD_WF_WF4_SHIFT, LCD_WF_WF4_WIDTH))

/*! @brief Set the WF4 field to a new value. */
#define LCD_WR_WF_WF4(base, index, value) (LCD_RMW_WF(base, index, LCD_WF_WF4_MASK, LCD_WF_WF4(value)))
#define LCD_BWR_WF_WF4(base, index, value) (BME_BFI32(&LCD_WF_REG(base, index), ((uint32_t)(value) << LCD_WF_WF4_SHIFT), LCD_WF_WF4_SHIFT, LCD_WF_WF4_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF, field WF48[7:0] (RW)
 *
 * Controls segments or phases connected to LCD_P48 as described above for
 * WF3TO0[WF3].
 */
/*@{*/
/*! @brief Read current value of the LCD_WF_WF48 field. */
#define LCD_RD_WF_WF48(base, index) ((LCD_WF_REG(base, index) & LCD_WF_WF48_MASK) >> LCD_WF_WF48_SHIFT)
#define LCD_BRD_WF_WF48(base, index) (BME_UBFX32(&LCD_WF_REG(base, index), LCD_WF_WF48_SHIFT, LCD_WF_WF48_WIDTH))

/*! @brief Set the WF48 field to a new value. */
#define LCD_WR_WF_WF48(base, index, value) (LCD_RMW_WF(base, index, LCD_WF_WF48_MASK, LCD_WF_WF48(value)))
#define LCD_BWR_WF_WF48(base, index, value) (BME_BFI32(&LCD_WF_REG(base, index), ((uint32_t)(value) << LCD_WF_WF48_SHIFT), LCD_WF_WF48_SHIFT, LCD_WF_WF48_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF, field WF44[7:0] (RW)
 *
 * Controls segments or phases connected to LCD_P44 as described above for
 * WF3TO0[WF3].
 */
/*@{*/
/*! @brief Read current value of the LCD_WF_WF44 field. */
#define LCD_RD_WF_WF44(base, index) ((LCD_WF_REG(base, index) & LCD_WF_WF44_MASK) >> LCD_WF_WF44_SHIFT)
#define LCD_BRD_WF_WF44(base, index) (BME_UBFX32(&LCD_WF_REG(base, index), LCD_WF_WF44_SHIFT, LCD_WF_WF44_WIDTH))

/*! @brief Set the WF44 field to a new value. */
#define LCD_WR_WF_WF44(base, index, value) (LCD_RMW_WF(base, index, LCD_WF_WF44_MASK, LCD_WF_WF44(value)))
#define LCD_BWR_WF_WF44(base, index, value) (BME_BFI32(&LCD_WF_REG(base, index), ((uint32_t)(value) << LCD_WF_WF44_SHIFT), LCD_WF_WF44_SHIFT, LCD_WF_WF44_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF, field WF40[7:0] (RW)
 *
 * Controls segments or phases connected to LCD_P40 as described above for
 * WF3TO0[WF3].
 */
/*@{*/
/*! @brief Read current value of the LCD_WF_WF40 field. */
#define LCD_RD_WF_WF40(base, index) ((LCD_WF_REG(base, index) & LCD_WF_WF40_MASK) >> LCD_WF_WF40_SHIFT)
#define LCD_BRD_WF_WF40(base, index) (BME_UBFX32(&LCD_WF_REG(base, index), LCD_WF_WF40_SHIFT, LCD_WF_WF40_WIDTH))

/*! @brief Set the WF40 field to a new value. */
#define LCD_WR_WF_WF40(base, index, value) (LCD_RMW_WF(base, index, LCD_WF_WF40_MASK, LCD_WF_WF40(value)))
#define LCD_BWR_WF_WF40(base, index, value) (BME_BFI32(&LCD_WF_REG(base, index), ((uint32_t)(value) << LCD_WF_WF40_SHIFT), LCD_WF_WF40_SHIFT, LCD_WF_WF40_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF, field WF8[7:0] (RW)
 *
 * Controls segments or phases connected to LCD_P8 as described above for
 * WF3TO0[WF3].
 */
/*@{*/
/*! @brief Read current value of the LCD_WF_WF8 field. */
#define LCD_RD_WF_WF8(base, index) ((LCD_WF_REG(base, index) & LCD_WF_WF8_MASK) >> LCD_WF_WF8_SHIFT)
#define LCD_BRD_WF_WF8(base, index) (BME_UBFX32(&LCD_WF_REG(base, index), LCD_WF_WF8_SHIFT, LCD_WF_WF8_WIDTH))

/*! @brief Set the WF8 field to a new value. */
#define LCD_WR_WF_WF8(base, index, value) (LCD_RMW_WF(base, index, LCD_WF_WF8_MASK, LCD_WF_WF8(value)))
#define LCD_BWR_WF_WF8(base, index, value) (BME_BFI32(&LCD_WF_REG(base, index), ((uint32_t)(value) << LCD_WF_WF8_SHIFT), LCD_WF_WF8_SHIFT, LCD_WF_WF8_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF, field WF36[7:0] (RW)
 *
 * Controls segments or phases connected to LCD_P36 as described above for
 * WF3TO0[WF3].
 */
/*@{*/
/*! @brief Read current value of the LCD_WF_WF36 field. */
#define LCD_RD_WF_WF36(base, index) ((LCD_WF_REG(base, index) & LCD_WF_WF36_MASK) >> LCD_WF_WF36_SHIFT)
#define LCD_BRD_WF_WF36(base, index) (BME_UBFX32(&LCD_WF_REG(base, index), LCD_WF_WF36_SHIFT, LCD_WF_WF36_WIDTH))

/*! @brief Set the WF36 field to a new value. */
#define LCD_WR_WF_WF36(base, index, value) (LCD_RMW_WF(base, index, LCD_WF_WF36_MASK, LCD_WF_WF36(value)))
#define LCD_BWR_WF_WF36(base, index, value) (BME_BFI32(&LCD_WF_REG(base, index), ((uint32_t)(value) << LCD_WF_WF36_SHIFT), LCD_WF_WF36_SHIFT, LCD_WF_WF36_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF, field WF32[7:0] (RW)
 *
 * Controls segments or phases connected to LCD_P32 as described above for
 * WF3TO0[WF3].
 */
/*@{*/
/*! @brief Read current value of the LCD_WF_WF32 field. */
#define LCD_RD_WF_WF32(base, index) ((LCD_WF_REG(base, index) & LCD_WF_WF32_MASK) >> LCD_WF_WF32_SHIFT)
#define LCD_BRD_WF_WF32(base, index) (BME_UBFX32(&LCD_WF_REG(base, index), LCD_WF_WF32_SHIFT, LCD_WF_WF32_WIDTH))

/*! @brief Set the WF32 field to a new value. */
#define LCD_WR_WF_WF32(base, index, value) (LCD_RMW_WF(base, index, LCD_WF_WF32_MASK, LCD_WF_WF32(value)))
#define LCD_BWR_WF_WF32(base, index, value) (BME_BFI32(&LCD_WF_REG(base, index), ((uint32_t)(value) << LCD_WF_WF32_SHIFT), LCD_WF_WF32_SHIFT, LCD_WF_WF32_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF, field WF28[7:0] (RW)
 *
 * Controls segments or phases connected to LCD_P28 as described above for
 * WF3TO0[WF3].
 */
/*@{*/
/*! @brief Read current value of the LCD_WF_WF28 field. */
#define LCD_RD_WF_WF28(base, index) ((LCD_WF_REG(base, index) & LCD_WF_WF28_MASK) >> LCD_WF_WF28_SHIFT)
#define LCD_BRD_WF_WF28(base, index) (BME_UBFX32(&LCD_WF_REG(base, index), LCD_WF_WF28_SHIFT, LCD_WF_WF28_WIDTH))

/*! @brief Set the WF28 field to a new value. */
#define LCD_WR_WF_WF28(base, index, value) (LCD_RMW_WF(base, index, LCD_WF_WF28_MASK, LCD_WF_WF28(value)))
#define LCD_BWR_WF_WF28(base, index, value) (BME_BFI32(&LCD_WF_REG(base, index), ((uint32_t)(value) << LCD_WF_WF28_SHIFT), LCD_WF_WF28_SHIFT, LCD_WF_WF28_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF, field WF12[7:0] (RW)
 *
 * Controls segments or phases connected to LCD_P12 as described above for
 * WF3TO0[WF3].
 */
/*@{*/
/*! @brief Read current value of the LCD_WF_WF12 field. */
#define LCD_RD_WF_WF12(base, index) ((LCD_WF_REG(base, index) & LCD_WF_WF12_MASK) >> LCD_WF_WF12_SHIFT)
#define LCD_BRD_WF_WF12(base, index) (BME_UBFX32(&LCD_WF_REG(base, index), LCD_WF_WF12_SHIFT, LCD_WF_WF12_WIDTH))

/*! @brief Set the WF12 field to a new value. */
#define LCD_WR_WF_WF12(base, index, value) (LCD_RMW_WF(base, index, LCD_WF_WF12_MASK, LCD_WF_WF12(value)))
#define LCD_BWR_WF_WF12(base, index, value) (BME_BFI32(&LCD_WF_REG(base, index), ((uint32_t)(value) << LCD_WF_WF12_SHIFT), LCD_WF_WF12_SHIFT, LCD_WF_WF12_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF, field WF24[7:0] (RW)
 *
 * Controls segments or phases connected to LCD_P24 as described above for
 * WF3TO0[WF3].
 */
/*@{*/
/*! @brief Read current value of the LCD_WF_WF24 field. */
#define LCD_RD_WF_WF24(base, index) ((LCD_WF_REG(base, index) & LCD_WF_WF24_MASK) >> LCD_WF_WF24_SHIFT)
#define LCD_BRD_WF_WF24(base, index) (BME_UBFX32(&LCD_WF_REG(base, index), LCD_WF_WF24_SHIFT, LCD_WF_WF24_WIDTH))

/*! @brief Set the WF24 field to a new value. */
#define LCD_WR_WF_WF24(base, index, value) (LCD_RMW_WF(base, index, LCD_WF_WF24_MASK, LCD_WF_WF24(value)))
#define LCD_BWR_WF_WF24(base, index, value) (BME_BFI32(&LCD_WF_REG(base, index), ((uint32_t)(value) << LCD_WF_WF24_SHIFT), LCD_WF_WF24_SHIFT, LCD_WF_WF24_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF, field WF20[7:0] (RW)
 *
 * Controls segments or phases connected to LCD_P20 as described above for
 * WF3TO0[WF3].
 */
/*@{*/
/*! @brief Read current value of the LCD_WF_WF20 field. */
#define LCD_RD_WF_WF20(base, index) ((LCD_WF_REG(base, index) & LCD_WF_WF20_MASK) >> LCD_WF_WF20_SHIFT)
#define LCD_BRD_WF_WF20(base, index) (BME_UBFX32(&LCD_WF_REG(base, index), LCD_WF_WF20_SHIFT, LCD_WF_WF20_WIDTH))

/*! @brief Set the WF20 field to a new value. */
#define LCD_WR_WF_WF20(base, index, value) (LCD_RMW_WF(base, index, LCD_WF_WF20_MASK, LCD_WF_WF20(value)))
#define LCD_BWR_WF_WF20(base, index, value) (BME_BFI32(&LCD_WF_REG(base, index), ((uint32_t)(value) << LCD_WF_WF20_SHIFT), LCD_WF_WF20_SHIFT, LCD_WF_WF20_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF, field WF16[7:0] (RW)
 *
 * Controls segments or phases connected to LCD_P16 as described above for
 * WF3TO0[WF3].
 */
/*@{*/
/*! @brief Read current value of the LCD_WF_WF16 field. */
#define LCD_RD_WF_WF16(base, index) ((LCD_WF_REG(base, index) & LCD_WF_WF16_MASK) >> LCD_WF_WF16_SHIFT)
#define LCD_BRD_WF_WF16(base, index) (BME_UBFX32(&LCD_WF_REG(base, index), LCD_WF_WF16_SHIFT, LCD_WF_WF16_WIDTH))

/*! @brief Set the WF16 field to a new value. */
#define LCD_WR_WF_WF16(base, index, value) (LCD_RMW_WF(base, index, LCD_WF_WF16_MASK, LCD_WF_WF16(value)))
#define LCD_BWR_WF_WF16(base, index, value) (BME_BFI32(&LCD_WF_REG(base, index), ((uint32_t)(value) << LCD_WF_WF16_SHIFT), LCD_WF_WF16_SHIFT, LCD_WF_WF16_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF, field WF5[15:8] (RW)
 *
 * Controls segments or phases connected to LCD_P5 as described above for
 * WF3TO0[WF3].
 */
/*@{*/
/*! @brief Read current value of the LCD_WF_WF5 field. */
#define LCD_RD_WF_WF5(base, index) ((LCD_WF_REG(base, index) & LCD_WF_WF5_MASK) >> LCD_WF_WF5_SHIFT)
#define LCD_BRD_WF_WF5(base, index) (BME_UBFX32(&LCD_WF_REG(base, index), LCD_WF_WF5_SHIFT, LCD_WF_WF5_WIDTH))

/*! @brief Set the WF5 field to a new value. */
#define LCD_WR_WF_WF5(base, index, value) (LCD_RMW_WF(base, index, LCD_WF_WF5_MASK, LCD_WF_WF5(value)))
#define LCD_BWR_WF_WF5(base, index, value) (BME_BFI32(&LCD_WF_REG(base, index), ((uint32_t)(value) << LCD_WF_WF5_SHIFT), LCD_WF_WF5_SHIFT, LCD_WF_WF5_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF, field WF49[15:8] (RW)
 *
 * Controls segments or phases connected to LCD_P49 as described above for
 * WF3TO0[WF3].
 */
/*@{*/
/*! @brief Read current value of the LCD_WF_WF49 field. */
#define LCD_RD_WF_WF49(base, index) ((LCD_WF_REG(base, index) & LCD_WF_WF49_MASK) >> LCD_WF_WF49_SHIFT)
#define LCD_BRD_WF_WF49(base, index) (BME_UBFX32(&LCD_WF_REG(base, index), LCD_WF_WF49_SHIFT, LCD_WF_WF49_WIDTH))

/*! @brief Set the WF49 field to a new value. */
#define LCD_WR_WF_WF49(base, index, value) (LCD_RMW_WF(base, index, LCD_WF_WF49_MASK, LCD_WF_WF49(value)))
#define LCD_BWR_WF_WF49(base, index, value) (BME_BFI32(&LCD_WF_REG(base, index), ((uint32_t)(value) << LCD_WF_WF49_SHIFT), LCD_WF_WF49_SHIFT, LCD_WF_WF49_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF, field WF45[15:8] (RW)
 *
 * Controls segments or phases connected to LCD_P45 as described above for
 * WF3TO0[WF3].
 */
/*@{*/
/*! @brief Read current value of the LCD_WF_WF45 field. */
#define LCD_RD_WF_WF45(base, index) ((LCD_WF_REG(base, index) & LCD_WF_WF45_MASK) >> LCD_WF_WF45_SHIFT)
#define LCD_BRD_WF_WF45(base, index) (BME_UBFX32(&LCD_WF_REG(base, index), LCD_WF_WF45_SHIFT, LCD_WF_WF45_WIDTH))

/*! @brief Set the WF45 field to a new value. */
#define LCD_WR_WF_WF45(base, index, value) (LCD_RMW_WF(base, index, LCD_WF_WF45_MASK, LCD_WF_WF45(value)))
#define LCD_BWR_WF_WF45(base, index, value) (BME_BFI32(&LCD_WF_REG(base, index), ((uint32_t)(value) << LCD_WF_WF45_SHIFT), LCD_WF_WF45_SHIFT, LCD_WF_WF45_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF, field WF61[15:8] (RW)
 *
 * Controls segments or phases connected to LCD_P61 as described above for
 * WF3TO0[WF3].
 */
/*@{*/
/*! @brief Read current value of the LCD_WF_WF61 field. */
#define LCD_RD_WF_WF61(base, index) ((LCD_WF_REG(base, index) & LCD_WF_WF61_MASK) >> LCD_WF_WF61_SHIFT)
#define LCD_BRD_WF_WF61(base, index) (BME_UBFX32(&LCD_WF_REG(base, index), LCD_WF_WF61_SHIFT, LCD_WF_WF61_WIDTH))

/*! @brief Set the WF61 field to a new value. */
#define LCD_WR_WF_WF61(base, index, value) (LCD_RMW_WF(base, index, LCD_WF_WF61_MASK, LCD_WF_WF61(value)))
#define LCD_BWR_WF_WF61(base, index, value) (BME_BFI32(&LCD_WF_REG(base, index), ((uint32_t)(value) << LCD_WF_WF61_SHIFT), LCD_WF_WF61_SHIFT, LCD_WF_WF61_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF, field WF25[15:8] (RW)
 *
 * Controls segments or phases connected to LCD_P25 as described above for
 * WF3TO0[WF3].
 */
/*@{*/
/*! @brief Read current value of the LCD_WF_WF25 field. */
#define LCD_RD_WF_WF25(base, index) ((LCD_WF_REG(base, index) & LCD_WF_WF25_MASK) >> LCD_WF_WF25_SHIFT)
#define LCD_BRD_WF_WF25(base, index) (BME_UBFX32(&LCD_WF_REG(base, index), LCD_WF_WF25_SHIFT, LCD_WF_WF25_WIDTH))

/*! @brief Set the WF25 field to a new value. */
#define LCD_WR_WF_WF25(base, index, value) (LCD_RMW_WF(base, index, LCD_WF_WF25_MASK, LCD_WF_WF25(value)))
#define LCD_BWR_WF_WF25(base, index, value) (BME_BFI32(&LCD_WF_REG(base, index), ((uint32_t)(value) << LCD_WF_WF25_SHIFT), LCD_WF_WF25_SHIFT, LCD_WF_WF25_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF, field WF17[15:8] (RW)
 *
 * Controls segments or phases connected to LCD_P17 as described above for
 * WF3TO0[WF3].
 */
/*@{*/
/*! @brief Read current value of the LCD_WF_WF17 field. */
#define LCD_RD_WF_WF17(base, index) ((LCD_WF_REG(base, index) & LCD_WF_WF17_MASK) >> LCD_WF_WF17_SHIFT)
#define LCD_BRD_WF_WF17(base, index) (BME_UBFX32(&LCD_WF_REG(base, index), LCD_WF_WF17_SHIFT, LCD_WF_WF17_WIDTH))

/*! @brief Set the WF17 field to a new value. */
#define LCD_WR_WF_WF17(base, index, value) (LCD_RMW_WF(base, index, LCD_WF_WF17_MASK, LCD_WF_WF17(value)))
#define LCD_BWR_WF_WF17(base, index, value) (BME_BFI32(&LCD_WF_REG(base, index), ((uint32_t)(value) << LCD_WF_WF17_SHIFT), LCD_WF_WF17_SHIFT, LCD_WF_WF17_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF, field WF41[15:8] (RW)
 *
 * Controls segments or phases connected to LCD_P41 as described above for
 * WF3TO0[WF3].
 */
/*@{*/
/*! @brief Read current value of the LCD_WF_WF41 field. */
#define LCD_RD_WF_WF41(base, index) ((LCD_WF_REG(base, index) & LCD_WF_WF41_MASK) >> LCD_WF_WF41_SHIFT)
#define LCD_BRD_WF_WF41(base, index) (BME_UBFX32(&LCD_WF_REG(base, index), LCD_WF_WF41_SHIFT, LCD_WF_WF41_WIDTH))

/*! @brief Set the WF41 field to a new value. */
#define LCD_WR_WF_WF41(base, index, value) (LCD_RMW_WF(base, index, LCD_WF_WF41_MASK, LCD_WF_WF41(value)))
#define LCD_BWR_WF_WF41(base, index, value) (BME_BFI32(&LCD_WF_REG(base, index), ((uint32_t)(value) << LCD_WF_WF41_SHIFT), LCD_WF_WF41_SHIFT, LCD_WF_WF41_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF, field WF13[15:8] (RW)
 *
 * Controls segments or phases connected to LCD_P13 as described above for
 * WF3TO0[WF3].
 */
/*@{*/
/*! @brief Read current value of the LCD_WF_WF13 field. */
#define LCD_RD_WF_WF13(base, index) ((LCD_WF_REG(base, index) & LCD_WF_WF13_MASK) >> LCD_WF_WF13_SHIFT)
#define LCD_BRD_WF_WF13(base, index) (BME_UBFX32(&LCD_WF_REG(base, index), LCD_WF_WF13_SHIFT, LCD_WF_WF13_WIDTH))

/*! @brief Set the WF13 field to a new value. */
#define LCD_WR_WF_WF13(base, index, value) (LCD_RMW_WF(base, index, LCD_WF_WF13_MASK, LCD_WF_WF13(value)))
#define LCD_BWR_WF_WF13(base, index, value) (BME_BFI32(&LCD_WF_REG(base, index), ((uint32_t)(value) << LCD_WF_WF13_SHIFT), LCD_WF_WF13_SHIFT, LCD_WF_WF13_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF, field WF57[15:8] (RW)
 *
 * Controls segments or phases connected to LCD_P57 as described above for
 * WF3TO0[WF3].
 */
/*@{*/
/*! @brief Read current value of the LCD_WF_WF57 field. */
#define LCD_RD_WF_WF57(base, index) ((LCD_WF_REG(base, index) & LCD_WF_WF57_MASK) >> LCD_WF_WF57_SHIFT)
#define LCD_BRD_WF_WF57(base, index) (BME_UBFX32(&LCD_WF_REG(base, index), LCD_WF_WF57_SHIFT, LCD_WF_WF57_WIDTH))

/*! @brief Set the WF57 field to a new value. */
#define LCD_WR_WF_WF57(base, index, value) (LCD_RMW_WF(base, index, LCD_WF_WF57_MASK, LCD_WF_WF57(value)))
#define LCD_BWR_WF_WF57(base, index, value) (BME_BFI32(&LCD_WF_REG(base, index), ((uint32_t)(value) << LCD_WF_WF57_SHIFT), LCD_WF_WF57_SHIFT, LCD_WF_WF57_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF, field WF53[15:8] (RW)
 *
 * Controls segments or phases connected to LCD_P53 as described above for
 * WF3TO0[WF3].
 */
/*@{*/
/*! @brief Read current value of the LCD_WF_WF53 field. */
#define LCD_RD_WF_WF53(base, index) ((LCD_WF_REG(base, index) & LCD_WF_WF53_MASK) >> LCD_WF_WF53_SHIFT)
#define LCD_BRD_WF_WF53(base, index) (BME_UBFX32(&LCD_WF_REG(base, index), LCD_WF_WF53_SHIFT, LCD_WF_WF53_WIDTH))

/*! @brief Set the WF53 field to a new value. */
#define LCD_WR_WF_WF53(base, index, value) (LCD_RMW_WF(base, index, LCD_WF_WF53_MASK, LCD_WF_WF53(value)))
#define LCD_BWR_WF_WF53(base, index, value) (BME_BFI32(&LCD_WF_REG(base, index), ((uint32_t)(value) << LCD_WF_WF53_SHIFT), LCD_WF_WF53_SHIFT, LCD_WF_WF53_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF, field WF37[15:8] (RW)
 *
 * Controls segments or phases connected to LCD_P37 as described above for
 * WF3TO0[WF3].
 */
/*@{*/
/*! @brief Read current value of the LCD_WF_WF37 field. */
#define LCD_RD_WF_WF37(base, index) ((LCD_WF_REG(base, index) & LCD_WF_WF37_MASK) >> LCD_WF_WF37_SHIFT)
#define LCD_BRD_WF_WF37(base, index) (BME_UBFX32(&LCD_WF_REG(base, index), LCD_WF_WF37_SHIFT, LCD_WF_WF37_WIDTH))

/*! @brief Set the WF37 field to a new value. */
#define LCD_WR_WF_WF37(base, index, value) (LCD_RMW_WF(base, index, LCD_WF_WF37_MASK, LCD_WF_WF37(value)))
#define LCD_BWR_WF_WF37(base, index, value) (BME_BFI32(&LCD_WF_REG(base, index), ((uint32_t)(value) << LCD_WF_WF37_SHIFT), LCD_WF_WF37_SHIFT, LCD_WF_WF37_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF, field WF9[15:8] (RW)
 *
 * Controls segments or phases connected to LCD_P9 as described above for
 * WF3TO0[WF3].
 */
/*@{*/
/*! @brief Read current value of the LCD_WF_WF9 field. */
#define LCD_RD_WF_WF9(base, index) ((LCD_WF_REG(base, index) & LCD_WF_WF9_MASK) >> LCD_WF_WF9_SHIFT)
#define LCD_BRD_WF_WF9(base, index) (BME_UBFX32(&LCD_WF_REG(base, index), LCD_WF_WF9_SHIFT, LCD_WF_WF9_WIDTH))

/*! @brief Set the WF9 field to a new value. */
#define LCD_WR_WF_WF9(base, index, value) (LCD_RMW_WF(base, index, LCD_WF_WF9_MASK, LCD_WF_WF9(value)))
#define LCD_BWR_WF_WF9(base, index, value) (BME_BFI32(&LCD_WF_REG(base, index), ((uint32_t)(value) << LCD_WF_WF9_SHIFT), LCD_WF_WF9_SHIFT, LCD_WF_WF9_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF, field WF1[15:8] (RW)
 *
 * Controls segments or phases connected to LCD_P1 as described above for WF3.
 */
/*@{*/
/*! @brief Read current value of the LCD_WF_WF1 field. */
#define LCD_RD_WF_WF1(base, index) ((LCD_WF_REG(base, index) & LCD_WF_WF1_MASK) >> LCD_WF_WF1_SHIFT)
#define LCD_BRD_WF_WF1(base, index) (BME_UBFX32(&LCD_WF_REG(base, index), LCD_WF_WF1_SHIFT, LCD_WF_WF1_WIDTH))

/*! @brief Set the WF1 field to a new value. */
#define LCD_WR_WF_WF1(base, index, value) (LCD_RMW_WF(base, index, LCD_WF_WF1_MASK, LCD_WF_WF1(value)))
#define LCD_BWR_WF_WF1(base, index, value) (BME_BFI32(&LCD_WF_REG(base, index), ((uint32_t)(value) << LCD_WF_WF1_SHIFT), LCD_WF_WF1_SHIFT, LCD_WF_WF1_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF, field WF29[15:8] (RW)
 *
 * Controls segments or phases connected to LCD_P29 as described above for
 * WF3TO0[WF3].
 */
/*@{*/
/*! @brief Read current value of the LCD_WF_WF29 field. */
#define LCD_RD_WF_WF29(base, index) ((LCD_WF_REG(base, index) & LCD_WF_WF29_MASK) >> LCD_WF_WF29_SHIFT)
#define LCD_BRD_WF_WF29(base, index) (BME_UBFX32(&LCD_WF_REG(base, index), LCD_WF_WF29_SHIFT, LCD_WF_WF29_WIDTH))

/*! @brief Set the WF29 field to a new value. */
#define LCD_WR_WF_WF29(base, index, value) (LCD_RMW_WF(base, index, LCD_WF_WF29_MASK, LCD_WF_WF29(value)))
#define LCD_BWR_WF_WF29(base, index, value) (BME_BFI32(&LCD_WF_REG(base, index), ((uint32_t)(value) << LCD_WF_WF29_SHIFT), LCD_WF_WF29_SHIFT, LCD_WF_WF29_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF, field WF33[15:8] (RW)
 *
 * Controls segments or phases connected to LCD_P33 as described above for
 * WF3TO0[WF3].
 */
/*@{*/
/*! @brief Read current value of the LCD_WF_WF33 field. */
#define LCD_RD_WF_WF33(base, index) ((LCD_WF_REG(base, index) & LCD_WF_WF33_MASK) >> LCD_WF_WF33_SHIFT)
#define LCD_BRD_WF_WF33(base, index) (BME_UBFX32(&LCD_WF_REG(base, index), LCD_WF_WF33_SHIFT, LCD_WF_WF33_WIDTH))

/*! @brief Set the WF33 field to a new value. */
#define LCD_WR_WF_WF33(base, index, value) (LCD_RMW_WF(base, index, LCD_WF_WF33_MASK, LCD_WF_WF33(value)))
#define LCD_BWR_WF_WF33(base, index, value) (BME_BFI32(&LCD_WF_REG(base, index), ((uint32_t)(value) << LCD_WF_WF33_SHIFT), LCD_WF_WF33_SHIFT, LCD_WF_WF33_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF, field WF21[15:8] (RW)
 *
 * Controls segments or phases connected to LCD_P21 as described above for
 * WF3TO0[WF3].
 */
/*@{*/
/*! @brief Read current value of the LCD_WF_WF21 field. */
#define LCD_RD_WF_WF21(base, index) ((LCD_WF_REG(base, index) & LCD_WF_WF21_MASK) >> LCD_WF_WF21_SHIFT)
#define LCD_BRD_WF_WF21(base, index) (BME_UBFX32(&LCD_WF_REG(base, index), LCD_WF_WF21_SHIFT, LCD_WF_WF21_WIDTH))

/*! @brief Set the WF21 field to a new value. */
#define LCD_WR_WF_WF21(base, index, value) (LCD_RMW_WF(base, index, LCD_WF_WF21_MASK, LCD_WF_WF21(value)))
#define LCD_BWR_WF_WF21(base, index, value) (BME_BFI32(&LCD_WF_REG(base, index), ((uint32_t)(value) << LCD_WF_WF21_SHIFT), LCD_WF_WF21_SHIFT, LCD_WF_WF21_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF, field WF26[23:16] (RW)
 *
 * Controls segments or phases connected to LCD_P26 as described above for
 * WF3TO0[WF3].
 */
/*@{*/
/*! @brief Read current value of the LCD_WF_WF26 field. */
#define LCD_RD_WF_WF26(base, index) ((LCD_WF_REG(base, index) & LCD_WF_WF26_MASK) >> LCD_WF_WF26_SHIFT)
#define LCD_BRD_WF_WF26(base, index) (BME_UBFX32(&LCD_WF_REG(base, index), LCD_WF_WF26_SHIFT, LCD_WF_WF26_WIDTH))

/*! @brief Set the WF26 field to a new value. */
#define LCD_WR_WF_WF26(base, index, value) (LCD_RMW_WF(base, index, LCD_WF_WF26_MASK, LCD_WF_WF26(value)))
#define LCD_BWR_WF_WF26(base, index, value) (BME_BFI32(&LCD_WF_REG(base, index), ((uint32_t)(value) << LCD_WF_WF26_SHIFT), LCD_WF_WF26_SHIFT, LCD_WF_WF26_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF, field WF46[23:16] (RW)
 *
 * Controls segments or phases connected to LCD_P46 as described above for
 * WF3TO0[WF3].
 */
/*@{*/
/*! @brief Read current value of the LCD_WF_WF46 field. */
#define LCD_RD_WF_WF46(base, index) ((LCD_WF_REG(base, index) & LCD_WF_WF46_MASK) >> LCD_WF_WF46_SHIFT)
#define LCD_BRD_WF_WF46(base, index) (BME_UBFX32(&LCD_WF_REG(base, index), LCD_WF_WF46_SHIFT, LCD_WF_WF46_WIDTH))

/*! @brief Set the WF46 field to a new value. */
#define LCD_WR_WF_WF46(base, index, value) (LCD_RMW_WF(base, index, LCD_WF_WF46_MASK, LCD_WF_WF46(value)))
#define LCD_BWR_WF_WF46(base, index, value) (BME_BFI32(&LCD_WF_REG(base, index), ((uint32_t)(value) << LCD_WF_WF46_SHIFT), LCD_WF_WF46_SHIFT, LCD_WF_WF46_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF, field WF6[23:16] (RW)
 *
 * Controls segments or phases connected to LCD_P6 as described above for
 * WF3TO0[WF3].
 */
/*@{*/
/*! @brief Read current value of the LCD_WF_WF6 field. */
#define LCD_RD_WF_WF6(base, index) ((LCD_WF_REG(base, index) & LCD_WF_WF6_MASK) >> LCD_WF_WF6_SHIFT)
#define LCD_BRD_WF_WF6(base, index) (BME_UBFX32(&LCD_WF_REG(base, index), LCD_WF_WF6_SHIFT, LCD_WF_WF6_WIDTH))

/*! @brief Set the WF6 field to a new value. */
#define LCD_WR_WF_WF6(base, index, value) (LCD_RMW_WF(base, index, LCD_WF_WF6_MASK, LCD_WF_WF6(value)))
#define LCD_BWR_WF_WF6(base, index, value) (BME_BFI32(&LCD_WF_REG(base, index), ((uint32_t)(value) << LCD_WF_WF6_SHIFT), LCD_WF_WF6_SHIFT, LCD_WF_WF6_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF, field WF42[23:16] (RW)
 *
 * Controls segments or phases connected to LCD_P42 as described above for
 * WF3TO0[WF3].
 */
/*@{*/
/*! @brief Read current value of the LCD_WF_WF42 field. */
#define LCD_RD_WF_WF42(base, index) ((LCD_WF_REG(base, index) & LCD_WF_WF42_MASK) >> LCD_WF_WF42_SHIFT)
#define LCD_BRD_WF_WF42(base, index) (BME_UBFX32(&LCD_WF_REG(base, index), LCD_WF_WF42_SHIFT, LCD_WF_WF42_WIDTH))

/*! @brief Set the WF42 field to a new value. */
#define LCD_WR_WF_WF42(base, index, value) (LCD_RMW_WF(base, index, LCD_WF_WF42_MASK, LCD_WF_WF42(value)))
#define LCD_BWR_WF_WF42(base, index, value) (BME_BFI32(&LCD_WF_REG(base, index), ((uint32_t)(value) << LCD_WF_WF42_SHIFT), LCD_WF_WF42_SHIFT, LCD_WF_WF42_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF, field WF18[23:16] (RW)
 *
 * Controls segments or phases connected to LCD_P18 as described above for
 * WF3TO0[WF3].
 */
/*@{*/
/*! @brief Read current value of the LCD_WF_WF18 field. */
#define LCD_RD_WF_WF18(base, index) ((LCD_WF_REG(base, index) & LCD_WF_WF18_MASK) >> LCD_WF_WF18_SHIFT)
#define LCD_BRD_WF_WF18(base, index) (BME_UBFX32(&LCD_WF_REG(base, index), LCD_WF_WF18_SHIFT, LCD_WF_WF18_WIDTH))

/*! @brief Set the WF18 field to a new value. */
#define LCD_WR_WF_WF18(base, index, value) (LCD_RMW_WF(base, index, LCD_WF_WF18_MASK, LCD_WF_WF18(value)))
#define LCD_BWR_WF_WF18(base, index, value) (BME_BFI32(&LCD_WF_REG(base, index), ((uint32_t)(value) << LCD_WF_WF18_SHIFT), LCD_WF_WF18_SHIFT, LCD_WF_WF18_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF, field WF38[23:16] (RW)
 *
 * Controls segments or phases connected to LCD_P38 as described above for
 * WF3TO0[WF3].
 */
/*@{*/
/*! @brief Read current value of the LCD_WF_WF38 field. */
#define LCD_RD_WF_WF38(base, index) ((LCD_WF_REG(base, index) & LCD_WF_WF38_MASK) >> LCD_WF_WF38_SHIFT)
#define LCD_BRD_WF_WF38(base, index) (BME_UBFX32(&LCD_WF_REG(base, index), LCD_WF_WF38_SHIFT, LCD_WF_WF38_WIDTH))

/*! @brief Set the WF38 field to a new value. */
#define LCD_WR_WF_WF38(base, index, value) (LCD_RMW_WF(base, index, LCD_WF_WF38_MASK, LCD_WF_WF38(value)))
#define LCD_BWR_WF_WF38(base, index, value) (BME_BFI32(&LCD_WF_REG(base, index), ((uint32_t)(value) << LCD_WF_WF38_SHIFT), LCD_WF_WF38_SHIFT, LCD_WF_WF38_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF, field WF22[23:16] (RW)
 *
 * Controls segments or phases connected to LCD_P22 as described above for
 * WF3TO0[WF3].
 */
/*@{*/
/*! @brief Read current value of the LCD_WF_WF22 field. */
#define LCD_RD_WF_WF22(base, index) ((LCD_WF_REG(base, index) & LCD_WF_WF22_MASK) >> LCD_WF_WF22_SHIFT)
#define LCD_BRD_WF_WF22(base, index) (BME_UBFX32(&LCD_WF_REG(base, index), LCD_WF_WF22_SHIFT, LCD_WF_WF22_WIDTH))

/*! @brief Set the WF22 field to a new value. */
#define LCD_WR_WF_WF22(base, index, value) (LCD_RMW_WF(base, index, LCD_WF_WF22_MASK, LCD_WF_WF22(value)))
#define LCD_BWR_WF_WF22(base, index, value) (BME_BFI32(&LCD_WF_REG(base, index), ((uint32_t)(value) << LCD_WF_WF22_SHIFT), LCD_WF_WF22_SHIFT, LCD_WF_WF22_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF, field WF34[23:16] (RW)
 *
 * Controls segments or phases connected to LCD_P34 as described above for
 * WF3TO0[WF3].
 */
/*@{*/
/*! @brief Read current value of the LCD_WF_WF34 field. */
#define LCD_RD_WF_WF34(base, index) ((LCD_WF_REG(base, index) & LCD_WF_WF34_MASK) >> LCD_WF_WF34_SHIFT)
#define LCD_BRD_WF_WF34(base, index) (BME_UBFX32(&LCD_WF_REG(base, index), LCD_WF_WF34_SHIFT, LCD_WF_WF34_WIDTH))

/*! @brief Set the WF34 field to a new value. */
#define LCD_WR_WF_WF34(base, index, value) (LCD_RMW_WF(base, index, LCD_WF_WF34_MASK, LCD_WF_WF34(value)))
#define LCD_BWR_WF_WF34(base, index, value) (BME_BFI32(&LCD_WF_REG(base, index), ((uint32_t)(value) << LCD_WF_WF34_SHIFT), LCD_WF_WF34_SHIFT, LCD_WF_WF34_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF, field WF50[23:16] (RW)
 *
 * Controls segments or phases connected to LCD_P50 as described above for
 * WF3TO0[WF3].
 */
/*@{*/
/*! @brief Read current value of the LCD_WF_WF50 field. */
#define LCD_RD_WF_WF50(base, index) ((LCD_WF_REG(base, index) & LCD_WF_WF50_MASK) >> LCD_WF_WF50_SHIFT)
#define LCD_BRD_WF_WF50(base, index) (BME_UBFX32(&LCD_WF_REG(base, index), LCD_WF_WF50_SHIFT, LCD_WF_WF50_WIDTH))

/*! @brief Set the WF50 field to a new value. */
#define LCD_WR_WF_WF50(base, index, value) (LCD_RMW_WF(base, index, LCD_WF_WF50_MASK, LCD_WF_WF50(value)))
#define LCD_BWR_WF_WF50(base, index, value) (BME_BFI32(&LCD_WF_REG(base, index), ((uint32_t)(value) << LCD_WF_WF50_SHIFT), LCD_WF_WF50_SHIFT, LCD_WF_WF50_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF, field WF14[23:16] (RW)
 *
 * Controls segments or phases connected to LCD_P14 as described above for
 * WF3TO0[WF3].
 */
/*@{*/
/*! @brief Read current value of the LCD_WF_WF14 field. */
#define LCD_RD_WF_WF14(base, index) ((LCD_WF_REG(base, index) & LCD_WF_WF14_MASK) >> LCD_WF_WF14_SHIFT)
#define LCD_BRD_WF_WF14(base, index) (BME_UBFX32(&LCD_WF_REG(base, index), LCD_WF_WF14_SHIFT, LCD_WF_WF14_WIDTH))

/*! @brief Set the WF14 field to a new value. */
#define LCD_WR_WF_WF14(base, index, value) (LCD_RMW_WF(base, index, LCD_WF_WF14_MASK, LCD_WF_WF14(value)))
#define LCD_BWR_WF_WF14(base, index, value) (BME_BFI32(&LCD_WF_REG(base, index), ((uint32_t)(value) << LCD_WF_WF14_SHIFT), LCD_WF_WF14_SHIFT, LCD_WF_WF14_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF, field WF54[23:16] (RW)
 *
 * Controls segments or phases connected to LCD_P54 as described above for
 * WF3TO0[WF3].
 */
/*@{*/
/*! @brief Read current value of the LCD_WF_WF54 field. */
#define LCD_RD_WF_WF54(base, index) ((LCD_WF_REG(base, index) & LCD_WF_WF54_MASK) >> LCD_WF_WF54_SHIFT)
#define LCD_BRD_WF_WF54(base, index) (BME_UBFX32(&LCD_WF_REG(base, index), LCD_WF_WF54_SHIFT, LCD_WF_WF54_WIDTH))

/*! @brief Set the WF54 field to a new value. */
#define LCD_WR_WF_WF54(base, index, value) (LCD_RMW_WF(base, index, LCD_WF_WF54_MASK, LCD_WF_WF54(value)))
#define LCD_BWR_WF_WF54(base, index, value) (BME_BFI32(&LCD_WF_REG(base, index), ((uint32_t)(value) << LCD_WF_WF54_SHIFT), LCD_WF_WF54_SHIFT, LCD_WF_WF54_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF, field WF2[23:16] (RW)
 *
 * Controls segments or phases connected to LCD_P2 as described above for WF3.
 */
/*@{*/
/*! @brief Read current value of the LCD_WF_WF2 field. */
#define LCD_RD_WF_WF2(base, index) ((LCD_WF_REG(base, index) & LCD_WF_WF2_MASK) >> LCD_WF_WF2_SHIFT)
#define LCD_BRD_WF_WF2(base, index) (BME_UBFX32(&LCD_WF_REG(base, index), LCD_WF_WF2_SHIFT, LCD_WF_WF2_WIDTH))

/*! @brief Set the WF2 field to a new value. */
#define LCD_WR_WF_WF2(base, index, value) (LCD_RMW_WF(base, index, LCD_WF_WF2_MASK, LCD_WF_WF2(value)))
#define LCD_BWR_WF_WF2(base, index, value) (BME_BFI32(&LCD_WF_REG(base, index), ((uint32_t)(value) << LCD_WF_WF2_SHIFT), LCD_WF_WF2_SHIFT, LCD_WF_WF2_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF, field WF58[23:16] (RW)
 *
 * Controls segments or phases connected to LCD_P58 as described above for
 * WF3TO0[WF3].
 */
/*@{*/
/*! @brief Read current value of the LCD_WF_WF58 field. */
#define LCD_RD_WF_WF58(base, index) ((LCD_WF_REG(base, index) & LCD_WF_WF58_MASK) >> LCD_WF_WF58_SHIFT)
#define LCD_BRD_WF_WF58(base, index) (BME_UBFX32(&LCD_WF_REG(base, index), LCD_WF_WF58_SHIFT, LCD_WF_WF58_WIDTH))

/*! @brief Set the WF58 field to a new value. */
#define LCD_WR_WF_WF58(base, index, value) (LCD_RMW_WF(base, index, LCD_WF_WF58_MASK, LCD_WF_WF58(value)))
#define LCD_BWR_WF_WF58(base, index, value) (BME_BFI32(&LCD_WF_REG(base, index), ((uint32_t)(value) << LCD_WF_WF58_SHIFT), LCD_WF_WF58_SHIFT, LCD_WF_WF58_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF, field WF30[23:16] (RW)
 *
 * Controls segments or phases connected to LCD_P30 as described above for
 * WF3TO0[WF3].
 */
/*@{*/
/*! @brief Read current value of the LCD_WF_WF30 field. */
#define LCD_RD_WF_WF30(base, index) ((LCD_WF_REG(base, index) & LCD_WF_WF30_MASK) >> LCD_WF_WF30_SHIFT)
#define LCD_BRD_WF_WF30(base, index) (BME_UBFX32(&LCD_WF_REG(base, index), LCD_WF_WF30_SHIFT, LCD_WF_WF30_WIDTH))

/*! @brief Set the WF30 field to a new value. */
#define LCD_WR_WF_WF30(base, index, value) (LCD_RMW_WF(base, index, LCD_WF_WF30_MASK, LCD_WF_WF30(value)))
#define LCD_BWR_WF_WF30(base, index, value) (BME_BFI32(&LCD_WF_REG(base, index), ((uint32_t)(value) << LCD_WF_WF30_SHIFT), LCD_WF_WF30_SHIFT, LCD_WF_WF30_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF, field WF62[23:16] (RW)
 *
 * Controls segments or phases connected to LCD_P62 as described above for
 * WF3TO0[WF3].
 */
/*@{*/
/*! @brief Read current value of the LCD_WF_WF62 field. */
#define LCD_RD_WF_WF62(base, index) ((LCD_WF_REG(base, index) & LCD_WF_WF62_MASK) >> LCD_WF_WF62_SHIFT)
#define LCD_BRD_WF_WF62(base, index) (BME_UBFX32(&LCD_WF_REG(base, index), LCD_WF_WF62_SHIFT, LCD_WF_WF62_WIDTH))

/*! @brief Set the WF62 field to a new value. */
#define LCD_WR_WF_WF62(base, index, value) (LCD_RMW_WF(base, index, LCD_WF_WF62_MASK, LCD_WF_WF62(value)))
#define LCD_BWR_WF_WF62(base, index, value) (BME_BFI32(&LCD_WF_REG(base, index), ((uint32_t)(value) << LCD_WF_WF62_SHIFT), LCD_WF_WF62_SHIFT, LCD_WF_WF62_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF, field WF10[23:16] (RW)
 *
 * Controls segments or phases connected to LCD_P10 as described above for
 * WF3TO0[WF3].
 */
/*@{*/
/*! @brief Read current value of the LCD_WF_WF10 field. */
#define LCD_RD_WF_WF10(base, index) ((LCD_WF_REG(base, index) & LCD_WF_WF10_MASK) >> LCD_WF_WF10_SHIFT)
#define LCD_BRD_WF_WF10(base, index) (BME_UBFX32(&LCD_WF_REG(base, index), LCD_WF_WF10_SHIFT, LCD_WF_WF10_WIDTH))

/*! @brief Set the WF10 field to a new value. */
#define LCD_WR_WF_WF10(base, index, value) (LCD_RMW_WF(base, index, LCD_WF_WF10_MASK, LCD_WF_WF10(value)))
#define LCD_BWR_WF_WF10(base, index, value) (BME_BFI32(&LCD_WF_REG(base, index), ((uint32_t)(value) << LCD_WF_WF10_SHIFT), LCD_WF_WF10_SHIFT, LCD_WF_WF10_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF, field WF63[31:24] (RW)
 *
 * Controls segments or phases connected to LCD_P63 as described above for
 * WF3TO0[WF3].
 */
/*@{*/
/*! @brief Read current value of the LCD_WF_WF63 field. */
#define LCD_RD_WF_WF63(base, index) ((LCD_WF_REG(base, index) & LCD_WF_WF63_MASK) >> LCD_WF_WF63_SHIFT)
#define LCD_BRD_WF_WF63(base, index) (BME_UBFX32(&LCD_WF_REG(base, index), LCD_WF_WF63_SHIFT, LCD_WF_WF63_WIDTH))

/*! @brief Set the WF63 field to a new value. */
#define LCD_WR_WF_WF63(base, index, value) (LCD_RMW_WF(base, index, LCD_WF_WF63_MASK, LCD_WF_WF63(value)))
#define LCD_BWR_WF_WF63(base, index, value) (BME_BFI32(&LCD_WF_REG(base, index), ((uint32_t)(value) << LCD_WF_WF63_SHIFT), LCD_WF_WF63_SHIFT, LCD_WF_WF63_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF, field WF59[31:24] (RW)
 *
 * Controls segments or phases connected to LCD_P59 as described above for
 * WF3TO0[WF3].
 */
/*@{*/
/*! @brief Read current value of the LCD_WF_WF59 field. */
#define LCD_RD_WF_WF59(base, index) ((LCD_WF_REG(base, index) & LCD_WF_WF59_MASK) >> LCD_WF_WF59_SHIFT)
#define LCD_BRD_WF_WF59(base, index) (BME_UBFX32(&LCD_WF_REG(base, index), LCD_WF_WF59_SHIFT, LCD_WF_WF59_WIDTH))

/*! @brief Set the WF59 field to a new value. */
#define LCD_WR_WF_WF59(base, index, value) (LCD_RMW_WF(base, index, LCD_WF_WF59_MASK, LCD_WF_WF59(value)))
#define LCD_BWR_WF_WF59(base, index, value) (BME_BFI32(&LCD_WF_REG(base, index), ((uint32_t)(value) << LCD_WF_WF59_SHIFT), LCD_WF_WF59_SHIFT, LCD_WF_WF59_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF, field WF55[31:24] (RW)
 *
 * Controls segments or phases connected to LCD_P55 as described above for
 * WF3TO0[WF3].
 */
/*@{*/
/*! @brief Read current value of the LCD_WF_WF55 field. */
#define LCD_RD_WF_WF55(base, index) ((LCD_WF_REG(base, index) & LCD_WF_WF55_MASK) >> LCD_WF_WF55_SHIFT)
#define LCD_BRD_WF_WF55(base, index) (BME_UBFX32(&LCD_WF_REG(base, index), LCD_WF_WF55_SHIFT, LCD_WF_WF55_WIDTH))

/*! @brief Set the WF55 field to a new value. */
#define LCD_WR_WF_WF55(base, index, value) (LCD_RMW_WF(base, index, LCD_WF_WF55_MASK, LCD_WF_WF55(value)))
#define LCD_BWR_WF_WF55(base, index, value) (BME_BFI32(&LCD_WF_REG(base, index), ((uint32_t)(value) << LCD_WF_WF55_SHIFT), LCD_WF_WF55_SHIFT, LCD_WF_WF55_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF, field WF3[31:24] (RW)
 *
 * Segment-on front plane operation - Each bit turns on or off the segments
 * associated with LCD_P3 in the following pattern: HGFEDCBA (most significant bit
 * controls segment H and least significant bit controls segment A). Segment-on
 * back plane operation - Each bit activates or deactivates the phases associated
 * with LCD_P3 in the following pattern: HGFEDCBA (most significant bit controls
 * phase H and least significant bit controls phase A). For each bit: 0 Segment off
 * or phase deactivated 1 Segment on or phase activated
 */
/*@{*/
/*! @brief Read current value of the LCD_WF_WF3 field. */
#define LCD_RD_WF_WF3(base, index) ((LCD_WF_REG(base, index) & LCD_WF_WF3_MASK) >> LCD_WF_WF3_SHIFT)
#define LCD_BRD_WF_WF3(base, index) (BME_UBFX32(&LCD_WF_REG(base, index), LCD_WF_WF3_SHIFT, LCD_WF_WF3_WIDTH))

/*! @brief Set the WF3 field to a new value. */
#define LCD_WR_WF_WF3(base, index, value) (LCD_RMW_WF(base, index, LCD_WF_WF3_MASK, LCD_WF_WF3(value)))
#define LCD_BWR_WF_WF3(base, index, value) (BME_BFI32(&LCD_WF_REG(base, index), ((uint32_t)(value) << LCD_WF_WF3_SHIFT), LCD_WF_WF3_SHIFT, LCD_WF_WF3_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF, field WF51[31:24] (RW)
 *
 * Controls segments or phases connected to LCD_P51 as described above for
 * WF3TO0[WF3].
 */
/*@{*/
/*! @brief Read current value of the LCD_WF_WF51 field. */
#define LCD_RD_WF_WF51(base, index) ((LCD_WF_REG(base, index) & LCD_WF_WF51_MASK) >> LCD_WF_WF51_SHIFT)
#define LCD_BRD_WF_WF51(base, index) (BME_UBFX32(&LCD_WF_REG(base, index), LCD_WF_WF51_SHIFT, LCD_WF_WF51_WIDTH))

/*! @brief Set the WF51 field to a new value. */
#define LCD_WR_WF_WF51(base, index, value) (LCD_RMW_WF(base, index, LCD_WF_WF51_MASK, LCD_WF_WF51(value)))
#define LCD_BWR_WF_WF51(base, index, value) (BME_BFI32(&LCD_WF_REG(base, index), ((uint32_t)(value) << LCD_WF_WF51_SHIFT), LCD_WF_WF51_SHIFT, LCD_WF_WF51_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF, field WF47[31:24] (RW)
 *
 * Controls segments or phases connected to LCD_P47 as described above for
 * WF3TO0[WF3].
 */
/*@{*/
/*! @brief Read current value of the LCD_WF_WF47 field. */
#define LCD_RD_WF_WF47(base, index) ((LCD_WF_REG(base, index) & LCD_WF_WF47_MASK) >> LCD_WF_WF47_SHIFT)
#define LCD_BRD_WF_WF47(base, index) (BME_UBFX32(&LCD_WF_REG(base, index), LCD_WF_WF47_SHIFT, LCD_WF_WF47_WIDTH))

/*! @brief Set the WF47 field to a new value. */
#define LCD_WR_WF_WF47(base, index, value) (LCD_RMW_WF(base, index, LCD_WF_WF47_MASK, LCD_WF_WF47(value)))
#define LCD_BWR_WF_WF47(base, index, value) (BME_BFI32(&LCD_WF_REG(base, index), ((uint32_t)(value) << LCD_WF_WF47_SHIFT), LCD_WF_WF47_SHIFT, LCD_WF_WF47_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF, field WF43[31:24] (RW)
 *
 * Controls segments or phases connected to LCD_P43 as described above for
 * WF3TO0[WF3].
 */
/*@{*/
/*! @brief Read current value of the LCD_WF_WF43 field. */
#define LCD_RD_WF_WF43(base, index) ((LCD_WF_REG(base, index) & LCD_WF_WF43_MASK) >> LCD_WF_WF43_SHIFT)
#define LCD_BRD_WF_WF43(base, index) (BME_UBFX32(&LCD_WF_REG(base, index), LCD_WF_WF43_SHIFT, LCD_WF_WF43_WIDTH))

/*! @brief Set the WF43 field to a new value. */
#define LCD_WR_WF_WF43(base, index, value) (LCD_RMW_WF(base, index, LCD_WF_WF43_MASK, LCD_WF_WF43(value)))
#define LCD_BWR_WF_WF43(base, index, value) (BME_BFI32(&LCD_WF_REG(base, index), ((uint32_t)(value) << LCD_WF_WF43_SHIFT), LCD_WF_WF43_SHIFT, LCD_WF_WF43_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF, field WF7[31:24] (RW)
 *
 * Controls segments or phases connected to LCD_P7 as described above for
 * WF3TO0[WF3].
 */
/*@{*/
/*! @brief Read current value of the LCD_WF_WF7 field. */
#define LCD_RD_WF_WF7(base, index) ((LCD_WF_REG(base, index) & LCD_WF_WF7_MASK) >> LCD_WF_WF7_SHIFT)
#define LCD_BRD_WF_WF7(base, index) (BME_UBFX32(&LCD_WF_REG(base, index), LCD_WF_WF7_SHIFT, LCD_WF_WF7_WIDTH))

/*! @brief Set the WF7 field to a new value. */
#define LCD_WR_WF_WF7(base, index, value) (LCD_RMW_WF(base, index, LCD_WF_WF7_MASK, LCD_WF_WF7(value)))
#define LCD_BWR_WF_WF7(base, index, value) (BME_BFI32(&LCD_WF_REG(base, index), ((uint32_t)(value) << LCD_WF_WF7_SHIFT), LCD_WF_WF7_SHIFT, LCD_WF_WF7_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF, field WF39[31:24] (RW)
 *
 * Controls segments or phases connected to LCD_P39 as described above for
 * WF3TO0[WF3].
 */
/*@{*/
/*! @brief Read current value of the LCD_WF_WF39 field. */
#define LCD_RD_WF_WF39(base, index) ((LCD_WF_REG(base, index) & LCD_WF_WF39_MASK) >> LCD_WF_WF39_SHIFT)
#define LCD_BRD_WF_WF39(base, index) (BME_UBFX32(&LCD_WF_REG(base, index), LCD_WF_WF39_SHIFT, LCD_WF_WF39_WIDTH))

/*! @brief Set the WF39 field to a new value. */
#define LCD_WR_WF_WF39(base, index, value) (LCD_RMW_WF(base, index, LCD_WF_WF39_MASK, LCD_WF_WF39(value)))
#define LCD_BWR_WF_WF39(base, index, value) (BME_BFI32(&LCD_WF_REG(base, index), ((uint32_t)(value) << LCD_WF_WF39_SHIFT), LCD_WF_WF39_SHIFT, LCD_WF_WF39_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF, field WF35[31:24] (RW)
 *
 * Controls segments or phases connected to LCD_P35 as described above for
 * WF3TO0[WF3].
 */
/*@{*/
/*! @brief Read current value of the LCD_WF_WF35 field. */
#define LCD_RD_WF_WF35(base, index) ((LCD_WF_REG(base, index) & LCD_WF_WF35_MASK) >> LCD_WF_WF35_SHIFT)
#define LCD_BRD_WF_WF35(base, index) (BME_UBFX32(&LCD_WF_REG(base, index), LCD_WF_WF35_SHIFT, LCD_WF_WF35_WIDTH))

/*! @brief Set the WF35 field to a new value. */
#define LCD_WR_WF_WF35(base, index, value) (LCD_RMW_WF(base, index, LCD_WF_WF35_MASK, LCD_WF_WF35(value)))
#define LCD_BWR_WF_WF35(base, index, value) (BME_BFI32(&LCD_WF_REG(base, index), ((uint32_t)(value) << LCD_WF_WF35_SHIFT), LCD_WF_WF35_SHIFT, LCD_WF_WF35_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF, field WF31[31:24] (RW)
 *
 * Controls segments or phases connected to LCD_P31 as described above for
 * WF3TO0[WF3].
 */
/*@{*/
/*! @brief Read current value of the LCD_WF_WF31 field. */
#define LCD_RD_WF_WF31(base, index) ((LCD_WF_REG(base, index) & LCD_WF_WF31_MASK) >> LCD_WF_WF31_SHIFT)
#define LCD_BRD_WF_WF31(base, index) (BME_UBFX32(&LCD_WF_REG(base, index), LCD_WF_WF31_SHIFT, LCD_WF_WF31_WIDTH))

/*! @brief Set the WF31 field to a new value. */
#define LCD_WR_WF_WF31(base, index, value) (LCD_RMW_WF(base, index, LCD_WF_WF31_MASK, LCD_WF_WF31(value)))
#define LCD_BWR_WF_WF31(base, index, value) (BME_BFI32(&LCD_WF_REG(base, index), ((uint32_t)(value) << LCD_WF_WF31_SHIFT), LCD_WF_WF31_SHIFT, LCD_WF_WF31_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF, field WF11[31:24] (RW)
 *
 * Controls segments or phases connected to LCD_P11 as described above for
 * WF3TO0[WF3].
 */
/*@{*/
/*! @brief Read current value of the LCD_WF_WF11 field. */
#define LCD_RD_WF_WF11(base, index) ((LCD_WF_REG(base, index) & LCD_WF_WF11_MASK) >> LCD_WF_WF11_SHIFT)
#define LCD_BRD_WF_WF11(base, index) (BME_UBFX32(&LCD_WF_REG(base, index), LCD_WF_WF11_SHIFT, LCD_WF_WF11_WIDTH))

/*! @brief Set the WF11 field to a new value. */
#define LCD_WR_WF_WF11(base, index, value) (LCD_RMW_WF(base, index, LCD_WF_WF11_MASK, LCD_WF_WF11(value)))
#define LCD_BWR_WF_WF11(base, index, value) (BME_BFI32(&LCD_WF_REG(base, index), ((uint32_t)(value) << LCD_WF_WF11_SHIFT), LCD_WF_WF11_SHIFT, LCD_WF_WF11_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF, field WF27[31:24] (RW)
 *
 * Controls segments or phases connected to LCD_P27 as described above for
 * WF3TO0[WF3].
 */
/*@{*/
/*! @brief Read current value of the LCD_WF_WF27 field. */
#define LCD_RD_WF_WF27(base, index) ((LCD_WF_REG(base, index) & LCD_WF_WF27_MASK) >> LCD_WF_WF27_SHIFT)
#define LCD_BRD_WF_WF27(base, index) (BME_UBFX32(&LCD_WF_REG(base, index), LCD_WF_WF27_SHIFT, LCD_WF_WF27_WIDTH))

/*! @brief Set the WF27 field to a new value. */
#define LCD_WR_WF_WF27(base, index, value) (LCD_RMW_WF(base, index, LCD_WF_WF27_MASK, LCD_WF_WF27(value)))
#define LCD_BWR_WF_WF27(base, index, value) (BME_BFI32(&LCD_WF_REG(base, index), ((uint32_t)(value) << LCD_WF_WF27_SHIFT), LCD_WF_WF27_SHIFT, LCD_WF_WF27_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF, field WF23[31:24] (RW)
 *
 * Controls segments or phases connected to LCD_P23 as described above for
 * WF3TO0[WF3].
 */
/*@{*/
/*! @brief Read current value of the LCD_WF_WF23 field. */
#define LCD_RD_WF_WF23(base, index) ((LCD_WF_REG(base, index) & LCD_WF_WF23_MASK) >> LCD_WF_WF23_SHIFT)
#define LCD_BRD_WF_WF23(base, index) (BME_UBFX32(&LCD_WF_REG(base, index), LCD_WF_WF23_SHIFT, LCD_WF_WF23_WIDTH))

/*! @brief Set the WF23 field to a new value. */
#define LCD_WR_WF_WF23(base, index, value) (LCD_RMW_WF(base, index, LCD_WF_WF23_MASK, LCD_WF_WF23(value)))
#define LCD_BWR_WF_WF23(base, index, value) (BME_BFI32(&LCD_WF_REG(base, index), ((uint32_t)(value) << LCD_WF_WF23_SHIFT), LCD_WF_WF23_SHIFT, LCD_WF_WF23_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF, field WF19[31:24] (RW)
 *
 * Controls segments or phases connected to LCD_P19 as described above for
 * WF3TO0[WF3].
 */
/*@{*/
/*! @brief Read current value of the LCD_WF_WF19 field. */
#define LCD_RD_WF_WF19(base, index) ((LCD_WF_REG(base, index) & LCD_WF_WF19_MASK) >> LCD_WF_WF19_SHIFT)
#define LCD_BRD_WF_WF19(base, index) (BME_UBFX32(&LCD_WF_REG(base, index), LCD_WF_WF19_SHIFT, LCD_WF_WF19_WIDTH))

/*! @brief Set the WF19 field to a new value. */
#define LCD_WR_WF_WF19(base, index, value) (LCD_RMW_WF(base, index, LCD_WF_WF19_MASK, LCD_WF_WF19(value)))
#define LCD_BWR_WF_WF19(base, index, value) (BME_BFI32(&LCD_WF_REG(base, index), ((uint32_t)(value) << LCD_WF_WF19_SHIFT), LCD_WF_WF19_SHIFT, LCD_WF_WF19_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF, field WF15[31:24] (RW)
 *
 * Controls segments or phases connected to LCD_P15 as described above for
 * WF3TO0[WF3].
 */
/*@{*/
/*! @brief Read current value of the LCD_WF_WF15 field. */
#define LCD_RD_WF_WF15(base, index) ((LCD_WF_REG(base, index) & LCD_WF_WF15_MASK) >> LCD_WF_WF15_SHIFT)
#define LCD_BRD_WF_WF15(base, index) (BME_UBFX32(&LCD_WF_REG(base, index), LCD_WF_WF15_SHIFT, LCD_WF_WF15_WIDTH))

/*! @brief Set the WF15 field to a new value. */
#define LCD_WR_WF_WF15(base, index, value) (LCD_RMW_WF(base, index, LCD_WF_WF15_MASK, LCD_WF_WF15(value)))
#define LCD_BWR_WF_WF15(base, index, value) (BME_BFI32(&LCD_WF_REG(base, index), ((uint32_t)(value) << LCD_WF_WF15_SHIFT), LCD_WF_WF15_SHIFT, LCD_WF_WF15_WIDTH))
/*@}*/

/*******************************************************************************
 * LCD_WF8B - LCD Waveform Register 0.
 ******************************************************************************/

/*!
 * @brief LCD_WF8B - LCD Waveform Register 0. (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire LCD_WF8B register
 */
/*@{*/
#define LCD_RD_WF8B(base, index) (LCD_WF8B_REG(base, index))
#define LCD_WR_WF8B(base, index, value) (LCD_WF8B_REG(base, index) = (value))
#define LCD_RMW_WF8B(base, index, mask, value) (LCD_WR_WF8B(base, index, (LCD_RD_WF8B(base, index) & ~(mask)) | (value)))
#define LCD_SET_WF8B(base, index, value) (BME_OR8(&LCD_WF8B_REG(base, index), (uint8_t)(value)))
#define LCD_CLR_WF8B(base, index, value) (BME_AND8(&LCD_WF8B_REG(base, index), (uint8_t)(~(value))))
#define LCD_TOG_WF8B(base, index, value) (BME_XOR8(&LCD_WF8B_REG(base, index), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual LCD_WF8B bitfields
 */

/*!
 * @name Register LCD_WF8B, field BPALCD0[0] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase A
 * - 0b1 - LCD segment on or LCD backplane active for phase A
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPALCD0 field. */
#define LCD_RD_WF8B_BPALCD0(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPALCD0_MASK) >> LCD_WF8B_BPALCD0_SHIFT)
#define LCD_BRD_WF8B_BPALCD0(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPALCD0_SHIFT, LCD_WF8B_BPALCD0_WIDTH))

/*! @brief Set the BPALCD0 field to a new value. */
#define LCD_WR_WF8B_BPALCD0(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPALCD0_MASK, LCD_WF8B_BPALCD0(value)))
#define LCD_BWR_WF8B_BPALCD0(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPALCD0_SHIFT), LCD_WF8B_BPALCD0_SHIFT, LCD_WF8B_BPALCD0_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPALCD63[0] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase A
 * - 0b1 - LCD segment on or LCD backplane active for phase A
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPALCD63 field. */
#define LCD_RD_WF8B_BPALCD63(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPALCD63_MASK) >> LCD_WF8B_BPALCD63_SHIFT)
#define LCD_BRD_WF8B_BPALCD63(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPALCD63_SHIFT, LCD_WF8B_BPALCD63_WIDTH))

/*! @brief Set the BPALCD63 field to a new value. */
#define LCD_WR_WF8B_BPALCD63(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPALCD63_MASK, LCD_WF8B_BPALCD63(value)))
#define LCD_BWR_WF8B_BPALCD63(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPALCD63_SHIFT), LCD_WF8B_BPALCD63_SHIFT, LCD_WF8B_BPALCD63_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPALCD62[0] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase A
 * - 0b1 - LCD segment on or LCD backplane active for phase A
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPALCD62 field. */
#define LCD_RD_WF8B_BPALCD62(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPALCD62_MASK) >> LCD_WF8B_BPALCD62_SHIFT)
#define LCD_BRD_WF8B_BPALCD62(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPALCD62_SHIFT, LCD_WF8B_BPALCD62_WIDTH))

/*! @brief Set the BPALCD62 field to a new value. */
#define LCD_WR_WF8B_BPALCD62(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPALCD62_MASK, LCD_WF8B_BPALCD62(value)))
#define LCD_BWR_WF8B_BPALCD62(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPALCD62_SHIFT), LCD_WF8B_BPALCD62_SHIFT, LCD_WF8B_BPALCD62_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPALCD61[0] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase A
 * - 0b1 - LCD segment on or LCD backplane active for phase A
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPALCD61 field. */
#define LCD_RD_WF8B_BPALCD61(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPALCD61_MASK) >> LCD_WF8B_BPALCD61_SHIFT)
#define LCD_BRD_WF8B_BPALCD61(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPALCD61_SHIFT, LCD_WF8B_BPALCD61_WIDTH))

/*! @brief Set the BPALCD61 field to a new value. */
#define LCD_WR_WF8B_BPALCD61(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPALCD61_MASK, LCD_WF8B_BPALCD61(value)))
#define LCD_BWR_WF8B_BPALCD61(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPALCD61_SHIFT), LCD_WF8B_BPALCD61_SHIFT, LCD_WF8B_BPALCD61_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPALCD60[0] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase A
 * - 0b1 - LCD segment on or LCD backplane active for phase A
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPALCD60 field. */
#define LCD_RD_WF8B_BPALCD60(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPALCD60_MASK) >> LCD_WF8B_BPALCD60_SHIFT)
#define LCD_BRD_WF8B_BPALCD60(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPALCD60_SHIFT, LCD_WF8B_BPALCD60_WIDTH))

/*! @brief Set the BPALCD60 field to a new value. */
#define LCD_WR_WF8B_BPALCD60(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPALCD60_MASK, LCD_WF8B_BPALCD60(value)))
#define LCD_BWR_WF8B_BPALCD60(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPALCD60_SHIFT), LCD_WF8B_BPALCD60_SHIFT, LCD_WF8B_BPALCD60_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPALCD59[0] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase A
 * - 0b1 - LCD segment on or LCD backplane active for phase A
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPALCD59 field. */
#define LCD_RD_WF8B_BPALCD59(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPALCD59_MASK) >> LCD_WF8B_BPALCD59_SHIFT)
#define LCD_BRD_WF8B_BPALCD59(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPALCD59_SHIFT, LCD_WF8B_BPALCD59_WIDTH))

/*! @brief Set the BPALCD59 field to a new value. */
#define LCD_WR_WF8B_BPALCD59(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPALCD59_MASK, LCD_WF8B_BPALCD59(value)))
#define LCD_BWR_WF8B_BPALCD59(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPALCD59_SHIFT), LCD_WF8B_BPALCD59_SHIFT, LCD_WF8B_BPALCD59_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPALCD58[0] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase A
 * - 0b1 - LCD segment on or LCD backplane active for phase A
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPALCD58 field. */
#define LCD_RD_WF8B_BPALCD58(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPALCD58_MASK) >> LCD_WF8B_BPALCD58_SHIFT)
#define LCD_BRD_WF8B_BPALCD58(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPALCD58_SHIFT, LCD_WF8B_BPALCD58_WIDTH))

/*! @brief Set the BPALCD58 field to a new value. */
#define LCD_WR_WF8B_BPALCD58(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPALCD58_MASK, LCD_WF8B_BPALCD58(value)))
#define LCD_BWR_WF8B_BPALCD58(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPALCD58_SHIFT), LCD_WF8B_BPALCD58_SHIFT, LCD_WF8B_BPALCD58_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPALCD57[0] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase A
 * - 0b1 - LCD segment on or LCD backplane active for phase A
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPALCD57 field. */
#define LCD_RD_WF8B_BPALCD57(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPALCD57_MASK) >> LCD_WF8B_BPALCD57_SHIFT)
#define LCD_BRD_WF8B_BPALCD57(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPALCD57_SHIFT, LCD_WF8B_BPALCD57_WIDTH))

/*! @brief Set the BPALCD57 field to a new value. */
#define LCD_WR_WF8B_BPALCD57(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPALCD57_MASK, LCD_WF8B_BPALCD57(value)))
#define LCD_BWR_WF8B_BPALCD57(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPALCD57_SHIFT), LCD_WF8B_BPALCD57_SHIFT, LCD_WF8B_BPALCD57_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPALCD1[0] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase A
 * - 0b1 - LCD segment on or LCD backplane active for phase A
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPALCD1 field. */
#define LCD_RD_WF8B_BPALCD1(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPALCD1_MASK) >> LCD_WF8B_BPALCD1_SHIFT)
#define LCD_BRD_WF8B_BPALCD1(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPALCD1_SHIFT, LCD_WF8B_BPALCD1_WIDTH))

/*! @brief Set the BPALCD1 field to a new value. */
#define LCD_WR_WF8B_BPALCD1(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPALCD1_MASK, LCD_WF8B_BPALCD1(value)))
#define LCD_BWR_WF8B_BPALCD1(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPALCD1_SHIFT), LCD_WF8B_BPALCD1_SHIFT, LCD_WF8B_BPALCD1_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPALCD56[0] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase A
 * - 0b1 - LCD segment on or LCD backplane active for phase A
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPALCD56 field. */
#define LCD_RD_WF8B_BPALCD56(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPALCD56_MASK) >> LCD_WF8B_BPALCD56_SHIFT)
#define LCD_BRD_WF8B_BPALCD56(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPALCD56_SHIFT, LCD_WF8B_BPALCD56_WIDTH))

/*! @brief Set the BPALCD56 field to a new value. */
#define LCD_WR_WF8B_BPALCD56(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPALCD56_MASK, LCD_WF8B_BPALCD56(value)))
#define LCD_BWR_WF8B_BPALCD56(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPALCD56_SHIFT), LCD_WF8B_BPALCD56_SHIFT, LCD_WF8B_BPALCD56_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPALCD55[0] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase A
 * - 0b1 - LCD segment on or LCD backplane active for phase A
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPALCD55 field. */
#define LCD_RD_WF8B_BPALCD55(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPALCD55_MASK) >> LCD_WF8B_BPALCD55_SHIFT)
#define LCD_BRD_WF8B_BPALCD55(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPALCD55_SHIFT, LCD_WF8B_BPALCD55_WIDTH))

/*! @brief Set the BPALCD55 field to a new value. */
#define LCD_WR_WF8B_BPALCD55(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPALCD55_MASK, LCD_WF8B_BPALCD55(value)))
#define LCD_BWR_WF8B_BPALCD55(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPALCD55_SHIFT), LCD_WF8B_BPALCD55_SHIFT, LCD_WF8B_BPALCD55_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPALCD54[0] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase A
 * - 0b1 - LCD segment on or LCD backplane active for phase A
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPALCD54 field. */
#define LCD_RD_WF8B_BPALCD54(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPALCD54_MASK) >> LCD_WF8B_BPALCD54_SHIFT)
#define LCD_BRD_WF8B_BPALCD54(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPALCD54_SHIFT, LCD_WF8B_BPALCD54_WIDTH))

/*! @brief Set the BPALCD54 field to a new value. */
#define LCD_WR_WF8B_BPALCD54(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPALCD54_MASK, LCD_WF8B_BPALCD54(value)))
#define LCD_BWR_WF8B_BPALCD54(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPALCD54_SHIFT), LCD_WF8B_BPALCD54_SHIFT, LCD_WF8B_BPALCD54_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPALCD53[0] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase A
 * - 0b1 - LCD segment on or LCD backplane active for phase A
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPALCD53 field. */
#define LCD_RD_WF8B_BPALCD53(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPALCD53_MASK) >> LCD_WF8B_BPALCD53_SHIFT)
#define LCD_BRD_WF8B_BPALCD53(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPALCD53_SHIFT, LCD_WF8B_BPALCD53_WIDTH))

/*! @brief Set the BPALCD53 field to a new value. */
#define LCD_WR_WF8B_BPALCD53(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPALCD53_MASK, LCD_WF8B_BPALCD53(value)))
#define LCD_BWR_WF8B_BPALCD53(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPALCD53_SHIFT), LCD_WF8B_BPALCD53_SHIFT, LCD_WF8B_BPALCD53_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPALCD52[0] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase A
 * - 0b1 - LCD segment on or LCD backplane active for phase A
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPALCD52 field. */
#define LCD_RD_WF8B_BPALCD52(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPALCD52_MASK) >> LCD_WF8B_BPALCD52_SHIFT)
#define LCD_BRD_WF8B_BPALCD52(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPALCD52_SHIFT, LCD_WF8B_BPALCD52_WIDTH))

/*! @brief Set the BPALCD52 field to a new value. */
#define LCD_WR_WF8B_BPALCD52(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPALCD52_MASK, LCD_WF8B_BPALCD52(value)))
#define LCD_BWR_WF8B_BPALCD52(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPALCD52_SHIFT), LCD_WF8B_BPALCD52_SHIFT, LCD_WF8B_BPALCD52_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPALCD51[0] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase A
 * - 0b1 - LCD segment on or LCD backplane active for phase A
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPALCD51 field. */
#define LCD_RD_WF8B_BPALCD51(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPALCD51_MASK) >> LCD_WF8B_BPALCD51_SHIFT)
#define LCD_BRD_WF8B_BPALCD51(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPALCD51_SHIFT, LCD_WF8B_BPALCD51_WIDTH))

/*! @brief Set the BPALCD51 field to a new value. */
#define LCD_WR_WF8B_BPALCD51(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPALCD51_MASK, LCD_WF8B_BPALCD51(value)))
#define LCD_BWR_WF8B_BPALCD51(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPALCD51_SHIFT), LCD_WF8B_BPALCD51_SHIFT, LCD_WF8B_BPALCD51_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPALCD50[0] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase A
 * - 0b1 - LCD segment on or LCD backplane active for phase A
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPALCD50 field. */
#define LCD_RD_WF8B_BPALCD50(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPALCD50_MASK) >> LCD_WF8B_BPALCD50_SHIFT)
#define LCD_BRD_WF8B_BPALCD50(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPALCD50_SHIFT, LCD_WF8B_BPALCD50_WIDTH))

/*! @brief Set the BPALCD50 field to a new value. */
#define LCD_WR_WF8B_BPALCD50(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPALCD50_MASK, LCD_WF8B_BPALCD50(value)))
#define LCD_BWR_WF8B_BPALCD50(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPALCD50_SHIFT), LCD_WF8B_BPALCD50_SHIFT, LCD_WF8B_BPALCD50_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPALCD2[0] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase A
 * - 0b1 - LCD segment on or LCD backplane active for phase A
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPALCD2 field. */
#define LCD_RD_WF8B_BPALCD2(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPALCD2_MASK) >> LCD_WF8B_BPALCD2_SHIFT)
#define LCD_BRD_WF8B_BPALCD2(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPALCD2_SHIFT, LCD_WF8B_BPALCD2_WIDTH))

/*! @brief Set the BPALCD2 field to a new value. */
#define LCD_WR_WF8B_BPALCD2(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPALCD2_MASK, LCD_WF8B_BPALCD2(value)))
#define LCD_BWR_WF8B_BPALCD2(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPALCD2_SHIFT), LCD_WF8B_BPALCD2_SHIFT, LCD_WF8B_BPALCD2_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPALCD49[0] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase A
 * - 0b1 - LCD segment on or LCD backplane active for phase A
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPALCD49 field. */
#define LCD_RD_WF8B_BPALCD49(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPALCD49_MASK) >> LCD_WF8B_BPALCD49_SHIFT)
#define LCD_BRD_WF8B_BPALCD49(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPALCD49_SHIFT, LCD_WF8B_BPALCD49_WIDTH))

/*! @brief Set the BPALCD49 field to a new value. */
#define LCD_WR_WF8B_BPALCD49(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPALCD49_MASK, LCD_WF8B_BPALCD49(value)))
#define LCD_BWR_WF8B_BPALCD49(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPALCD49_SHIFT), LCD_WF8B_BPALCD49_SHIFT, LCD_WF8B_BPALCD49_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPALCD48[0] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase A
 * - 0b1 - LCD segment on or LCD backplane active for phase A
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPALCD48 field. */
#define LCD_RD_WF8B_BPALCD48(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPALCD48_MASK) >> LCD_WF8B_BPALCD48_SHIFT)
#define LCD_BRD_WF8B_BPALCD48(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPALCD48_SHIFT, LCD_WF8B_BPALCD48_WIDTH))

/*! @brief Set the BPALCD48 field to a new value. */
#define LCD_WR_WF8B_BPALCD48(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPALCD48_MASK, LCD_WF8B_BPALCD48(value)))
#define LCD_BWR_WF8B_BPALCD48(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPALCD48_SHIFT), LCD_WF8B_BPALCD48_SHIFT, LCD_WF8B_BPALCD48_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPALCD47[0] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase A
 * - 0b1 - LCD segment on or LCD backplane active for phase A
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPALCD47 field. */
#define LCD_RD_WF8B_BPALCD47(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPALCD47_MASK) >> LCD_WF8B_BPALCD47_SHIFT)
#define LCD_BRD_WF8B_BPALCD47(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPALCD47_SHIFT, LCD_WF8B_BPALCD47_WIDTH))

/*! @brief Set the BPALCD47 field to a new value. */
#define LCD_WR_WF8B_BPALCD47(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPALCD47_MASK, LCD_WF8B_BPALCD47(value)))
#define LCD_BWR_WF8B_BPALCD47(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPALCD47_SHIFT), LCD_WF8B_BPALCD47_SHIFT, LCD_WF8B_BPALCD47_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPALCD46[0] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase A
 * - 0b1 - LCD segment on or LCD backplane active for phase A
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPALCD46 field. */
#define LCD_RD_WF8B_BPALCD46(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPALCD46_MASK) >> LCD_WF8B_BPALCD46_SHIFT)
#define LCD_BRD_WF8B_BPALCD46(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPALCD46_SHIFT, LCD_WF8B_BPALCD46_WIDTH))

/*! @brief Set the BPALCD46 field to a new value. */
#define LCD_WR_WF8B_BPALCD46(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPALCD46_MASK, LCD_WF8B_BPALCD46(value)))
#define LCD_BWR_WF8B_BPALCD46(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPALCD46_SHIFT), LCD_WF8B_BPALCD46_SHIFT, LCD_WF8B_BPALCD46_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPALCD45[0] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase A
 * - 0b1 - LCD segment on or LCD backplane active for phase A
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPALCD45 field. */
#define LCD_RD_WF8B_BPALCD45(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPALCD45_MASK) >> LCD_WF8B_BPALCD45_SHIFT)
#define LCD_BRD_WF8B_BPALCD45(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPALCD45_SHIFT, LCD_WF8B_BPALCD45_WIDTH))

/*! @brief Set the BPALCD45 field to a new value. */
#define LCD_WR_WF8B_BPALCD45(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPALCD45_MASK, LCD_WF8B_BPALCD45(value)))
#define LCD_BWR_WF8B_BPALCD45(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPALCD45_SHIFT), LCD_WF8B_BPALCD45_SHIFT, LCD_WF8B_BPALCD45_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPALCD44[0] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase A
 * - 0b1 - LCD segment on or LCD backplane active for phase A
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPALCD44 field. */
#define LCD_RD_WF8B_BPALCD44(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPALCD44_MASK) >> LCD_WF8B_BPALCD44_SHIFT)
#define LCD_BRD_WF8B_BPALCD44(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPALCD44_SHIFT, LCD_WF8B_BPALCD44_WIDTH))

/*! @brief Set the BPALCD44 field to a new value. */
#define LCD_WR_WF8B_BPALCD44(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPALCD44_MASK, LCD_WF8B_BPALCD44(value)))
#define LCD_BWR_WF8B_BPALCD44(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPALCD44_SHIFT), LCD_WF8B_BPALCD44_SHIFT, LCD_WF8B_BPALCD44_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPALCD43[0] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase A
 * - 0b1 - LCD segment on or LCD backplane active for phase A
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPALCD43 field. */
#define LCD_RD_WF8B_BPALCD43(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPALCD43_MASK) >> LCD_WF8B_BPALCD43_SHIFT)
#define LCD_BRD_WF8B_BPALCD43(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPALCD43_SHIFT, LCD_WF8B_BPALCD43_WIDTH))

/*! @brief Set the BPALCD43 field to a new value. */
#define LCD_WR_WF8B_BPALCD43(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPALCD43_MASK, LCD_WF8B_BPALCD43(value)))
#define LCD_BWR_WF8B_BPALCD43(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPALCD43_SHIFT), LCD_WF8B_BPALCD43_SHIFT, LCD_WF8B_BPALCD43_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPALCD3[0] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase A
 * - 0b1 - LCD segment on or LCD backplane active for phase A
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPALCD3 field. */
#define LCD_RD_WF8B_BPALCD3(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPALCD3_MASK) >> LCD_WF8B_BPALCD3_SHIFT)
#define LCD_BRD_WF8B_BPALCD3(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPALCD3_SHIFT, LCD_WF8B_BPALCD3_WIDTH))

/*! @brief Set the BPALCD3 field to a new value. */
#define LCD_WR_WF8B_BPALCD3(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPALCD3_MASK, LCD_WF8B_BPALCD3(value)))
#define LCD_BWR_WF8B_BPALCD3(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPALCD3_SHIFT), LCD_WF8B_BPALCD3_SHIFT, LCD_WF8B_BPALCD3_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPALCD42[0] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase A
 * - 0b1 - LCD segment on or LCD backplane active for phase A
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPALCD42 field. */
#define LCD_RD_WF8B_BPALCD42(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPALCD42_MASK) >> LCD_WF8B_BPALCD42_SHIFT)
#define LCD_BRD_WF8B_BPALCD42(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPALCD42_SHIFT, LCD_WF8B_BPALCD42_WIDTH))

/*! @brief Set the BPALCD42 field to a new value. */
#define LCD_WR_WF8B_BPALCD42(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPALCD42_MASK, LCD_WF8B_BPALCD42(value)))
#define LCD_BWR_WF8B_BPALCD42(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPALCD42_SHIFT), LCD_WF8B_BPALCD42_SHIFT, LCD_WF8B_BPALCD42_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPALCD41[0] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase A
 * - 0b1 - LCD segment on or LCD backplane active for phase A
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPALCD41 field. */
#define LCD_RD_WF8B_BPALCD41(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPALCD41_MASK) >> LCD_WF8B_BPALCD41_SHIFT)
#define LCD_BRD_WF8B_BPALCD41(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPALCD41_SHIFT, LCD_WF8B_BPALCD41_WIDTH))

/*! @brief Set the BPALCD41 field to a new value. */
#define LCD_WR_WF8B_BPALCD41(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPALCD41_MASK, LCD_WF8B_BPALCD41(value)))
#define LCD_BWR_WF8B_BPALCD41(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPALCD41_SHIFT), LCD_WF8B_BPALCD41_SHIFT, LCD_WF8B_BPALCD41_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPALCD40[0] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase A
 * - 0b1 - LCD segment on or LCD backplane active for phase A
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPALCD40 field. */
#define LCD_RD_WF8B_BPALCD40(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPALCD40_MASK) >> LCD_WF8B_BPALCD40_SHIFT)
#define LCD_BRD_WF8B_BPALCD40(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPALCD40_SHIFT, LCD_WF8B_BPALCD40_WIDTH))

/*! @brief Set the BPALCD40 field to a new value. */
#define LCD_WR_WF8B_BPALCD40(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPALCD40_MASK, LCD_WF8B_BPALCD40(value)))
#define LCD_BWR_WF8B_BPALCD40(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPALCD40_SHIFT), LCD_WF8B_BPALCD40_SHIFT, LCD_WF8B_BPALCD40_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPALCD39[0] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase A
 * - 0b1 - LCD segment on or LCD backplane active for phase A
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPALCD39 field. */
#define LCD_RD_WF8B_BPALCD39(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPALCD39_MASK) >> LCD_WF8B_BPALCD39_SHIFT)
#define LCD_BRD_WF8B_BPALCD39(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPALCD39_SHIFT, LCD_WF8B_BPALCD39_WIDTH))

/*! @brief Set the BPALCD39 field to a new value. */
#define LCD_WR_WF8B_BPALCD39(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPALCD39_MASK, LCD_WF8B_BPALCD39(value)))
#define LCD_BWR_WF8B_BPALCD39(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPALCD39_SHIFT), LCD_WF8B_BPALCD39_SHIFT, LCD_WF8B_BPALCD39_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPALCD38[0] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase A
 * - 0b1 - LCD segment on or LCD backplane active for phase A
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPALCD38 field. */
#define LCD_RD_WF8B_BPALCD38(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPALCD38_MASK) >> LCD_WF8B_BPALCD38_SHIFT)
#define LCD_BRD_WF8B_BPALCD38(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPALCD38_SHIFT, LCD_WF8B_BPALCD38_WIDTH))

/*! @brief Set the BPALCD38 field to a new value. */
#define LCD_WR_WF8B_BPALCD38(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPALCD38_MASK, LCD_WF8B_BPALCD38(value)))
#define LCD_BWR_WF8B_BPALCD38(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPALCD38_SHIFT), LCD_WF8B_BPALCD38_SHIFT, LCD_WF8B_BPALCD38_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPALCD37[0] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase A
 * - 0b1 - LCD segment on or LCD backplane active for phase A
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPALCD37 field. */
#define LCD_RD_WF8B_BPALCD37(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPALCD37_MASK) >> LCD_WF8B_BPALCD37_SHIFT)
#define LCD_BRD_WF8B_BPALCD37(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPALCD37_SHIFT, LCD_WF8B_BPALCD37_WIDTH))

/*! @brief Set the BPALCD37 field to a new value. */
#define LCD_WR_WF8B_BPALCD37(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPALCD37_MASK, LCD_WF8B_BPALCD37(value)))
#define LCD_BWR_WF8B_BPALCD37(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPALCD37_SHIFT), LCD_WF8B_BPALCD37_SHIFT, LCD_WF8B_BPALCD37_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPALCD36[0] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase A
 * - 0b1 - LCD segment on or LCD backplane active for phase A
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPALCD36 field. */
#define LCD_RD_WF8B_BPALCD36(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPALCD36_MASK) >> LCD_WF8B_BPALCD36_SHIFT)
#define LCD_BRD_WF8B_BPALCD36(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPALCD36_SHIFT, LCD_WF8B_BPALCD36_WIDTH))

/*! @brief Set the BPALCD36 field to a new value. */
#define LCD_WR_WF8B_BPALCD36(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPALCD36_MASK, LCD_WF8B_BPALCD36(value)))
#define LCD_BWR_WF8B_BPALCD36(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPALCD36_SHIFT), LCD_WF8B_BPALCD36_SHIFT, LCD_WF8B_BPALCD36_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPALCD4[0] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase A
 * - 0b1 - LCD segment on or LCD backplane active for phase A
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPALCD4 field. */
#define LCD_RD_WF8B_BPALCD4(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPALCD4_MASK) >> LCD_WF8B_BPALCD4_SHIFT)
#define LCD_BRD_WF8B_BPALCD4(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPALCD4_SHIFT, LCD_WF8B_BPALCD4_WIDTH))

/*! @brief Set the BPALCD4 field to a new value. */
#define LCD_WR_WF8B_BPALCD4(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPALCD4_MASK, LCD_WF8B_BPALCD4(value)))
#define LCD_BWR_WF8B_BPALCD4(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPALCD4_SHIFT), LCD_WF8B_BPALCD4_SHIFT, LCD_WF8B_BPALCD4_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPALCD35[0] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase A
 * - 0b1 - LCD segment on or LCD backplane active for phase A
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPALCD35 field. */
#define LCD_RD_WF8B_BPALCD35(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPALCD35_MASK) >> LCD_WF8B_BPALCD35_SHIFT)
#define LCD_BRD_WF8B_BPALCD35(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPALCD35_SHIFT, LCD_WF8B_BPALCD35_WIDTH))

/*! @brief Set the BPALCD35 field to a new value. */
#define LCD_WR_WF8B_BPALCD35(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPALCD35_MASK, LCD_WF8B_BPALCD35(value)))
#define LCD_BWR_WF8B_BPALCD35(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPALCD35_SHIFT), LCD_WF8B_BPALCD35_SHIFT, LCD_WF8B_BPALCD35_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPALCD34[0] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase A
 * - 0b1 - LCD segment on or LCD backplane active for phase A
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPALCD34 field. */
#define LCD_RD_WF8B_BPALCD34(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPALCD34_MASK) >> LCD_WF8B_BPALCD34_SHIFT)
#define LCD_BRD_WF8B_BPALCD34(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPALCD34_SHIFT, LCD_WF8B_BPALCD34_WIDTH))

/*! @brief Set the BPALCD34 field to a new value. */
#define LCD_WR_WF8B_BPALCD34(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPALCD34_MASK, LCD_WF8B_BPALCD34(value)))
#define LCD_BWR_WF8B_BPALCD34(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPALCD34_SHIFT), LCD_WF8B_BPALCD34_SHIFT, LCD_WF8B_BPALCD34_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPALCD33[0] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase A
 * - 0b1 - LCD segment on or LCD backplane active for phase A
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPALCD33 field. */
#define LCD_RD_WF8B_BPALCD33(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPALCD33_MASK) >> LCD_WF8B_BPALCD33_SHIFT)
#define LCD_BRD_WF8B_BPALCD33(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPALCD33_SHIFT, LCD_WF8B_BPALCD33_WIDTH))

/*! @brief Set the BPALCD33 field to a new value. */
#define LCD_WR_WF8B_BPALCD33(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPALCD33_MASK, LCD_WF8B_BPALCD33(value)))
#define LCD_BWR_WF8B_BPALCD33(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPALCD33_SHIFT), LCD_WF8B_BPALCD33_SHIFT, LCD_WF8B_BPALCD33_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPALCD32[0] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase A
 * - 0b1 - LCD segment on or LCD backplane active for phase A
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPALCD32 field. */
#define LCD_RD_WF8B_BPALCD32(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPALCD32_MASK) >> LCD_WF8B_BPALCD32_SHIFT)
#define LCD_BRD_WF8B_BPALCD32(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPALCD32_SHIFT, LCD_WF8B_BPALCD32_WIDTH))

/*! @brief Set the BPALCD32 field to a new value. */
#define LCD_WR_WF8B_BPALCD32(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPALCD32_MASK, LCD_WF8B_BPALCD32(value)))
#define LCD_BWR_WF8B_BPALCD32(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPALCD32_SHIFT), LCD_WF8B_BPALCD32_SHIFT, LCD_WF8B_BPALCD32_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPALCD31[0] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase A
 * - 0b1 - LCD segment on or LCD backplane active for phase A
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPALCD31 field. */
#define LCD_RD_WF8B_BPALCD31(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPALCD31_MASK) >> LCD_WF8B_BPALCD31_SHIFT)
#define LCD_BRD_WF8B_BPALCD31(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPALCD31_SHIFT, LCD_WF8B_BPALCD31_WIDTH))

/*! @brief Set the BPALCD31 field to a new value. */
#define LCD_WR_WF8B_BPALCD31(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPALCD31_MASK, LCD_WF8B_BPALCD31(value)))
#define LCD_BWR_WF8B_BPALCD31(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPALCD31_SHIFT), LCD_WF8B_BPALCD31_SHIFT, LCD_WF8B_BPALCD31_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPALCD30[0] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase A
 * - 0b1 - LCD segment on or LCD backplane active for phase A
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPALCD30 field. */
#define LCD_RD_WF8B_BPALCD30(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPALCD30_MASK) >> LCD_WF8B_BPALCD30_SHIFT)
#define LCD_BRD_WF8B_BPALCD30(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPALCD30_SHIFT, LCD_WF8B_BPALCD30_WIDTH))

/*! @brief Set the BPALCD30 field to a new value. */
#define LCD_WR_WF8B_BPALCD30(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPALCD30_MASK, LCD_WF8B_BPALCD30(value)))
#define LCD_BWR_WF8B_BPALCD30(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPALCD30_SHIFT), LCD_WF8B_BPALCD30_SHIFT, LCD_WF8B_BPALCD30_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPALCD29[0] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase A
 * - 0b1 - LCD segment on or LCD backplane active for phase A
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPALCD29 field. */
#define LCD_RD_WF8B_BPALCD29(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPALCD29_MASK) >> LCD_WF8B_BPALCD29_SHIFT)
#define LCD_BRD_WF8B_BPALCD29(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPALCD29_SHIFT, LCD_WF8B_BPALCD29_WIDTH))

/*! @brief Set the BPALCD29 field to a new value. */
#define LCD_WR_WF8B_BPALCD29(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPALCD29_MASK, LCD_WF8B_BPALCD29(value)))
#define LCD_BWR_WF8B_BPALCD29(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPALCD29_SHIFT), LCD_WF8B_BPALCD29_SHIFT, LCD_WF8B_BPALCD29_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPALCD5[0] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase A
 * - 0b1 - LCD segment on or LCD backplane active for phase A
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPALCD5 field. */
#define LCD_RD_WF8B_BPALCD5(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPALCD5_MASK) >> LCD_WF8B_BPALCD5_SHIFT)
#define LCD_BRD_WF8B_BPALCD5(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPALCD5_SHIFT, LCD_WF8B_BPALCD5_WIDTH))

/*! @brief Set the BPALCD5 field to a new value. */
#define LCD_WR_WF8B_BPALCD5(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPALCD5_MASK, LCD_WF8B_BPALCD5(value)))
#define LCD_BWR_WF8B_BPALCD5(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPALCD5_SHIFT), LCD_WF8B_BPALCD5_SHIFT, LCD_WF8B_BPALCD5_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPALCD28[0] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase A
 * - 0b1 - LCD segment on or LCD backplane active for phase A
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPALCD28 field. */
#define LCD_RD_WF8B_BPALCD28(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPALCD28_MASK) >> LCD_WF8B_BPALCD28_SHIFT)
#define LCD_BRD_WF8B_BPALCD28(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPALCD28_SHIFT, LCD_WF8B_BPALCD28_WIDTH))

/*! @brief Set the BPALCD28 field to a new value. */
#define LCD_WR_WF8B_BPALCD28(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPALCD28_MASK, LCD_WF8B_BPALCD28(value)))
#define LCD_BWR_WF8B_BPALCD28(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPALCD28_SHIFT), LCD_WF8B_BPALCD28_SHIFT, LCD_WF8B_BPALCD28_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPALCD27[0] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase A
 * - 0b1 - LCD segment on or LCD backplane active for phase A
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPALCD27 field. */
#define LCD_RD_WF8B_BPALCD27(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPALCD27_MASK) >> LCD_WF8B_BPALCD27_SHIFT)
#define LCD_BRD_WF8B_BPALCD27(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPALCD27_SHIFT, LCD_WF8B_BPALCD27_WIDTH))

/*! @brief Set the BPALCD27 field to a new value. */
#define LCD_WR_WF8B_BPALCD27(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPALCD27_MASK, LCD_WF8B_BPALCD27(value)))
#define LCD_BWR_WF8B_BPALCD27(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPALCD27_SHIFT), LCD_WF8B_BPALCD27_SHIFT, LCD_WF8B_BPALCD27_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPALCD26[0] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase A
 * - 0b1 - LCD segment on or LCD backplane active for phase A
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPALCD26 field. */
#define LCD_RD_WF8B_BPALCD26(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPALCD26_MASK) >> LCD_WF8B_BPALCD26_SHIFT)
#define LCD_BRD_WF8B_BPALCD26(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPALCD26_SHIFT, LCD_WF8B_BPALCD26_WIDTH))

/*! @brief Set the BPALCD26 field to a new value. */
#define LCD_WR_WF8B_BPALCD26(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPALCD26_MASK, LCD_WF8B_BPALCD26(value)))
#define LCD_BWR_WF8B_BPALCD26(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPALCD26_SHIFT), LCD_WF8B_BPALCD26_SHIFT, LCD_WF8B_BPALCD26_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPALCD25[0] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase A
 * - 0b1 - LCD segment on or LCD backplane active for phase A
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPALCD25 field. */
#define LCD_RD_WF8B_BPALCD25(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPALCD25_MASK) >> LCD_WF8B_BPALCD25_SHIFT)
#define LCD_BRD_WF8B_BPALCD25(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPALCD25_SHIFT, LCD_WF8B_BPALCD25_WIDTH))

/*! @brief Set the BPALCD25 field to a new value. */
#define LCD_WR_WF8B_BPALCD25(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPALCD25_MASK, LCD_WF8B_BPALCD25(value)))
#define LCD_BWR_WF8B_BPALCD25(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPALCD25_SHIFT), LCD_WF8B_BPALCD25_SHIFT, LCD_WF8B_BPALCD25_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPALCD24[0] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase A
 * - 0b1 - LCD segment on or LCD backplane active for phase A
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPALCD24 field. */
#define LCD_RD_WF8B_BPALCD24(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPALCD24_MASK) >> LCD_WF8B_BPALCD24_SHIFT)
#define LCD_BRD_WF8B_BPALCD24(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPALCD24_SHIFT, LCD_WF8B_BPALCD24_WIDTH))

/*! @brief Set the BPALCD24 field to a new value. */
#define LCD_WR_WF8B_BPALCD24(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPALCD24_MASK, LCD_WF8B_BPALCD24(value)))
#define LCD_BWR_WF8B_BPALCD24(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPALCD24_SHIFT), LCD_WF8B_BPALCD24_SHIFT, LCD_WF8B_BPALCD24_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPALCD23[0] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase A
 * - 0b1 - LCD segment on or LCD backplane active for phase A
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPALCD23 field. */
#define LCD_RD_WF8B_BPALCD23(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPALCD23_MASK) >> LCD_WF8B_BPALCD23_SHIFT)
#define LCD_BRD_WF8B_BPALCD23(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPALCD23_SHIFT, LCD_WF8B_BPALCD23_WIDTH))

/*! @brief Set the BPALCD23 field to a new value. */
#define LCD_WR_WF8B_BPALCD23(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPALCD23_MASK, LCD_WF8B_BPALCD23(value)))
#define LCD_BWR_WF8B_BPALCD23(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPALCD23_SHIFT), LCD_WF8B_BPALCD23_SHIFT, LCD_WF8B_BPALCD23_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPALCD22[0] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase A
 * - 0b1 - LCD segment on or LCD backplane active for phase A
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPALCD22 field. */
#define LCD_RD_WF8B_BPALCD22(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPALCD22_MASK) >> LCD_WF8B_BPALCD22_SHIFT)
#define LCD_BRD_WF8B_BPALCD22(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPALCD22_SHIFT, LCD_WF8B_BPALCD22_WIDTH))

/*! @brief Set the BPALCD22 field to a new value. */
#define LCD_WR_WF8B_BPALCD22(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPALCD22_MASK, LCD_WF8B_BPALCD22(value)))
#define LCD_BWR_WF8B_BPALCD22(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPALCD22_SHIFT), LCD_WF8B_BPALCD22_SHIFT, LCD_WF8B_BPALCD22_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPALCD6[0] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase A
 * - 0b1 - LCD segment on or LCD backplane active for phase A
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPALCD6 field. */
#define LCD_RD_WF8B_BPALCD6(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPALCD6_MASK) >> LCD_WF8B_BPALCD6_SHIFT)
#define LCD_BRD_WF8B_BPALCD6(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPALCD6_SHIFT, LCD_WF8B_BPALCD6_WIDTH))

/*! @brief Set the BPALCD6 field to a new value. */
#define LCD_WR_WF8B_BPALCD6(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPALCD6_MASK, LCD_WF8B_BPALCD6(value)))
#define LCD_BWR_WF8B_BPALCD6(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPALCD6_SHIFT), LCD_WF8B_BPALCD6_SHIFT, LCD_WF8B_BPALCD6_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPALCD21[0] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase A
 * - 0b1 - LCD segment on or LCD backplane active for phase A
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPALCD21 field. */
#define LCD_RD_WF8B_BPALCD21(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPALCD21_MASK) >> LCD_WF8B_BPALCD21_SHIFT)
#define LCD_BRD_WF8B_BPALCD21(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPALCD21_SHIFT, LCD_WF8B_BPALCD21_WIDTH))

/*! @brief Set the BPALCD21 field to a new value. */
#define LCD_WR_WF8B_BPALCD21(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPALCD21_MASK, LCD_WF8B_BPALCD21(value)))
#define LCD_BWR_WF8B_BPALCD21(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPALCD21_SHIFT), LCD_WF8B_BPALCD21_SHIFT, LCD_WF8B_BPALCD21_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPALCD20[0] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase A
 * - 0b1 - LCD segment on or LCD backplane active for phase A
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPALCD20 field. */
#define LCD_RD_WF8B_BPALCD20(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPALCD20_MASK) >> LCD_WF8B_BPALCD20_SHIFT)
#define LCD_BRD_WF8B_BPALCD20(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPALCD20_SHIFT, LCD_WF8B_BPALCD20_WIDTH))

/*! @brief Set the BPALCD20 field to a new value. */
#define LCD_WR_WF8B_BPALCD20(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPALCD20_MASK, LCD_WF8B_BPALCD20(value)))
#define LCD_BWR_WF8B_BPALCD20(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPALCD20_SHIFT), LCD_WF8B_BPALCD20_SHIFT, LCD_WF8B_BPALCD20_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPALCD19[0] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase A
 * - 0b1 - LCD segment on or LCD backplane active for phase A
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPALCD19 field. */
#define LCD_RD_WF8B_BPALCD19(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPALCD19_MASK) >> LCD_WF8B_BPALCD19_SHIFT)
#define LCD_BRD_WF8B_BPALCD19(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPALCD19_SHIFT, LCD_WF8B_BPALCD19_WIDTH))

/*! @brief Set the BPALCD19 field to a new value. */
#define LCD_WR_WF8B_BPALCD19(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPALCD19_MASK, LCD_WF8B_BPALCD19(value)))
#define LCD_BWR_WF8B_BPALCD19(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPALCD19_SHIFT), LCD_WF8B_BPALCD19_SHIFT, LCD_WF8B_BPALCD19_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPALCD18[0] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase A
 * - 0b1 - LCD segment on or LCD backplane active for phase A
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPALCD18 field. */
#define LCD_RD_WF8B_BPALCD18(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPALCD18_MASK) >> LCD_WF8B_BPALCD18_SHIFT)
#define LCD_BRD_WF8B_BPALCD18(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPALCD18_SHIFT, LCD_WF8B_BPALCD18_WIDTH))

/*! @brief Set the BPALCD18 field to a new value. */
#define LCD_WR_WF8B_BPALCD18(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPALCD18_MASK, LCD_WF8B_BPALCD18(value)))
#define LCD_BWR_WF8B_BPALCD18(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPALCD18_SHIFT), LCD_WF8B_BPALCD18_SHIFT, LCD_WF8B_BPALCD18_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPALCD17[0] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase A
 * - 0b1 - LCD segment on or LCD backplane active for phase A
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPALCD17 field. */
#define LCD_RD_WF8B_BPALCD17(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPALCD17_MASK) >> LCD_WF8B_BPALCD17_SHIFT)
#define LCD_BRD_WF8B_BPALCD17(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPALCD17_SHIFT, LCD_WF8B_BPALCD17_WIDTH))

/*! @brief Set the BPALCD17 field to a new value. */
#define LCD_WR_WF8B_BPALCD17(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPALCD17_MASK, LCD_WF8B_BPALCD17(value)))
#define LCD_BWR_WF8B_BPALCD17(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPALCD17_SHIFT), LCD_WF8B_BPALCD17_SHIFT, LCD_WF8B_BPALCD17_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPALCD16[0] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase A
 * - 0b1 - LCD segment on or LCD backplane active for phase A
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPALCD16 field. */
#define LCD_RD_WF8B_BPALCD16(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPALCD16_MASK) >> LCD_WF8B_BPALCD16_SHIFT)
#define LCD_BRD_WF8B_BPALCD16(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPALCD16_SHIFT, LCD_WF8B_BPALCD16_WIDTH))

/*! @brief Set the BPALCD16 field to a new value. */
#define LCD_WR_WF8B_BPALCD16(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPALCD16_MASK, LCD_WF8B_BPALCD16(value)))
#define LCD_BWR_WF8B_BPALCD16(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPALCD16_SHIFT), LCD_WF8B_BPALCD16_SHIFT, LCD_WF8B_BPALCD16_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPALCD15[0] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase A
 * - 0b1 - LCD segment on or LCD backplane active for phase A
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPALCD15 field. */
#define LCD_RD_WF8B_BPALCD15(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPALCD15_MASK) >> LCD_WF8B_BPALCD15_SHIFT)
#define LCD_BRD_WF8B_BPALCD15(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPALCD15_SHIFT, LCD_WF8B_BPALCD15_WIDTH))

/*! @brief Set the BPALCD15 field to a new value. */
#define LCD_WR_WF8B_BPALCD15(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPALCD15_MASK, LCD_WF8B_BPALCD15(value)))
#define LCD_BWR_WF8B_BPALCD15(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPALCD15_SHIFT), LCD_WF8B_BPALCD15_SHIFT, LCD_WF8B_BPALCD15_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPALCD7[0] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase A
 * - 0b1 - LCD segment on or LCD backplane active for phase A
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPALCD7 field. */
#define LCD_RD_WF8B_BPALCD7(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPALCD7_MASK) >> LCD_WF8B_BPALCD7_SHIFT)
#define LCD_BRD_WF8B_BPALCD7(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPALCD7_SHIFT, LCD_WF8B_BPALCD7_WIDTH))

/*! @brief Set the BPALCD7 field to a new value. */
#define LCD_WR_WF8B_BPALCD7(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPALCD7_MASK, LCD_WF8B_BPALCD7(value)))
#define LCD_BWR_WF8B_BPALCD7(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPALCD7_SHIFT), LCD_WF8B_BPALCD7_SHIFT, LCD_WF8B_BPALCD7_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPALCD14[0] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase A
 * - 0b1 - LCD segment on or LCD backplane active for phase A
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPALCD14 field. */
#define LCD_RD_WF8B_BPALCD14(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPALCD14_MASK) >> LCD_WF8B_BPALCD14_SHIFT)
#define LCD_BRD_WF8B_BPALCD14(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPALCD14_SHIFT, LCD_WF8B_BPALCD14_WIDTH))

/*! @brief Set the BPALCD14 field to a new value. */
#define LCD_WR_WF8B_BPALCD14(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPALCD14_MASK, LCD_WF8B_BPALCD14(value)))
#define LCD_BWR_WF8B_BPALCD14(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPALCD14_SHIFT), LCD_WF8B_BPALCD14_SHIFT, LCD_WF8B_BPALCD14_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPALCD13[0] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase A
 * - 0b1 - LCD segment on or LCD backplane active for phase A
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPALCD13 field. */
#define LCD_RD_WF8B_BPALCD13(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPALCD13_MASK) >> LCD_WF8B_BPALCD13_SHIFT)
#define LCD_BRD_WF8B_BPALCD13(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPALCD13_SHIFT, LCD_WF8B_BPALCD13_WIDTH))

/*! @brief Set the BPALCD13 field to a new value. */
#define LCD_WR_WF8B_BPALCD13(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPALCD13_MASK, LCD_WF8B_BPALCD13(value)))
#define LCD_BWR_WF8B_BPALCD13(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPALCD13_SHIFT), LCD_WF8B_BPALCD13_SHIFT, LCD_WF8B_BPALCD13_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPALCD12[0] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase A
 * - 0b1 - LCD segment on or LCD backplane active for phase A
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPALCD12 field. */
#define LCD_RD_WF8B_BPALCD12(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPALCD12_MASK) >> LCD_WF8B_BPALCD12_SHIFT)
#define LCD_BRD_WF8B_BPALCD12(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPALCD12_SHIFT, LCD_WF8B_BPALCD12_WIDTH))

/*! @brief Set the BPALCD12 field to a new value. */
#define LCD_WR_WF8B_BPALCD12(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPALCD12_MASK, LCD_WF8B_BPALCD12(value)))
#define LCD_BWR_WF8B_BPALCD12(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPALCD12_SHIFT), LCD_WF8B_BPALCD12_SHIFT, LCD_WF8B_BPALCD12_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPALCD11[0] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase A
 * - 0b1 - LCD segment on or LCD backplane active for phase A
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPALCD11 field. */
#define LCD_RD_WF8B_BPALCD11(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPALCD11_MASK) >> LCD_WF8B_BPALCD11_SHIFT)
#define LCD_BRD_WF8B_BPALCD11(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPALCD11_SHIFT, LCD_WF8B_BPALCD11_WIDTH))

/*! @brief Set the BPALCD11 field to a new value. */
#define LCD_WR_WF8B_BPALCD11(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPALCD11_MASK, LCD_WF8B_BPALCD11(value)))
#define LCD_BWR_WF8B_BPALCD11(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPALCD11_SHIFT), LCD_WF8B_BPALCD11_SHIFT, LCD_WF8B_BPALCD11_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPALCD10[0] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase A
 * - 0b1 - LCD segment on or LCD backplane active for phase A
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPALCD10 field. */
#define LCD_RD_WF8B_BPALCD10(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPALCD10_MASK) >> LCD_WF8B_BPALCD10_SHIFT)
#define LCD_BRD_WF8B_BPALCD10(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPALCD10_SHIFT, LCD_WF8B_BPALCD10_WIDTH))

/*! @brief Set the BPALCD10 field to a new value. */
#define LCD_WR_WF8B_BPALCD10(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPALCD10_MASK, LCD_WF8B_BPALCD10(value)))
#define LCD_BWR_WF8B_BPALCD10(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPALCD10_SHIFT), LCD_WF8B_BPALCD10_SHIFT, LCD_WF8B_BPALCD10_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPALCD9[0] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase A
 * - 0b1 - LCD segment on or LCD backplane active for phase A
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPALCD9 field. */
#define LCD_RD_WF8B_BPALCD9(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPALCD9_MASK) >> LCD_WF8B_BPALCD9_SHIFT)
#define LCD_BRD_WF8B_BPALCD9(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPALCD9_SHIFT, LCD_WF8B_BPALCD9_WIDTH))

/*! @brief Set the BPALCD9 field to a new value. */
#define LCD_WR_WF8B_BPALCD9(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPALCD9_MASK, LCD_WF8B_BPALCD9(value)))
#define LCD_BWR_WF8B_BPALCD9(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPALCD9_SHIFT), LCD_WF8B_BPALCD9_SHIFT, LCD_WF8B_BPALCD9_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPALCD8[0] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase A
 * - 0b1 - LCD segment on or LCD backplane active for phase A
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPALCD8 field. */
#define LCD_RD_WF8B_BPALCD8(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPALCD8_MASK) >> LCD_WF8B_BPALCD8_SHIFT)
#define LCD_BRD_WF8B_BPALCD8(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPALCD8_SHIFT, LCD_WF8B_BPALCD8_WIDTH))

/*! @brief Set the BPALCD8 field to a new value. */
#define LCD_WR_WF8B_BPALCD8(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPALCD8_MASK, LCD_WF8B_BPALCD8(value)))
#define LCD_BWR_WF8B_BPALCD8(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPALCD8_SHIFT), LCD_WF8B_BPALCD8_SHIFT, LCD_WF8B_BPALCD8_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPBLCD1[1] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase B
 * - 0b1 - LCD segment on or LCD backplane active for phase B
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPBLCD1 field. */
#define LCD_RD_WF8B_BPBLCD1(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPBLCD1_MASK) >> LCD_WF8B_BPBLCD1_SHIFT)
#define LCD_BRD_WF8B_BPBLCD1(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPBLCD1_SHIFT, LCD_WF8B_BPBLCD1_WIDTH))

/*! @brief Set the BPBLCD1 field to a new value. */
#define LCD_WR_WF8B_BPBLCD1(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPBLCD1_MASK, LCD_WF8B_BPBLCD1(value)))
#define LCD_BWR_WF8B_BPBLCD1(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPBLCD1_SHIFT), LCD_WF8B_BPBLCD1_SHIFT, LCD_WF8B_BPBLCD1_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPBLCD32[1] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase B
 * - 0b1 - LCD segment on or LCD backplane active for phase B
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPBLCD32 field. */
#define LCD_RD_WF8B_BPBLCD32(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPBLCD32_MASK) >> LCD_WF8B_BPBLCD32_SHIFT)
#define LCD_BRD_WF8B_BPBLCD32(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPBLCD32_SHIFT, LCD_WF8B_BPBLCD32_WIDTH))

/*! @brief Set the BPBLCD32 field to a new value. */
#define LCD_WR_WF8B_BPBLCD32(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPBLCD32_MASK, LCD_WF8B_BPBLCD32(value)))
#define LCD_BWR_WF8B_BPBLCD32(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPBLCD32_SHIFT), LCD_WF8B_BPBLCD32_SHIFT, LCD_WF8B_BPBLCD32_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPBLCD30[1] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase B
 * - 0b1 - LCD segment on or LCD backplane active for phase B
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPBLCD30 field. */
#define LCD_RD_WF8B_BPBLCD30(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPBLCD30_MASK) >> LCD_WF8B_BPBLCD30_SHIFT)
#define LCD_BRD_WF8B_BPBLCD30(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPBLCD30_SHIFT, LCD_WF8B_BPBLCD30_WIDTH))

/*! @brief Set the BPBLCD30 field to a new value. */
#define LCD_WR_WF8B_BPBLCD30(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPBLCD30_MASK, LCD_WF8B_BPBLCD30(value)))
#define LCD_BWR_WF8B_BPBLCD30(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPBLCD30_SHIFT), LCD_WF8B_BPBLCD30_SHIFT, LCD_WF8B_BPBLCD30_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPBLCD60[1] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase B
 * - 0b1 - LCD segment on or LCD backplane active for phase B
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPBLCD60 field. */
#define LCD_RD_WF8B_BPBLCD60(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPBLCD60_MASK) >> LCD_WF8B_BPBLCD60_SHIFT)
#define LCD_BRD_WF8B_BPBLCD60(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPBLCD60_SHIFT, LCD_WF8B_BPBLCD60_WIDTH))

/*! @brief Set the BPBLCD60 field to a new value. */
#define LCD_WR_WF8B_BPBLCD60(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPBLCD60_MASK, LCD_WF8B_BPBLCD60(value)))
#define LCD_BWR_WF8B_BPBLCD60(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPBLCD60_SHIFT), LCD_WF8B_BPBLCD60_SHIFT, LCD_WF8B_BPBLCD60_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPBLCD24[1] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase B
 * - 0b1 - LCD segment on or LCD backplane active for phase B
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPBLCD24 field. */
#define LCD_RD_WF8B_BPBLCD24(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPBLCD24_MASK) >> LCD_WF8B_BPBLCD24_SHIFT)
#define LCD_BRD_WF8B_BPBLCD24(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPBLCD24_SHIFT, LCD_WF8B_BPBLCD24_WIDTH))

/*! @brief Set the BPBLCD24 field to a new value. */
#define LCD_WR_WF8B_BPBLCD24(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPBLCD24_MASK, LCD_WF8B_BPBLCD24(value)))
#define LCD_BWR_WF8B_BPBLCD24(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPBLCD24_SHIFT), LCD_WF8B_BPBLCD24_SHIFT, LCD_WF8B_BPBLCD24_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPBLCD28[1] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase B
 * - 0b1 - LCD segment on or LCD backplane active for phase B
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPBLCD28 field. */
#define LCD_RD_WF8B_BPBLCD28(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPBLCD28_MASK) >> LCD_WF8B_BPBLCD28_SHIFT)
#define LCD_BRD_WF8B_BPBLCD28(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPBLCD28_SHIFT, LCD_WF8B_BPBLCD28_WIDTH))

/*! @brief Set the BPBLCD28 field to a new value. */
#define LCD_WR_WF8B_BPBLCD28(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPBLCD28_MASK, LCD_WF8B_BPBLCD28(value)))
#define LCD_BWR_WF8B_BPBLCD28(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPBLCD28_SHIFT), LCD_WF8B_BPBLCD28_SHIFT, LCD_WF8B_BPBLCD28_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPBLCD23[1] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase B
 * - 0b1 - LCD segment on or LCD backplane active for phase B
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPBLCD23 field. */
#define LCD_RD_WF8B_BPBLCD23(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPBLCD23_MASK) >> LCD_WF8B_BPBLCD23_SHIFT)
#define LCD_BRD_WF8B_BPBLCD23(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPBLCD23_SHIFT, LCD_WF8B_BPBLCD23_WIDTH))

/*! @brief Set the BPBLCD23 field to a new value. */
#define LCD_WR_WF8B_BPBLCD23(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPBLCD23_MASK, LCD_WF8B_BPBLCD23(value)))
#define LCD_BWR_WF8B_BPBLCD23(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPBLCD23_SHIFT), LCD_WF8B_BPBLCD23_SHIFT, LCD_WF8B_BPBLCD23_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPBLCD48[1] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase B
 * - 0b1 - LCD segment on or LCD backplane active for phase B
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPBLCD48 field. */
#define LCD_RD_WF8B_BPBLCD48(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPBLCD48_MASK) >> LCD_WF8B_BPBLCD48_SHIFT)
#define LCD_BRD_WF8B_BPBLCD48(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPBLCD48_SHIFT, LCD_WF8B_BPBLCD48_WIDTH))

/*! @brief Set the BPBLCD48 field to a new value. */
#define LCD_WR_WF8B_BPBLCD48(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPBLCD48_MASK, LCD_WF8B_BPBLCD48(value)))
#define LCD_BWR_WF8B_BPBLCD48(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPBLCD48_SHIFT), LCD_WF8B_BPBLCD48_SHIFT, LCD_WF8B_BPBLCD48_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPBLCD10[1] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase B
 * - 0b1 - LCD segment on or LCD backplane active for phase B
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPBLCD10 field. */
#define LCD_RD_WF8B_BPBLCD10(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPBLCD10_MASK) >> LCD_WF8B_BPBLCD10_SHIFT)
#define LCD_BRD_WF8B_BPBLCD10(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPBLCD10_SHIFT, LCD_WF8B_BPBLCD10_WIDTH))

/*! @brief Set the BPBLCD10 field to a new value. */
#define LCD_WR_WF8B_BPBLCD10(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPBLCD10_MASK, LCD_WF8B_BPBLCD10(value)))
#define LCD_BWR_WF8B_BPBLCD10(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPBLCD10_SHIFT), LCD_WF8B_BPBLCD10_SHIFT, LCD_WF8B_BPBLCD10_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPBLCD15[1] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase B
 * - 0b1 - LCD segment on or LCD backplane active for phase B
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPBLCD15 field. */
#define LCD_RD_WF8B_BPBLCD15(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPBLCD15_MASK) >> LCD_WF8B_BPBLCD15_SHIFT)
#define LCD_BRD_WF8B_BPBLCD15(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPBLCD15_SHIFT, LCD_WF8B_BPBLCD15_WIDTH))

/*! @brief Set the BPBLCD15 field to a new value. */
#define LCD_WR_WF8B_BPBLCD15(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPBLCD15_MASK, LCD_WF8B_BPBLCD15(value)))
#define LCD_BWR_WF8B_BPBLCD15(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPBLCD15_SHIFT), LCD_WF8B_BPBLCD15_SHIFT, LCD_WF8B_BPBLCD15_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPBLCD36[1] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase B
 * - 0b1 - LCD segment on or LCD backplane active for phase B
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPBLCD36 field. */
#define LCD_RD_WF8B_BPBLCD36(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPBLCD36_MASK) >> LCD_WF8B_BPBLCD36_SHIFT)
#define LCD_BRD_WF8B_BPBLCD36(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPBLCD36_SHIFT, LCD_WF8B_BPBLCD36_WIDTH))

/*! @brief Set the BPBLCD36 field to a new value. */
#define LCD_WR_WF8B_BPBLCD36(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPBLCD36_MASK, LCD_WF8B_BPBLCD36(value)))
#define LCD_BWR_WF8B_BPBLCD36(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPBLCD36_SHIFT), LCD_WF8B_BPBLCD36_SHIFT, LCD_WF8B_BPBLCD36_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPBLCD44[1] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase B
 * - 0b1 - LCD segment on or LCD backplane active for phase B
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPBLCD44 field. */
#define LCD_RD_WF8B_BPBLCD44(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPBLCD44_MASK) >> LCD_WF8B_BPBLCD44_SHIFT)
#define LCD_BRD_WF8B_BPBLCD44(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPBLCD44_SHIFT, LCD_WF8B_BPBLCD44_WIDTH))

/*! @brief Set the BPBLCD44 field to a new value. */
#define LCD_WR_WF8B_BPBLCD44(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPBLCD44_MASK, LCD_WF8B_BPBLCD44(value)))
#define LCD_BWR_WF8B_BPBLCD44(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPBLCD44_SHIFT), LCD_WF8B_BPBLCD44_SHIFT, LCD_WF8B_BPBLCD44_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPBLCD62[1] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase B
 * - 0b1 - LCD segment on or LCD backplane active for phase B
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPBLCD62 field. */
#define LCD_RD_WF8B_BPBLCD62(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPBLCD62_MASK) >> LCD_WF8B_BPBLCD62_SHIFT)
#define LCD_BRD_WF8B_BPBLCD62(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPBLCD62_SHIFT, LCD_WF8B_BPBLCD62_WIDTH))

/*! @brief Set the BPBLCD62 field to a new value. */
#define LCD_WR_WF8B_BPBLCD62(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPBLCD62_MASK, LCD_WF8B_BPBLCD62(value)))
#define LCD_BWR_WF8B_BPBLCD62(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPBLCD62_SHIFT), LCD_WF8B_BPBLCD62_SHIFT, LCD_WF8B_BPBLCD62_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPBLCD53[1] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase B
 * - 0b1 - LCD segment on or LCD backplane active for phase B
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPBLCD53 field. */
#define LCD_RD_WF8B_BPBLCD53(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPBLCD53_MASK) >> LCD_WF8B_BPBLCD53_SHIFT)
#define LCD_BRD_WF8B_BPBLCD53(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPBLCD53_SHIFT, LCD_WF8B_BPBLCD53_WIDTH))

/*! @brief Set the BPBLCD53 field to a new value. */
#define LCD_WR_WF8B_BPBLCD53(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPBLCD53_MASK, LCD_WF8B_BPBLCD53(value)))
#define LCD_BWR_WF8B_BPBLCD53(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPBLCD53_SHIFT), LCD_WF8B_BPBLCD53_SHIFT, LCD_WF8B_BPBLCD53_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPBLCD22[1] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase B
 * - 0b1 - LCD segment on or LCD backplane active for phase B
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPBLCD22 field. */
#define LCD_RD_WF8B_BPBLCD22(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPBLCD22_MASK) >> LCD_WF8B_BPBLCD22_SHIFT)
#define LCD_BRD_WF8B_BPBLCD22(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPBLCD22_SHIFT, LCD_WF8B_BPBLCD22_WIDTH))

/*! @brief Set the BPBLCD22 field to a new value. */
#define LCD_WR_WF8B_BPBLCD22(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPBLCD22_MASK, LCD_WF8B_BPBLCD22(value)))
#define LCD_BWR_WF8B_BPBLCD22(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPBLCD22_SHIFT), LCD_WF8B_BPBLCD22_SHIFT, LCD_WF8B_BPBLCD22_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPBLCD47[1] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase B
 * - 0b1 - LCD segment on or LCD backplane active for phase B
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPBLCD47 field. */
#define LCD_RD_WF8B_BPBLCD47(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPBLCD47_MASK) >> LCD_WF8B_BPBLCD47_SHIFT)
#define LCD_BRD_WF8B_BPBLCD47(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPBLCD47_SHIFT, LCD_WF8B_BPBLCD47_WIDTH))

/*! @brief Set the BPBLCD47 field to a new value. */
#define LCD_WR_WF8B_BPBLCD47(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPBLCD47_MASK, LCD_WF8B_BPBLCD47(value)))
#define LCD_BWR_WF8B_BPBLCD47(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPBLCD47_SHIFT), LCD_WF8B_BPBLCD47_SHIFT, LCD_WF8B_BPBLCD47_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPBLCD33[1] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase B
 * - 0b1 - LCD segment on or LCD backplane active for phase B
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPBLCD33 field. */
#define LCD_RD_WF8B_BPBLCD33(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPBLCD33_MASK) >> LCD_WF8B_BPBLCD33_SHIFT)
#define LCD_BRD_WF8B_BPBLCD33(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPBLCD33_SHIFT, LCD_WF8B_BPBLCD33_WIDTH))

/*! @brief Set the BPBLCD33 field to a new value. */
#define LCD_WR_WF8B_BPBLCD33(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPBLCD33_MASK, LCD_WF8B_BPBLCD33(value)))
#define LCD_BWR_WF8B_BPBLCD33(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPBLCD33_SHIFT), LCD_WF8B_BPBLCD33_SHIFT, LCD_WF8B_BPBLCD33_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPBLCD2[1] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase B
 * - 0b1 - LCD segment on or LCD backplane active for phase B
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPBLCD2 field. */
#define LCD_RD_WF8B_BPBLCD2(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPBLCD2_MASK) >> LCD_WF8B_BPBLCD2_SHIFT)
#define LCD_BRD_WF8B_BPBLCD2(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPBLCD2_SHIFT, LCD_WF8B_BPBLCD2_WIDTH))

/*! @brief Set the BPBLCD2 field to a new value. */
#define LCD_WR_WF8B_BPBLCD2(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPBLCD2_MASK, LCD_WF8B_BPBLCD2(value)))
#define LCD_BWR_WF8B_BPBLCD2(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPBLCD2_SHIFT), LCD_WF8B_BPBLCD2_SHIFT, LCD_WF8B_BPBLCD2_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPBLCD49[1] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase B
 * - 0b1 - LCD segment on or LCD backplane active for phase B
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPBLCD49 field. */
#define LCD_RD_WF8B_BPBLCD49(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPBLCD49_MASK) >> LCD_WF8B_BPBLCD49_SHIFT)
#define LCD_BRD_WF8B_BPBLCD49(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPBLCD49_SHIFT, LCD_WF8B_BPBLCD49_WIDTH))

/*! @brief Set the BPBLCD49 field to a new value. */
#define LCD_WR_WF8B_BPBLCD49(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPBLCD49_MASK, LCD_WF8B_BPBLCD49(value)))
#define LCD_BWR_WF8B_BPBLCD49(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPBLCD49_SHIFT), LCD_WF8B_BPBLCD49_SHIFT, LCD_WF8B_BPBLCD49_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPBLCD0[1] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase B
 * - 0b1 - LCD segment on or LCD backplane active for phase B
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPBLCD0 field. */
#define LCD_RD_WF8B_BPBLCD0(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPBLCD0_MASK) >> LCD_WF8B_BPBLCD0_SHIFT)
#define LCD_BRD_WF8B_BPBLCD0(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPBLCD0_SHIFT, LCD_WF8B_BPBLCD0_WIDTH))

/*! @brief Set the BPBLCD0 field to a new value. */
#define LCD_WR_WF8B_BPBLCD0(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPBLCD0_MASK, LCD_WF8B_BPBLCD0(value)))
#define LCD_BWR_WF8B_BPBLCD0(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPBLCD0_SHIFT), LCD_WF8B_BPBLCD0_SHIFT, LCD_WF8B_BPBLCD0_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPBLCD55[1] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase B
 * - 0b1 - LCD segment on or LCD backplane active for phase B
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPBLCD55 field. */
#define LCD_RD_WF8B_BPBLCD55(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPBLCD55_MASK) >> LCD_WF8B_BPBLCD55_SHIFT)
#define LCD_BRD_WF8B_BPBLCD55(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPBLCD55_SHIFT, LCD_WF8B_BPBLCD55_WIDTH))

/*! @brief Set the BPBLCD55 field to a new value. */
#define LCD_WR_WF8B_BPBLCD55(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPBLCD55_MASK, LCD_WF8B_BPBLCD55(value)))
#define LCD_BWR_WF8B_BPBLCD55(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPBLCD55_SHIFT), LCD_WF8B_BPBLCD55_SHIFT, LCD_WF8B_BPBLCD55_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPBLCD56[1] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase B
 * - 0b1 - LCD segment on or LCD backplane active for phase B
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPBLCD56 field. */
#define LCD_RD_WF8B_BPBLCD56(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPBLCD56_MASK) >> LCD_WF8B_BPBLCD56_SHIFT)
#define LCD_BRD_WF8B_BPBLCD56(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPBLCD56_SHIFT, LCD_WF8B_BPBLCD56_WIDTH))

/*! @brief Set the BPBLCD56 field to a new value. */
#define LCD_WR_WF8B_BPBLCD56(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPBLCD56_MASK, LCD_WF8B_BPBLCD56(value)))
#define LCD_BWR_WF8B_BPBLCD56(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPBLCD56_SHIFT), LCD_WF8B_BPBLCD56_SHIFT, LCD_WF8B_BPBLCD56_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPBLCD21[1] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase B
 * - 0b1 - LCD segment on or LCD backplane active for phase B
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPBLCD21 field. */
#define LCD_RD_WF8B_BPBLCD21(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPBLCD21_MASK) >> LCD_WF8B_BPBLCD21_SHIFT)
#define LCD_BRD_WF8B_BPBLCD21(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPBLCD21_SHIFT, LCD_WF8B_BPBLCD21_WIDTH))

/*! @brief Set the BPBLCD21 field to a new value. */
#define LCD_WR_WF8B_BPBLCD21(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPBLCD21_MASK, LCD_WF8B_BPBLCD21(value)))
#define LCD_BWR_WF8B_BPBLCD21(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPBLCD21_SHIFT), LCD_WF8B_BPBLCD21_SHIFT, LCD_WF8B_BPBLCD21_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPBLCD6[1] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase B
 * - 0b1 - LCD segment on or LCD backplane active for phase B
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPBLCD6 field. */
#define LCD_RD_WF8B_BPBLCD6(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPBLCD6_MASK) >> LCD_WF8B_BPBLCD6_SHIFT)
#define LCD_BRD_WF8B_BPBLCD6(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPBLCD6_SHIFT, LCD_WF8B_BPBLCD6_WIDTH))

/*! @brief Set the BPBLCD6 field to a new value. */
#define LCD_WR_WF8B_BPBLCD6(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPBLCD6_MASK, LCD_WF8B_BPBLCD6(value)))
#define LCD_BWR_WF8B_BPBLCD6(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPBLCD6_SHIFT), LCD_WF8B_BPBLCD6_SHIFT, LCD_WF8B_BPBLCD6_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPBLCD29[1] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase B
 * - 0b1 - LCD segment on or LCD backplane active for phase B
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPBLCD29 field. */
#define LCD_RD_WF8B_BPBLCD29(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPBLCD29_MASK) >> LCD_WF8B_BPBLCD29_SHIFT)
#define LCD_BRD_WF8B_BPBLCD29(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPBLCD29_SHIFT, LCD_WF8B_BPBLCD29_WIDTH))

/*! @brief Set the BPBLCD29 field to a new value. */
#define LCD_WR_WF8B_BPBLCD29(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPBLCD29_MASK, LCD_WF8B_BPBLCD29(value)))
#define LCD_BWR_WF8B_BPBLCD29(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPBLCD29_SHIFT), LCD_WF8B_BPBLCD29_SHIFT, LCD_WF8B_BPBLCD29_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPBLCD25[1] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase B
 * - 0b1 - LCD segment on or LCD backplane active for phase B
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPBLCD25 field. */
#define LCD_RD_WF8B_BPBLCD25(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPBLCD25_MASK) >> LCD_WF8B_BPBLCD25_SHIFT)
#define LCD_BRD_WF8B_BPBLCD25(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPBLCD25_SHIFT, LCD_WF8B_BPBLCD25_WIDTH))

/*! @brief Set the BPBLCD25 field to a new value. */
#define LCD_WR_WF8B_BPBLCD25(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPBLCD25_MASK, LCD_WF8B_BPBLCD25(value)))
#define LCD_BWR_WF8B_BPBLCD25(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPBLCD25_SHIFT), LCD_WF8B_BPBLCD25_SHIFT, LCD_WF8B_BPBLCD25_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPBLCD8[1] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase B
 * - 0b1 - LCD segment on or LCD backplane active for phase B
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPBLCD8 field. */
#define LCD_RD_WF8B_BPBLCD8(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPBLCD8_MASK) >> LCD_WF8B_BPBLCD8_SHIFT)
#define LCD_BRD_WF8B_BPBLCD8(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPBLCD8_SHIFT, LCD_WF8B_BPBLCD8_WIDTH))

/*! @brief Set the BPBLCD8 field to a new value. */
#define LCD_WR_WF8B_BPBLCD8(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPBLCD8_MASK, LCD_WF8B_BPBLCD8(value)))
#define LCD_BWR_WF8B_BPBLCD8(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPBLCD8_SHIFT), LCD_WF8B_BPBLCD8_SHIFT, LCD_WF8B_BPBLCD8_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPBLCD54[1] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase B
 * - 0b1 - LCD segment on or LCD backplane active for phase B
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPBLCD54 field. */
#define LCD_RD_WF8B_BPBLCD54(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPBLCD54_MASK) >> LCD_WF8B_BPBLCD54_SHIFT)
#define LCD_BRD_WF8B_BPBLCD54(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPBLCD54_SHIFT, LCD_WF8B_BPBLCD54_WIDTH))

/*! @brief Set the BPBLCD54 field to a new value. */
#define LCD_WR_WF8B_BPBLCD54(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPBLCD54_MASK, LCD_WF8B_BPBLCD54(value)))
#define LCD_BWR_WF8B_BPBLCD54(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPBLCD54_SHIFT), LCD_WF8B_BPBLCD54_SHIFT, LCD_WF8B_BPBLCD54_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPBLCD38[1] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase B
 * - 0b1 - LCD segment on or LCD backplane active for phase B
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPBLCD38 field. */
#define LCD_RD_WF8B_BPBLCD38(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPBLCD38_MASK) >> LCD_WF8B_BPBLCD38_SHIFT)
#define LCD_BRD_WF8B_BPBLCD38(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPBLCD38_SHIFT, LCD_WF8B_BPBLCD38_WIDTH))

/*! @brief Set the BPBLCD38 field to a new value. */
#define LCD_WR_WF8B_BPBLCD38(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPBLCD38_MASK, LCD_WF8B_BPBLCD38(value)))
#define LCD_BWR_WF8B_BPBLCD38(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPBLCD38_SHIFT), LCD_WF8B_BPBLCD38_SHIFT, LCD_WF8B_BPBLCD38_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPBLCD43[1] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase B
 * - 0b1 - LCD segment on or LCD backplane active for phase B
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPBLCD43 field. */
#define LCD_RD_WF8B_BPBLCD43(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPBLCD43_MASK) >> LCD_WF8B_BPBLCD43_SHIFT)
#define LCD_BRD_WF8B_BPBLCD43(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPBLCD43_SHIFT, LCD_WF8B_BPBLCD43_WIDTH))

/*! @brief Set the BPBLCD43 field to a new value. */
#define LCD_WR_WF8B_BPBLCD43(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPBLCD43_MASK, LCD_WF8B_BPBLCD43(value)))
#define LCD_BWR_WF8B_BPBLCD43(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPBLCD43_SHIFT), LCD_WF8B_BPBLCD43_SHIFT, LCD_WF8B_BPBLCD43_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPBLCD20[1] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase B
 * - 0b1 - LCD segment on or LCD backplane active for phase B
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPBLCD20 field. */
#define LCD_RD_WF8B_BPBLCD20(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPBLCD20_MASK) >> LCD_WF8B_BPBLCD20_SHIFT)
#define LCD_BRD_WF8B_BPBLCD20(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPBLCD20_SHIFT, LCD_WF8B_BPBLCD20_WIDTH))

/*! @brief Set the BPBLCD20 field to a new value. */
#define LCD_WR_WF8B_BPBLCD20(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPBLCD20_MASK, LCD_WF8B_BPBLCD20(value)))
#define LCD_BWR_WF8B_BPBLCD20(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPBLCD20_SHIFT), LCD_WF8B_BPBLCD20_SHIFT, LCD_WF8B_BPBLCD20_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPBLCD9[1] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase B
 * - 0b1 - LCD segment on or LCD backplane active for phase B
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPBLCD9 field. */
#define LCD_RD_WF8B_BPBLCD9(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPBLCD9_MASK) >> LCD_WF8B_BPBLCD9_SHIFT)
#define LCD_BRD_WF8B_BPBLCD9(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPBLCD9_SHIFT, LCD_WF8B_BPBLCD9_WIDTH))

/*! @brief Set the BPBLCD9 field to a new value. */
#define LCD_WR_WF8B_BPBLCD9(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPBLCD9_MASK, LCD_WF8B_BPBLCD9(value)))
#define LCD_BWR_WF8B_BPBLCD9(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPBLCD9_SHIFT), LCD_WF8B_BPBLCD9_SHIFT, LCD_WF8B_BPBLCD9_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPBLCD7[1] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase B
 * - 0b1 - LCD segment on or LCD backplane active for phase B
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPBLCD7 field. */
#define LCD_RD_WF8B_BPBLCD7(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPBLCD7_MASK) >> LCD_WF8B_BPBLCD7_SHIFT)
#define LCD_BRD_WF8B_BPBLCD7(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPBLCD7_SHIFT, LCD_WF8B_BPBLCD7_WIDTH))

/*! @brief Set the BPBLCD7 field to a new value. */
#define LCD_WR_WF8B_BPBLCD7(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPBLCD7_MASK, LCD_WF8B_BPBLCD7(value)))
#define LCD_BWR_WF8B_BPBLCD7(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPBLCD7_SHIFT), LCD_WF8B_BPBLCD7_SHIFT, LCD_WF8B_BPBLCD7_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPBLCD50[1] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase B
 * - 0b1 - LCD segment on or LCD backplane active for phase B
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPBLCD50 field. */
#define LCD_RD_WF8B_BPBLCD50(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPBLCD50_MASK) >> LCD_WF8B_BPBLCD50_SHIFT)
#define LCD_BRD_WF8B_BPBLCD50(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPBLCD50_SHIFT, LCD_WF8B_BPBLCD50_WIDTH))

/*! @brief Set the BPBLCD50 field to a new value. */
#define LCD_WR_WF8B_BPBLCD50(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPBLCD50_MASK, LCD_WF8B_BPBLCD50(value)))
#define LCD_BWR_WF8B_BPBLCD50(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPBLCD50_SHIFT), LCD_WF8B_BPBLCD50_SHIFT, LCD_WF8B_BPBLCD50_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPBLCD40[1] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase B
 * - 0b1 - LCD segment on or LCD backplane active for phase B
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPBLCD40 field. */
#define LCD_RD_WF8B_BPBLCD40(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPBLCD40_MASK) >> LCD_WF8B_BPBLCD40_SHIFT)
#define LCD_BRD_WF8B_BPBLCD40(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPBLCD40_SHIFT, LCD_WF8B_BPBLCD40_WIDTH))

/*! @brief Set the BPBLCD40 field to a new value. */
#define LCD_WR_WF8B_BPBLCD40(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPBLCD40_MASK, LCD_WF8B_BPBLCD40(value)))
#define LCD_BWR_WF8B_BPBLCD40(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPBLCD40_SHIFT), LCD_WF8B_BPBLCD40_SHIFT, LCD_WF8B_BPBLCD40_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPBLCD63[1] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase B
 * - 0b1 - LCD segment on or LCD backplane active for phase B
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPBLCD63 field. */
#define LCD_RD_WF8B_BPBLCD63(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPBLCD63_MASK) >> LCD_WF8B_BPBLCD63_SHIFT)
#define LCD_BRD_WF8B_BPBLCD63(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPBLCD63_SHIFT, LCD_WF8B_BPBLCD63_WIDTH))

/*! @brief Set the BPBLCD63 field to a new value. */
#define LCD_WR_WF8B_BPBLCD63(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPBLCD63_MASK, LCD_WF8B_BPBLCD63(value)))
#define LCD_BWR_WF8B_BPBLCD63(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPBLCD63_SHIFT), LCD_WF8B_BPBLCD63_SHIFT, LCD_WF8B_BPBLCD63_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPBLCD26[1] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase B
 * - 0b1 - LCD segment on or LCD backplane active for phase B
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPBLCD26 field. */
#define LCD_RD_WF8B_BPBLCD26(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPBLCD26_MASK) >> LCD_WF8B_BPBLCD26_SHIFT)
#define LCD_BRD_WF8B_BPBLCD26(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPBLCD26_SHIFT, LCD_WF8B_BPBLCD26_WIDTH))

/*! @brief Set the BPBLCD26 field to a new value. */
#define LCD_WR_WF8B_BPBLCD26(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPBLCD26_MASK, LCD_WF8B_BPBLCD26(value)))
#define LCD_BWR_WF8B_BPBLCD26(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPBLCD26_SHIFT), LCD_WF8B_BPBLCD26_SHIFT, LCD_WF8B_BPBLCD26_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPBLCD12[1] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase B
 * - 0b1 - LCD segment on or LCD backplane active for phase B
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPBLCD12 field. */
#define LCD_RD_WF8B_BPBLCD12(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPBLCD12_MASK) >> LCD_WF8B_BPBLCD12_SHIFT)
#define LCD_BRD_WF8B_BPBLCD12(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPBLCD12_SHIFT, LCD_WF8B_BPBLCD12_WIDTH))

/*! @brief Set the BPBLCD12 field to a new value. */
#define LCD_WR_WF8B_BPBLCD12(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPBLCD12_MASK, LCD_WF8B_BPBLCD12(value)))
#define LCD_BWR_WF8B_BPBLCD12(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPBLCD12_SHIFT), LCD_WF8B_BPBLCD12_SHIFT, LCD_WF8B_BPBLCD12_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPBLCD19[1] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase B
 * - 0b1 - LCD segment on or LCD backplane active for phase B
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPBLCD19 field. */
#define LCD_RD_WF8B_BPBLCD19(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPBLCD19_MASK) >> LCD_WF8B_BPBLCD19_SHIFT)
#define LCD_BRD_WF8B_BPBLCD19(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPBLCD19_SHIFT, LCD_WF8B_BPBLCD19_WIDTH))

/*! @brief Set the BPBLCD19 field to a new value. */
#define LCD_WR_WF8B_BPBLCD19(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPBLCD19_MASK, LCD_WF8B_BPBLCD19(value)))
#define LCD_BWR_WF8B_BPBLCD19(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPBLCD19_SHIFT), LCD_WF8B_BPBLCD19_SHIFT, LCD_WF8B_BPBLCD19_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPBLCD34[1] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase B
 * - 0b1 - LCD segment on or LCD backplane active for phase B
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPBLCD34 field. */
#define LCD_RD_WF8B_BPBLCD34(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPBLCD34_MASK) >> LCD_WF8B_BPBLCD34_SHIFT)
#define LCD_BRD_WF8B_BPBLCD34(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPBLCD34_SHIFT, LCD_WF8B_BPBLCD34_WIDTH))

/*! @brief Set the BPBLCD34 field to a new value. */
#define LCD_WR_WF8B_BPBLCD34(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPBLCD34_MASK, LCD_WF8B_BPBLCD34(value)))
#define LCD_BWR_WF8B_BPBLCD34(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPBLCD34_SHIFT), LCD_WF8B_BPBLCD34_SHIFT, LCD_WF8B_BPBLCD34_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPBLCD39[1] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase B
 * - 0b1 - LCD segment on or LCD backplane active for phase B
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPBLCD39 field. */
#define LCD_RD_WF8B_BPBLCD39(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPBLCD39_MASK) >> LCD_WF8B_BPBLCD39_SHIFT)
#define LCD_BRD_WF8B_BPBLCD39(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPBLCD39_SHIFT, LCD_WF8B_BPBLCD39_WIDTH))

/*! @brief Set the BPBLCD39 field to a new value. */
#define LCD_WR_WF8B_BPBLCD39(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPBLCD39_MASK, LCD_WF8B_BPBLCD39(value)))
#define LCD_BWR_WF8B_BPBLCD39(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPBLCD39_SHIFT), LCD_WF8B_BPBLCD39_SHIFT, LCD_WF8B_BPBLCD39_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPBLCD59[1] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase B
 * - 0b1 - LCD segment on or LCD backplane active for phase B
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPBLCD59 field. */
#define LCD_RD_WF8B_BPBLCD59(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPBLCD59_MASK) >> LCD_WF8B_BPBLCD59_SHIFT)
#define LCD_BRD_WF8B_BPBLCD59(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPBLCD59_SHIFT, LCD_WF8B_BPBLCD59_WIDTH))

/*! @brief Set the BPBLCD59 field to a new value. */
#define LCD_WR_WF8B_BPBLCD59(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPBLCD59_MASK, LCD_WF8B_BPBLCD59(value)))
#define LCD_BWR_WF8B_BPBLCD59(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPBLCD59_SHIFT), LCD_WF8B_BPBLCD59_SHIFT, LCD_WF8B_BPBLCD59_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPBLCD61[1] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase B
 * - 0b1 - LCD segment on or LCD backplane active for phase B
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPBLCD61 field. */
#define LCD_RD_WF8B_BPBLCD61(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPBLCD61_MASK) >> LCD_WF8B_BPBLCD61_SHIFT)
#define LCD_BRD_WF8B_BPBLCD61(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPBLCD61_SHIFT, LCD_WF8B_BPBLCD61_WIDTH))

/*! @brief Set the BPBLCD61 field to a new value. */
#define LCD_WR_WF8B_BPBLCD61(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPBLCD61_MASK, LCD_WF8B_BPBLCD61(value)))
#define LCD_BWR_WF8B_BPBLCD61(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPBLCD61_SHIFT), LCD_WF8B_BPBLCD61_SHIFT, LCD_WF8B_BPBLCD61_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPBLCD37[1] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase B
 * - 0b1 - LCD segment on or LCD backplane active for phase B
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPBLCD37 field. */
#define LCD_RD_WF8B_BPBLCD37(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPBLCD37_MASK) >> LCD_WF8B_BPBLCD37_SHIFT)
#define LCD_BRD_WF8B_BPBLCD37(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPBLCD37_SHIFT, LCD_WF8B_BPBLCD37_WIDTH))

/*! @brief Set the BPBLCD37 field to a new value. */
#define LCD_WR_WF8B_BPBLCD37(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPBLCD37_MASK, LCD_WF8B_BPBLCD37(value)))
#define LCD_BWR_WF8B_BPBLCD37(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPBLCD37_SHIFT), LCD_WF8B_BPBLCD37_SHIFT, LCD_WF8B_BPBLCD37_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPBLCD31[1] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase B
 * - 0b1 - LCD segment on or LCD backplane active for phase B
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPBLCD31 field. */
#define LCD_RD_WF8B_BPBLCD31(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPBLCD31_MASK) >> LCD_WF8B_BPBLCD31_SHIFT)
#define LCD_BRD_WF8B_BPBLCD31(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPBLCD31_SHIFT, LCD_WF8B_BPBLCD31_WIDTH))

/*! @brief Set the BPBLCD31 field to a new value. */
#define LCD_WR_WF8B_BPBLCD31(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPBLCD31_MASK, LCD_WF8B_BPBLCD31(value)))
#define LCD_BWR_WF8B_BPBLCD31(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPBLCD31_SHIFT), LCD_WF8B_BPBLCD31_SHIFT, LCD_WF8B_BPBLCD31_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPBLCD58[1] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase B
 * - 0b1 - LCD segment on or LCD backplane active for phase B
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPBLCD58 field. */
#define LCD_RD_WF8B_BPBLCD58(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPBLCD58_MASK) >> LCD_WF8B_BPBLCD58_SHIFT)
#define LCD_BRD_WF8B_BPBLCD58(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPBLCD58_SHIFT, LCD_WF8B_BPBLCD58_WIDTH))

/*! @brief Set the BPBLCD58 field to a new value. */
#define LCD_WR_WF8B_BPBLCD58(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPBLCD58_MASK, LCD_WF8B_BPBLCD58(value)))
#define LCD_BWR_WF8B_BPBLCD58(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPBLCD58_SHIFT), LCD_WF8B_BPBLCD58_SHIFT, LCD_WF8B_BPBLCD58_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPBLCD18[1] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase B
 * - 0b1 - LCD segment on or LCD backplane active for phase B
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPBLCD18 field. */
#define LCD_RD_WF8B_BPBLCD18(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPBLCD18_MASK) >> LCD_WF8B_BPBLCD18_SHIFT)
#define LCD_BRD_WF8B_BPBLCD18(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPBLCD18_SHIFT, LCD_WF8B_BPBLCD18_WIDTH))

/*! @brief Set the BPBLCD18 field to a new value. */
#define LCD_WR_WF8B_BPBLCD18(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPBLCD18_MASK, LCD_WF8B_BPBLCD18(value)))
#define LCD_BWR_WF8B_BPBLCD18(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPBLCD18_SHIFT), LCD_WF8B_BPBLCD18_SHIFT, LCD_WF8B_BPBLCD18_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPBLCD45[1] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase B
 * - 0b1 - LCD segment on or LCD backplane active for phase B
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPBLCD45 field. */
#define LCD_RD_WF8B_BPBLCD45(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPBLCD45_MASK) >> LCD_WF8B_BPBLCD45_SHIFT)
#define LCD_BRD_WF8B_BPBLCD45(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPBLCD45_SHIFT, LCD_WF8B_BPBLCD45_WIDTH))

/*! @brief Set the BPBLCD45 field to a new value. */
#define LCD_WR_WF8B_BPBLCD45(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPBLCD45_MASK, LCD_WF8B_BPBLCD45(value)))
#define LCD_BWR_WF8B_BPBLCD45(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPBLCD45_SHIFT), LCD_WF8B_BPBLCD45_SHIFT, LCD_WF8B_BPBLCD45_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPBLCD27[1] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase B
 * - 0b1 - LCD segment on or LCD backplane active for phase B
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPBLCD27 field. */
#define LCD_RD_WF8B_BPBLCD27(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPBLCD27_MASK) >> LCD_WF8B_BPBLCD27_SHIFT)
#define LCD_BRD_WF8B_BPBLCD27(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPBLCD27_SHIFT, LCD_WF8B_BPBLCD27_WIDTH))

/*! @brief Set the BPBLCD27 field to a new value. */
#define LCD_WR_WF8B_BPBLCD27(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPBLCD27_MASK, LCD_WF8B_BPBLCD27(value)))
#define LCD_BWR_WF8B_BPBLCD27(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPBLCD27_SHIFT), LCD_WF8B_BPBLCD27_SHIFT, LCD_WF8B_BPBLCD27_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPBLCD14[1] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase B
 * - 0b1 - LCD segment on or LCD backplane active for phase B
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPBLCD14 field. */
#define LCD_RD_WF8B_BPBLCD14(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPBLCD14_MASK) >> LCD_WF8B_BPBLCD14_SHIFT)
#define LCD_BRD_WF8B_BPBLCD14(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPBLCD14_SHIFT, LCD_WF8B_BPBLCD14_WIDTH))

/*! @brief Set the BPBLCD14 field to a new value. */
#define LCD_WR_WF8B_BPBLCD14(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPBLCD14_MASK, LCD_WF8B_BPBLCD14(value)))
#define LCD_BWR_WF8B_BPBLCD14(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPBLCD14_SHIFT), LCD_WF8B_BPBLCD14_SHIFT, LCD_WF8B_BPBLCD14_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPBLCD51[1] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase B
 * - 0b1 - LCD segment on or LCD backplane active for phase B
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPBLCD51 field. */
#define LCD_RD_WF8B_BPBLCD51(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPBLCD51_MASK) >> LCD_WF8B_BPBLCD51_SHIFT)
#define LCD_BRD_WF8B_BPBLCD51(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPBLCD51_SHIFT, LCD_WF8B_BPBLCD51_WIDTH))

/*! @brief Set the BPBLCD51 field to a new value. */
#define LCD_WR_WF8B_BPBLCD51(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPBLCD51_MASK, LCD_WF8B_BPBLCD51(value)))
#define LCD_BWR_WF8B_BPBLCD51(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPBLCD51_SHIFT), LCD_WF8B_BPBLCD51_SHIFT, LCD_WF8B_BPBLCD51_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPBLCD52[1] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase B
 * - 0b1 - LCD segment on or LCD backplane active for phase B
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPBLCD52 field. */
#define LCD_RD_WF8B_BPBLCD52(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPBLCD52_MASK) >> LCD_WF8B_BPBLCD52_SHIFT)
#define LCD_BRD_WF8B_BPBLCD52(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPBLCD52_SHIFT, LCD_WF8B_BPBLCD52_WIDTH))

/*! @brief Set the BPBLCD52 field to a new value. */
#define LCD_WR_WF8B_BPBLCD52(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPBLCD52_MASK, LCD_WF8B_BPBLCD52(value)))
#define LCD_BWR_WF8B_BPBLCD52(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPBLCD52_SHIFT), LCD_WF8B_BPBLCD52_SHIFT, LCD_WF8B_BPBLCD52_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPBLCD4[1] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase B
 * - 0b1 - LCD segment on or LCD backplane active for phase B
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPBLCD4 field. */
#define LCD_RD_WF8B_BPBLCD4(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPBLCD4_MASK) >> LCD_WF8B_BPBLCD4_SHIFT)
#define LCD_BRD_WF8B_BPBLCD4(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPBLCD4_SHIFT, LCD_WF8B_BPBLCD4_WIDTH))

/*! @brief Set the BPBLCD4 field to a new value. */
#define LCD_WR_WF8B_BPBLCD4(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPBLCD4_MASK, LCD_WF8B_BPBLCD4(value)))
#define LCD_BWR_WF8B_BPBLCD4(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPBLCD4_SHIFT), LCD_WF8B_BPBLCD4_SHIFT, LCD_WF8B_BPBLCD4_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPBLCD35[1] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase B
 * - 0b1 - LCD segment on or LCD backplane active for phase B
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPBLCD35 field. */
#define LCD_RD_WF8B_BPBLCD35(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPBLCD35_MASK) >> LCD_WF8B_BPBLCD35_SHIFT)
#define LCD_BRD_WF8B_BPBLCD35(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPBLCD35_SHIFT, LCD_WF8B_BPBLCD35_WIDTH))

/*! @brief Set the BPBLCD35 field to a new value. */
#define LCD_WR_WF8B_BPBLCD35(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPBLCD35_MASK, LCD_WF8B_BPBLCD35(value)))
#define LCD_BWR_WF8B_BPBLCD35(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPBLCD35_SHIFT), LCD_WF8B_BPBLCD35_SHIFT, LCD_WF8B_BPBLCD35_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPBLCD17[1] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase B
 * - 0b1 - LCD segment on or LCD backplane active for phase B
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPBLCD17 field. */
#define LCD_RD_WF8B_BPBLCD17(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPBLCD17_MASK) >> LCD_WF8B_BPBLCD17_SHIFT)
#define LCD_BRD_WF8B_BPBLCD17(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPBLCD17_SHIFT, LCD_WF8B_BPBLCD17_WIDTH))

/*! @brief Set the BPBLCD17 field to a new value. */
#define LCD_WR_WF8B_BPBLCD17(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPBLCD17_MASK, LCD_WF8B_BPBLCD17(value)))
#define LCD_BWR_WF8B_BPBLCD17(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPBLCD17_SHIFT), LCD_WF8B_BPBLCD17_SHIFT, LCD_WF8B_BPBLCD17_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPBLCD41[1] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase B
 * - 0b1 - LCD segment on or LCD backplane active for phase B
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPBLCD41 field. */
#define LCD_RD_WF8B_BPBLCD41(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPBLCD41_MASK) >> LCD_WF8B_BPBLCD41_SHIFT)
#define LCD_BRD_WF8B_BPBLCD41(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPBLCD41_SHIFT, LCD_WF8B_BPBLCD41_WIDTH))

/*! @brief Set the BPBLCD41 field to a new value. */
#define LCD_WR_WF8B_BPBLCD41(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPBLCD41_MASK, LCD_WF8B_BPBLCD41(value)))
#define LCD_BWR_WF8B_BPBLCD41(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPBLCD41_SHIFT), LCD_WF8B_BPBLCD41_SHIFT, LCD_WF8B_BPBLCD41_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPBLCD11[1] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase B
 * - 0b1 - LCD segment on or LCD backplane active for phase B
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPBLCD11 field. */
#define LCD_RD_WF8B_BPBLCD11(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPBLCD11_MASK) >> LCD_WF8B_BPBLCD11_SHIFT)
#define LCD_BRD_WF8B_BPBLCD11(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPBLCD11_SHIFT, LCD_WF8B_BPBLCD11_WIDTH))

/*! @brief Set the BPBLCD11 field to a new value. */
#define LCD_WR_WF8B_BPBLCD11(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPBLCD11_MASK, LCD_WF8B_BPBLCD11(value)))
#define LCD_BWR_WF8B_BPBLCD11(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPBLCD11_SHIFT), LCD_WF8B_BPBLCD11_SHIFT, LCD_WF8B_BPBLCD11_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPBLCD46[1] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase B
 * - 0b1 - LCD segment on or LCD backplane active for phase B
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPBLCD46 field. */
#define LCD_RD_WF8B_BPBLCD46(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPBLCD46_MASK) >> LCD_WF8B_BPBLCD46_SHIFT)
#define LCD_BRD_WF8B_BPBLCD46(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPBLCD46_SHIFT, LCD_WF8B_BPBLCD46_WIDTH))

/*! @brief Set the BPBLCD46 field to a new value. */
#define LCD_WR_WF8B_BPBLCD46(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPBLCD46_MASK, LCD_WF8B_BPBLCD46(value)))
#define LCD_BWR_WF8B_BPBLCD46(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPBLCD46_SHIFT), LCD_WF8B_BPBLCD46_SHIFT, LCD_WF8B_BPBLCD46_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPBLCD57[1] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase B
 * - 0b1 - LCD segment on or LCD backplane active for phase B
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPBLCD57 field. */
#define LCD_RD_WF8B_BPBLCD57(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPBLCD57_MASK) >> LCD_WF8B_BPBLCD57_SHIFT)
#define LCD_BRD_WF8B_BPBLCD57(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPBLCD57_SHIFT, LCD_WF8B_BPBLCD57_WIDTH))

/*! @brief Set the BPBLCD57 field to a new value. */
#define LCD_WR_WF8B_BPBLCD57(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPBLCD57_MASK, LCD_WF8B_BPBLCD57(value)))
#define LCD_BWR_WF8B_BPBLCD57(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPBLCD57_SHIFT), LCD_WF8B_BPBLCD57_SHIFT, LCD_WF8B_BPBLCD57_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPBLCD42[1] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase B
 * - 0b1 - LCD segment on or LCD backplane active for phase B
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPBLCD42 field. */
#define LCD_RD_WF8B_BPBLCD42(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPBLCD42_MASK) >> LCD_WF8B_BPBLCD42_SHIFT)
#define LCD_BRD_WF8B_BPBLCD42(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPBLCD42_SHIFT, LCD_WF8B_BPBLCD42_WIDTH))

/*! @brief Set the BPBLCD42 field to a new value. */
#define LCD_WR_WF8B_BPBLCD42(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPBLCD42_MASK, LCD_WF8B_BPBLCD42(value)))
#define LCD_BWR_WF8B_BPBLCD42(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPBLCD42_SHIFT), LCD_WF8B_BPBLCD42_SHIFT, LCD_WF8B_BPBLCD42_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPBLCD5[1] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase B
 * - 0b1 - LCD segment on or LCD backplane active for phase B
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPBLCD5 field. */
#define LCD_RD_WF8B_BPBLCD5(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPBLCD5_MASK) >> LCD_WF8B_BPBLCD5_SHIFT)
#define LCD_BRD_WF8B_BPBLCD5(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPBLCD5_SHIFT, LCD_WF8B_BPBLCD5_WIDTH))

/*! @brief Set the BPBLCD5 field to a new value. */
#define LCD_WR_WF8B_BPBLCD5(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPBLCD5_MASK, LCD_WF8B_BPBLCD5(value)))
#define LCD_BWR_WF8B_BPBLCD5(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPBLCD5_SHIFT), LCD_WF8B_BPBLCD5_SHIFT, LCD_WF8B_BPBLCD5_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPBLCD3[1] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase B
 * - 0b1 - LCD segment on or LCD backplane active for phase B
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPBLCD3 field. */
#define LCD_RD_WF8B_BPBLCD3(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPBLCD3_MASK) >> LCD_WF8B_BPBLCD3_SHIFT)
#define LCD_BRD_WF8B_BPBLCD3(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPBLCD3_SHIFT, LCD_WF8B_BPBLCD3_WIDTH))

/*! @brief Set the BPBLCD3 field to a new value. */
#define LCD_WR_WF8B_BPBLCD3(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPBLCD3_MASK, LCD_WF8B_BPBLCD3(value)))
#define LCD_BWR_WF8B_BPBLCD3(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPBLCD3_SHIFT), LCD_WF8B_BPBLCD3_SHIFT, LCD_WF8B_BPBLCD3_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPBLCD16[1] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase B
 * - 0b1 - LCD segment on or LCD backplane active for phase B
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPBLCD16 field. */
#define LCD_RD_WF8B_BPBLCD16(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPBLCD16_MASK) >> LCD_WF8B_BPBLCD16_SHIFT)
#define LCD_BRD_WF8B_BPBLCD16(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPBLCD16_SHIFT, LCD_WF8B_BPBLCD16_WIDTH))

/*! @brief Set the BPBLCD16 field to a new value. */
#define LCD_WR_WF8B_BPBLCD16(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPBLCD16_MASK, LCD_WF8B_BPBLCD16(value)))
#define LCD_BWR_WF8B_BPBLCD16(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPBLCD16_SHIFT), LCD_WF8B_BPBLCD16_SHIFT, LCD_WF8B_BPBLCD16_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPBLCD13[1] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase B
 * - 0b1 - LCD segment on or LCD backplane active for phase B
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPBLCD13 field. */
#define LCD_RD_WF8B_BPBLCD13(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPBLCD13_MASK) >> LCD_WF8B_BPBLCD13_SHIFT)
#define LCD_BRD_WF8B_BPBLCD13(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPBLCD13_SHIFT, LCD_WF8B_BPBLCD13_WIDTH))

/*! @brief Set the BPBLCD13 field to a new value. */
#define LCD_WR_WF8B_BPBLCD13(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPBLCD13_MASK, LCD_WF8B_BPBLCD13(value)))
#define LCD_BWR_WF8B_BPBLCD13(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPBLCD13_SHIFT), LCD_WF8B_BPBLCD13_SHIFT, LCD_WF8B_BPBLCD13_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPCLCD10[2] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase C
 * - 0b1 - LCD segment on or LCD backplane active for phase C
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPCLCD10 field. */
#define LCD_RD_WF8B_BPCLCD10(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPCLCD10_MASK) >> LCD_WF8B_BPCLCD10_SHIFT)
#define LCD_BRD_WF8B_BPCLCD10(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPCLCD10_SHIFT, LCD_WF8B_BPCLCD10_WIDTH))

/*! @brief Set the BPCLCD10 field to a new value. */
#define LCD_WR_WF8B_BPCLCD10(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPCLCD10_MASK, LCD_WF8B_BPCLCD10(value)))
#define LCD_BWR_WF8B_BPCLCD10(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPCLCD10_SHIFT), LCD_WF8B_BPCLCD10_SHIFT, LCD_WF8B_BPCLCD10_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPCLCD55[2] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase C
 * - 0b1 - LCD segment on or LCD backplane active for phase C
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPCLCD55 field. */
#define LCD_RD_WF8B_BPCLCD55(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPCLCD55_MASK) >> LCD_WF8B_BPCLCD55_SHIFT)
#define LCD_BRD_WF8B_BPCLCD55(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPCLCD55_SHIFT, LCD_WF8B_BPCLCD55_WIDTH))

/*! @brief Set the BPCLCD55 field to a new value. */
#define LCD_WR_WF8B_BPCLCD55(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPCLCD55_MASK, LCD_WF8B_BPCLCD55(value)))
#define LCD_BWR_WF8B_BPCLCD55(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPCLCD55_SHIFT), LCD_WF8B_BPCLCD55_SHIFT, LCD_WF8B_BPCLCD55_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPCLCD2[2] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase C
 * - 0b1 - LCD segment on or LCD backplane active for phase C
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPCLCD2 field. */
#define LCD_RD_WF8B_BPCLCD2(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPCLCD2_MASK) >> LCD_WF8B_BPCLCD2_SHIFT)
#define LCD_BRD_WF8B_BPCLCD2(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPCLCD2_SHIFT, LCD_WF8B_BPCLCD2_WIDTH))

/*! @brief Set the BPCLCD2 field to a new value. */
#define LCD_WR_WF8B_BPCLCD2(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPCLCD2_MASK, LCD_WF8B_BPCLCD2(value)))
#define LCD_BWR_WF8B_BPCLCD2(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPCLCD2_SHIFT), LCD_WF8B_BPCLCD2_SHIFT, LCD_WF8B_BPCLCD2_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPCLCD23[2] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase C
 * - 0b1 - LCD segment on or LCD backplane active for phase C
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPCLCD23 field. */
#define LCD_RD_WF8B_BPCLCD23(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPCLCD23_MASK) >> LCD_WF8B_BPCLCD23_SHIFT)
#define LCD_BRD_WF8B_BPCLCD23(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPCLCD23_SHIFT, LCD_WF8B_BPCLCD23_WIDTH))

/*! @brief Set the BPCLCD23 field to a new value. */
#define LCD_WR_WF8B_BPCLCD23(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPCLCD23_MASK, LCD_WF8B_BPCLCD23(value)))
#define LCD_BWR_WF8B_BPCLCD23(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPCLCD23_SHIFT), LCD_WF8B_BPCLCD23_SHIFT, LCD_WF8B_BPCLCD23_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPCLCD48[2] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase C
 * - 0b1 - LCD segment on or LCD backplane active for phase C
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPCLCD48 field. */
#define LCD_RD_WF8B_BPCLCD48(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPCLCD48_MASK) >> LCD_WF8B_BPCLCD48_SHIFT)
#define LCD_BRD_WF8B_BPCLCD48(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPCLCD48_SHIFT, LCD_WF8B_BPCLCD48_WIDTH))

/*! @brief Set the BPCLCD48 field to a new value. */
#define LCD_WR_WF8B_BPCLCD48(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPCLCD48_MASK, LCD_WF8B_BPCLCD48(value)))
#define LCD_BWR_WF8B_BPCLCD48(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPCLCD48_SHIFT), LCD_WF8B_BPCLCD48_SHIFT, LCD_WF8B_BPCLCD48_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPCLCD24[2] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase C
 * - 0b1 - LCD segment on or LCD backplane active for phase C
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPCLCD24 field. */
#define LCD_RD_WF8B_BPCLCD24(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPCLCD24_MASK) >> LCD_WF8B_BPCLCD24_SHIFT)
#define LCD_BRD_WF8B_BPCLCD24(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPCLCD24_SHIFT, LCD_WF8B_BPCLCD24_WIDTH))

/*! @brief Set the BPCLCD24 field to a new value. */
#define LCD_WR_WF8B_BPCLCD24(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPCLCD24_MASK, LCD_WF8B_BPCLCD24(value)))
#define LCD_BWR_WF8B_BPCLCD24(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPCLCD24_SHIFT), LCD_WF8B_BPCLCD24_SHIFT, LCD_WF8B_BPCLCD24_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPCLCD60[2] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase C
 * - 0b1 - LCD segment on or LCD backplane active for phase C
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPCLCD60 field. */
#define LCD_RD_WF8B_BPCLCD60(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPCLCD60_MASK) >> LCD_WF8B_BPCLCD60_SHIFT)
#define LCD_BRD_WF8B_BPCLCD60(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPCLCD60_SHIFT, LCD_WF8B_BPCLCD60_WIDTH))

/*! @brief Set the BPCLCD60 field to a new value. */
#define LCD_WR_WF8B_BPCLCD60(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPCLCD60_MASK, LCD_WF8B_BPCLCD60(value)))
#define LCD_BWR_WF8B_BPCLCD60(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPCLCD60_SHIFT), LCD_WF8B_BPCLCD60_SHIFT, LCD_WF8B_BPCLCD60_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPCLCD47[2] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase C
 * - 0b1 - LCD segment on or LCD backplane active for phase C
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPCLCD47 field. */
#define LCD_RD_WF8B_BPCLCD47(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPCLCD47_MASK) >> LCD_WF8B_BPCLCD47_SHIFT)
#define LCD_BRD_WF8B_BPCLCD47(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPCLCD47_SHIFT, LCD_WF8B_BPCLCD47_WIDTH))

/*! @brief Set the BPCLCD47 field to a new value. */
#define LCD_WR_WF8B_BPCLCD47(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPCLCD47_MASK, LCD_WF8B_BPCLCD47(value)))
#define LCD_BWR_WF8B_BPCLCD47(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPCLCD47_SHIFT), LCD_WF8B_BPCLCD47_SHIFT, LCD_WF8B_BPCLCD47_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPCLCD22[2] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase C
 * - 0b1 - LCD segment on or LCD backplane active for phase C
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPCLCD22 field. */
#define LCD_RD_WF8B_BPCLCD22(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPCLCD22_MASK) >> LCD_WF8B_BPCLCD22_SHIFT)
#define LCD_BRD_WF8B_BPCLCD22(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPCLCD22_SHIFT, LCD_WF8B_BPCLCD22_WIDTH))

/*! @brief Set the BPCLCD22 field to a new value. */
#define LCD_WR_WF8B_BPCLCD22(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPCLCD22_MASK, LCD_WF8B_BPCLCD22(value)))
#define LCD_BWR_WF8B_BPCLCD22(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPCLCD22_SHIFT), LCD_WF8B_BPCLCD22_SHIFT, LCD_WF8B_BPCLCD22_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPCLCD8[2] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase C
 * - 0b1 - LCD segment on or LCD backplane active for phase C
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPCLCD8 field. */
#define LCD_RD_WF8B_BPCLCD8(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPCLCD8_MASK) >> LCD_WF8B_BPCLCD8_SHIFT)
#define LCD_BRD_WF8B_BPCLCD8(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPCLCD8_SHIFT, LCD_WF8B_BPCLCD8_WIDTH))

/*! @brief Set the BPCLCD8 field to a new value. */
#define LCD_WR_WF8B_BPCLCD8(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPCLCD8_MASK, LCD_WF8B_BPCLCD8(value)))
#define LCD_BWR_WF8B_BPCLCD8(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPCLCD8_SHIFT), LCD_WF8B_BPCLCD8_SHIFT, LCD_WF8B_BPCLCD8_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPCLCD21[2] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase C
 * - 0b1 - LCD segment on or LCD backplane active for phase C
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPCLCD21 field. */
#define LCD_RD_WF8B_BPCLCD21(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPCLCD21_MASK) >> LCD_WF8B_BPCLCD21_SHIFT)
#define LCD_BRD_WF8B_BPCLCD21(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPCLCD21_SHIFT, LCD_WF8B_BPCLCD21_WIDTH))

/*! @brief Set the BPCLCD21 field to a new value. */
#define LCD_WR_WF8B_BPCLCD21(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPCLCD21_MASK, LCD_WF8B_BPCLCD21(value)))
#define LCD_BWR_WF8B_BPCLCD21(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPCLCD21_SHIFT), LCD_WF8B_BPCLCD21_SHIFT, LCD_WF8B_BPCLCD21_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPCLCD49[2] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase C
 * - 0b1 - LCD segment on or LCD backplane active for phase C
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPCLCD49 field. */
#define LCD_RD_WF8B_BPCLCD49(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPCLCD49_MASK) >> LCD_WF8B_BPCLCD49_SHIFT)
#define LCD_BRD_WF8B_BPCLCD49(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPCLCD49_SHIFT, LCD_WF8B_BPCLCD49_WIDTH))

/*! @brief Set the BPCLCD49 field to a new value. */
#define LCD_WR_WF8B_BPCLCD49(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPCLCD49_MASK, LCD_WF8B_BPCLCD49(value)))
#define LCD_BWR_WF8B_BPCLCD49(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPCLCD49_SHIFT), LCD_WF8B_BPCLCD49_SHIFT, LCD_WF8B_BPCLCD49_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPCLCD25[2] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase C
 * - 0b1 - LCD segment on or LCD backplane active for phase C
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPCLCD25 field. */
#define LCD_RD_WF8B_BPCLCD25(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPCLCD25_MASK) >> LCD_WF8B_BPCLCD25_SHIFT)
#define LCD_BRD_WF8B_BPCLCD25(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPCLCD25_SHIFT, LCD_WF8B_BPCLCD25_WIDTH))

/*! @brief Set the BPCLCD25 field to a new value. */
#define LCD_WR_WF8B_BPCLCD25(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPCLCD25_MASK, LCD_WF8B_BPCLCD25(value)))
#define LCD_BWR_WF8B_BPCLCD25(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPCLCD25_SHIFT), LCD_WF8B_BPCLCD25_SHIFT, LCD_WF8B_BPCLCD25_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPCLCD1[2] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase C
 * - 0b1 - LCD segment on or LCD backplane active for phase C
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPCLCD1 field. */
#define LCD_RD_WF8B_BPCLCD1(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPCLCD1_MASK) >> LCD_WF8B_BPCLCD1_SHIFT)
#define LCD_BRD_WF8B_BPCLCD1(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPCLCD1_SHIFT, LCD_WF8B_BPCLCD1_WIDTH))

/*! @brief Set the BPCLCD1 field to a new value. */
#define LCD_WR_WF8B_BPCLCD1(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPCLCD1_MASK, LCD_WF8B_BPCLCD1(value)))
#define LCD_BWR_WF8B_BPCLCD1(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPCLCD1_SHIFT), LCD_WF8B_BPCLCD1_SHIFT, LCD_WF8B_BPCLCD1_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPCLCD20[2] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase C
 * - 0b1 - LCD segment on or LCD backplane active for phase C
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPCLCD20 field. */
#define LCD_RD_WF8B_BPCLCD20(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPCLCD20_MASK) >> LCD_WF8B_BPCLCD20_SHIFT)
#define LCD_BRD_WF8B_BPCLCD20(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPCLCD20_SHIFT, LCD_WF8B_BPCLCD20_WIDTH))

/*! @brief Set the BPCLCD20 field to a new value. */
#define LCD_WR_WF8B_BPCLCD20(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPCLCD20_MASK, LCD_WF8B_BPCLCD20(value)))
#define LCD_BWR_WF8B_BPCLCD20(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPCLCD20_SHIFT), LCD_WF8B_BPCLCD20_SHIFT, LCD_WF8B_BPCLCD20_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPCLCD50[2] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase C
 * - 0b1 - LCD segment on or LCD backplane active for phase C
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPCLCD50 field. */
#define LCD_RD_WF8B_BPCLCD50(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPCLCD50_MASK) >> LCD_WF8B_BPCLCD50_SHIFT)
#define LCD_BRD_WF8B_BPCLCD50(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPCLCD50_SHIFT, LCD_WF8B_BPCLCD50_WIDTH))

/*! @brief Set the BPCLCD50 field to a new value. */
#define LCD_WR_WF8B_BPCLCD50(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPCLCD50_MASK, LCD_WF8B_BPCLCD50(value)))
#define LCD_BWR_WF8B_BPCLCD50(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPCLCD50_SHIFT), LCD_WF8B_BPCLCD50_SHIFT, LCD_WF8B_BPCLCD50_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPCLCD19[2] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase C
 * - 0b1 - LCD segment on or LCD backplane active for phase C
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPCLCD19 field. */
#define LCD_RD_WF8B_BPCLCD19(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPCLCD19_MASK) >> LCD_WF8B_BPCLCD19_SHIFT)
#define LCD_BRD_WF8B_BPCLCD19(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPCLCD19_SHIFT, LCD_WF8B_BPCLCD19_WIDTH))

/*! @brief Set the BPCLCD19 field to a new value. */
#define LCD_WR_WF8B_BPCLCD19(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPCLCD19_MASK, LCD_WF8B_BPCLCD19(value)))
#define LCD_BWR_WF8B_BPCLCD19(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPCLCD19_SHIFT), LCD_WF8B_BPCLCD19_SHIFT, LCD_WF8B_BPCLCD19_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPCLCD26[2] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase C
 * - 0b1 - LCD segment on or LCD backplane active for phase C
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPCLCD26 field. */
#define LCD_RD_WF8B_BPCLCD26(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPCLCD26_MASK) >> LCD_WF8B_BPCLCD26_SHIFT)
#define LCD_BRD_WF8B_BPCLCD26(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPCLCD26_SHIFT, LCD_WF8B_BPCLCD26_WIDTH))

/*! @brief Set the BPCLCD26 field to a new value. */
#define LCD_WR_WF8B_BPCLCD26(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPCLCD26_MASK, LCD_WF8B_BPCLCD26(value)))
#define LCD_BWR_WF8B_BPCLCD26(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPCLCD26_SHIFT), LCD_WF8B_BPCLCD26_SHIFT, LCD_WF8B_BPCLCD26_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPCLCD59[2] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase C
 * - 0b1 - LCD segment on or LCD backplane active for phase C
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPCLCD59 field. */
#define LCD_RD_WF8B_BPCLCD59(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPCLCD59_MASK) >> LCD_WF8B_BPCLCD59_SHIFT)
#define LCD_BRD_WF8B_BPCLCD59(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPCLCD59_SHIFT, LCD_WF8B_BPCLCD59_WIDTH))

/*! @brief Set the BPCLCD59 field to a new value. */
#define LCD_WR_WF8B_BPCLCD59(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPCLCD59_MASK, LCD_WF8B_BPCLCD59(value)))
#define LCD_BWR_WF8B_BPCLCD59(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPCLCD59_SHIFT), LCD_WF8B_BPCLCD59_SHIFT, LCD_WF8B_BPCLCD59_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPCLCD61[2] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase C
 * - 0b1 - LCD segment on or LCD backplane active for phase C
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPCLCD61 field. */
#define LCD_RD_WF8B_BPCLCD61(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPCLCD61_MASK) >> LCD_WF8B_BPCLCD61_SHIFT)
#define LCD_BRD_WF8B_BPCLCD61(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPCLCD61_SHIFT, LCD_WF8B_BPCLCD61_WIDTH))

/*! @brief Set the BPCLCD61 field to a new value. */
#define LCD_WR_WF8B_BPCLCD61(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPCLCD61_MASK, LCD_WF8B_BPCLCD61(value)))
#define LCD_BWR_WF8B_BPCLCD61(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPCLCD61_SHIFT), LCD_WF8B_BPCLCD61_SHIFT, LCD_WF8B_BPCLCD61_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPCLCD46[2] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase C
 * - 0b1 - LCD segment on or LCD backplane active for phase C
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPCLCD46 field. */
#define LCD_RD_WF8B_BPCLCD46(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPCLCD46_MASK) >> LCD_WF8B_BPCLCD46_SHIFT)
#define LCD_BRD_WF8B_BPCLCD46(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPCLCD46_SHIFT, LCD_WF8B_BPCLCD46_WIDTH))

/*! @brief Set the BPCLCD46 field to a new value. */
#define LCD_WR_WF8B_BPCLCD46(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPCLCD46_MASK, LCD_WF8B_BPCLCD46(value)))
#define LCD_BWR_WF8B_BPCLCD46(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPCLCD46_SHIFT), LCD_WF8B_BPCLCD46_SHIFT, LCD_WF8B_BPCLCD46_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPCLCD18[2] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase C
 * - 0b1 - LCD segment on or LCD backplane active for phase C
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPCLCD18 field. */
#define LCD_RD_WF8B_BPCLCD18(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPCLCD18_MASK) >> LCD_WF8B_BPCLCD18_SHIFT)
#define LCD_BRD_WF8B_BPCLCD18(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPCLCD18_SHIFT, LCD_WF8B_BPCLCD18_WIDTH))

/*! @brief Set the BPCLCD18 field to a new value. */
#define LCD_WR_WF8B_BPCLCD18(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPCLCD18_MASK, LCD_WF8B_BPCLCD18(value)))
#define LCD_BWR_WF8B_BPCLCD18(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPCLCD18_SHIFT), LCD_WF8B_BPCLCD18_SHIFT, LCD_WF8B_BPCLCD18_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPCLCD5[2] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase C
 * - 0b1 - LCD segment on or LCD backplane active for phase C
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPCLCD5 field. */
#define LCD_RD_WF8B_BPCLCD5(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPCLCD5_MASK) >> LCD_WF8B_BPCLCD5_SHIFT)
#define LCD_BRD_WF8B_BPCLCD5(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPCLCD5_SHIFT, LCD_WF8B_BPCLCD5_WIDTH))

/*! @brief Set the BPCLCD5 field to a new value. */
#define LCD_WR_WF8B_BPCLCD5(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPCLCD5_MASK, LCD_WF8B_BPCLCD5(value)))
#define LCD_BWR_WF8B_BPCLCD5(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPCLCD5_SHIFT), LCD_WF8B_BPCLCD5_SHIFT, LCD_WF8B_BPCLCD5_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPCLCD63[2] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase C
 * - 0b1 - LCD segment on or LCD backplane active for phase C
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPCLCD63 field. */
#define LCD_RD_WF8B_BPCLCD63(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPCLCD63_MASK) >> LCD_WF8B_BPCLCD63_SHIFT)
#define LCD_BRD_WF8B_BPCLCD63(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPCLCD63_SHIFT, LCD_WF8B_BPCLCD63_WIDTH))

/*! @brief Set the BPCLCD63 field to a new value. */
#define LCD_WR_WF8B_BPCLCD63(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPCLCD63_MASK, LCD_WF8B_BPCLCD63(value)))
#define LCD_BWR_WF8B_BPCLCD63(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPCLCD63_SHIFT), LCD_WF8B_BPCLCD63_SHIFT, LCD_WF8B_BPCLCD63_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPCLCD27[2] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase C
 * - 0b1 - LCD segment on or LCD backplane active for phase C
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPCLCD27 field. */
#define LCD_RD_WF8B_BPCLCD27(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPCLCD27_MASK) >> LCD_WF8B_BPCLCD27_SHIFT)
#define LCD_BRD_WF8B_BPCLCD27(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPCLCD27_SHIFT, LCD_WF8B_BPCLCD27_WIDTH))

/*! @brief Set the BPCLCD27 field to a new value. */
#define LCD_WR_WF8B_BPCLCD27(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPCLCD27_MASK, LCD_WF8B_BPCLCD27(value)))
#define LCD_BWR_WF8B_BPCLCD27(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPCLCD27_SHIFT), LCD_WF8B_BPCLCD27_SHIFT, LCD_WF8B_BPCLCD27_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPCLCD17[2] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase C
 * - 0b1 - LCD segment on or LCD backplane active for phase C
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPCLCD17 field. */
#define LCD_RD_WF8B_BPCLCD17(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPCLCD17_MASK) >> LCD_WF8B_BPCLCD17_SHIFT)
#define LCD_BRD_WF8B_BPCLCD17(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPCLCD17_SHIFT, LCD_WF8B_BPCLCD17_WIDTH))

/*! @brief Set the BPCLCD17 field to a new value. */
#define LCD_WR_WF8B_BPCLCD17(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPCLCD17_MASK, LCD_WF8B_BPCLCD17(value)))
#define LCD_BWR_WF8B_BPCLCD17(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPCLCD17_SHIFT), LCD_WF8B_BPCLCD17_SHIFT, LCD_WF8B_BPCLCD17_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPCLCD51[2] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase C
 * - 0b1 - LCD segment on or LCD backplane active for phase C
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPCLCD51 field. */
#define LCD_RD_WF8B_BPCLCD51(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPCLCD51_MASK) >> LCD_WF8B_BPCLCD51_SHIFT)
#define LCD_BRD_WF8B_BPCLCD51(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPCLCD51_SHIFT, LCD_WF8B_BPCLCD51_WIDTH))

/*! @brief Set the BPCLCD51 field to a new value. */
#define LCD_WR_WF8B_BPCLCD51(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPCLCD51_MASK, LCD_WF8B_BPCLCD51(value)))
#define LCD_BWR_WF8B_BPCLCD51(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPCLCD51_SHIFT), LCD_WF8B_BPCLCD51_SHIFT, LCD_WF8B_BPCLCD51_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPCLCD9[2] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase C
 * - 0b1 - LCD segment on or LCD backplane active for phase C
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPCLCD9 field. */
#define LCD_RD_WF8B_BPCLCD9(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPCLCD9_MASK) >> LCD_WF8B_BPCLCD9_SHIFT)
#define LCD_BRD_WF8B_BPCLCD9(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPCLCD9_SHIFT, LCD_WF8B_BPCLCD9_WIDTH))

/*! @brief Set the BPCLCD9 field to a new value. */
#define LCD_WR_WF8B_BPCLCD9(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPCLCD9_MASK, LCD_WF8B_BPCLCD9(value)))
#define LCD_BWR_WF8B_BPCLCD9(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPCLCD9_SHIFT), LCD_WF8B_BPCLCD9_SHIFT, LCD_WF8B_BPCLCD9_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPCLCD54[2] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase C
 * - 0b1 - LCD segment on or LCD backplane active for phase C
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPCLCD54 field. */
#define LCD_RD_WF8B_BPCLCD54(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPCLCD54_MASK) >> LCD_WF8B_BPCLCD54_SHIFT)
#define LCD_BRD_WF8B_BPCLCD54(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPCLCD54_SHIFT, LCD_WF8B_BPCLCD54_WIDTH))

/*! @brief Set the BPCLCD54 field to a new value. */
#define LCD_WR_WF8B_BPCLCD54(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPCLCD54_MASK, LCD_WF8B_BPCLCD54(value)))
#define LCD_BWR_WF8B_BPCLCD54(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPCLCD54_SHIFT), LCD_WF8B_BPCLCD54_SHIFT, LCD_WF8B_BPCLCD54_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPCLCD15[2] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase C
 * - 0b1 - LCD segment on or LCD backplane active for phase C
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPCLCD15 field. */
#define LCD_RD_WF8B_BPCLCD15(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPCLCD15_MASK) >> LCD_WF8B_BPCLCD15_SHIFT)
#define LCD_BRD_WF8B_BPCLCD15(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPCLCD15_SHIFT, LCD_WF8B_BPCLCD15_WIDTH))

/*! @brief Set the BPCLCD15 field to a new value. */
#define LCD_WR_WF8B_BPCLCD15(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPCLCD15_MASK, LCD_WF8B_BPCLCD15(value)))
#define LCD_BWR_WF8B_BPCLCD15(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPCLCD15_SHIFT), LCD_WF8B_BPCLCD15_SHIFT, LCD_WF8B_BPCLCD15_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPCLCD16[2] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase C
 * - 0b1 - LCD segment on or LCD backplane active for phase C
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPCLCD16 field. */
#define LCD_RD_WF8B_BPCLCD16(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPCLCD16_MASK) >> LCD_WF8B_BPCLCD16_SHIFT)
#define LCD_BRD_WF8B_BPCLCD16(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPCLCD16_SHIFT, LCD_WF8B_BPCLCD16_WIDTH))

/*! @brief Set the BPCLCD16 field to a new value. */
#define LCD_WR_WF8B_BPCLCD16(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPCLCD16_MASK, LCD_WF8B_BPCLCD16(value)))
#define LCD_BWR_WF8B_BPCLCD16(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPCLCD16_SHIFT), LCD_WF8B_BPCLCD16_SHIFT, LCD_WF8B_BPCLCD16_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPCLCD14[2] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase C
 * - 0b1 - LCD segment on or LCD backplane active for phase C
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPCLCD14 field. */
#define LCD_RD_WF8B_BPCLCD14(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPCLCD14_MASK) >> LCD_WF8B_BPCLCD14_SHIFT)
#define LCD_BRD_WF8B_BPCLCD14(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPCLCD14_SHIFT, LCD_WF8B_BPCLCD14_WIDTH))

/*! @brief Set the BPCLCD14 field to a new value. */
#define LCD_WR_WF8B_BPCLCD14(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPCLCD14_MASK, LCD_WF8B_BPCLCD14(value)))
#define LCD_BWR_WF8B_BPCLCD14(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPCLCD14_SHIFT), LCD_WF8B_BPCLCD14_SHIFT, LCD_WF8B_BPCLCD14_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPCLCD32[2] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase C
 * - 0b1 - LCD segment on or LCD backplane active for phase C
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPCLCD32 field. */
#define LCD_RD_WF8B_BPCLCD32(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPCLCD32_MASK) >> LCD_WF8B_BPCLCD32_SHIFT)
#define LCD_BRD_WF8B_BPCLCD32(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPCLCD32_SHIFT, LCD_WF8B_BPCLCD32_WIDTH))

/*! @brief Set the BPCLCD32 field to a new value. */
#define LCD_WR_WF8B_BPCLCD32(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPCLCD32_MASK, LCD_WF8B_BPCLCD32(value)))
#define LCD_BWR_WF8B_BPCLCD32(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPCLCD32_SHIFT), LCD_WF8B_BPCLCD32_SHIFT, LCD_WF8B_BPCLCD32_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPCLCD28[2] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase C
 * - 0b1 - LCD segment on or LCD backplane active for phase C
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPCLCD28 field. */
#define LCD_RD_WF8B_BPCLCD28(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPCLCD28_MASK) >> LCD_WF8B_BPCLCD28_SHIFT)
#define LCD_BRD_WF8B_BPCLCD28(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPCLCD28_SHIFT, LCD_WF8B_BPCLCD28_WIDTH))

/*! @brief Set the BPCLCD28 field to a new value. */
#define LCD_WR_WF8B_BPCLCD28(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPCLCD28_MASK, LCD_WF8B_BPCLCD28(value)))
#define LCD_BWR_WF8B_BPCLCD28(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPCLCD28_SHIFT), LCD_WF8B_BPCLCD28_SHIFT, LCD_WF8B_BPCLCD28_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPCLCD53[2] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase C
 * - 0b1 - LCD segment on or LCD backplane active for phase C
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPCLCD53 field. */
#define LCD_RD_WF8B_BPCLCD53(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPCLCD53_MASK) >> LCD_WF8B_BPCLCD53_SHIFT)
#define LCD_BRD_WF8B_BPCLCD53(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPCLCD53_SHIFT, LCD_WF8B_BPCLCD53_WIDTH))

/*! @brief Set the BPCLCD53 field to a new value. */
#define LCD_WR_WF8B_BPCLCD53(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPCLCD53_MASK, LCD_WF8B_BPCLCD53(value)))
#define LCD_BWR_WF8B_BPCLCD53(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPCLCD53_SHIFT), LCD_WF8B_BPCLCD53_SHIFT, LCD_WF8B_BPCLCD53_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPCLCD33[2] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase C
 * - 0b1 - LCD segment on or LCD backplane active for phase C
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPCLCD33 field. */
#define LCD_RD_WF8B_BPCLCD33(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPCLCD33_MASK) >> LCD_WF8B_BPCLCD33_SHIFT)
#define LCD_BRD_WF8B_BPCLCD33(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPCLCD33_SHIFT, LCD_WF8B_BPCLCD33_WIDTH))

/*! @brief Set the BPCLCD33 field to a new value. */
#define LCD_WR_WF8B_BPCLCD33(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPCLCD33_MASK, LCD_WF8B_BPCLCD33(value)))
#define LCD_BWR_WF8B_BPCLCD33(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPCLCD33_SHIFT), LCD_WF8B_BPCLCD33_SHIFT, LCD_WF8B_BPCLCD33_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPCLCD0[2] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase C
 * - 0b1 - LCD segment on or LCD backplane active for phase C
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPCLCD0 field. */
#define LCD_RD_WF8B_BPCLCD0(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPCLCD0_MASK) >> LCD_WF8B_BPCLCD0_SHIFT)
#define LCD_BRD_WF8B_BPCLCD0(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPCLCD0_SHIFT, LCD_WF8B_BPCLCD0_WIDTH))

/*! @brief Set the BPCLCD0 field to a new value. */
#define LCD_WR_WF8B_BPCLCD0(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPCLCD0_MASK, LCD_WF8B_BPCLCD0(value)))
#define LCD_BWR_WF8B_BPCLCD0(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPCLCD0_SHIFT), LCD_WF8B_BPCLCD0_SHIFT, LCD_WF8B_BPCLCD0_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPCLCD43[2] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase C
 * - 0b1 - LCD segment on or LCD backplane active for phase C
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPCLCD43 field. */
#define LCD_RD_WF8B_BPCLCD43(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPCLCD43_MASK) >> LCD_WF8B_BPCLCD43_SHIFT)
#define LCD_BRD_WF8B_BPCLCD43(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPCLCD43_SHIFT, LCD_WF8B_BPCLCD43_WIDTH))

/*! @brief Set the BPCLCD43 field to a new value. */
#define LCD_WR_WF8B_BPCLCD43(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPCLCD43_MASK, LCD_WF8B_BPCLCD43(value)))
#define LCD_BWR_WF8B_BPCLCD43(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPCLCD43_SHIFT), LCD_WF8B_BPCLCD43_SHIFT, LCD_WF8B_BPCLCD43_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPCLCD7[2] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase C
 * - 0b1 - LCD segment on or LCD backplane active for phase C
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPCLCD7 field. */
#define LCD_RD_WF8B_BPCLCD7(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPCLCD7_MASK) >> LCD_WF8B_BPCLCD7_SHIFT)
#define LCD_BRD_WF8B_BPCLCD7(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPCLCD7_SHIFT, LCD_WF8B_BPCLCD7_WIDTH))

/*! @brief Set the BPCLCD7 field to a new value. */
#define LCD_WR_WF8B_BPCLCD7(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPCLCD7_MASK, LCD_WF8B_BPCLCD7(value)))
#define LCD_BWR_WF8B_BPCLCD7(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPCLCD7_SHIFT), LCD_WF8B_BPCLCD7_SHIFT, LCD_WF8B_BPCLCD7_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPCLCD4[2] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase C
 * - 0b1 - LCD segment on or LCD backplane active for phase C
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPCLCD4 field. */
#define LCD_RD_WF8B_BPCLCD4(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPCLCD4_MASK) >> LCD_WF8B_BPCLCD4_SHIFT)
#define LCD_BRD_WF8B_BPCLCD4(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPCLCD4_SHIFT, LCD_WF8B_BPCLCD4_WIDTH))

/*! @brief Set the BPCLCD4 field to a new value. */
#define LCD_WR_WF8B_BPCLCD4(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPCLCD4_MASK, LCD_WF8B_BPCLCD4(value)))
#define LCD_BWR_WF8B_BPCLCD4(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPCLCD4_SHIFT), LCD_WF8B_BPCLCD4_SHIFT, LCD_WF8B_BPCLCD4_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPCLCD34[2] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase C
 * - 0b1 - LCD segment on or LCD backplane active for phase C
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPCLCD34 field. */
#define LCD_RD_WF8B_BPCLCD34(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPCLCD34_MASK) >> LCD_WF8B_BPCLCD34_SHIFT)
#define LCD_BRD_WF8B_BPCLCD34(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPCLCD34_SHIFT, LCD_WF8B_BPCLCD34_WIDTH))

/*! @brief Set the BPCLCD34 field to a new value. */
#define LCD_WR_WF8B_BPCLCD34(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPCLCD34_MASK, LCD_WF8B_BPCLCD34(value)))
#define LCD_BWR_WF8B_BPCLCD34(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPCLCD34_SHIFT), LCD_WF8B_BPCLCD34_SHIFT, LCD_WF8B_BPCLCD34_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPCLCD29[2] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase C
 * - 0b1 - LCD segment on or LCD backplane active for phase C
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPCLCD29 field. */
#define LCD_RD_WF8B_BPCLCD29(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPCLCD29_MASK) >> LCD_WF8B_BPCLCD29_SHIFT)
#define LCD_BRD_WF8B_BPCLCD29(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPCLCD29_SHIFT, LCD_WF8B_BPCLCD29_WIDTH))

/*! @brief Set the BPCLCD29 field to a new value. */
#define LCD_WR_WF8B_BPCLCD29(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPCLCD29_MASK, LCD_WF8B_BPCLCD29(value)))
#define LCD_BWR_WF8B_BPCLCD29(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPCLCD29_SHIFT), LCD_WF8B_BPCLCD29_SHIFT, LCD_WF8B_BPCLCD29_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPCLCD45[2] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase C
 * - 0b1 - LCD segment on or LCD backplane active for phase C
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPCLCD45 field. */
#define LCD_RD_WF8B_BPCLCD45(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPCLCD45_MASK) >> LCD_WF8B_BPCLCD45_SHIFT)
#define LCD_BRD_WF8B_BPCLCD45(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPCLCD45_SHIFT, LCD_WF8B_BPCLCD45_WIDTH))

/*! @brief Set the BPCLCD45 field to a new value. */
#define LCD_WR_WF8B_BPCLCD45(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPCLCD45_MASK, LCD_WF8B_BPCLCD45(value)))
#define LCD_BWR_WF8B_BPCLCD45(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPCLCD45_SHIFT), LCD_WF8B_BPCLCD45_SHIFT, LCD_WF8B_BPCLCD45_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPCLCD57[2] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase C
 * - 0b1 - LCD segment on or LCD backplane active for phase C
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPCLCD57 field. */
#define LCD_RD_WF8B_BPCLCD57(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPCLCD57_MASK) >> LCD_WF8B_BPCLCD57_SHIFT)
#define LCD_BRD_WF8B_BPCLCD57(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPCLCD57_SHIFT, LCD_WF8B_BPCLCD57_WIDTH))

/*! @brief Set the BPCLCD57 field to a new value. */
#define LCD_WR_WF8B_BPCLCD57(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPCLCD57_MASK, LCD_WF8B_BPCLCD57(value)))
#define LCD_BWR_WF8B_BPCLCD57(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPCLCD57_SHIFT), LCD_WF8B_BPCLCD57_SHIFT, LCD_WF8B_BPCLCD57_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPCLCD42[2] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase C
 * - 0b1 - LCD segment on or LCD backplane active for phase C
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPCLCD42 field. */
#define LCD_RD_WF8B_BPCLCD42(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPCLCD42_MASK) >> LCD_WF8B_BPCLCD42_SHIFT)
#define LCD_BRD_WF8B_BPCLCD42(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPCLCD42_SHIFT, LCD_WF8B_BPCLCD42_WIDTH))

/*! @brief Set the BPCLCD42 field to a new value. */
#define LCD_WR_WF8B_BPCLCD42(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPCLCD42_MASK, LCD_WF8B_BPCLCD42(value)))
#define LCD_BWR_WF8B_BPCLCD42(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPCLCD42_SHIFT), LCD_WF8B_BPCLCD42_SHIFT, LCD_WF8B_BPCLCD42_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPCLCD35[2] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase C
 * - 0b1 - LCD segment on or LCD backplane active for phase C
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPCLCD35 field. */
#define LCD_RD_WF8B_BPCLCD35(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPCLCD35_MASK) >> LCD_WF8B_BPCLCD35_SHIFT)
#define LCD_BRD_WF8B_BPCLCD35(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPCLCD35_SHIFT, LCD_WF8B_BPCLCD35_WIDTH))

/*! @brief Set the BPCLCD35 field to a new value. */
#define LCD_WR_WF8B_BPCLCD35(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPCLCD35_MASK, LCD_WF8B_BPCLCD35(value)))
#define LCD_BWR_WF8B_BPCLCD35(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPCLCD35_SHIFT), LCD_WF8B_BPCLCD35_SHIFT, LCD_WF8B_BPCLCD35_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPCLCD13[2] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase C
 * - 0b1 - LCD segment on or LCD backplane active for phase C
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPCLCD13 field. */
#define LCD_RD_WF8B_BPCLCD13(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPCLCD13_MASK) >> LCD_WF8B_BPCLCD13_SHIFT)
#define LCD_BRD_WF8B_BPCLCD13(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPCLCD13_SHIFT, LCD_WF8B_BPCLCD13_WIDTH))

/*! @brief Set the BPCLCD13 field to a new value. */
#define LCD_WR_WF8B_BPCLCD13(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPCLCD13_MASK, LCD_WF8B_BPCLCD13(value)))
#define LCD_BWR_WF8B_BPCLCD13(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPCLCD13_SHIFT), LCD_WF8B_BPCLCD13_SHIFT, LCD_WF8B_BPCLCD13_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPCLCD36[2] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase C
 * - 0b1 - LCD segment on or LCD backplane active for phase C
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPCLCD36 field. */
#define LCD_RD_WF8B_BPCLCD36(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPCLCD36_MASK) >> LCD_WF8B_BPCLCD36_SHIFT)
#define LCD_BRD_WF8B_BPCLCD36(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPCLCD36_SHIFT, LCD_WF8B_BPCLCD36_WIDTH))

/*! @brief Set the BPCLCD36 field to a new value. */
#define LCD_WR_WF8B_BPCLCD36(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPCLCD36_MASK, LCD_WF8B_BPCLCD36(value)))
#define LCD_BWR_WF8B_BPCLCD36(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPCLCD36_SHIFT), LCD_WF8B_BPCLCD36_SHIFT, LCD_WF8B_BPCLCD36_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPCLCD30[2] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase C
 * - 0b1 - LCD segment on or LCD backplane active for phase C
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPCLCD30 field. */
#define LCD_RD_WF8B_BPCLCD30(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPCLCD30_MASK) >> LCD_WF8B_BPCLCD30_SHIFT)
#define LCD_BRD_WF8B_BPCLCD30(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPCLCD30_SHIFT, LCD_WF8B_BPCLCD30_WIDTH))

/*! @brief Set the BPCLCD30 field to a new value. */
#define LCD_WR_WF8B_BPCLCD30(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPCLCD30_MASK, LCD_WF8B_BPCLCD30(value)))
#define LCD_BWR_WF8B_BPCLCD30(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPCLCD30_SHIFT), LCD_WF8B_BPCLCD30_SHIFT, LCD_WF8B_BPCLCD30_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPCLCD52[2] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase C
 * - 0b1 - LCD segment on or LCD backplane active for phase C
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPCLCD52 field. */
#define LCD_RD_WF8B_BPCLCD52(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPCLCD52_MASK) >> LCD_WF8B_BPCLCD52_SHIFT)
#define LCD_BRD_WF8B_BPCLCD52(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPCLCD52_SHIFT, LCD_WF8B_BPCLCD52_WIDTH))

/*! @brief Set the BPCLCD52 field to a new value. */
#define LCD_WR_WF8B_BPCLCD52(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPCLCD52_MASK, LCD_WF8B_BPCLCD52(value)))
#define LCD_BWR_WF8B_BPCLCD52(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPCLCD52_SHIFT), LCD_WF8B_BPCLCD52_SHIFT, LCD_WF8B_BPCLCD52_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPCLCD58[2] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase C
 * - 0b1 - LCD segment on or LCD backplane active for phase C
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPCLCD58 field. */
#define LCD_RD_WF8B_BPCLCD58(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPCLCD58_MASK) >> LCD_WF8B_BPCLCD58_SHIFT)
#define LCD_BRD_WF8B_BPCLCD58(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPCLCD58_SHIFT, LCD_WF8B_BPCLCD58_WIDTH))

/*! @brief Set the BPCLCD58 field to a new value. */
#define LCD_WR_WF8B_BPCLCD58(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPCLCD58_MASK, LCD_WF8B_BPCLCD58(value)))
#define LCD_BWR_WF8B_BPCLCD58(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPCLCD58_SHIFT), LCD_WF8B_BPCLCD58_SHIFT, LCD_WF8B_BPCLCD58_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPCLCD41[2] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase C
 * - 0b1 - LCD segment on or LCD backplane active for phase C
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPCLCD41 field. */
#define LCD_RD_WF8B_BPCLCD41(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPCLCD41_MASK) >> LCD_WF8B_BPCLCD41_SHIFT)
#define LCD_BRD_WF8B_BPCLCD41(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPCLCD41_SHIFT, LCD_WF8B_BPCLCD41_WIDTH))

/*! @brief Set the BPCLCD41 field to a new value. */
#define LCD_WR_WF8B_BPCLCD41(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPCLCD41_MASK, LCD_WF8B_BPCLCD41(value)))
#define LCD_BWR_WF8B_BPCLCD41(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPCLCD41_SHIFT), LCD_WF8B_BPCLCD41_SHIFT, LCD_WF8B_BPCLCD41_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPCLCD37[2] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase C
 * - 0b1 - LCD segment on or LCD backplane active for phase C
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPCLCD37 field. */
#define LCD_RD_WF8B_BPCLCD37(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPCLCD37_MASK) >> LCD_WF8B_BPCLCD37_SHIFT)
#define LCD_BRD_WF8B_BPCLCD37(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPCLCD37_SHIFT, LCD_WF8B_BPCLCD37_WIDTH))

/*! @brief Set the BPCLCD37 field to a new value. */
#define LCD_WR_WF8B_BPCLCD37(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPCLCD37_MASK, LCD_WF8B_BPCLCD37(value)))
#define LCD_BWR_WF8B_BPCLCD37(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPCLCD37_SHIFT), LCD_WF8B_BPCLCD37_SHIFT, LCD_WF8B_BPCLCD37_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPCLCD3[2] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase C
 * - 0b1 - LCD segment on or LCD backplane active for phase C
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPCLCD3 field. */
#define LCD_RD_WF8B_BPCLCD3(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPCLCD3_MASK) >> LCD_WF8B_BPCLCD3_SHIFT)
#define LCD_BRD_WF8B_BPCLCD3(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPCLCD3_SHIFT, LCD_WF8B_BPCLCD3_WIDTH))

/*! @brief Set the BPCLCD3 field to a new value. */
#define LCD_WR_WF8B_BPCLCD3(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPCLCD3_MASK, LCD_WF8B_BPCLCD3(value)))
#define LCD_BWR_WF8B_BPCLCD3(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPCLCD3_SHIFT), LCD_WF8B_BPCLCD3_SHIFT, LCD_WF8B_BPCLCD3_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPCLCD12[2] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase C
 * - 0b1 - LCD segment on or LCD backplane active for phase C
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPCLCD12 field. */
#define LCD_RD_WF8B_BPCLCD12(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPCLCD12_MASK) >> LCD_WF8B_BPCLCD12_SHIFT)
#define LCD_BRD_WF8B_BPCLCD12(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPCLCD12_SHIFT, LCD_WF8B_BPCLCD12_WIDTH))

/*! @brief Set the BPCLCD12 field to a new value. */
#define LCD_WR_WF8B_BPCLCD12(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPCLCD12_MASK, LCD_WF8B_BPCLCD12(value)))
#define LCD_BWR_WF8B_BPCLCD12(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPCLCD12_SHIFT), LCD_WF8B_BPCLCD12_SHIFT, LCD_WF8B_BPCLCD12_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPCLCD11[2] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase C
 * - 0b1 - LCD segment on or LCD backplane active for phase C
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPCLCD11 field. */
#define LCD_RD_WF8B_BPCLCD11(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPCLCD11_MASK) >> LCD_WF8B_BPCLCD11_SHIFT)
#define LCD_BRD_WF8B_BPCLCD11(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPCLCD11_SHIFT, LCD_WF8B_BPCLCD11_WIDTH))

/*! @brief Set the BPCLCD11 field to a new value. */
#define LCD_WR_WF8B_BPCLCD11(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPCLCD11_MASK, LCD_WF8B_BPCLCD11(value)))
#define LCD_BWR_WF8B_BPCLCD11(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPCLCD11_SHIFT), LCD_WF8B_BPCLCD11_SHIFT, LCD_WF8B_BPCLCD11_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPCLCD38[2] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase C
 * - 0b1 - LCD segment on or LCD backplane active for phase C
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPCLCD38 field. */
#define LCD_RD_WF8B_BPCLCD38(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPCLCD38_MASK) >> LCD_WF8B_BPCLCD38_SHIFT)
#define LCD_BRD_WF8B_BPCLCD38(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPCLCD38_SHIFT, LCD_WF8B_BPCLCD38_WIDTH))

/*! @brief Set the BPCLCD38 field to a new value. */
#define LCD_WR_WF8B_BPCLCD38(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPCLCD38_MASK, LCD_WF8B_BPCLCD38(value)))
#define LCD_BWR_WF8B_BPCLCD38(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPCLCD38_SHIFT), LCD_WF8B_BPCLCD38_SHIFT, LCD_WF8B_BPCLCD38_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPCLCD44[2] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase C
 * - 0b1 - LCD segment on or LCD backplane active for phase C
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPCLCD44 field. */
#define LCD_RD_WF8B_BPCLCD44(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPCLCD44_MASK) >> LCD_WF8B_BPCLCD44_SHIFT)
#define LCD_BRD_WF8B_BPCLCD44(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPCLCD44_SHIFT, LCD_WF8B_BPCLCD44_WIDTH))

/*! @brief Set the BPCLCD44 field to a new value. */
#define LCD_WR_WF8B_BPCLCD44(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPCLCD44_MASK, LCD_WF8B_BPCLCD44(value)))
#define LCD_BWR_WF8B_BPCLCD44(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPCLCD44_SHIFT), LCD_WF8B_BPCLCD44_SHIFT, LCD_WF8B_BPCLCD44_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPCLCD31[2] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase C
 * - 0b1 - LCD segment on or LCD backplane active for phase C
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPCLCD31 field. */
#define LCD_RD_WF8B_BPCLCD31(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPCLCD31_MASK) >> LCD_WF8B_BPCLCD31_SHIFT)
#define LCD_BRD_WF8B_BPCLCD31(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPCLCD31_SHIFT, LCD_WF8B_BPCLCD31_WIDTH))

/*! @brief Set the BPCLCD31 field to a new value. */
#define LCD_WR_WF8B_BPCLCD31(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPCLCD31_MASK, LCD_WF8B_BPCLCD31(value)))
#define LCD_BWR_WF8B_BPCLCD31(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPCLCD31_SHIFT), LCD_WF8B_BPCLCD31_SHIFT, LCD_WF8B_BPCLCD31_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPCLCD40[2] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase C
 * - 0b1 - LCD segment on or LCD backplane active for phase C
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPCLCD40 field. */
#define LCD_RD_WF8B_BPCLCD40(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPCLCD40_MASK) >> LCD_WF8B_BPCLCD40_SHIFT)
#define LCD_BRD_WF8B_BPCLCD40(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPCLCD40_SHIFT, LCD_WF8B_BPCLCD40_WIDTH))

/*! @brief Set the BPCLCD40 field to a new value. */
#define LCD_WR_WF8B_BPCLCD40(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPCLCD40_MASK, LCD_WF8B_BPCLCD40(value)))
#define LCD_BWR_WF8B_BPCLCD40(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPCLCD40_SHIFT), LCD_WF8B_BPCLCD40_SHIFT, LCD_WF8B_BPCLCD40_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPCLCD62[2] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase C
 * - 0b1 - LCD segment on or LCD backplane active for phase C
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPCLCD62 field. */
#define LCD_RD_WF8B_BPCLCD62(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPCLCD62_MASK) >> LCD_WF8B_BPCLCD62_SHIFT)
#define LCD_BRD_WF8B_BPCLCD62(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPCLCD62_SHIFT, LCD_WF8B_BPCLCD62_WIDTH))

/*! @brief Set the BPCLCD62 field to a new value. */
#define LCD_WR_WF8B_BPCLCD62(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPCLCD62_MASK, LCD_WF8B_BPCLCD62(value)))
#define LCD_BWR_WF8B_BPCLCD62(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPCLCD62_SHIFT), LCD_WF8B_BPCLCD62_SHIFT, LCD_WF8B_BPCLCD62_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPCLCD56[2] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase C
 * - 0b1 - LCD segment on or LCD backplane active for phase C
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPCLCD56 field. */
#define LCD_RD_WF8B_BPCLCD56(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPCLCD56_MASK) >> LCD_WF8B_BPCLCD56_SHIFT)
#define LCD_BRD_WF8B_BPCLCD56(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPCLCD56_SHIFT, LCD_WF8B_BPCLCD56_WIDTH))

/*! @brief Set the BPCLCD56 field to a new value. */
#define LCD_WR_WF8B_BPCLCD56(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPCLCD56_MASK, LCD_WF8B_BPCLCD56(value)))
#define LCD_BWR_WF8B_BPCLCD56(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPCLCD56_SHIFT), LCD_WF8B_BPCLCD56_SHIFT, LCD_WF8B_BPCLCD56_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPCLCD39[2] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase C
 * - 0b1 - LCD segment on or LCD backplane active for phase C
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPCLCD39 field. */
#define LCD_RD_WF8B_BPCLCD39(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPCLCD39_MASK) >> LCD_WF8B_BPCLCD39_SHIFT)
#define LCD_BRD_WF8B_BPCLCD39(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPCLCD39_SHIFT, LCD_WF8B_BPCLCD39_WIDTH))

/*! @brief Set the BPCLCD39 field to a new value. */
#define LCD_WR_WF8B_BPCLCD39(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPCLCD39_MASK, LCD_WF8B_BPCLCD39(value)))
#define LCD_BWR_WF8B_BPCLCD39(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPCLCD39_SHIFT), LCD_WF8B_BPCLCD39_SHIFT, LCD_WF8B_BPCLCD39_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPCLCD6[2] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase C
 * - 0b1 - LCD segment on or LCD backplane active for phase C
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPCLCD6 field. */
#define LCD_RD_WF8B_BPCLCD6(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPCLCD6_MASK) >> LCD_WF8B_BPCLCD6_SHIFT)
#define LCD_BRD_WF8B_BPCLCD6(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPCLCD6_SHIFT, LCD_WF8B_BPCLCD6_WIDTH))

/*! @brief Set the BPCLCD6 field to a new value. */
#define LCD_WR_WF8B_BPCLCD6(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPCLCD6_MASK, LCD_WF8B_BPCLCD6(value)))
#define LCD_BWR_WF8B_BPCLCD6(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPCLCD6_SHIFT), LCD_WF8B_BPCLCD6_SHIFT, LCD_WF8B_BPCLCD6_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPDLCD47[3] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase D
 * - 0b1 - LCD segment on or LCD backplane active for phase D
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPDLCD47 field. */
#define LCD_RD_WF8B_BPDLCD47(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPDLCD47_MASK) >> LCD_WF8B_BPDLCD47_SHIFT)
#define LCD_BRD_WF8B_BPDLCD47(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPDLCD47_SHIFT, LCD_WF8B_BPDLCD47_WIDTH))

/*! @brief Set the BPDLCD47 field to a new value. */
#define LCD_WR_WF8B_BPDLCD47(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPDLCD47_MASK, LCD_WF8B_BPDLCD47(value)))
#define LCD_BWR_WF8B_BPDLCD47(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPDLCD47_SHIFT), LCD_WF8B_BPDLCD47_SHIFT, LCD_WF8B_BPDLCD47_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPDLCD23[3] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase D
 * - 0b1 - LCD segment on or LCD backplane active for phase D
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPDLCD23 field. */
#define LCD_RD_WF8B_BPDLCD23(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPDLCD23_MASK) >> LCD_WF8B_BPDLCD23_SHIFT)
#define LCD_BRD_WF8B_BPDLCD23(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPDLCD23_SHIFT, LCD_WF8B_BPDLCD23_WIDTH))

/*! @brief Set the BPDLCD23 field to a new value. */
#define LCD_WR_WF8B_BPDLCD23(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPDLCD23_MASK, LCD_WF8B_BPDLCD23(value)))
#define LCD_BWR_WF8B_BPDLCD23(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPDLCD23_SHIFT), LCD_WF8B_BPDLCD23_SHIFT, LCD_WF8B_BPDLCD23_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPDLCD48[3] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase D
 * - 0b1 - LCD segment on or LCD backplane active for phase D
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPDLCD48 field. */
#define LCD_RD_WF8B_BPDLCD48(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPDLCD48_MASK) >> LCD_WF8B_BPDLCD48_SHIFT)
#define LCD_BRD_WF8B_BPDLCD48(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPDLCD48_SHIFT, LCD_WF8B_BPDLCD48_WIDTH))

/*! @brief Set the BPDLCD48 field to a new value. */
#define LCD_WR_WF8B_BPDLCD48(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPDLCD48_MASK, LCD_WF8B_BPDLCD48(value)))
#define LCD_BWR_WF8B_BPDLCD48(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPDLCD48_SHIFT), LCD_WF8B_BPDLCD48_SHIFT, LCD_WF8B_BPDLCD48_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPDLCD24[3] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase D
 * - 0b1 - LCD segment on or LCD backplane active for phase D
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPDLCD24 field. */
#define LCD_RD_WF8B_BPDLCD24(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPDLCD24_MASK) >> LCD_WF8B_BPDLCD24_SHIFT)
#define LCD_BRD_WF8B_BPDLCD24(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPDLCD24_SHIFT, LCD_WF8B_BPDLCD24_WIDTH))

/*! @brief Set the BPDLCD24 field to a new value. */
#define LCD_WR_WF8B_BPDLCD24(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPDLCD24_MASK, LCD_WF8B_BPDLCD24(value)))
#define LCD_BWR_WF8B_BPDLCD24(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPDLCD24_SHIFT), LCD_WF8B_BPDLCD24_SHIFT, LCD_WF8B_BPDLCD24_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPDLCD15[3] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase D
 * - 0b1 - LCD segment on or LCD backplane active for phase D
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPDLCD15 field. */
#define LCD_RD_WF8B_BPDLCD15(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPDLCD15_MASK) >> LCD_WF8B_BPDLCD15_SHIFT)
#define LCD_BRD_WF8B_BPDLCD15(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPDLCD15_SHIFT, LCD_WF8B_BPDLCD15_WIDTH))

/*! @brief Set the BPDLCD15 field to a new value. */
#define LCD_WR_WF8B_BPDLCD15(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPDLCD15_MASK, LCD_WF8B_BPDLCD15(value)))
#define LCD_BWR_WF8B_BPDLCD15(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPDLCD15_SHIFT), LCD_WF8B_BPDLCD15_SHIFT, LCD_WF8B_BPDLCD15_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPDLCD22[3] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase D
 * - 0b1 - LCD segment on or LCD backplane active for phase D
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPDLCD22 field. */
#define LCD_RD_WF8B_BPDLCD22(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPDLCD22_MASK) >> LCD_WF8B_BPDLCD22_SHIFT)
#define LCD_BRD_WF8B_BPDLCD22(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPDLCD22_SHIFT, LCD_WF8B_BPDLCD22_WIDTH))

/*! @brief Set the BPDLCD22 field to a new value. */
#define LCD_WR_WF8B_BPDLCD22(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPDLCD22_MASK, LCD_WF8B_BPDLCD22(value)))
#define LCD_BWR_WF8B_BPDLCD22(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPDLCD22_SHIFT), LCD_WF8B_BPDLCD22_SHIFT, LCD_WF8B_BPDLCD22_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPDLCD60[3] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase D
 * - 0b1 - LCD segment on or LCD backplane active for phase D
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPDLCD60 field. */
#define LCD_RD_WF8B_BPDLCD60(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPDLCD60_MASK) >> LCD_WF8B_BPDLCD60_SHIFT)
#define LCD_BRD_WF8B_BPDLCD60(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPDLCD60_SHIFT, LCD_WF8B_BPDLCD60_WIDTH))

/*! @brief Set the BPDLCD60 field to a new value. */
#define LCD_WR_WF8B_BPDLCD60(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPDLCD60_MASK, LCD_WF8B_BPDLCD60(value)))
#define LCD_BWR_WF8B_BPDLCD60(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPDLCD60_SHIFT), LCD_WF8B_BPDLCD60_SHIFT, LCD_WF8B_BPDLCD60_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPDLCD10[3] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase D
 * - 0b1 - LCD segment on or LCD backplane active for phase D
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPDLCD10 field. */
#define LCD_RD_WF8B_BPDLCD10(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPDLCD10_MASK) >> LCD_WF8B_BPDLCD10_SHIFT)
#define LCD_BRD_WF8B_BPDLCD10(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPDLCD10_SHIFT, LCD_WF8B_BPDLCD10_WIDTH))

/*! @brief Set the BPDLCD10 field to a new value. */
#define LCD_WR_WF8B_BPDLCD10(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPDLCD10_MASK, LCD_WF8B_BPDLCD10(value)))
#define LCD_BWR_WF8B_BPDLCD10(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPDLCD10_SHIFT), LCD_WF8B_BPDLCD10_SHIFT, LCD_WF8B_BPDLCD10_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPDLCD21[3] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase D
 * - 0b1 - LCD segment on or LCD backplane active for phase D
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPDLCD21 field. */
#define LCD_RD_WF8B_BPDLCD21(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPDLCD21_MASK) >> LCD_WF8B_BPDLCD21_SHIFT)
#define LCD_BRD_WF8B_BPDLCD21(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPDLCD21_SHIFT, LCD_WF8B_BPDLCD21_WIDTH))

/*! @brief Set the BPDLCD21 field to a new value. */
#define LCD_WR_WF8B_BPDLCD21(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPDLCD21_MASK, LCD_WF8B_BPDLCD21(value)))
#define LCD_BWR_WF8B_BPDLCD21(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPDLCD21_SHIFT), LCD_WF8B_BPDLCD21_SHIFT, LCD_WF8B_BPDLCD21_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPDLCD49[3] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase D
 * - 0b1 - LCD segment on or LCD backplane active for phase D
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPDLCD49 field. */
#define LCD_RD_WF8B_BPDLCD49(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPDLCD49_MASK) >> LCD_WF8B_BPDLCD49_SHIFT)
#define LCD_BRD_WF8B_BPDLCD49(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPDLCD49_SHIFT, LCD_WF8B_BPDLCD49_WIDTH))

/*! @brief Set the BPDLCD49 field to a new value. */
#define LCD_WR_WF8B_BPDLCD49(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPDLCD49_MASK, LCD_WF8B_BPDLCD49(value)))
#define LCD_BWR_WF8B_BPDLCD49(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPDLCD49_SHIFT), LCD_WF8B_BPDLCD49_SHIFT, LCD_WF8B_BPDLCD49_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPDLCD1[3] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase D
 * - 0b1 - LCD segment on or LCD backplane active for phase D
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPDLCD1 field. */
#define LCD_RD_WF8B_BPDLCD1(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPDLCD1_MASK) >> LCD_WF8B_BPDLCD1_SHIFT)
#define LCD_BRD_WF8B_BPDLCD1(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPDLCD1_SHIFT, LCD_WF8B_BPDLCD1_WIDTH))

/*! @brief Set the BPDLCD1 field to a new value. */
#define LCD_WR_WF8B_BPDLCD1(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPDLCD1_MASK, LCD_WF8B_BPDLCD1(value)))
#define LCD_BWR_WF8B_BPDLCD1(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPDLCD1_SHIFT), LCD_WF8B_BPDLCD1_SHIFT, LCD_WF8B_BPDLCD1_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPDLCD25[3] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase D
 * - 0b1 - LCD segment on or LCD backplane active for phase D
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPDLCD25 field. */
#define LCD_RD_WF8B_BPDLCD25(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPDLCD25_MASK) >> LCD_WF8B_BPDLCD25_SHIFT)
#define LCD_BRD_WF8B_BPDLCD25(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPDLCD25_SHIFT, LCD_WF8B_BPDLCD25_WIDTH))

/*! @brief Set the BPDLCD25 field to a new value. */
#define LCD_WR_WF8B_BPDLCD25(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPDLCD25_MASK, LCD_WF8B_BPDLCD25(value)))
#define LCD_BWR_WF8B_BPDLCD25(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPDLCD25_SHIFT), LCD_WF8B_BPDLCD25_SHIFT, LCD_WF8B_BPDLCD25_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPDLCD20[3] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase D
 * - 0b1 - LCD segment on or LCD backplane active for phase D
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPDLCD20 field. */
#define LCD_RD_WF8B_BPDLCD20(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPDLCD20_MASK) >> LCD_WF8B_BPDLCD20_SHIFT)
#define LCD_BRD_WF8B_BPDLCD20(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPDLCD20_SHIFT, LCD_WF8B_BPDLCD20_WIDTH))

/*! @brief Set the BPDLCD20 field to a new value. */
#define LCD_WR_WF8B_BPDLCD20(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPDLCD20_MASK, LCD_WF8B_BPDLCD20(value)))
#define LCD_BWR_WF8B_BPDLCD20(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPDLCD20_SHIFT), LCD_WF8B_BPDLCD20_SHIFT, LCD_WF8B_BPDLCD20_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPDLCD2[3] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase D
 * - 0b1 - LCD segment on or LCD backplane active for phase D
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPDLCD2 field. */
#define LCD_RD_WF8B_BPDLCD2(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPDLCD2_MASK) >> LCD_WF8B_BPDLCD2_SHIFT)
#define LCD_BRD_WF8B_BPDLCD2(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPDLCD2_SHIFT, LCD_WF8B_BPDLCD2_WIDTH))

/*! @brief Set the BPDLCD2 field to a new value. */
#define LCD_WR_WF8B_BPDLCD2(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPDLCD2_MASK, LCD_WF8B_BPDLCD2(value)))
#define LCD_BWR_WF8B_BPDLCD2(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPDLCD2_SHIFT), LCD_WF8B_BPDLCD2_SHIFT, LCD_WF8B_BPDLCD2_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPDLCD55[3] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase D
 * - 0b1 - LCD segment on or LCD backplane active for phase D
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPDLCD55 field. */
#define LCD_RD_WF8B_BPDLCD55(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPDLCD55_MASK) >> LCD_WF8B_BPDLCD55_SHIFT)
#define LCD_BRD_WF8B_BPDLCD55(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPDLCD55_SHIFT, LCD_WF8B_BPDLCD55_WIDTH))

/*! @brief Set the BPDLCD55 field to a new value. */
#define LCD_WR_WF8B_BPDLCD55(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPDLCD55_MASK, LCD_WF8B_BPDLCD55(value)))
#define LCD_BWR_WF8B_BPDLCD55(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPDLCD55_SHIFT), LCD_WF8B_BPDLCD55_SHIFT, LCD_WF8B_BPDLCD55_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPDLCD59[3] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase D
 * - 0b1 - LCD segment on or LCD backplane active for phase D
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPDLCD59 field. */
#define LCD_RD_WF8B_BPDLCD59(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPDLCD59_MASK) >> LCD_WF8B_BPDLCD59_SHIFT)
#define LCD_BRD_WF8B_BPDLCD59(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPDLCD59_SHIFT, LCD_WF8B_BPDLCD59_WIDTH))

/*! @brief Set the BPDLCD59 field to a new value. */
#define LCD_WR_WF8B_BPDLCD59(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPDLCD59_MASK, LCD_WF8B_BPDLCD59(value)))
#define LCD_BWR_WF8B_BPDLCD59(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPDLCD59_SHIFT), LCD_WF8B_BPDLCD59_SHIFT, LCD_WF8B_BPDLCD59_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPDLCD5[3] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase D
 * - 0b1 - LCD segment on or LCD backplane active for phase D
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPDLCD5 field. */
#define LCD_RD_WF8B_BPDLCD5(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPDLCD5_MASK) >> LCD_WF8B_BPDLCD5_SHIFT)
#define LCD_BRD_WF8B_BPDLCD5(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPDLCD5_SHIFT, LCD_WF8B_BPDLCD5_WIDTH))

/*! @brief Set the BPDLCD5 field to a new value. */
#define LCD_WR_WF8B_BPDLCD5(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPDLCD5_MASK, LCD_WF8B_BPDLCD5(value)))
#define LCD_BWR_WF8B_BPDLCD5(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPDLCD5_SHIFT), LCD_WF8B_BPDLCD5_SHIFT, LCD_WF8B_BPDLCD5_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPDLCD19[3] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase D
 * - 0b1 - LCD segment on or LCD backplane active for phase D
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPDLCD19 field. */
#define LCD_RD_WF8B_BPDLCD19(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPDLCD19_MASK) >> LCD_WF8B_BPDLCD19_SHIFT)
#define LCD_BRD_WF8B_BPDLCD19(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPDLCD19_SHIFT, LCD_WF8B_BPDLCD19_WIDTH))

/*! @brief Set the BPDLCD19 field to a new value. */
#define LCD_WR_WF8B_BPDLCD19(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPDLCD19_MASK, LCD_WF8B_BPDLCD19(value)))
#define LCD_BWR_WF8B_BPDLCD19(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPDLCD19_SHIFT), LCD_WF8B_BPDLCD19_SHIFT, LCD_WF8B_BPDLCD19_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPDLCD6[3] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase D
 * - 0b1 - LCD segment on or LCD backplane active for phase D
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPDLCD6 field. */
#define LCD_RD_WF8B_BPDLCD6(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPDLCD6_MASK) >> LCD_WF8B_BPDLCD6_SHIFT)
#define LCD_BRD_WF8B_BPDLCD6(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPDLCD6_SHIFT, LCD_WF8B_BPDLCD6_WIDTH))

/*! @brief Set the BPDLCD6 field to a new value. */
#define LCD_WR_WF8B_BPDLCD6(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPDLCD6_MASK, LCD_WF8B_BPDLCD6(value)))
#define LCD_BWR_WF8B_BPDLCD6(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPDLCD6_SHIFT), LCD_WF8B_BPDLCD6_SHIFT, LCD_WF8B_BPDLCD6_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPDLCD26[3] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase D
 * - 0b1 - LCD segment on or LCD backplane active for phase D
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPDLCD26 field. */
#define LCD_RD_WF8B_BPDLCD26(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPDLCD26_MASK) >> LCD_WF8B_BPDLCD26_SHIFT)
#define LCD_BRD_WF8B_BPDLCD26(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPDLCD26_SHIFT, LCD_WF8B_BPDLCD26_WIDTH))

/*! @brief Set the BPDLCD26 field to a new value. */
#define LCD_WR_WF8B_BPDLCD26(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPDLCD26_MASK, LCD_WF8B_BPDLCD26(value)))
#define LCD_BWR_WF8B_BPDLCD26(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPDLCD26_SHIFT), LCD_WF8B_BPDLCD26_SHIFT, LCD_WF8B_BPDLCD26_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPDLCD0[3] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase D
 * - 0b1 - LCD segment on or LCD backplane active for phase D
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPDLCD0 field. */
#define LCD_RD_WF8B_BPDLCD0(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPDLCD0_MASK) >> LCD_WF8B_BPDLCD0_SHIFT)
#define LCD_BRD_WF8B_BPDLCD0(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPDLCD0_SHIFT, LCD_WF8B_BPDLCD0_WIDTH))

/*! @brief Set the BPDLCD0 field to a new value. */
#define LCD_WR_WF8B_BPDLCD0(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPDLCD0_MASK, LCD_WF8B_BPDLCD0(value)))
#define LCD_BWR_WF8B_BPDLCD0(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPDLCD0_SHIFT), LCD_WF8B_BPDLCD0_SHIFT, LCD_WF8B_BPDLCD0_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPDLCD50[3] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase D
 * - 0b1 - LCD segment on or LCD backplane active for phase D
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPDLCD50 field. */
#define LCD_RD_WF8B_BPDLCD50(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPDLCD50_MASK) >> LCD_WF8B_BPDLCD50_SHIFT)
#define LCD_BRD_WF8B_BPDLCD50(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPDLCD50_SHIFT, LCD_WF8B_BPDLCD50_WIDTH))

/*! @brief Set the BPDLCD50 field to a new value. */
#define LCD_WR_WF8B_BPDLCD50(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPDLCD50_MASK, LCD_WF8B_BPDLCD50(value)))
#define LCD_BWR_WF8B_BPDLCD50(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPDLCD50_SHIFT), LCD_WF8B_BPDLCD50_SHIFT, LCD_WF8B_BPDLCD50_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPDLCD46[3] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase D
 * - 0b1 - LCD segment on or LCD backplane active for phase D
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPDLCD46 field. */
#define LCD_RD_WF8B_BPDLCD46(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPDLCD46_MASK) >> LCD_WF8B_BPDLCD46_SHIFT)
#define LCD_BRD_WF8B_BPDLCD46(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPDLCD46_SHIFT, LCD_WF8B_BPDLCD46_WIDTH))

/*! @brief Set the BPDLCD46 field to a new value. */
#define LCD_WR_WF8B_BPDLCD46(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPDLCD46_MASK, LCD_WF8B_BPDLCD46(value)))
#define LCD_BWR_WF8B_BPDLCD46(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPDLCD46_SHIFT), LCD_WF8B_BPDLCD46_SHIFT, LCD_WF8B_BPDLCD46_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPDLCD18[3] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase D
 * - 0b1 - LCD segment on or LCD backplane active for phase D
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPDLCD18 field. */
#define LCD_RD_WF8B_BPDLCD18(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPDLCD18_MASK) >> LCD_WF8B_BPDLCD18_SHIFT)
#define LCD_BRD_WF8B_BPDLCD18(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPDLCD18_SHIFT, LCD_WF8B_BPDLCD18_WIDTH))

/*! @brief Set the BPDLCD18 field to a new value. */
#define LCD_WR_WF8B_BPDLCD18(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPDLCD18_MASK, LCD_WF8B_BPDLCD18(value)))
#define LCD_BWR_WF8B_BPDLCD18(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPDLCD18_SHIFT), LCD_WF8B_BPDLCD18_SHIFT, LCD_WF8B_BPDLCD18_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPDLCD61[3] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase D
 * - 0b1 - LCD segment on or LCD backplane active for phase D
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPDLCD61 field. */
#define LCD_RD_WF8B_BPDLCD61(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPDLCD61_MASK) >> LCD_WF8B_BPDLCD61_SHIFT)
#define LCD_BRD_WF8B_BPDLCD61(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPDLCD61_SHIFT, LCD_WF8B_BPDLCD61_WIDTH))

/*! @brief Set the BPDLCD61 field to a new value. */
#define LCD_WR_WF8B_BPDLCD61(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPDLCD61_MASK, LCD_WF8B_BPDLCD61(value)))
#define LCD_BWR_WF8B_BPDLCD61(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPDLCD61_SHIFT), LCD_WF8B_BPDLCD61_SHIFT, LCD_WF8B_BPDLCD61_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPDLCD9[3] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase D
 * - 0b1 - LCD segment on or LCD backplane active for phase D
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPDLCD9 field. */
#define LCD_RD_WF8B_BPDLCD9(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPDLCD9_MASK) >> LCD_WF8B_BPDLCD9_SHIFT)
#define LCD_BRD_WF8B_BPDLCD9(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPDLCD9_SHIFT, LCD_WF8B_BPDLCD9_WIDTH))

/*! @brief Set the BPDLCD9 field to a new value. */
#define LCD_WR_WF8B_BPDLCD9(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPDLCD9_MASK, LCD_WF8B_BPDLCD9(value)))
#define LCD_BWR_WF8B_BPDLCD9(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPDLCD9_SHIFT), LCD_WF8B_BPDLCD9_SHIFT, LCD_WF8B_BPDLCD9_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPDLCD17[3] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase D
 * - 0b1 - LCD segment on or LCD backplane active for phase D
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPDLCD17 field. */
#define LCD_RD_WF8B_BPDLCD17(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPDLCD17_MASK) >> LCD_WF8B_BPDLCD17_SHIFT)
#define LCD_BRD_WF8B_BPDLCD17(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPDLCD17_SHIFT, LCD_WF8B_BPDLCD17_WIDTH))

/*! @brief Set the BPDLCD17 field to a new value. */
#define LCD_WR_WF8B_BPDLCD17(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPDLCD17_MASK, LCD_WF8B_BPDLCD17(value)))
#define LCD_BWR_WF8B_BPDLCD17(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPDLCD17_SHIFT), LCD_WF8B_BPDLCD17_SHIFT, LCD_WF8B_BPDLCD17_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPDLCD27[3] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase D
 * - 0b1 - LCD segment on or LCD backplane active for phase D
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPDLCD27 field. */
#define LCD_RD_WF8B_BPDLCD27(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPDLCD27_MASK) >> LCD_WF8B_BPDLCD27_SHIFT)
#define LCD_BRD_WF8B_BPDLCD27(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPDLCD27_SHIFT, LCD_WF8B_BPDLCD27_WIDTH))

/*! @brief Set the BPDLCD27 field to a new value. */
#define LCD_WR_WF8B_BPDLCD27(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPDLCD27_MASK, LCD_WF8B_BPDLCD27(value)))
#define LCD_BWR_WF8B_BPDLCD27(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPDLCD27_SHIFT), LCD_WF8B_BPDLCD27_SHIFT, LCD_WF8B_BPDLCD27_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPDLCD53[3] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase D
 * - 0b1 - LCD segment on or LCD backplane active for phase D
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPDLCD53 field. */
#define LCD_RD_WF8B_BPDLCD53(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPDLCD53_MASK) >> LCD_WF8B_BPDLCD53_SHIFT)
#define LCD_BRD_WF8B_BPDLCD53(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPDLCD53_SHIFT, LCD_WF8B_BPDLCD53_WIDTH))

/*! @brief Set the BPDLCD53 field to a new value. */
#define LCD_WR_WF8B_BPDLCD53(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPDLCD53_MASK, LCD_WF8B_BPDLCD53(value)))
#define LCD_BWR_WF8B_BPDLCD53(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPDLCD53_SHIFT), LCD_WF8B_BPDLCD53_SHIFT, LCD_WF8B_BPDLCD53_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPDLCD51[3] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase D
 * - 0b1 - LCD segment on or LCD backplane active for phase D
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPDLCD51 field. */
#define LCD_RD_WF8B_BPDLCD51(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPDLCD51_MASK) >> LCD_WF8B_BPDLCD51_SHIFT)
#define LCD_BRD_WF8B_BPDLCD51(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPDLCD51_SHIFT, LCD_WF8B_BPDLCD51_WIDTH))

/*! @brief Set the BPDLCD51 field to a new value. */
#define LCD_WR_WF8B_BPDLCD51(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPDLCD51_MASK, LCD_WF8B_BPDLCD51(value)))
#define LCD_BWR_WF8B_BPDLCD51(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPDLCD51_SHIFT), LCD_WF8B_BPDLCD51_SHIFT, LCD_WF8B_BPDLCD51_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPDLCD54[3] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase D
 * - 0b1 - LCD segment on or LCD backplane active for phase D
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPDLCD54 field. */
#define LCD_RD_WF8B_BPDLCD54(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPDLCD54_MASK) >> LCD_WF8B_BPDLCD54_SHIFT)
#define LCD_BRD_WF8B_BPDLCD54(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPDLCD54_SHIFT, LCD_WF8B_BPDLCD54_WIDTH))

/*! @brief Set the BPDLCD54 field to a new value. */
#define LCD_WR_WF8B_BPDLCD54(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPDLCD54_MASK, LCD_WF8B_BPDLCD54(value)))
#define LCD_BWR_WF8B_BPDLCD54(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPDLCD54_SHIFT), LCD_WF8B_BPDLCD54_SHIFT, LCD_WF8B_BPDLCD54_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPDLCD13[3] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase D
 * - 0b1 - LCD segment on or LCD backplane active for phase D
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPDLCD13 field. */
#define LCD_RD_WF8B_BPDLCD13(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPDLCD13_MASK) >> LCD_WF8B_BPDLCD13_SHIFT)
#define LCD_BRD_WF8B_BPDLCD13(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPDLCD13_SHIFT, LCD_WF8B_BPDLCD13_WIDTH))

/*! @brief Set the BPDLCD13 field to a new value. */
#define LCD_WR_WF8B_BPDLCD13(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPDLCD13_MASK, LCD_WF8B_BPDLCD13(value)))
#define LCD_BWR_WF8B_BPDLCD13(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPDLCD13_SHIFT), LCD_WF8B_BPDLCD13_SHIFT, LCD_WF8B_BPDLCD13_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPDLCD16[3] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase D
 * - 0b1 - LCD segment on or LCD backplane active for phase D
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPDLCD16 field. */
#define LCD_RD_WF8B_BPDLCD16(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPDLCD16_MASK) >> LCD_WF8B_BPDLCD16_SHIFT)
#define LCD_BRD_WF8B_BPDLCD16(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPDLCD16_SHIFT, LCD_WF8B_BPDLCD16_WIDTH))

/*! @brief Set the BPDLCD16 field to a new value. */
#define LCD_WR_WF8B_BPDLCD16(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPDLCD16_MASK, LCD_WF8B_BPDLCD16(value)))
#define LCD_BWR_WF8B_BPDLCD16(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPDLCD16_SHIFT), LCD_WF8B_BPDLCD16_SHIFT, LCD_WF8B_BPDLCD16_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPDLCD32[3] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase D
 * - 0b1 - LCD segment on or LCD backplane active for phase D
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPDLCD32 field. */
#define LCD_RD_WF8B_BPDLCD32(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPDLCD32_MASK) >> LCD_WF8B_BPDLCD32_SHIFT)
#define LCD_BRD_WF8B_BPDLCD32(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPDLCD32_SHIFT, LCD_WF8B_BPDLCD32_WIDTH))

/*! @brief Set the BPDLCD32 field to a new value. */
#define LCD_WR_WF8B_BPDLCD32(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPDLCD32_MASK, LCD_WF8B_BPDLCD32(value)))
#define LCD_BWR_WF8B_BPDLCD32(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPDLCD32_SHIFT), LCD_WF8B_BPDLCD32_SHIFT, LCD_WF8B_BPDLCD32_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPDLCD14[3] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase D
 * - 0b1 - LCD segment on or LCD backplane active for phase D
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPDLCD14 field. */
#define LCD_RD_WF8B_BPDLCD14(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPDLCD14_MASK) >> LCD_WF8B_BPDLCD14_SHIFT)
#define LCD_BRD_WF8B_BPDLCD14(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPDLCD14_SHIFT, LCD_WF8B_BPDLCD14_WIDTH))

/*! @brief Set the BPDLCD14 field to a new value. */
#define LCD_WR_WF8B_BPDLCD14(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPDLCD14_MASK, LCD_WF8B_BPDLCD14(value)))
#define LCD_BWR_WF8B_BPDLCD14(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPDLCD14_SHIFT), LCD_WF8B_BPDLCD14_SHIFT, LCD_WF8B_BPDLCD14_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPDLCD28[3] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase D
 * - 0b1 - LCD segment on or LCD backplane active for phase D
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPDLCD28 field. */
#define LCD_RD_WF8B_BPDLCD28(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPDLCD28_MASK) >> LCD_WF8B_BPDLCD28_SHIFT)
#define LCD_BRD_WF8B_BPDLCD28(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPDLCD28_SHIFT, LCD_WF8B_BPDLCD28_WIDTH))

/*! @brief Set the BPDLCD28 field to a new value. */
#define LCD_WR_WF8B_BPDLCD28(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPDLCD28_MASK, LCD_WF8B_BPDLCD28(value)))
#define LCD_BWR_WF8B_BPDLCD28(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPDLCD28_SHIFT), LCD_WF8B_BPDLCD28_SHIFT, LCD_WF8B_BPDLCD28_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPDLCD43[3] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase D
 * - 0b1 - LCD segment on or LCD backplane active for phase D
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPDLCD43 field. */
#define LCD_RD_WF8B_BPDLCD43(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPDLCD43_MASK) >> LCD_WF8B_BPDLCD43_SHIFT)
#define LCD_BRD_WF8B_BPDLCD43(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPDLCD43_SHIFT, LCD_WF8B_BPDLCD43_WIDTH))

/*! @brief Set the BPDLCD43 field to a new value. */
#define LCD_WR_WF8B_BPDLCD43(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPDLCD43_MASK, LCD_WF8B_BPDLCD43(value)))
#define LCD_BWR_WF8B_BPDLCD43(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPDLCD43_SHIFT), LCD_WF8B_BPDLCD43_SHIFT, LCD_WF8B_BPDLCD43_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPDLCD4[3] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase D
 * - 0b1 - LCD segment on or LCD backplane active for phase D
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPDLCD4 field. */
#define LCD_RD_WF8B_BPDLCD4(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPDLCD4_MASK) >> LCD_WF8B_BPDLCD4_SHIFT)
#define LCD_BRD_WF8B_BPDLCD4(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPDLCD4_SHIFT, LCD_WF8B_BPDLCD4_WIDTH))

/*! @brief Set the BPDLCD4 field to a new value. */
#define LCD_WR_WF8B_BPDLCD4(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPDLCD4_MASK, LCD_WF8B_BPDLCD4(value)))
#define LCD_BWR_WF8B_BPDLCD4(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPDLCD4_SHIFT), LCD_WF8B_BPDLCD4_SHIFT, LCD_WF8B_BPDLCD4_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPDLCD45[3] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase D
 * - 0b1 - LCD segment on or LCD backplane active for phase D
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPDLCD45 field. */
#define LCD_RD_WF8B_BPDLCD45(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPDLCD45_MASK) >> LCD_WF8B_BPDLCD45_SHIFT)
#define LCD_BRD_WF8B_BPDLCD45(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPDLCD45_SHIFT, LCD_WF8B_BPDLCD45_WIDTH))

/*! @brief Set the BPDLCD45 field to a new value. */
#define LCD_WR_WF8B_BPDLCD45(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPDLCD45_MASK, LCD_WF8B_BPDLCD45(value)))
#define LCD_BWR_WF8B_BPDLCD45(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPDLCD45_SHIFT), LCD_WF8B_BPDLCD45_SHIFT, LCD_WF8B_BPDLCD45_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPDLCD8[3] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase D
 * - 0b1 - LCD segment on or LCD backplane active for phase D
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPDLCD8 field. */
#define LCD_RD_WF8B_BPDLCD8(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPDLCD8_MASK) >> LCD_WF8B_BPDLCD8_SHIFT)
#define LCD_BRD_WF8B_BPDLCD8(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPDLCD8_SHIFT, LCD_WF8B_BPDLCD8_WIDTH))

/*! @brief Set the BPDLCD8 field to a new value. */
#define LCD_WR_WF8B_BPDLCD8(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPDLCD8_MASK, LCD_WF8B_BPDLCD8(value)))
#define LCD_BWR_WF8B_BPDLCD8(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPDLCD8_SHIFT), LCD_WF8B_BPDLCD8_SHIFT, LCD_WF8B_BPDLCD8_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPDLCD62[3] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase D
 * - 0b1 - LCD segment on or LCD backplane active for phase D
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPDLCD62 field. */
#define LCD_RD_WF8B_BPDLCD62(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPDLCD62_MASK) >> LCD_WF8B_BPDLCD62_SHIFT)
#define LCD_BRD_WF8B_BPDLCD62(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPDLCD62_SHIFT, LCD_WF8B_BPDLCD62_WIDTH))

/*! @brief Set the BPDLCD62 field to a new value. */
#define LCD_WR_WF8B_BPDLCD62(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPDLCD62_MASK, LCD_WF8B_BPDLCD62(value)))
#define LCD_BWR_WF8B_BPDLCD62(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPDLCD62_SHIFT), LCD_WF8B_BPDLCD62_SHIFT, LCD_WF8B_BPDLCD62_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPDLCD33[3] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase D
 * - 0b1 - LCD segment on or LCD backplane active for phase D
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPDLCD33 field. */
#define LCD_RD_WF8B_BPDLCD33(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPDLCD33_MASK) >> LCD_WF8B_BPDLCD33_SHIFT)
#define LCD_BRD_WF8B_BPDLCD33(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPDLCD33_SHIFT, LCD_WF8B_BPDLCD33_WIDTH))

/*! @brief Set the BPDLCD33 field to a new value. */
#define LCD_WR_WF8B_BPDLCD33(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPDLCD33_MASK, LCD_WF8B_BPDLCD33(value)))
#define LCD_BWR_WF8B_BPDLCD33(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPDLCD33_SHIFT), LCD_WF8B_BPDLCD33_SHIFT, LCD_WF8B_BPDLCD33_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPDLCD34[3] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase D
 * - 0b1 - LCD segment on or LCD backplane active for phase D
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPDLCD34 field. */
#define LCD_RD_WF8B_BPDLCD34(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPDLCD34_MASK) >> LCD_WF8B_BPDLCD34_SHIFT)
#define LCD_BRD_WF8B_BPDLCD34(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPDLCD34_SHIFT, LCD_WF8B_BPDLCD34_WIDTH))

/*! @brief Set the BPDLCD34 field to a new value. */
#define LCD_WR_WF8B_BPDLCD34(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPDLCD34_MASK, LCD_WF8B_BPDLCD34(value)))
#define LCD_BWR_WF8B_BPDLCD34(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPDLCD34_SHIFT), LCD_WF8B_BPDLCD34_SHIFT, LCD_WF8B_BPDLCD34_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPDLCD29[3] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase D
 * - 0b1 - LCD segment on or LCD backplane active for phase D
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPDLCD29 field. */
#define LCD_RD_WF8B_BPDLCD29(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPDLCD29_MASK) >> LCD_WF8B_BPDLCD29_SHIFT)
#define LCD_BRD_WF8B_BPDLCD29(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPDLCD29_SHIFT, LCD_WF8B_BPDLCD29_WIDTH))

/*! @brief Set the BPDLCD29 field to a new value. */
#define LCD_WR_WF8B_BPDLCD29(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPDLCD29_MASK, LCD_WF8B_BPDLCD29(value)))
#define LCD_BWR_WF8B_BPDLCD29(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPDLCD29_SHIFT), LCD_WF8B_BPDLCD29_SHIFT, LCD_WF8B_BPDLCD29_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPDLCD58[3] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase D
 * - 0b1 - LCD segment on or LCD backplane active for phase D
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPDLCD58 field. */
#define LCD_RD_WF8B_BPDLCD58(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPDLCD58_MASK) >> LCD_WF8B_BPDLCD58_SHIFT)
#define LCD_BRD_WF8B_BPDLCD58(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPDLCD58_SHIFT, LCD_WF8B_BPDLCD58_WIDTH))

/*! @brief Set the BPDLCD58 field to a new value. */
#define LCD_WR_WF8B_BPDLCD58(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPDLCD58_MASK, LCD_WF8B_BPDLCD58(value)))
#define LCD_BWR_WF8B_BPDLCD58(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPDLCD58_SHIFT), LCD_WF8B_BPDLCD58_SHIFT, LCD_WF8B_BPDLCD58_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPDLCD57[3] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase D
 * - 0b1 - LCD segment on or LCD backplane active for phase D
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPDLCD57 field. */
#define LCD_RD_WF8B_BPDLCD57(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPDLCD57_MASK) >> LCD_WF8B_BPDLCD57_SHIFT)
#define LCD_BRD_WF8B_BPDLCD57(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPDLCD57_SHIFT, LCD_WF8B_BPDLCD57_WIDTH))

/*! @brief Set the BPDLCD57 field to a new value. */
#define LCD_WR_WF8B_BPDLCD57(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPDLCD57_MASK, LCD_WF8B_BPDLCD57(value)))
#define LCD_BWR_WF8B_BPDLCD57(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPDLCD57_SHIFT), LCD_WF8B_BPDLCD57_SHIFT, LCD_WF8B_BPDLCD57_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPDLCD42[3] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase D
 * - 0b1 - LCD segment on or LCD backplane active for phase D
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPDLCD42 field. */
#define LCD_RD_WF8B_BPDLCD42(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPDLCD42_MASK) >> LCD_WF8B_BPDLCD42_SHIFT)
#define LCD_BRD_WF8B_BPDLCD42(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPDLCD42_SHIFT, LCD_WF8B_BPDLCD42_WIDTH))

/*! @brief Set the BPDLCD42 field to a new value. */
#define LCD_WR_WF8B_BPDLCD42(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPDLCD42_MASK, LCD_WF8B_BPDLCD42(value)))
#define LCD_BWR_WF8B_BPDLCD42(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPDLCD42_SHIFT), LCD_WF8B_BPDLCD42_SHIFT, LCD_WF8B_BPDLCD42_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPDLCD35[3] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase D
 * - 0b1 - LCD segment on or LCD backplane active for phase D
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPDLCD35 field. */
#define LCD_RD_WF8B_BPDLCD35(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPDLCD35_MASK) >> LCD_WF8B_BPDLCD35_SHIFT)
#define LCD_BRD_WF8B_BPDLCD35(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPDLCD35_SHIFT, LCD_WF8B_BPDLCD35_WIDTH))

/*! @brief Set the BPDLCD35 field to a new value. */
#define LCD_WR_WF8B_BPDLCD35(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPDLCD35_MASK, LCD_WF8B_BPDLCD35(value)))
#define LCD_BWR_WF8B_BPDLCD35(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPDLCD35_SHIFT), LCD_WF8B_BPDLCD35_SHIFT, LCD_WF8B_BPDLCD35_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPDLCD52[3] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase D
 * - 0b1 - LCD segment on or LCD backplane active for phase D
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPDLCD52 field. */
#define LCD_RD_WF8B_BPDLCD52(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPDLCD52_MASK) >> LCD_WF8B_BPDLCD52_SHIFT)
#define LCD_BRD_WF8B_BPDLCD52(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPDLCD52_SHIFT, LCD_WF8B_BPDLCD52_WIDTH))

/*! @brief Set the BPDLCD52 field to a new value. */
#define LCD_WR_WF8B_BPDLCD52(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPDLCD52_MASK, LCD_WF8B_BPDLCD52(value)))
#define LCD_BWR_WF8B_BPDLCD52(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPDLCD52_SHIFT), LCD_WF8B_BPDLCD52_SHIFT, LCD_WF8B_BPDLCD52_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPDLCD7[3] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase D
 * - 0b1 - LCD segment on or LCD backplane active for phase D
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPDLCD7 field. */
#define LCD_RD_WF8B_BPDLCD7(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPDLCD7_MASK) >> LCD_WF8B_BPDLCD7_SHIFT)
#define LCD_BRD_WF8B_BPDLCD7(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPDLCD7_SHIFT, LCD_WF8B_BPDLCD7_WIDTH))

/*! @brief Set the BPDLCD7 field to a new value. */
#define LCD_WR_WF8B_BPDLCD7(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPDLCD7_MASK, LCD_WF8B_BPDLCD7(value)))
#define LCD_BWR_WF8B_BPDLCD7(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPDLCD7_SHIFT), LCD_WF8B_BPDLCD7_SHIFT, LCD_WF8B_BPDLCD7_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPDLCD36[3] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase D
 * - 0b1 - LCD segment on or LCD backplane active for phase D
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPDLCD36 field. */
#define LCD_RD_WF8B_BPDLCD36(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPDLCD36_MASK) >> LCD_WF8B_BPDLCD36_SHIFT)
#define LCD_BRD_WF8B_BPDLCD36(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPDLCD36_SHIFT, LCD_WF8B_BPDLCD36_WIDTH))

/*! @brief Set the BPDLCD36 field to a new value. */
#define LCD_WR_WF8B_BPDLCD36(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPDLCD36_MASK, LCD_WF8B_BPDLCD36(value)))
#define LCD_BWR_WF8B_BPDLCD36(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPDLCD36_SHIFT), LCD_WF8B_BPDLCD36_SHIFT, LCD_WF8B_BPDLCD36_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPDLCD30[3] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase D
 * - 0b1 - LCD segment on or LCD backplane active for phase D
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPDLCD30 field. */
#define LCD_RD_WF8B_BPDLCD30(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPDLCD30_MASK) >> LCD_WF8B_BPDLCD30_SHIFT)
#define LCD_BRD_WF8B_BPDLCD30(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPDLCD30_SHIFT, LCD_WF8B_BPDLCD30_WIDTH))

/*! @brief Set the BPDLCD30 field to a new value. */
#define LCD_WR_WF8B_BPDLCD30(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPDLCD30_MASK, LCD_WF8B_BPDLCD30(value)))
#define LCD_BWR_WF8B_BPDLCD30(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPDLCD30_SHIFT), LCD_WF8B_BPDLCD30_SHIFT, LCD_WF8B_BPDLCD30_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPDLCD41[3] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase D
 * - 0b1 - LCD segment on or LCD backplane active for phase D
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPDLCD41 field. */
#define LCD_RD_WF8B_BPDLCD41(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPDLCD41_MASK) >> LCD_WF8B_BPDLCD41_SHIFT)
#define LCD_BRD_WF8B_BPDLCD41(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPDLCD41_SHIFT, LCD_WF8B_BPDLCD41_WIDTH))

/*! @brief Set the BPDLCD41 field to a new value. */
#define LCD_WR_WF8B_BPDLCD41(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPDLCD41_MASK, LCD_WF8B_BPDLCD41(value)))
#define LCD_BWR_WF8B_BPDLCD41(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPDLCD41_SHIFT), LCD_WF8B_BPDLCD41_SHIFT, LCD_WF8B_BPDLCD41_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPDLCD37[3] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase D
 * - 0b1 - LCD segment on or LCD backplane active for phase D
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPDLCD37 field. */
#define LCD_RD_WF8B_BPDLCD37(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPDLCD37_MASK) >> LCD_WF8B_BPDLCD37_SHIFT)
#define LCD_BRD_WF8B_BPDLCD37(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPDLCD37_SHIFT, LCD_WF8B_BPDLCD37_WIDTH))

/*! @brief Set the BPDLCD37 field to a new value. */
#define LCD_WR_WF8B_BPDLCD37(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPDLCD37_MASK, LCD_WF8B_BPDLCD37(value)))
#define LCD_BWR_WF8B_BPDLCD37(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPDLCD37_SHIFT), LCD_WF8B_BPDLCD37_SHIFT, LCD_WF8B_BPDLCD37_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPDLCD44[3] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase D
 * - 0b1 - LCD segment on or LCD backplane active for phase D
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPDLCD44 field. */
#define LCD_RD_WF8B_BPDLCD44(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPDLCD44_MASK) >> LCD_WF8B_BPDLCD44_SHIFT)
#define LCD_BRD_WF8B_BPDLCD44(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPDLCD44_SHIFT, LCD_WF8B_BPDLCD44_WIDTH))

/*! @brief Set the BPDLCD44 field to a new value. */
#define LCD_WR_WF8B_BPDLCD44(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPDLCD44_MASK, LCD_WF8B_BPDLCD44(value)))
#define LCD_BWR_WF8B_BPDLCD44(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPDLCD44_SHIFT), LCD_WF8B_BPDLCD44_SHIFT, LCD_WF8B_BPDLCD44_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPDLCD63[3] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase D
 * - 0b1 - LCD segment on or LCD backplane active for phase D
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPDLCD63 field. */
#define LCD_RD_WF8B_BPDLCD63(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPDLCD63_MASK) >> LCD_WF8B_BPDLCD63_SHIFT)
#define LCD_BRD_WF8B_BPDLCD63(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPDLCD63_SHIFT, LCD_WF8B_BPDLCD63_WIDTH))

/*! @brief Set the BPDLCD63 field to a new value. */
#define LCD_WR_WF8B_BPDLCD63(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPDLCD63_MASK, LCD_WF8B_BPDLCD63(value)))
#define LCD_BWR_WF8B_BPDLCD63(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPDLCD63_SHIFT), LCD_WF8B_BPDLCD63_SHIFT, LCD_WF8B_BPDLCD63_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPDLCD38[3] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase D
 * - 0b1 - LCD segment on or LCD backplane active for phase D
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPDLCD38 field. */
#define LCD_RD_WF8B_BPDLCD38(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPDLCD38_MASK) >> LCD_WF8B_BPDLCD38_SHIFT)
#define LCD_BRD_WF8B_BPDLCD38(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPDLCD38_SHIFT, LCD_WF8B_BPDLCD38_WIDTH))

/*! @brief Set the BPDLCD38 field to a new value. */
#define LCD_WR_WF8B_BPDLCD38(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPDLCD38_MASK, LCD_WF8B_BPDLCD38(value)))
#define LCD_BWR_WF8B_BPDLCD38(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPDLCD38_SHIFT), LCD_WF8B_BPDLCD38_SHIFT, LCD_WF8B_BPDLCD38_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPDLCD56[3] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase D
 * - 0b1 - LCD segment on or LCD backplane active for phase D
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPDLCD56 field. */
#define LCD_RD_WF8B_BPDLCD56(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPDLCD56_MASK) >> LCD_WF8B_BPDLCD56_SHIFT)
#define LCD_BRD_WF8B_BPDLCD56(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPDLCD56_SHIFT, LCD_WF8B_BPDLCD56_WIDTH))

/*! @brief Set the BPDLCD56 field to a new value. */
#define LCD_WR_WF8B_BPDLCD56(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPDLCD56_MASK, LCD_WF8B_BPDLCD56(value)))
#define LCD_BWR_WF8B_BPDLCD56(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPDLCD56_SHIFT), LCD_WF8B_BPDLCD56_SHIFT, LCD_WF8B_BPDLCD56_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPDLCD40[3] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase D
 * - 0b1 - LCD segment on or LCD backplane active for phase D
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPDLCD40 field. */
#define LCD_RD_WF8B_BPDLCD40(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPDLCD40_MASK) >> LCD_WF8B_BPDLCD40_SHIFT)
#define LCD_BRD_WF8B_BPDLCD40(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPDLCD40_SHIFT, LCD_WF8B_BPDLCD40_WIDTH))

/*! @brief Set the BPDLCD40 field to a new value. */
#define LCD_WR_WF8B_BPDLCD40(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPDLCD40_MASK, LCD_WF8B_BPDLCD40(value)))
#define LCD_BWR_WF8B_BPDLCD40(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPDLCD40_SHIFT), LCD_WF8B_BPDLCD40_SHIFT, LCD_WF8B_BPDLCD40_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPDLCD31[3] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase D
 * - 0b1 - LCD segment on or LCD backplane active for phase D
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPDLCD31 field. */
#define LCD_RD_WF8B_BPDLCD31(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPDLCD31_MASK) >> LCD_WF8B_BPDLCD31_SHIFT)
#define LCD_BRD_WF8B_BPDLCD31(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPDLCD31_SHIFT, LCD_WF8B_BPDLCD31_WIDTH))

/*! @brief Set the BPDLCD31 field to a new value. */
#define LCD_WR_WF8B_BPDLCD31(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPDLCD31_MASK, LCD_WF8B_BPDLCD31(value)))
#define LCD_BWR_WF8B_BPDLCD31(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPDLCD31_SHIFT), LCD_WF8B_BPDLCD31_SHIFT, LCD_WF8B_BPDLCD31_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPDLCD12[3] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase D
 * - 0b1 - LCD segment on or LCD backplane active for phase D
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPDLCD12 field. */
#define LCD_RD_WF8B_BPDLCD12(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPDLCD12_MASK) >> LCD_WF8B_BPDLCD12_SHIFT)
#define LCD_BRD_WF8B_BPDLCD12(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPDLCD12_SHIFT, LCD_WF8B_BPDLCD12_WIDTH))

/*! @brief Set the BPDLCD12 field to a new value. */
#define LCD_WR_WF8B_BPDLCD12(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPDLCD12_MASK, LCD_WF8B_BPDLCD12(value)))
#define LCD_BWR_WF8B_BPDLCD12(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPDLCD12_SHIFT), LCD_WF8B_BPDLCD12_SHIFT, LCD_WF8B_BPDLCD12_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPDLCD39[3] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase D
 * - 0b1 - LCD segment on or LCD backplane active for phase D
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPDLCD39 field. */
#define LCD_RD_WF8B_BPDLCD39(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPDLCD39_MASK) >> LCD_WF8B_BPDLCD39_SHIFT)
#define LCD_BRD_WF8B_BPDLCD39(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPDLCD39_SHIFT, LCD_WF8B_BPDLCD39_WIDTH))

/*! @brief Set the BPDLCD39 field to a new value. */
#define LCD_WR_WF8B_BPDLCD39(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPDLCD39_MASK, LCD_WF8B_BPDLCD39(value)))
#define LCD_BWR_WF8B_BPDLCD39(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPDLCD39_SHIFT), LCD_WF8B_BPDLCD39_SHIFT, LCD_WF8B_BPDLCD39_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPDLCD3[3] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase D
 * - 0b1 - LCD segment on or LCD backplane active for phase D
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPDLCD3 field. */
#define LCD_RD_WF8B_BPDLCD3(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPDLCD3_MASK) >> LCD_WF8B_BPDLCD3_SHIFT)
#define LCD_BRD_WF8B_BPDLCD3(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPDLCD3_SHIFT, LCD_WF8B_BPDLCD3_WIDTH))

/*! @brief Set the BPDLCD3 field to a new value. */
#define LCD_WR_WF8B_BPDLCD3(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPDLCD3_MASK, LCD_WF8B_BPDLCD3(value)))
#define LCD_BWR_WF8B_BPDLCD3(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPDLCD3_SHIFT), LCD_WF8B_BPDLCD3_SHIFT, LCD_WF8B_BPDLCD3_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPDLCD11[3] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase D
 * - 0b1 - LCD segment on or LCD backplane active for phase D
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPDLCD11 field. */
#define LCD_RD_WF8B_BPDLCD11(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPDLCD11_MASK) >> LCD_WF8B_BPDLCD11_SHIFT)
#define LCD_BRD_WF8B_BPDLCD11(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPDLCD11_SHIFT, LCD_WF8B_BPDLCD11_WIDTH))

/*! @brief Set the BPDLCD11 field to a new value. */
#define LCD_WR_WF8B_BPDLCD11(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPDLCD11_MASK, LCD_WF8B_BPDLCD11(value)))
#define LCD_BWR_WF8B_BPDLCD11(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPDLCD11_SHIFT), LCD_WF8B_BPDLCD11_SHIFT, LCD_WF8B_BPDLCD11_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPELCD12[4] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase E
 * - 0b1 - LCD segment on or LCD backplane active for phase E
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPELCD12 field. */
#define LCD_RD_WF8B_BPELCD12(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPELCD12_MASK) >> LCD_WF8B_BPELCD12_SHIFT)
#define LCD_BRD_WF8B_BPELCD12(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPELCD12_SHIFT, LCD_WF8B_BPELCD12_WIDTH))

/*! @brief Set the BPELCD12 field to a new value. */
#define LCD_WR_WF8B_BPELCD12(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPELCD12_MASK, LCD_WF8B_BPELCD12(value)))
#define LCD_BWR_WF8B_BPELCD12(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPELCD12_SHIFT), LCD_WF8B_BPELCD12_SHIFT, LCD_WF8B_BPELCD12_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPELCD39[4] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase E
 * - 0b1 - LCD segment on or LCD backplane active for phase E
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPELCD39 field. */
#define LCD_RD_WF8B_BPELCD39(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPELCD39_MASK) >> LCD_WF8B_BPELCD39_SHIFT)
#define LCD_BRD_WF8B_BPELCD39(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPELCD39_SHIFT, LCD_WF8B_BPELCD39_WIDTH))

/*! @brief Set the BPELCD39 field to a new value. */
#define LCD_WR_WF8B_BPELCD39(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPELCD39_MASK, LCD_WF8B_BPELCD39(value)))
#define LCD_BWR_WF8B_BPELCD39(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPELCD39_SHIFT), LCD_WF8B_BPELCD39_SHIFT, LCD_WF8B_BPELCD39_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPELCD3[4] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase E
 * - 0b1 - LCD segment on or LCD backplane active for phase E
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPELCD3 field. */
#define LCD_RD_WF8B_BPELCD3(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPELCD3_MASK) >> LCD_WF8B_BPELCD3_SHIFT)
#define LCD_BRD_WF8B_BPELCD3(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPELCD3_SHIFT, LCD_WF8B_BPELCD3_WIDTH))

/*! @brief Set the BPELCD3 field to a new value. */
#define LCD_WR_WF8B_BPELCD3(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPELCD3_MASK, LCD_WF8B_BPELCD3(value)))
#define LCD_BWR_WF8B_BPELCD3(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPELCD3_SHIFT), LCD_WF8B_BPELCD3_SHIFT, LCD_WF8B_BPELCD3_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPELCD38[4] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase E
 * - 0b1 - LCD segment on or LCD backplane active for phase E
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPELCD38 field. */
#define LCD_RD_WF8B_BPELCD38(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPELCD38_MASK) >> LCD_WF8B_BPELCD38_SHIFT)
#define LCD_BRD_WF8B_BPELCD38(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPELCD38_SHIFT, LCD_WF8B_BPELCD38_WIDTH))

/*! @brief Set the BPELCD38 field to a new value. */
#define LCD_WR_WF8B_BPELCD38(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPELCD38_MASK, LCD_WF8B_BPELCD38(value)))
#define LCD_BWR_WF8B_BPELCD38(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPELCD38_SHIFT), LCD_WF8B_BPELCD38_SHIFT, LCD_WF8B_BPELCD38_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPELCD40[4] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase E
 * - 0b1 - LCD segment on or LCD backplane active for phase E
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPELCD40 field. */
#define LCD_RD_WF8B_BPELCD40(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPELCD40_MASK) >> LCD_WF8B_BPELCD40_SHIFT)
#define LCD_BRD_WF8B_BPELCD40(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPELCD40_SHIFT, LCD_WF8B_BPELCD40_WIDTH))

/*! @brief Set the BPELCD40 field to a new value. */
#define LCD_WR_WF8B_BPELCD40(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPELCD40_MASK, LCD_WF8B_BPELCD40(value)))
#define LCD_BWR_WF8B_BPELCD40(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPELCD40_SHIFT), LCD_WF8B_BPELCD40_SHIFT, LCD_WF8B_BPELCD40_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPELCD37[4] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase E
 * - 0b1 - LCD segment on or LCD backplane active for phase E
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPELCD37 field. */
#define LCD_RD_WF8B_BPELCD37(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPELCD37_MASK) >> LCD_WF8B_BPELCD37_SHIFT)
#define LCD_BRD_WF8B_BPELCD37(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPELCD37_SHIFT, LCD_WF8B_BPELCD37_WIDTH))

/*! @brief Set the BPELCD37 field to a new value. */
#define LCD_WR_WF8B_BPELCD37(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPELCD37_MASK, LCD_WF8B_BPELCD37(value)))
#define LCD_BWR_WF8B_BPELCD37(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPELCD37_SHIFT), LCD_WF8B_BPELCD37_SHIFT, LCD_WF8B_BPELCD37_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPELCD41[4] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase E
 * - 0b1 - LCD segment on or LCD backplane active for phase E
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPELCD41 field. */
#define LCD_RD_WF8B_BPELCD41(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPELCD41_MASK) >> LCD_WF8B_BPELCD41_SHIFT)
#define LCD_BRD_WF8B_BPELCD41(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPELCD41_SHIFT, LCD_WF8B_BPELCD41_WIDTH))

/*! @brief Set the BPELCD41 field to a new value. */
#define LCD_WR_WF8B_BPELCD41(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPELCD41_MASK, LCD_WF8B_BPELCD41(value)))
#define LCD_BWR_WF8B_BPELCD41(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPELCD41_SHIFT), LCD_WF8B_BPELCD41_SHIFT, LCD_WF8B_BPELCD41_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPELCD36[4] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase E
 * - 0b1 - LCD segment on or LCD backplane active for phase E
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPELCD36 field. */
#define LCD_RD_WF8B_BPELCD36(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPELCD36_MASK) >> LCD_WF8B_BPELCD36_SHIFT)
#define LCD_BRD_WF8B_BPELCD36(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPELCD36_SHIFT, LCD_WF8B_BPELCD36_WIDTH))

/*! @brief Set the BPELCD36 field to a new value. */
#define LCD_WR_WF8B_BPELCD36(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPELCD36_MASK, LCD_WF8B_BPELCD36(value)))
#define LCD_BWR_WF8B_BPELCD36(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPELCD36_SHIFT), LCD_WF8B_BPELCD36_SHIFT, LCD_WF8B_BPELCD36_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPELCD8[4] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase E
 * - 0b1 - LCD segment on or LCD backplane active for phase E
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPELCD8 field. */
#define LCD_RD_WF8B_BPELCD8(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPELCD8_MASK) >> LCD_WF8B_BPELCD8_SHIFT)
#define LCD_BRD_WF8B_BPELCD8(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPELCD8_SHIFT, LCD_WF8B_BPELCD8_WIDTH))

/*! @brief Set the BPELCD8 field to a new value. */
#define LCD_WR_WF8B_BPELCD8(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPELCD8_MASK, LCD_WF8B_BPELCD8(value)))
#define LCD_BWR_WF8B_BPELCD8(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPELCD8_SHIFT), LCD_WF8B_BPELCD8_SHIFT, LCD_WF8B_BPELCD8_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPELCD35[4] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase E
 * - 0b1 - LCD segment on or LCD backplane active for phase E
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPELCD35 field. */
#define LCD_RD_WF8B_BPELCD35(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPELCD35_MASK) >> LCD_WF8B_BPELCD35_SHIFT)
#define LCD_BRD_WF8B_BPELCD35(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPELCD35_SHIFT, LCD_WF8B_BPELCD35_WIDTH))

/*! @brief Set the BPELCD35 field to a new value. */
#define LCD_WR_WF8B_BPELCD35(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPELCD35_MASK, LCD_WF8B_BPELCD35(value)))
#define LCD_BWR_WF8B_BPELCD35(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPELCD35_SHIFT), LCD_WF8B_BPELCD35_SHIFT, LCD_WF8B_BPELCD35_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPELCD42[4] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase E
 * - 0b1 - LCD segment on or LCD backplane active for phase E
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPELCD42 field. */
#define LCD_RD_WF8B_BPELCD42(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPELCD42_MASK) >> LCD_WF8B_BPELCD42_SHIFT)
#define LCD_BRD_WF8B_BPELCD42(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPELCD42_SHIFT, LCD_WF8B_BPELCD42_WIDTH))

/*! @brief Set the BPELCD42 field to a new value. */
#define LCD_WR_WF8B_BPELCD42(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPELCD42_MASK, LCD_WF8B_BPELCD42(value)))
#define LCD_BWR_WF8B_BPELCD42(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPELCD42_SHIFT), LCD_WF8B_BPELCD42_SHIFT, LCD_WF8B_BPELCD42_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPELCD34[4] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase E
 * - 0b1 - LCD segment on or LCD backplane active for phase E
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPELCD34 field. */
#define LCD_RD_WF8B_BPELCD34(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPELCD34_MASK) >> LCD_WF8B_BPELCD34_SHIFT)
#define LCD_BRD_WF8B_BPELCD34(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPELCD34_SHIFT, LCD_WF8B_BPELCD34_WIDTH))

/*! @brief Set the BPELCD34 field to a new value. */
#define LCD_WR_WF8B_BPELCD34(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPELCD34_MASK, LCD_WF8B_BPELCD34(value)))
#define LCD_BWR_WF8B_BPELCD34(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPELCD34_SHIFT), LCD_WF8B_BPELCD34_SHIFT, LCD_WF8B_BPELCD34_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPELCD33[4] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase E
 * - 0b1 - LCD segment on or LCD backplane active for phase E
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPELCD33 field. */
#define LCD_RD_WF8B_BPELCD33(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPELCD33_MASK) >> LCD_WF8B_BPELCD33_SHIFT)
#define LCD_BRD_WF8B_BPELCD33(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPELCD33_SHIFT, LCD_WF8B_BPELCD33_WIDTH))

/*! @brief Set the BPELCD33 field to a new value. */
#define LCD_WR_WF8B_BPELCD33(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPELCD33_MASK, LCD_WF8B_BPELCD33(value)))
#define LCD_BWR_WF8B_BPELCD33(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPELCD33_SHIFT), LCD_WF8B_BPELCD33_SHIFT, LCD_WF8B_BPELCD33_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPELCD11[4] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase E
 * - 0b1 - LCD segment on or LCD backplane active for phase E
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPELCD11 field. */
#define LCD_RD_WF8B_BPELCD11(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPELCD11_MASK) >> LCD_WF8B_BPELCD11_SHIFT)
#define LCD_BRD_WF8B_BPELCD11(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPELCD11_SHIFT, LCD_WF8B_BPELCD11_WIDTH))

/*! @brief Set the BPELCD11 field to a new value. */
#define LCD_WR_WF8B_BPELCD11(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPELCD11_MASK, LCD_WF8B_BPELCD11(value)))
#define LCD_BWR_WF8B_BPELCD11(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPELCD11_SHIFT), LCD_WF8B_BPELCD11_SHIFT, LCD_WF8B_BPELCD11_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPELCD43[4] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase E
 * - 0b1 - LCD segment on or LCD backplane active for phase E
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPELCD43 field. */
#define LCD_RD_WF8B_BPELCD43(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPELCD43_MASK) >> LCD_WF8B_BPELCD43_SHIFT)
#define LCD_BRD_WF8B_BPELCD43(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPELCD43_SHIFT, LCD_WF8B_BPELCD43_WIDTH))

/*! @brief Set the BPELCD43 field to a new value. */
#define LCD_WR_WF8B_BPELCD43(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPELCD43_MASK, LCD_WF8B_BPELCD43(value)))
#define LCD_BWR_WF8B_BPELCD43(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPELCD43_SHIFT), LCD_WF8B_BPELCD43_SHIFT, LCD_WF8B_BPELCD43_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPELCD32[4] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase E
 * - 0b1 - LCD segment on or LCD backplane active for phase E
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPELCD32 field. */
#define LCD_RD_WF8B_BPELCD32(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPELCD32_MASK) >> LCD_WF8B_BPELCD32_SHIFT)
#define LCD_BRD_WF8B_BPELCD32(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPELCD32_SHIFT, LCD_WF8B_BPELCD32_WIDTH))

/*! @brief Set the BPELCD32 field to a new value. */
#define LCD_WR_WF8B_BPELCD32(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPELCD32_MASK, LCD_WF8B_BPELCD32(value)))
#define LCD_BWR_WF8B_BPELCD32(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPELCD32_SHIFT), LCD_WF8B_BPELCD32_SHIFT, LCD_WF8B_BPELCD32_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPELCD31[4] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase E
 * - 0b1 - LCD segment on or LCD backplane active for phase E
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPELCD31 field. */
#define LCD_RD_WF8B_BPELCD31(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPELCD31_MASK) >> LCD_WF8B_BPELCD31_SHIFT)
#define LCD_BRD_WF8B_BPELCD31(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPELCD31_SHIFT, LCD_WF8B_BPELCD31_WIDTH))

/*! @brief Set the BPELCD31 field to a new value. */
#define LCD_WR_WF8B_BPELCD31(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPELCD31_MASK, LCD_WF8B_BPELCD31(value)))
#define LCD_BWR_WF8B_BPELCD31(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPELCD31_SHIFT), LCD_WF8B_BPELCD31_SHIFT, LCD_WF8B_BPELCD31_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPELCD44[4] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase E
 * - 0b1 - LCD segment on or LCD backplane active for phase E
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPELCD44 field. */
#define LCD_RD_WF8B_BPELCD44(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPELCD44_MASK) >> LCD_WF8B_BPELCD44_SHIFT)
#define LCD_BRD_WF8B_BPELCD44(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPELCD44_SHIFT, LCD_WF8B_BPELCD44_WIDTH))

/*! @brief Set the BPELCD44 field to a new value. */
#define LCD_WR_WF8B_BPELCD44(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPELCD44_MASK, LCD_WF8B_BPELCD44(value)))
#define LCD_BWR_WF8B_BPELCD44(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPELCD44_SHIFT), LCD_WF8B_BPELCD44_SHIFT, LCD_WF8B_BPELCD44_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPELCD30[4] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase E
 * - 0b1 - LCD segment on or LCD backplane active for phase E
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPELCD30 field. */
#define LCD_RD_WF8B_BPELCD30(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPELCD30_MASK) >> LCD_WF8B_BPELCD30_SHIFT)
#define LCD_BRD_WF8B_BPELCD30(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPELCD30_SHIFT, LCD_WF8B_BPELCD30_WIDTH))

/*! @brief Set the BPELCD30 field to a new value. */
#define LCD_WR_WF8B_BPELCD30(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPELCD30_MASK, LCD_WF8B_BPELCD30(value)))
#define LCD_BWR_WF8B_BPELCD30(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPELCD30_SHIFT), LCD_WF8B_BPELCD30_SHIFT, LCD_WF8B_BPELCD30_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPELCD29[4] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase E
 * - 0b1 - LCD segment on or LCD backplane active for phase E
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPELCD29 field. */
#define LCD_RD_WF8B_BPELCD29(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPELCD29_MASK) >> LCD_WF8B_BPELCD29_SHIFT)
#define LCD_BRD_WF8B_BPELCD29(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPELCD29_SHIFT, LCD_WF8B_BPELCD29_WIDTH))

/*! @brief Set the BPELCD29 field to a new value. */
#define LCD_WR_WF8B_BPELCD29(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPELCD29_MASK, LCD_WF8B_BPELCD29(value)))
#define LCD_BWR_WF8B_BPELCD29(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPELCD29_SHIFT), LCD_WF8B_BPELCD29_SHIFT, LCD_WF8B_BPELCD29_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPELCD7[4] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase E
 * - 0b1 - LCD segment on or LCD backplane active for phase E
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPELCD7 field. */
#define LCD_RD_WF8B_BPELCD7(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPELCD7_MASK) >> LCD_WF8B_BPELCD7_SHIFT)
#define LCD_BRD_WF8B_BPELCD7(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPELCD7_SHIFT, LCD_WF8B_BPELCD7_WIDTH))

/*! @brief Set the BPELCD7 field to a new value. */
#define LCD_WR_WF8B_BPELCD7(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPELCD7_MASK, LCD_WF8B_BPELCD7(value)))
#define LCD_BWR_WF8B_BPELCD7(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPELCD7_SHIFT), LCD_WF8B_BPELCD7_SHIFT, LCD_WF8B_BPELCD7_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPELCD45[4] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase E
 * - 0b1 - LCD segment on or LCD backplane active for phase E
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPELCD45 field. */
#define LCD_RD_WF8B_BPELCD45(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPELCD45_MASK) >> LCD_WF8B_BPELCD45_SHIFT)
#define LCD_BRD_WF8B_BPELCD45(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPELCD45_SHIFT, LCD_WF8B_BPELCD45_WIDTH))

/*! @brief Set the BPELCD45 field to a new value. */
#define LCD_WR_WF8B_BPELCD45(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPELCD45_MASK, LCD_WF8B_BPELCD45(value)))
#define LCD_BWR_WF8B_BPELCD45(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPELCD45_SHIFT), LCD_WF8B_BPELCD45_SHIFT, LCD_WF8B_BPELCD45_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPELCD28[4] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase E
 * - 0b1 - LCD segment on or LCD backplane active for phase E
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPELCD28 field. */
#define LCD_RD_WF8B_BPELCD28(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPELCD28_MASK) >> LCD_WF8B_BPELCD28_SHIFT)
#define LCD_BRD_WF8B_BPELCD28(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPELCD28_SHIFT, LCD_WF8B_BPELCD28_WIDTH))

/*! @brief Set the BPELCD28 field to a new value. */
#define LCD_WR_WF8B_BPELCD28(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPELCD28_MASK, LCD_WF8B_BPELCD28(value)))
#define LCD_BWR_WF8B_BPELCD28(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPELCD28_SHIFT), LCD_WF8B_BPELCD28_SHIFT, LCD_WF8B_BPELCD28_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPELCD2[4] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase E
 * - 0b1 - LCD segment on or LCD backplane active for phase E
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPELCD2 field. */
#define LCD_RD_WF8B_BPELCD2(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPELCD2_MASK) >> LCD_WF8B_BPELCD2_SHIFT)
#define LCD_BRD_WF8B_BPELCD2(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPELCD2_SHIFT, LCD_WF8B_BPELCD2_WIDTH))

/*! @brief Set the BPELCD2 field to a new value. */
#define LCD_WR_WF8B_BPELCD2(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPELCD2_MASK, LCD_WF8B_BPELCD2(value)))
#define LCD_BWR_WF8B_BPELCD2(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPELCD2_SHIFT), LCD_WF8B_BPELCD2_SHIFT, LCD_WF8B_BPELCD2_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPELCD27[4] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase E
 * - 0b1 - LCD segment on or LCD backplane active for phase E
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPELCD27 field. */
#define LCD_RD_WF8B_BPELCD27(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPELCD27_MASK) >> LCD_WF8B_BPELCD27_SHIFT)
#define LCD_BRD_WF8B_BPELCD27(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPELCD27_SHIFT, LCD_WF8B_BPELCD27_WIDTH))

/*! @brief Set the BPELCD27 field to a new value. */
#define LCD_WR_WF8B_BPELCD27(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPELCD27_MASK, LCD_WF8B_BPELCD27(value)))
#define LCD_BWR_WF8B_BPELCD27(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPELCD27_SHIFT), LCD_WF8B_BPELCD27_SHIFT, LCD_WF8B_BPELCD27_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPELCD46[4] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase E
 * - 0b1 - LCD segment on or LCD backplane active for phase E
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPELCD46 field. */
#define LCD_RD_WF8B_BPELCD46(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPELCD46_MASK) >> LCD_WF8B_BPELCD46_SHIFT)
#define LCD_BRD_WF8B_BPELCD46(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPELCD46_SHIFT, LCD_WF8B_BPELCD46_WIDTH))

/*! @brief Set the BPELCD46 field to a new value. */
#define LCD_WR_WF8B_BPELCD46(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPELCD46_MASK, LCD_WF8B_BPELCD46(value)))
#define LCD_BWR_WF8B_BPELCD46(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPELCD46_SHIFT), LCD_WF8B_BPELCD46_SHIFT, LCD_WF8B_BPELCD46_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPELCD26[4] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase E
 * - 0b1 - LCD segment on or LCD backplane active for phase E
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPELCD26 field. */
#define LCD_RD_WF8B_BPELCD26(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPELCD26_MASK) >> LCD_WF8B_BPELCD26_SHIFT)
#define LCD_BRD_WF8B_BPELCD26(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPELCD26_SHIFT, LCD_WF8B_BPELCD26_WIDTH))

/*! @brief Set the BPELCD26 field to a new value. */
#define LCD_WR_WF8B_BPELCD26(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPELCD26_MASK, LCD_WF8B_BPELCD26(value)))
#define LCD_BWR_WF8B_BPELCD26(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPELCD26_SHIFT), LCD_WF8B_BPELCD26_SHIFT, LCD_WF8B_BPELCD26_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPELCD10[4] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase E
 * - 0b1 - LCD segment on or LCD backplane active for phase E
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPELCD10 field. */
#define LCD_RD_WF8B_BPELCD10(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPELCD10_MASK) >> LCD_WF8B_BPELCD10_SHIFT)
#define LCD_BRD_WF8B_BPELCD10(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPELCD10_SHIFT, LCD_WF8B_BPELCD10_WIDTH))

/*! @brief Set the BPELCD10 field to a new value. */
#define LCD_WR_WF8B_BPELCD10(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPELCD10_MASK, LCD_WF8B_BPELCD10(value)))
#define LCD_BWR_WF8B_BPELCD10(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPELCD10_SHIFT), LCD_WF8B_BPELCD10_SHIFT, LCD_WF8B_BPELCD10_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPELCD13[4] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase E
 * - 0b1 - LCD segment on or LCD backplane active for phase E
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPELCD13 field. */
#define LCD_RD_WF8B_BPELCD13(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPELCD13_MASK) >> LCD_WF8B_BPELCD13_SHIFT)
#define LCD_BRD_WF8B_BPELCD13(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPELCD13_SHIFT, LCD_WF8B_BPELCD13_WIDTH))

/*! @brief Set the BPELCD13 field to a new value. */
#define LCD_WR_WF8B_BPELCD13(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPELCD13_MASK, LCD_WF8B_BPELCD13(value)))
#define LCD_BWR_WF8B_BPELCD13(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPELCD13_SHIFT), LCD_WF8B_BPELCD13_SHIFT, LCD_WF8B_BPELCD13_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPELCD25[4] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase E
 * - 0b1 - LCD segment on or LCD backplane active for phase E
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPELCD25 field. */
#define LCD_RD_WF8B_BPELCD25(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPELCD25_MASK) >> LCD_WF8B_BPELCD25_SHIFT)
#define LCD_BRD_WF8B_BPELCD25(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPELCD25_SHIFT, LCD_WF8B_BPELCD25_WIDTH))

/*! @brief Set the BPELCD25 field to a new value. */
#define LCD_WR_WF8B_BPELCD25(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPELCD25_MASK, LCD_WF8B_BPELCD25(value)))
#define LCD_BWR_WF8B_BPELCD25(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPELCD25_SHIFT), LCD_WF8B_BPELCD25_SHIFT, LCD_WF8B_BPELCD25_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPELCD5[4] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase E
 * - 0b1 - LCD segment on or LCD backplane active for phase E
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPELCD5 field. */
#define LCD_RD_WF8B_BPELCD5(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPELCD5_MASK) >> LCD_WF8B_BPELCD5_SHIFT)
#define LCD_BRD_WF8B_BPELCD5(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPELCD5_SHIFT, LCD_WF8B_BPELCD5_WIDTH))

/*! @brief Set the BPELCD5 field to a new value. */
#define LCD_WR_WF8B_BPELCD5(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPELCD5_MASK, LCD_WF8B_BPELCD5(value)))
#define LCD_BWR_WF8B_BPELCD5(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPELCD5_SHIFT), LCD_WF8B_BPELCD5_SHIFT, LCD_WF8B_BPELCD5_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPELCD24[4] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase E
 * - 0b1 - LCD segment on or LCD backplane active for phase E
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPELCD24 field. */
#define LCD_RD_WF8B_BPELCD24(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPELCD24_MASK) >> LCD_WF8B_BPELCD24_SHIFT)
#define LCD_BRD_WF8B_BPELCD24(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPELCD24_SHIFT, LCD_WF8B_BPELCD24_WIDTH))

/*! @brief Set the BPELCD24 field to a new value. */
#define LCD_WR_WF8B_BPELCD24(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPELCD24_MASK, LCD_WF8B_BPELCD24(value)))
#define LCD_BWR_WF8B_BPELCD24(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPELCD24_SHIFT), LCD_WF8B_BPELCD24_SHIFT, LCD_WF8B_BPELCD24_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPELCD47[4] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase E
 * - 0b1 - LCD segment on or LCD backplane active for phase E
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPELCD47 field. */
#define LCD_RD_WF8B_BPELCD47(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPELCD47_MASK) >> LCD_WF8B_BPELCD47_SHIFT)
#define LCD_BRD_WF8B_BPELCD47(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPELCD47_SHIFT, LCD_WF8B_BPELCD47_WIDTH))

/*! @brief Set the BPELCD47 field to a new value. */
#define LCD_WR_WF8B_BPELCD47(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPELCD47_MASK, LCD_WF8B_BPELCD47(value)))
#define LCD_BWR_WF8B_BPELCD47(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPELCD47_SHIFT), LCD_WF8B_BPELCD47_SHIFT, LCD_WF8B_BPELCD47_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPELCD23[4] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase E
 * - 0b1 - LCD segment on or LCD backplane active for phase E
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPELCD23 field. */
#define LCD_RD_WF8B_BPELCD23(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPELCD23_MASK) >> LCD_WF8B_BPELCD23_SHIFT)
#define LCD_BRD_WF8B_BPELCD23(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPELCD23_SHIFT, LCD_WF8B_BPELCD23_WIDTH))

/*! @brief Set the BPELCD23 field to a new value. */
#define LCD_WR_WF8B_BPELCD23(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPELCD23_MASK, LCD_WF8B_BPELCD23(value)))
#define LCD_BWR_WF8B_BPELCD23(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPELCD23_SHIFT), LCD_WF8B_BPELCD23_SHIFT, LCD_WF8B_BPELCD23_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPELCD22[4] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase E
 * - 0b1 - LCD segment on or LCD backplane active for phase E
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPELCD22 field. */
#define LCD_RD_WF8B_BPELCD22(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPELCD22_MASK) >> LCD_WF8B_BPELCD22_SHIFT)
#define LCD_BRD_WF8B_BPELCD22(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPELCD22_SHIFT, LCD_WF8B_BPELCD22_WIDTH))

/*! @brief Set the BPELCD22 field to a new value. */
#define LCD_WR_WF8B_BPELCD22(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPELCD22_MASK, LCD_WF8B_BPELCD22(value)))
#define LCD_BWR_WF8B_BPELCD22(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPELCD22_SHIFT), LCD_WF8B_BPELCD22_SHIFT, LCD_WF8B_BPELCD22_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPELCD48[4] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase E
 * - 0b1 - LCD segment on or LCD backplane active for phase E
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPELCD48 field. */
#define LCD_RD_WF8B_BPELCD48(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPELCD48_MASK) >> LCD_WF8B_BPELCD48_SHIFT)
#define LCD_BRD_WF8B_BPELCD48(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPELCD48_SHIFT, LCD_WF8B_BPELCD48_WIDTH))

/*! @brief Set the BPELCD48 field to a new value. */
#define LCD_WR_WF8B_BPELCD48(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPELCD48_MASK, LCD_WF8B_BPELCD48(value)))
#define LCD_BWR_WF8B_BPELCD48(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPELCD48_SHIFT), LCD_WF8B_BPELCD48_SHIFT, LCD_WF8B_BPELCD48_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPELCD21[4] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase E
 * - 0b1 - LCD segment on or LCD backplane active for phase E
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPELCD21 field. */
#define LCD_RD_WF8B_BPELCD21(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPELCD21_MASK) >> LCD_WF8B_BPELCD21_SHIFT)
#define LCD_BRD_WF8B_BPELCD21(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPELCD21_SHIFT, LCD_WF8B_BPELCD21_WIDTH))

/*! @brief Set the BPELCD21 field to a new value. */
#define LCD_WR_WF8B_BPELCD21(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPELCD21_MASK, LCD_WF8B_BPELCD21(value)))
#define LCD_BWR_WF8B_BPELCD21(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPELCD21_SHIFT), LCD_WF8B_BPELCD21_SHIFT, LCD_WF8B_BPELCD21_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPELCD49[4] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase E
 * - 0b1 - LCD segment on or LCD backplane active for phase E
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPELCD49 field. */
#define LCD_RD_WF8B_BPELCD49(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPELCD49_MASK) >> LCD_WF8B_BPELCD49_SHIFT)
#define LCD_BRD_WF8B_BPELCD49(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPELCD49_SHIFT, LCD_WF8B_BPELCD49_WIDTH))

/*! @brief Set the BPELCD49 field to a new value. */
#define LCD_WR_WF8B_BPELCD49(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPELCD49_MASK, LCD_WF8B_BPELCD49(value)))
#define LCD_BWR_WF8B_BPELCD49(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPELCD49_SHIFT), LCD_WF8B_BPELCD49_SHIFT, LCD_WF8B_BPELCD49_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPELCD20[4] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase E
 * - 0b1 - LCD segment on or LCD backplane active for phase E
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPELCD20 field. */
#define LCD_RD_WF8B_BPELCD20(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPELCD20_MASK) >> LCD_WF8B_BPELCD20_SHIFT)
#define LCD_BRD_WF8B_BPELCD20(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPELCD20_SHIFT, LCD_WF8B_BPELCD20_WIDTH))

/*! @brief Set the BPELCD20 field to a new value. */
#define LCD_WR_WF8B_BPELCD20(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPELCD20_MASK, LCD_WF8B_BPELCD20(value)))
#define LCD_BWR_WF8B_BPELCD20(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPELCD20_SHIFT), LCD_WF8B_BPELCD20_SHIFT, LCD_WF8B_BPELCD20_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPELCD19[4] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase E
 * - 0b1 - LCD segment on or LCD backplane active for phase E
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPELCD19 field. */
#define LCD_RD_WF8B_BPELCD19(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPELCD19_MASK) >> LCD_WF8B_BPELCD19_SHIFT)
#define LCD_BRD_WF8B_BPELCD19(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPELCD19_SHIFT, LCD_WF8B_BPELCD19_WIDTH))

/*! @brief Set the BPELCD19 field to a new value. */
#define LCD_WR_WF8B_BPELCD19(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPELCD19_MASK, LCD_WF8B_BPELCD19(value)))
#define LCD_BWR_WF8B_BPELCD19(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPELCD19_SHIFT), LCD_WF8B_BPELCD19_SHIFT, LCD_WF8B_BPELCD19_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPELCD9[4] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase E
 * - 0b1 - LCD segment on or LCD backplane active for phase E
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPELCD9 field. */
#define LCD_RD_WF8B_BPELCD9(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPELCD9_MASK) >> LCD_WF8B_BPELCD9_SHIFT)
#define LCD_BRD_WF8B_BPELCD9(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPELCD9_SHIFT, LCD_WF8B_BPELCD9_WIDTH))

/*! @brief Set the BPELCD9 field to a new value. */
#define LCD_WR_WF8B_BPELCD9(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPELCD9_MASK, LCD_WF8B_BPELCD9(value)))
#define LCD_BWR_WF8B_BPELCD9(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPELCD9_SHIFT), LCD_WF8B_BPELCD9_SHIFT, LCD_WF8B_BPELCD9_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPELCD50[4] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase E
 * - 0b1 - LCD segment on or LCD backplane active for phase E
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPELCD50 field. */
#define LCD_RD_WF8B_BPELCD50(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPELCD50_MASK) >> LCD_WF8B_BPELCD50_SHIFT)
#define LCD_BRD_WF8B_BPELCD50(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPELCD50_SHIFT, LCD_WF8B_BPELCD50_WIDTH))

/*! @brief Set the BPELCD50 field to a new value. */
#define LCD_WR_WF8B_BPELCD50(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPELCD50_MASK, LCD_WF8B_BPELCD50(value)))
#define LCD_BWR_WF8B_BPELCD50(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPELCD50_SHIFT), LCD_WF8B_BPELCD50_SHIFT, LCD_WF8B_BPELCD50_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPELCD18[4] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase E
 * - 0b1 - LCD segment on or LCD backplane active for phase E
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPELCD18 field. */
#define LCD_RD_WF8B_BPELCD18(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPELCD18_MASK) >> LCD_WF8B_BPELCD18_SHIFT)
#define LCD_BRD_WF8B_BPELCD18(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPELCD18_SHIFT, LCD_WF8B_BPELCD18_WIDTH))

/*! @brief Set the BPELCD18 field to a new value. */
#define LCD_WR_WF8B_BPELCD18(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPELCD18_MASK, LCD_WF8B_BPELCD18(value)))
#define LCD_BWR_WF8B_BPELCD18(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPELCD18_SHIFT), LCD_WF8B_BPELCD18_SHIFT, LCD_WF8B_BPELCD18_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPELCD6[4] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase E
 * - 0b1 - LCD segment on or LCD backplane active for phase E
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPELCD6 field. */
#define LCD_RD_WF8B_BPELCD6(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPELCD6_MASK) >> LCD_WF8B_BPELCD6_SHIFT)
#define LCD_BRD_WF8B_BPELCD6(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPELCD6_SHIFT, LCD_WF8B_BPELCD6_WIDTH))

/*! @brief Set the BPELCD6 field to a new value. */
#define LCD_WR_WF8B_BPELCD6(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPELCD6_MASK, LCD_WF8B_BPELCD6(value)))
#define LCD_BWR_WF8B_BPELCD6(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPELCD6_SHIFT), LCD_WF8B_BPELCD6_SHIFT, LCD_WF8B_BPELCD6_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPELCD17[4] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase E
 * - 0b1 - LCD segment on or LCD backplane active for phase E
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPELCD17 field. */
#define LCD_RD_WF8B_BPELCD17(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPELCD17_MASK) >> LCD_WF8B_BPELCD17_SHIFT)
#define LCD_BRD_WF8B_BPELCD17(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPELCD17_SHIFT, LCD_WF8B_BPELCD17_WIDTH))

/*! @brief Set the BPELCD17 field to a new value. */
#define LCD_WR_WF8B_BPELCD17(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPELCD17_MASK, LCD_WF8B_BPELCD17(value)))
#define LCD_BWR_WF8B_BPELCD17(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPELCD17_SHIFT), LCD_WF8B_BPELCD17_SHIFT, LCD_WF8B_BPELCD17_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPELCD51[4] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase E
 * - 0b1 - LCD segment on or LCD backplane active for phase E
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPELCD51 field. */
#define LCD_RD_WF8B_BPELCD51(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPELCD51_MASK) >> LCD_WF8B_BPELCD51_SHIFT)
#define LCD_BRD_WF8B_BPELCD51(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPELCD51_SHIFT, LCD_WF8B_BPELCD51_WIDTH))

/*! @brief Set the BPELCD51 field to a new value. */
#define LCD_WR_WF8B_BPELCD51(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPELCD51_MASK, LCD_WF8B_BPELCD51(value)))
#define LCD_BWR_WF8B_BPELCD51(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPELCD51_SHIFT), LCD_WF8B_BPELCD51_SHIFT, LCD_WF8B_BPELCD51_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPELCD16[4] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase E
 * - 0b1 - LCD segment on or LCD backplane active for phase E
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPELCD16 field. */
#define LCD_RD_WF8B_BPELCD16(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPELCD16_MASK) >> LCD_WF8B_BPELCD16_SHIFT)
#define LCD_BRD_WF8B_BPELCD16(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPELCD16_SHIFT, LCD_WF8B_BPELCD16_WIDTH))

/*! @brief Set the BPELCD16 field to a new value. */
#define LCD_WR_WF8B_BPELCD16(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPELCD16_MASK, LCD_WF8B_BPELCD16(value)))
#define LCD_BWR_WF8B_BPELCD16(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPELCD16_SHIFT), LCD_WF8B_BPELCD16_SHIFT, LCD_WF8B_BPELCD16_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPELCD56[4] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase E
 * - 0b1 - LCD segment on or LCD backplane active for phase E
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPELCD56 field. */
#define LCD_RD_WF8B_BPELCD56(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPELCD56_MASK) >> LCD_WF8B_BPELCD56_SHIFT)
#define LCD_BRD_WF8B_BPELCD56(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPELCD56_SHIFT, LCD_WF8B_BPELCD56_WIDTH))

/*! @brief Set the BPELCD56 field to a new value. */
#define LCD_WR_WF8B_BPELCD56(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPELCD56_MASK, LCD_WF8B_BPELCD56(value)))
#define LCD_BWR_WF8B_BPELCD56(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPELCD56_SHIFT), LCD_WF8B_BPELCD56_SHIFT, LCD_WF8B_BPELCD56_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPELCD57[4] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase E
 * - 0b1 - LCD segment on or LCD backplane active for phase E
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPELCD57 field. */
#define LCD_RD_WF8B_BPELCD57(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPELCD57_MASK) >> LCD_WF8B_BPELCD57_SHIFT)
#define LCD_BRD_WF8B_BPELCD57(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPELCD57_SHIFT, LCD_WF8B_BPELCD57_WIDTH))

/*! @brief Set the BPELCD57 field to a new value. */
#define LCD_WR_WF8B_BPELCD57(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPELCD57_MASK, LCD_WF8B_BPELCD57(value)))
#define LCD_BWR_WF8B_BPELCD57(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPELCD57_SHIFT), LCD_WF8B_BPELCD57_SHIFT, LCD_WF8B_BPELCD57_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPELCD52[4] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase E
 * - 0b1 - LCD segment on or LCD backplane active for phase E
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPELCD52 field. */
#define LCD_RD_WF8B_BPELCD52(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPELCD52_MASK) >> LCD_WF8B_BPELCD52_SHIFT)
#define LCD_BRD_WF8B_BPELCD52(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPELCD52_SHIFT, LCD_WF8B_BPELCD52_WIDTH))

/*! @brief Set the BPELCD52 field to a new value. */
#define LCD_WR_WF8B_BPELCD52(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPELCD52_MASK, LCD_WF8B_BPELCD52(value)))
#define LCD_BWR_WF8B_BPELCD52(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPELCD52_SHIFT), LCD_WF8B_BPELCD52_SHIFT, LCD_WF8B_BPELCD52_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPELCD1[4] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase E
 * - 0b1 - LCD segment on or LCD backplane active for phase E
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPELCD1 field. */
#define LCD_RD_WF8B_BPELCD1(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPELCD1_MASK) >> LCD_WF8B_BPELCD1_SHIFT)
#define LCD_BRD_WF8B_BPELCD1(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPELCD1_SHIFT, LCD_WF8B_BPELCD1_WIDTH))

/*! @brief Set the BPELCD1 field to a new value. */
#define LCD_WR_WF8B_BPELCD1(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPELCD1_MASK, LCD_WF8B_BPELCD1(value)))
#define LCD_BWR_WF8B_BPELCD1(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPELCD1_SHIFT), LCD_WF8B_BPELCD1_SHIFT, LCD_WF8B_BPELCD1_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPELCD58[4] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase E
 * - 0b1 - LCD segment on or LCD backplane active for phase E
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPELCD58 field. */
#define LCD_RD_WF8B_BPELCD58(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPELCD58_MASK) >> LCD_WF8B_BPELCD58_SHIFT)
#define LCD_BRD_WF8B_BPELCD58(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPELCD58_SHIFT, LCD_WF8B_BPELCD58_WIDTH))

/*! @brief Set the BPELCD58 field to a new value. */
#define LCD_WR_WF8B_BPELCD58(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPELCD58_MASK, LCD_WF8B_BPELCD58(value)))
#define LCD_BWR_WF8B_BPELCD58(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPELCD58_SHIFT), LCD_WF8B_BPELCD58_SHIFT, LCD_WF8B_BPELCD58_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPELCD59[4] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase E
 * - 0b1 - LCD segment on or LCD backplane active for phase E
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPELCD59 field. */
#define LCD_RD_WF8B_BPELCD59(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPELCD59_MASK) >> LCD_WF8B_BPELCD59_SHIFT)
#define LCD_BRD_WF8B_BPELCD59(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPELCD59_SHIFT, LCD_WF8B_BPELCD59_WIDTH))

/*! @brief Set the BPELCD59 field to a new value. */
#define LCD_WR_WF8B_BPELCD59(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPELCD59_MASK, LCD_WF8B_BPELCD59(value)))
#define LCD_BWR_WF8B_BPELCD59(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPELCD59_SHIFT), LCD_WF8B_BPELCD59_SHIFT, LCD_WF8B_BPELCD59_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPELCD53[4] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase E
 * - 0b1 - LCD segment on or LCD backplane active for phase E
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPELCD53 field. */
#define LCD_RD_WF8B_BPELCD53(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPELCD53_MASK) >> LCD_WF8B_BPELCD53_SHIFT)
#define LCD_BRD_WF8B_BPELCD53(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPELCD53_SHIFT, LCD_WF8B_BPELCD53_WIDTH))

/*! @brief Set the BPELCD53 field to a new value. */
#define LCD_WR_WF8B_BPELCD53(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPELCD53_MASK, LCD_WF8B_BPELCD53(value)))
#define LCD_BWR_WF8B_BPELCD53(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPELCD53_SHIFT), LCD_WF8B_BPELCD53_SHIFT, LCD_WF8B_BPELCD53_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPELCD14[4] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase E
 * - 0b1 - LCD segment on or LCD backplane active for phase E
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPELCD14 field. */
#define LCD_RD_WF8B_BPELCD14(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPELCD14_MASK) >> LCD_WF8B_BPELCD14_SHIFT)
#define LCD_BRD_WF8B_BPELCD14(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPELCD14_SHIFT, LCD_WF8B_BPELCD14_WIDTH))

/*! @brief Set the BPELCD14 field to a new value. */
#define LCD_WR_WF8B_BPELCD14(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPELCD14_MASK, LCD_WF8B_BPELCD14(value)))
#define LCD_BWR_WF8B_BPELCD14(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPELCD14_SHIFT), LCD_WF8B_BPELCD14_SHIFT, LCD_WF8B_BPELCD14_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPELCD0[4] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase E
 * - 0b1 - LCD segment on or LCD backplane active for phase E
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPELCD0 field. */
#define LCD_RD_WF8B_BPELCD0(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPELCD0_MASK) >> LCD_WF8B_BPELCD0_SHIFT)
#define LCD_BRD_WF8B_BPELCD0(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPELCD0_SHIFT, LCD_WF8B_BPELCD0_WIDTH))

/*! @brief Set the BPELCD0 field to a new value. */
#define LCD_WR_WF8B_BPELCD0(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPELCD0_MASK, LCD_WF8B_BPELCD0(value)))
#define LCD_BWR_WF8B_BPELCD0(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPELCD0_SHIFT), LCD_WF8B_BPELCD0_SHIFT, LCD_WF8B_BPELCD0_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPELCD60[4] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase E
 * - 0b1 - LCD segment on or LCD backplane active for phase E
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPELCD60 field. */
#define LCD_RD_WF8B_BPELCD60(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPELCD60_MASK) >> LCD_WF8B_BPELCD60_SHIFT)
#define LCD_BRD_WF8B_BPELCD60(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPELCD60_SHIFT, LCD_WF8B_BPELCD60_WIDTH))

/*! @brief Set the BPELCD60 field to a new value. */
#define LCD_WR_WF8B_BPELCD60(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPELCD60_MASK, LCD_WF8B_BPELCD60(value)))
#define LCD_BWR_WF8B_BPELCD60(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPELCD60_SHIFT), LCD_WF8B_BPELCD60_SHIFT, LCD_WF8B_BPELCD60_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPELCD15[4] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase E
 * - 0b1 - LCD segment on or LCD backplane active for phase E
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPELCD15 field. */
#define LCD_RD_WF8B_BPELCD15(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPELCD15_MASK) >> LCD_WF8B_BPELCD15_SHIFT)
#define LCD_BRD_WF8B_BPELCD15(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPELCD15_SHIFT, LCD_WF8B_BPELCD15_WIDTH))

/*! @brief Set the BPELCD15 field to a new value. */
#define LCD_WR_WF8B_BPELCD15(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPELCD15_MASK, LCD_WF8B_BPELCD15(value)))
#define LCD_BWR_WF8B_BPELCD15(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPELCD15_SHIFT), LCD_WF8B_BPELCD15_SHIFT, LCD_WF8B_BPELCD15_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPELCD61[4] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase E
 * - 0b1 - LCD segment on or LCD backplane active for phase E
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPELCD61 field. */
#define LCD_RD_WF8B_BPELCD61(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPELCD61_MASK) >> LCD_WF8B_BPELCD61_SHIFT)
#define LCD_BRD_WF8B_BPELCD61(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPELCD61_SHIFT, LCD_WF8B_BPELCD61_WIDTH))

/*! @brief Set the BPELCD61 field to a new value. */
#define LCD_WR_WF8B_BPELCD61(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPELCD61_MASK, LCD_WF8B_BPELCD61(value)))
#define LCD_BWR_WF8B_BPELCD61(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPELCD61_SHIFT), LCD_WF8B_BPELCD61_SHIFT, LCD_WF8B_BPELCD61_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPELCD54[4] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase E
 * - 0b1 - LCD segment on or LCD backplane active for phase E
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPELCD54 field. */
#define LCD_RD_WF8B_BPELCD54(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPELCD54_MASK) >> LCD_WF8B_BPELCD54_SHIFT)
#define LCD_BRD_WF8B_BPELCD54(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPELCD54_SHIFT, LCD_WF8B_BPELCD54_WIDTH))

/*! @brief Set the BPELCD54 field to a new value. */
#define LCD_WR_WF8B_BPELCD54(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPELCD54_MASK, LCD_WF8B_BPELCD54(value)))
#define LCD_BWR_WF8B_BPELCD54(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPELCD54_SHIFT), LCD_WF8B_BPELCD54_SHIFT, LCD_WF8B_BPELCD54_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPELCD62[4] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase E
 * - 0b1 - LCD segment on or LCD backplane active for phase E
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPELCD62 field. */
#define LCD_RD_WF8B_BPELCD62(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPELCD62_MASK) >> LCD_WF8B_BPELCD62_SHIFT)
#define LCD_BRD_WF8B_BPELCD62(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPELCD62_SHIFT, LCD_WF8B_BPELCD62_WIDTH))

/*! @brief Set the BPELCD62 field to a new value. */
#define LCD_WR_WF8B_BPELCD62(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPELCD62_MASK, LCD_WF8B_BPELCD62(value)))
#define LCD_BWR_WF8B_BPELCD62(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPELCD62_SHIFT), LCD_WF8B_BPELCD62_SHIFT, LCD_WF8B_BPELCD62_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPELCD63[4] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase E
 * - 0b1 - LCD segment on or LCD backplane active for phase E
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPELCD63 field. */
#define LCD_RD_WF8B_BPELCD63(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPELCD63_MASK) >> LCD_WF8B_BPELCD63_SHIFT)
#define LCD_BRD_WF8B_BPELCD63(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPELCD63_SHIFT, LCD_WF8B_BPELCD63_WIDTH))

/*! @brief Set the BPELCD63 field to a new value. */
#define LCD_WR_WF8B_BPELCD63(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPELCD63_MASK, LCD_WF8B_BPELCD63(value)))
#define LCD_BWR_WF8B_BPELCD63(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPELCD63_SHIFT), LCD_WF8B_BPELCD63_SHIFT, LCD_WF8B_BPELCD63_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPELCD55[4] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase E
 * - 0b1 - LCD segment on or LCD backplane active for phase E
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPELCD55 field. */
#define LCD_RD_WF8B_BPELCD55(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPELCD55_MASK) >> LCD_WF8B_BPELCD55_SHIFT)
#define LCD_BRD_WF8B_BPELCD55(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPELCD55_SHIFT, LCD_WF8B_BPELCD55_WIDTH))

/*! @brief Set the BPELCD55 field to a new value. */
#define LCD_WR_WF8B_BPELCD55(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPELCD55_MASK, LCD_WF8B_BPELCD55(value)))
#define LCD_BWR_WF8B_BPELCD55(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPELCD55_SHIFT), LCD_WF8B_BPELCD55_SHIFT, LCD_WF8B_BPELCD55_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPELCD4[4] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase E
 * - 0b1 - LCD segment on or LCD backplane active for phase E
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPELCD4 field. */
#define LCD_RD_WF8B_BPELCD4(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPELCD4_MASK) >> LCD_WF8B_BPELCD4_SHIFT)
#define LCD_BRD_WF8B_BPELCD4(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPELCD4_SHIFT, LCD_WF8B_BPELCD4_WIDTH))

/*! @brief Set the BPELCD4 field to a new value. */
#define LCD_WR_WF8B_BPELCD4(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPELCD4_MASK, LCD_WF8B_BPELCD4(value)))
#define LCD_BWR_WF8B_BPELCD4(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPELCD4_SHIFT), LCD_WF8B_BPELCD4_SHIFT, LCD_WF8B_BPELCD4_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPFLCD13[5] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase F
 * - 0b1 - LCD segment on or LCD backplane active for phase F
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPFLCD13 field. */
#define LCD_RD_WF8B_BPFLCD13(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPFLCD13_MASK) >> LCD_WF8B_BPFLCD13_SHIFT)
#define LCD_BRD_WF8B_BPFLCD13(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPFLCD13_SHIFT, LCD_WF8B_BPFLCD13_WIDTH))

/*! @brief Set the BPFLCD13 field to a new value. */
#define LCD_WR_WF8B_BPFLCD13(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPFLCD13_MASK, LCD_WF8B_BPFLCD13(value)))
#define LCD_BWR_WF8B_BPFLCD13(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPFLCD13_SHIFT), LCD_WF8B_BPFLCD13_SHIFT, LCD_WF8B_BPFLCD13_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPFLCD39[5] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase F
 * - 0b1 - LCD segment on or LCD backplane active for phase F
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPFLCD39 field. */
#define LCD_RD_WF8B_BPFLCD39(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPFLCD39_MASK) >> LCD_WF8B_BPFLCD39_SHIFT)
#define LCD_BRD_WF8B_BPFLCD39(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPFLCD39_SHIFT, LCD_WF8B_BPFLCD39_WIDTH))

/*! @brief Set the BPFLCD39 field to a new value. */
#define LCD_WR_WF8B_BPFLCD39(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPFLCD39_MASK, LCD_WF8B_BPFLCD39(value)))
#define LCD_BWR_WF8B_BPFLCD39(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPFLCD39_SHIFT), LCD_WF8B_BPFLCD39_SHIFT, LCD_WF8B_BPFLCD39_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPFLCD55[5] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase F
 * - 0b1 - LCD segment on or LCD backplane active for phase F
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPFLCD55 field. */
#define LCD_RD_WF8B_BPFLCD55(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPFLCD55_MASK) >> LCD_WF8B_BPFLCD55_SHIFT)
#define LCD_BRD_WF8B_BPFLCD55(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPFLCD55_SHIFT, LCD_WF8B_BPFLCD55_WIDTH))

/*! @brief Set the BPFLCD55 field to a new value. */
#define LCD_WR_WF8B_BPFLCD55(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPFLCD55_MASK, LCD_WF8B_BPFLCD55(value)))
#define LCD_BWR_WF8B_BPFLCD55(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPFLCD55_SHIFT), LCD_WF8B_BPFLCD55_SHIFT, LCD_WF8B_BPFLCD55_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPFLCD47[5] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase F
 * - 0b1 - LCD segment on or LCD backplane active for phase F
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPFLCD47 field. */
#define LCD_RD_WF8B_BPFLCD47(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPFLCD47_MASK) >> LCD_WF8B_BPFLCD47_SHIFT)
#define LCD_BRD_WF8B_BPFLCD47(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPFLCD47_SHIFT, LCD_WF8B_BPFLCD47_WIDTH))

/*! @brief Set the BPFLCD47 field to a new value. */
#define LCD_WR_WF8B_BPFLCD47(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPFLCD47_MASK, LCD_WF8B_BPFLCD47(value)))
#define LCD_BWR_WF8B_BPFLCD47(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPFLCD47_SHIFT), LCD_WF8B_BPFLCD47_SHIFT, LCD_WF8B_BPFLCD47_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPFLCD63[5] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase F
 * - 0b1 - LCD segment on or LCD backplane active for phase F
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPFLCD63 field. */
#define LCD_RD_WF8B_BPFLCD63(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPFLCD63_MASK) >> LCD_WF8B_BPFLCD63_SHIFT)
#define LCD_BRD_WF8B_BPFLCD63(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPFLCD63_SHIFT, LCD_WF8B_BPFLCD63_WIDTH))

/*! @brief Set the BPFLCD63 field to a new value. */
#define LCD_WR_WF8B_BPFLCD63(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPFLCD63_MASK, LCD_WF8B_BPFLCD63(value)))
#define LCD_BWR_WF8B_BPFLCD63(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPFLCD63_SHIFT), LCD_WF8B_BPFLCD63_SHIFT, LCD_WF8B_BPFLCD63_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPFLCD43[5] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase F
 * - 0b1 - LCD segment on or LCD backplane active for phase F
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPFLCD43 field. */
#define LCD_RD_WF8B_BPFLCD43(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPFLCD43_MASK) >> LCD_WF8B_BPFLCD43_SHIFT)
#define LCD_BRD_WF8B_BPFLCD43(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPFLCD43_SHIFT, LCD_WF8B_BPFLCD43_WIDTH))

/*! @brief Set the BPFLCD43 field to a new value. */
#define LCD_WR_WF8B_BPFLCD43(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPFLCD43_MASK, LCD_WF8B_BPFLCD43(value)))
#define LCD_BWR_WF8B_BPFLCD43(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPFLCD43_SHIFT), LCD_WF8B_BPFLCD43_SHIFT, LCD_WF8B_BPFLCD43_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPFLCD5[5] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase F
 * - 0b1 - LCD segment on or LCD backplane active for phase F
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPFLCD5 field. */
#define LCD_RD_WF8B_BPFLCD5(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPFLCD5_MASK) >> LCD_WF8B_BPFLCD5_SHIFT)
#define LCD_BRD_WF8B_BPFLCD5(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPFLCD5_SHIFT, LCD_WF8B_BPFLCD5_WIDTH))

/*! @brief Set the BPFLCD5 field to a new value. */
#define LCD_WR_WF8B_BPFLCD5(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPFLCD5_MASK, LCD_WF8B_BPFLCD5(value)))
#define LCD_BWR_WF8B_BPFLCD5(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPFLCD5_SHIFT), LCD_WF8B_BPFLCD5_SHIFT, LCD_WF8B_BPFLCD5_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPFLCD62[5] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase F
 * - 0b1 - LCD segment on or LCD backplane active for phase F
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPFLCD62 field. */
#define LCD_RD_WF8B_BPFLCD62(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPFLCD62_MASK) >> LCD_WF8B_BPFLCD62_SHIFT)
#define LCD_BRD_WF8B_BPFLCD62(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPFLCD62_SHIFT, LCD_WF8B_BPFLCD62_WIDTH))

/*! @brief Set the BPFLCD62 field to a new value. */
#define LCD_WR_WF8B_BPFLCD62(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPFLCD62_MASK, LCD_WF8B_BPFLCD62(value)))
#define LCD_BWR_WF8B_BPFLCD62(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPFLCD62_SHIFT), LCD_WF8B_BPFLCD62_SHIFT, LCD_WF8B_BPFLCD62_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPFLCD14[5] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase F
 * - 0b1 - LCD segment on or LCD backplane active for phase F
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPFLCD14 field. */
#define LCD_RD_WF8B_BPFLCD14(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPFLCD14_MASK) >> LCD_WF8B_BPFLCD14_SHIFT)
#define LCD_BRD_WF8B_BPFLCD14(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPFLCD14_SHIFT, LCD_WF8B_BPFLCD14_WIDTH))

/*! @brief Set the BPFLCD14 field to a new value. */
#define LCD_WR_WF8B_BPFLCD14(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPFLCD14_MASK, LCD_WF8B_BPFLCD14(value)))
#define LCD_BWR_WF8B_BPFLCD14(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPFLCD14_SHIFT), LCD_WF8B_BPFLCD14_SHIFT, LCD_WF8B_BPFLCD14_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPFLCD24[5] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase F
 * - 0b1 - LCD segment on or LCD backplane active for phase F
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPFLCD24 field. */
#define LCD_RD_WF8B_BPFLCD24(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPFLCD24_MASK) >> LCD_WF8B_BPFLCD24_SHIFT)
#define LCD_BRD_WF8B_BPFLCD24(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPFLCD24_SHIFT, LCD_WF8B_BPFLCD24_WIDTH))

/*! @brief Set the BPFLCD24 field to a new value. */
#define LCD_WR_WF8B_BPFLCD24(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPFLCD24_MASK, LCD_WF8B_BPFLCD24(value)))
#define LCD_BWR_WF8B_BPFLCD24(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPFLCD24_SHIFT), LCD_WF8B_BPFLCD24_SHIFT, LCD_WF8B_BPFLCD24_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPFLCD54[5] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase F
 * - 0b1 - LCD segment on or LCD backplane active for phase F
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPFLCD54 field. */
#define LCD_RD_WF8B_BPFLCD54(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPFLCD54_MASK) >> LCD_WF8B_BPFLCD54_SHIFT)
#define LCD_BRD_WF8B_BPFLCD54(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPFLCD54_SHIFT, LCD_WF8B_BPFLCD54_WIDTH))

/*! @brief Set the BPFLCD54 field to a new value. */
#define LCD_WR_WF8B_BPFLCD54(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPFLCD54_MASK, LCD_WF8B_BPFLCD54(value)))
#define LCD_BWR_WF8B_BPFLCD54(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPFLCD54_SHIFT), LCD_WF8B_BPFLCD54_SHIFT, LCD_WF8B_BPFLCD54_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPFLCD15[5] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase F
 * - 0b1 - LCD segment on or LCD backplane active for phase F
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPFLCD15 field. */
#define LCD_RD_WF8B_BPFLCD15(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPFLCD15_MASK) >> LCD_WF8B_BPFLCD15_SHIFT)
#define LCD_BRD_WF8B_BPFLCD15(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPFLCD15_SHIFT, LCD_WF8B_BPFLCD15_WIDTH))

/*! @brief Set the BPFLCD15 field to a new value. */
#define LCD_WR_WF8B_BPFLCD15(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPFLCD15_MASK, LCD_WF8B_BPFLCD15(value)))
#define LCD_BWR_WF8B_BPFLCD15(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPFLCD15_SHIFT), LCD_WF8B_BPFLCD15_SHIFT, LCD_WF8B_BPFLCD15_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPFLCD32[5] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase F
 * - 0b1 - LCD segment on or LCD backplane active for phase F
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPFLCD32 field. */
#define LCD_RD_WF8B_BPFLCD32(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPFLCD32_MASK) >> LCD_WF8B_BPFLCD32_SHIFT)
#define LCD_BRD_WF8B_BPFLCD32(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPFLCD32_SHIFT, LCD_WF8B_BPFLCD32_WIDTH))

/*! @brief Set the BPFLCD32 field to a new value. */
#define LCD_WR_WF8B_BPFLCD32(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPFLCD32_MASK, LCD_WF8B_BPFLCD32(value)))
#define LCD_BWR_WF8B_BPFLCD32(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPFLCD32_SHIFT), LCD_WF8B_BPFLCD32_SHIFT, LCD_WF8B_BPFLCD32_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPFLCD61[5] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase F
 * - 0b1 - LCD segment on or LCD backplane active for phase F
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPFLCD61 field. */
#define LCD_RD_WF8B_BPFLCD61(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPFLCD61_MASK) >> LCD_WF8B_BPFLCD61_SHIFT)
#define LCD_BRD_WF8B_BPFLCD61(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPFLCD61_SHIFT, LCD_WF8B_BPFLCD61_WIDTH))

/*! @brief Set the BPFLCD61 field to a new value. */
#define LCD_WR_WF8B_BPFLCD61(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPFLCD61_MASK, LCD_WF8B_BPFLCD61(value)))
#define LCD_BWR_WF8B_BPFLCD61(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPFLCD61_SHIFT), LCD_WF8B_BPFLCD61_SHIFT, LCD_WF8B_BPFLCD61_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPFLCD25[5] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase F
 * - 0b1 - LCD segment on or LCD backplane active for phase F
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPFLCD25 field. */
#define LCD_RD_WF8B_BPFLCD25(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPFLCD25_MASK) >> LCD_WF8B_BPFLCD25_SHIFT)
#define LCD_BRD_WF8B_BPFLCD25(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPFLCD25_SHIFT, LCD_WF8B_BPFLCD25_WIDTH))

/*! @brief Set the BPFLCD25 field to a new value. */
#define LCD_WR_WF8B_BPFLCD25(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPFLCD25_MASK, LCD_WF8B_BPFLCD25(value)))
#define LCD_BWR_WF8B_BPFLCD25(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPFLCD25_SHIFT), LCD_WF8B_BPFLCD25_SHIFT, LCD_WF8B_BPFLCD25_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPFLCD60[5] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase F
 * - 0b1 - LCD segment on or LCD backplane active for phase F
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPFLCD60 field. */
#define LCD_RD_WF8B_BPFLCD60(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPFLCD60_MASK) >> LCD_WF8B_BPFLCD60_SHIFT)
#define LCD_BRD_WF8B_BPFLCD60(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPFLCD60_SHIFT, LCD_WF8B_BPFLCD60_WIDTH))

/*! @brief Set the BPFLCD60 field to a new value. */
#define LCD_WR_WF8B_BPFLCD60(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPFLCD60_MASK, LCD_WF8B_BPFLCD60(value)))
#define LCD_BWR_WF8B_BPFLCD60(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPFLCD60_SHIFT), LCD_WF8B_BPFLCD60_SHIFT, LCD_WF8B_BPFLCD60_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPFLCD41[5] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase F
 * - 0b1 - LCD segment on or LCD backplane active for phase F
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPFLCD41 field. */
#define LCD_RD_WF8B_BPFLCD41(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPFLCD41_MASK) >> LCD_WF8B_BPFLCD41_SHIFT)
#define LCD_BRD_WF8B_BPFLCD41(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPFLCD41_SHIFT, LCD_WF8B_BPFLCD41_WIDTH))

/*! @brief Set the BPFLCD41 field to a new value. */
#define LCD_WR_WF8B_BPFLCD41(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPFLCD41_MASK, LCD_WF8B_BPFLCD41(value)))
#define LCD_BWR_WF8B_BPFLCD41(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPFLCD41_SHIFT), LCD_WF8B_BPFLCD41_SHIFT, LCD_WF8B_BPFLCD41_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPFLCD33[5] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase F
 * - 0b1 - LCD segment on or LCD backplane active for phase F
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPFLCD33 field. */
#define LCD_RD_WF8B_BPFLCD33(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPFLCD33_MASK) >> LCD_WF8B_BPFLCD33_SHIFT)
#define LCD_BRD_WF8B_BPFLCD33(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPFLCD33_SHIFT, LCD_WF8B_BPFLCD33_WIDTH))

/*! @brief Set the BPFLCD33 field to a new value. */
#define LCD_WR_WF8B_BPFLCD33(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPFLCD33_MASK, LCD_WF8B_BPFLCD33(value)))
#define LCD_BWR_WF8B_BPFLCD33(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPFLCD33_SHIFT), LCD_WF8B_BPFLCD33_SHIFT, LCD_WF8B_BPFLCD33_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPFLCD53[5] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase F
 * - 0b1 - LCD segment on or LCD backplane active for phase F
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPFLCD53 field. */
#define LCD_RD_WF8B_BPFLCD53(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPFLCD53_MASK) >> LCD_WF8B_BPFLCD53_SHIFT)
#define LCD_BRD_WF8B_BPFLCD53(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPFLCD53_SHIFT, LCD_WF8B_BPFLCD53_WIDTH))

/*! @brief Set the BPFLCD53 field to a new value. */
#define LCD_WR_WF8B_BPFLCD53(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPFLCD53_MASK, LCD_WF8B_BPFLCD53(value)))
#define LCD_BWR_WF8B_BPFLCD53(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPFLCD53_SHIFT), LCD_WF8B_BPFLCD53_SHIFT, LCD_WF8B_BPFLCD53_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPFLCD59[5] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase F
 * - 0b1 - LCD segment on or LCD backplane active for phase F
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPFLCD59 field. */
#define LCD_RD_WF8B_BPFLCD59(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPFLCD59_MASK) >> LCD_WF8B_BPFLCD59_SHIFT)
#define LCD_BRD_WF8B_BPFLCD59(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPFLCD59_SHIFT, LCD_WF8B_BPFLCD59_WIDTH))

/*! @brief Set the BPFLCD59 field to a new value. */
#define LCD_WR_WF8B_BPFLCD59(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPFLCD59_MASK, LCD_WF8B_BPFLCD59(value)))
#define LCD_BWR_WF8B_BPFLCD59(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPFLCD59_SHIFT), LCD_WF8B_BPFLCD59_SHIFT, LCD_WF8B_BPFLCD59_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPFLCD0[5] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase F
 * - 0b1 - LCD segment on or LCD backplane active for phase F
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPFLCD0 field. */
#define LCD_RD_WF8B_BPFLCD0(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPFLCD0_MASK) >> LCD_WF8B_BPFLCD0_SHIFT)
#define LCD_BRD_WF8B_BPFLCD0(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPFLCD0_SHIFT, LCD_WF8B_BPFLCD0_WIDTH))

/*! @brief Set the BPFLCD0 field to a new value. */
#define LCD_WR_WF8B_BPFLCD0(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPFLCD0_MASK, LCD_WF8B_BPFLCD0(value)))
#define LCD_BWR_WF8B_BPFLCD0(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPFLCD0_SHIFT), LCD_WF8B_BPFLCD0_SHIFT, LCD_WF8B_BPFLCD0_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPFLCD46[5] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase F
 * - 0b1 - LCD segment on or LCD backplane active for phase F
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPFLCD46 field. */
#define LCD_RD_WF8B_BPFLCD46(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPFLCD46_MASK) >> LCD_WF8B_BPFLCD46_SHIFT)
#define LCD_BRD_WF8B_BPFLCD46(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPFLCD46_SHIFT, LCD_WF8B_BPFLCD46_WIDTH))

/*! @brief Set the BPFLCD46 field to a new value. */
#define LCD_WR_WF8B_BPFLCD46(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPFLCD46_MASK, LCD_WF8B_BPFLCD46(value)))
#define LCD_BWR_WF8B_BPFLCD46(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPFLCD46_SHIFT), LCD_WF8B_BPFLCD46_SHIFT, LCD_WF8B_BPFLCD46_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPFLCD58[5] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase F
 * - 0b1 - LCD segment on or LCD backplane active for phase F
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPFLCD58 field. */
#define LCD_RD_WF8B_BPFLCD58(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPFLCD58_MASK) >> LCD_WF8B_BPFLCD58_SHIFT)
#define LCD_BRD_WF8B_BPFLCD58(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPFLCD58_SHIFT, LCD_WF8B_BPFLCD58_WIDTH))

/*! @brief Set the BPFLCD58 field to a new value. */
#define LCD_WR_WF8B_BPFLCD58(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPFLCD58_MASK, LCD_WF8B_BPFLCD58(value)))
#define LCD_BWR_WF8B_BPFLCD58(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPFLCD58_SHIFT), LCD_WF8B_BPFLCD58_SHIFT, LCD_WF8B_BPFLCD58_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPFLCD26[5] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase F
 * - 0b1 - LCD segment on or LCD backplane active for phase F
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPFLCD26 field. */
#define LCD_RD_WF8B_BPFLCD26(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPFLCD26_MASK) >> LCD_WF8B_BPFLCD26_SHIFT)
#define LCD_BRD_WF8B_BPFLCD26(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPFLCD26_SHIFT, LCD_WF8B_BPFLCD26_WIDTH))

/*! @brief Set the BPFLCD26 field to a new value. */
#define LCD_WR_WF8B_BPFLCD26(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPFLCD26_MASK, LCD_WF8B_BPFLCD26(value)))
#define LCD_BWR_WF8B_BPFLCD26(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPFLCD26_SHIFT), LCD_WF8B_BPFLCD26_SHIFT, LCD_WF8B_BPFLCD26_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPFLCD36[5] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase F
 * - 0b1 - LCD segment on or LCD backplane active for phase F
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPFLCD36 field. */
#define LCD_RD_WF8B_BPFLCD36(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPFLCD36_MASK) >> LCD_WF8B_BPFLCD36_SHIFT)
#define LCD_BRD_WF8B_BPFLCD36(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPFLCD36_SHIFT, LCD_WF8B_BPFLCD36_WIDTH))

/*! @brief Set the BPFLCD36 field to a new value. */
#define LCD_WR_WF8B_BPFLCD36(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPFLCD36_MASK, LCD_WF8B_BPFLCD36(value)))
#define LCD_BWR_WF8B_BPFLCD36(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPFLCD36_SHIFT), LCD_WF8B_BPFLCD36_SHIFT, LCD_WF8B_BPFLCD36_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPFLCD10[5] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase F
 * - 0b1 - LCD segment on or LCD backplane active for phase F
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPFLCD10 field. */
#define LCD_RD_WF8B_BPFLCD10(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPFLCD10_MASK) >> LCD_WF8B_BPFLCD10_SHIFT)
#define LCD_BRD_WF8B_BPFLCD10(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPFLCD10_SHIFT, LCD_WF8B_BPFLCD10_WIDTH))

/*! @brief Set the BPFLCD10 field to a new value. */
#define LCD_WR_WF8B_BPFLCD10(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPFLCD10_MASK, LCD_WF8B_BPFLCD10(value)))
#define LCD_BWR_WF8B_BPFLCD10(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPFLCD10_SHIFT), LCD_WF8B_BPFLCD10_SHIFT, LCD_WF8B_BPFLCD10_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPFLCD52[5] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase F
 * - 0b1 - LCD segment on or LCD backplane active for phase F
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPFLCD52 field. */
#define LCD_RD_WF8B_BPFLCD52(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPFLCD52_MASK) >> LCD_WF8B_BPFLCD52_SHIFT)
#define LCD_BRD_WF8B_BPFLCD52(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPFLCD52_SHIFT, LCD_WF8B_BPFLCD52_WIDTH))

/*! @brief Set the BPFLCD52 field to a new value. */
#define LCD_WR_WF8B_BPFLCD52(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPFLCD52_MASK, LCD_WF8B_BPFLCD52(value)))
#define LCD_BWR_WF8B_BPFLCD52(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPFLCD52_SHIFT), LCD_WF8B_BPFLCD52_SHIFT, LCD_WF8B_BPFLCD52_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPFLCD57[5] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase F
 * - 0b1 - LCD segment on or LCD backplane active for phase F
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPFLCD57 field. */
#define LCD_RD_WF8B_BPFLCD57(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPFLCD57_MASK) >> LCD_WF8B_BPFLCD57_SHIFT)
#define LCD_BRD_WF8B_BPFLCD57(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPFLCD57_SHIFT, LCD_WF8B_BPFLCD57_WIDTH))

/*! @brief Set the BPFLCD57 field to a new value. */
#define LCD_WR_WF8B_BPFLCD57(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPFLCD57_MASK, LCD_WF8B_BPFLCD57(value)))
#define LCD_BWR_WF8B_BPFLCD57(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPFLCD57_SHIFT), LCD_WF8B_BPFLCD57_SHIFT, LCD_WF8B_BPFLCD57_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPFLCD27[5] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase F
 * - 0b1 - LCD segment on or LCD backplane active for phase F
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPFLCD27 field. */
#define LCD_RD_WF8B_BPFLCD27(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPFLCD27_MASK) >> LCD_WF8B_BPFLCD27_SHIFT)
#define LCD_BRD_WF8B_BPFLCD27(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPFLCD27_SHIFT, LCD_WF8B_BPFLCD27_WIDTH))

/*! @brief Set the BPFLCD27 field to a new value. */
#define LCD_WR_WF8B_BPFLCD27(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPFLCD27_MASK, LCD_WF8B_BPFLCD27(value)))
#define LCD_BWR_WF8B_BPFLCD27(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPFLCD27_SHIFT), LCD_WF8B_BPFLCD27_SHIFT, LCD_WF8B_BPFLCD27_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPFLCD11[5] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase F
 * - 0b1 - LCD segment on or LCD backplane active for phase F
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPFLCD11 field. */
#define LCD_RD_WF8B_BPFLCD11(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPFLCD11_MASK) >> LCD_WF8B_BPFLCD11_SHIFT)
#define LCD_BRD_WF8B_BPFLCD11(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPFLCD11_SHIFT, LCD_WF8B_BPFLCD11_WIDTH))

/*! @brief Set the BPFLCD11 field to a new value. */
#define LCD_WR_WF8B_BPFLCD11(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPFLCD11_MASK, LCD_WF8B_BPFLCD11(value)))
#define LCD_BWR_WF8B_BPFLCD11(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPFLCD11_SHIFT), LCD_WF8B_BPFLCD11_SHIFT, LCD_WF8B_BPFLCD11_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPFLCD56[5] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase F
 * - 0b1 - LCD segment on or LCD backplane active for phase F
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPFLCD56 field. */
#define LCD_RD_WF8B_BPFLCD56(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPFLCD56_MASK) >> LCD_WF8B_BPFLCD56_SHIFT)
#define LCD_BRD_WF8B_BPFLCD56(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPFLCD56_SHIFT, LCD_WF8B_BPFLCD56_WIDTH))

/*! @brief Set the BPFLCD56 field to a new value. */
#define LCD_WR_WF8B_BPFLCD56(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPFLCD56_MASK, LCD_WF8B_BPFLCD56(value)))
#define LCD_BWR_WF8B_BPFLCD56(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPFLCD56_SHIFT), LCD_WF8B_BPFLCD56_SHIFT, LCD_WF8B_BPFLCD56_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPFLCD1[5] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase F
 * - 0b1 - LCD segment on or LCD backplane active for phase F
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPFLCD1 field. */
#define LCD_RD_WF8B_BPFLCD1(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPFLCD1_MASK) >> LCD_WF8B_BPFLCD1_SHIFT)
#define LCD_BRD_WF8B_BPFLCD1(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPFLCD1_SHIFT, LCD_WF8B_BPFLCD1_WIDTH))

/*! @brief Set the BPFLCD1 field to a new value. */
#define LCD_WR_WF8B_BPFLCD1(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPFLCD1_MASK, LCD_WF8B_BPFLCD1(value)))
#define LCD_BWR_WF8B_BPFLCD1(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPFLCD1_SHIFT), LCD_WF8B_BPFLCD1_SHIFT, LCD_WF8B_BPFLCD1_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPFLCD8[5] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase F
 * - 0b1 - LCD segment on or LCD backplane active for phase F
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPFLCD8 field. */
#define LCD_RD_WF8B_BPFLCD8(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPFLCD8_MASK) >> LCD_WF8B_BPFLCD8_SHIFT)
#define LCD_BRD_WF8B_BPFLCD8(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPFLCD8_SHIFT, LCD_WF8B_BPFLCD8_WIDTH))

/*! @brief Set the BPFLCD8 field to a new value. */
#define LCD_WR_WF8B_BPFLCD8(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPFLCD8_MASK, LCD_WF8B_BPFLCD8(value)))
#define LCD_BWR_WF8B_BPFLCD8(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPFLCD8_SHIFT), LCD_WF8B_BPFLCD8_SHIFT, LCD_WF8B_BPFLCD8_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPFLCD40[5] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase F
 * - 0b1 - LCD segment on or LCD backplane active for phase F
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPFLCD40 field. */
#define LCD_RD_WF8B_BPFLCD40(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPFLCD40_MASK) >> LCD_WF8B_BPFLCD40_SHIFT)
#define LCD_BRD_WF8B_BPFLCD40(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPFLCD40_SHIFT, LCD_WF8B_BPFLCD40_WIDTH))

/*! @brief Set the BPFLCD40 field to a new value. */
#define LCD_WR_WF8B_BPFLCD40(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPFLCD40_MASK, LCD_WF8B_BPFLCD40(value)))
#define LCD_BWR_WF8B_BPFLCD40(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPFLCD40_SHIFT), LCD_WF8B_BPFLCD40_SHIFT, LCD_WF8B_BPFLCD40_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPFLCD51[5] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase F
 * - 0b1 - LCD segment on or LCD backplane active for phase F
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPFLCD51 field. */
#define LCD_RD_WF8B_BPFLCD51(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPFLCD51_MASK) >> LCD_WF8B_BPFLCD51_SHIFT)
#define LCD_BRD_WF8B_BPFLCD51(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPFLCD51_SHIFT, LCD_WF8B_BPFLCD51_WIDTH))

/*! @brief Set the BPFLCD51 field to a new value. */
#define LCD_WR_WF8B_BPFLCD51(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPFLCD51_MASK, LCD_WF8B_BPFLCD51(value)))
#define LCD_BWR_WF8B_BPFLCD51(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPFLCD51_SHIFT), LCD_WF8B_BPFLCD51_SHIFT, LCD_WF8B_BPFLCD51_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPFLCD16[5] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase F
 * - 0b1 - LCD segment on or LCD backplane active for phase F
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPFLCD16 field. */
#define LCD_RD_WF8B_BPFLCD16(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPFLCD16_MASK) >> LCD_WF8B_BPFLCD16_SHIFT)
#define LCD_BRD_WF8B_BPFLCD16(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPFLCD16_SHIFT, LCD_WF8B_BPFLCD16_WIDTH))

/*! @brief Set the BPFLCD16 field to a new value. */
#define LCD_WR_WF8B_BPFLCD16(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPFLCD16_MASK, LCD_WF8B_BPFLCD16(value)))
#define LCD_BWR_WF8B_BPFLCD16(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPFLCD16_SHIFT), LCD_WF8B_BPFLCD16_SHIFT, LCD_WF8B_BPFLCD16_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPFLCD45[5] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase F
 * - 0b1 - LCD segment on or LCD backplane active for phase F
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPFLCD45 field. */
#define LCD_RD_WF8B_BPFLCD45(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPFLCD45_MASK) >> LCD_WF8B_BPFLCD45_SHIFT)
#define LCD_BRD_WF8B_BPFLCD45(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPFLCD45_SHIFT, LCD_WF8B_BPFLCD45_WIDTH))

/*! @brief Set the BPFLCD45 field to a new value. */
#define LCD_WR_WF8B_BPFLCD45(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPFLCD45_MASK, LCD_WF8B_BPFLCD45(value)))
#define LCD_BWR_WF8B_BPFLCD45(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPFLCD45_SHIFT), LCD_WF8B_BPFLCD45_SHIFT, LCD_WF8B_BPFLCD45_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPFLCD6[5] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase F
 * - 0b1 - LCD segment on or LCD backplane active for phase F
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPFLCD6 field. */
#define LCD_RD_WF8B_BPFLCD6(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPFLCD6_MASK) >> LCD_WF8B_BPFLCD6_SHIFT)
#define LCD_BRD_WF8B_BPFLCD6(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPFLCD6_SHIFT, LCD_WF8B_BPFLCD6_WIDTH))

/*! @brief Set the BPFLCD6 field to a new value. */
#define LCD_WR_WF8B_BPFLCD6(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPFLCD6_MASK, LCD_WF8B_BPFLCD6(value)))
#define LCD_BWR_WF8B_BPFLCD6(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPFLCD6_SHIFT), LCD_WF8B_BPFLCD6_SHIFT, LCD_WF8B_BPFLCD6_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPFLCD17[5] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase F
 * - 0b1 - LCD segment on or LCD backplane active for phase F
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPFLCD17 field. */
#define LCD_RD_WF8B_BPFLCD17(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPFLCD17_MASK) >> LCD_WF8B_BPFLCD17_SHIFT)
#define LCD_BRD_WF8B_BPFLCD17(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPFLCD17_SHIFT, LCD_WF8B_BPFLCD17_WIDTH))

/*! @brief Set the BPFLCD17 field to a new value. */
#define LCD_WR_WF8B_BPFLCD17(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPFLCD17_MASK, LCD_WF8B_BPFLCD17(value)))
#define LCD_BWR_WF8B_BPFLCD17(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPFLCD17_SHIFT), LCD_WF8B_BPFLCD17_SHIFT, LCD_WF8B_BPFLCD17_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPFLCD28[5] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase F
 * - 0b1 - LCD segment on or LCD backplane active for phase F
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPFLCD28 field. */
#define LCD_RD_WF8B_BPFLCD28(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPFLCD28_MASK) >> LCD_WF8B_BPFLCD28_SHIFT)
#define LCD_BRD_WF8B_BPFLCD28(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPFLCD28_SHIFT, LCD_WF8B_BPFLCD28_WIDTH))

/*! @brief Set the BPFLCD28 field to a new value. */
#define LCD_WR_WF8B_BPFLCD28(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPFLCD28_MASK, LCD_WF8B_BPFLCD28(value)))
#define LCD_BWR_WF8B_BPFLCD28(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPFLCD28_SHIFT), LCD_WF8B_BPFLCD28_SHIFT, LCD_WF8B_BPFLCD28_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPFLCD42[5] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase F
 * - 0b1 - LCD segment on or LCD backplane active for phase F
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPFLCD42 field. */
#define LCD_RD_WF8B_BPFLCD42(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPFLCD42_MASK) >> LCD_WF8B_BPFLCD42_SHIFT)
#define LCD_BRD_WF8B_BPFLCD42(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPFLCD42_SHIFT, LCD_WF8B_BPFLCD42_WIDTH))

/*! @brief Set the BPFLCD42 field to a new value. */
#define LCD_WR_WF8B_BPFLCD42(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPFLCD42_MASK, LCD_WF8B_BPFLCD42(value)))
#define LCD_BWR_WF8B_BPFLCD42(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPFLCD42_SHIFT), LCD_WF8B_BPFLCD42_SHIFT, LCD_WF8B_BPFLCD42_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPFLCD29[5] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase F
 * - 0b1 - LCD segment on or LCD backplane active for phase F
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPFLCD29 field. */
#define LCD_RD_WF8B_BPFLCD29(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPFLCD29_MASK) >> LCD_WF8B_BPFLCD29_SHIFT)
#define LCD_BRD_WF8B_BPFLCD29(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPFLCD29_SHIFT, LCD_WF8B_BPFLCD29_WIDTH))

/*! @brief Set the BPFLCD29 field to a new value. */
#define LCD_WR_WF8B_BPFLCD29(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPFLCD29_MASK, LCD_WF8B_BPFLCD29(value)))
#define LCD_BWR_WF8B_BPFLCD29(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPFLCD29_SHIFT), LCD_WF8B_BPFLCD29_SHIFT, LCD_WF8B_BPFLCD29_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPFLCD50[5] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase F
 * - 0b1 - LCD segment on or LCD backplane active for phase F
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPFLCD50 field. */
#define LCD_RD_WF8B_BPFLCD50(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPFLCD50_MASK) >> LCD_WF8B_BPFLCD50_SHIFT)
#define LCD_BRD_WF8B_BPFLCD50(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPFLCD50_SHIFT, LCD_WF8B_BPFLCD50_WIDTH))

/*! @brief Set the BPFLCD50 field to a new value. */
#define LCD_WR_WF8B_BPFLCD50(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPFLCD50_MASK, LCD_WF8B_BPFLCD50(value)))
#define LCD_BWR_WF8B_BPFLCD50(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPFLCD50_SHIFT), LCD_WF8B_BPFLCD50_SHIFT, LCD_WF8B_BPFLCD50_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPFLCD18[5] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase F
 * - 0b1 - LCD segment on or LCD backplane active for phase F
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPFLCD18 field. */
#define LCD_RD_WF8B_BPFLCD18(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPFLCD18_MASK) >> LCD_WF8B_BPFLCD18_SHIFT)
#define LCD_BRD_WF8B_BPFLCD18(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPFLCD18_SHIFT, LCD_WF8B_BPFLCD18_WIDTH))

/*! @brief Set the BPFLCD18 field to a new value. */
#define LCD_WR_WF8B_BPFLCD18(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPFLCD18_MASK, LCD_WF8B_BPFLCD18(value)))
#define LCD_BWR_WF8B_BPFLCD18(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPFLCD18_SHIFT), LCD_WF8B_BPFLCD18_SHIFT, LCD_WF8B_BPFLCD18_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPFLCD34[5] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase F
 * - 0b1 - LCD segment on or LCD backplane active for phase F
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPFLCD34 field. */
#define LCD_RD_WF8B_BPFLCD34(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPFLCD34_MASK) >> LCD_WF8B_BPFLCD34_SHIFT)
#define LCD_BRD_WF8B_BPFLCD34(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPFLCD34_SHIFT, LCD_WF8B_BPFLCD34_WIDTH))

/*! @brief Set the BPFLCD34 field to a new value. */
#define LCD_WR_WF8B_BPFLCD34(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPFLCD34_MASK, LCD_WF8B_BPFLCD34(value)))
#define LCD_BWR_WF8B_BPFLCD34(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPFLCD34_SHIFT), LCD_WF8B_BPFLCD34_SHIFT, LCD_WF8B_BPFLCD34_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPFLCD19[5] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase F
 * - 0b1 - LCD segment on or LCD backplane active for phase F
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPFLCD19 field. */
#define LCD_RD_WF8B_BPFLCD19(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPFLCD19_MASK) >> LCD_WF8B_BPFLCD19_SHIFT)
#define LCD_BRD_WF8B_BPFLCD19(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPFLCD19_SHIFT, LCD_WF8B_BPFLCD19_WIDTH))

/*! @brief Set the BPFLCD19 field to a new value. */
#define LCD_WR_WF8B_BPFLCD19(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPFLCD19_MASK, LCD_WF8B_BPFLCD19(value)))
#define LCD_BWR_WF8B_BPFLCD19(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPFLCD19_SHIFT), LCD_WF8B_BPFLCD19_SHIFT, LCD_WF8B_BPFLCD19_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPFLCD2[5] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase F
 * - 0b1 - LCD segment on or LCD backplane active for phase F
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPFLCD2 field. */
#define LCD_RD_WF8B_BPFLCD2(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPFLCD2_MASK) >> LCD_WF8B_BPFLCD2_SHIFT)
#define LCD_BRD_WF8B_BPFLCD2(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPFLCD2_SHIFT, LCD_WF8B_BPFLCD2_WIDTH))

/*! @brief Set the BPFLCD2 field to a new value. */
#define LCD_WR_WF8B_BPFLCD2(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPFLCD2_MASK, LCD_WF8B_BPFLCD2(value)))
#define LCD_BWR_WF8B_BPFLCD2(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPFLCD2_SHIFT), LCD_WF8B_BPFLCD2_SHIFT, LCD_WF8B_BPFLCD2_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPFLCD9[5] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase F
 * - 0b1 - LCD segment on or LCD backplane active for phase F
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPFLCD9 field. */
#define LCD_RD_WF8B_BPFLCD9(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPFLCD9_MASK) >> LCD_WF8B_BPFLCD9_SHIFT)
#define LCD_BRD_WF8B_BPFLCD9(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPFLCD9_SHIFT, LCD_WF8B_BPFLCD9_WIDTH))

/*! @brief Set the BPFLCD9 field to a new value. */
#define LCD_WR_WF8B_BPFLCD9(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPFLCD9_MASK, LCD_WF8B_BPFLCD9(value)))
#define LCD_BWR_WF8B_BPFLCD9(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPFLCD9_SHIFT), LCD_WF8B_BPFLCD9_SHIFT, LCD_WF8B_BPFLCD9_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPFLCD3[5] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase F
 * - 0b1 - LCD segment on or LCD backplane active for phase F
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPFLCD3 field. */
#define LCD_RD_WF8B_BPFLCD3(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPFLCD3_MASK) >> LCD_WF8B_BPFLCD3_SHIFT)
#define LCD_BRD_WF8B_BPFLCD3(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPFLCD3_SHIFT, LCD_WF8B_BPFLCD3_WIDTH))

/*! @brief Set the BPFLCD3 field to a new value. */
#define LCD_WR_WF8B_BPFLCD3(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPFLCD3_MASK, LCD_WF8B_BPFLCD3(value)))
#define LCD_BWR_WF8B_BPFLCD3(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPFLCD3_SHIFT), LCD_WF8B_BPFLCD3_SHIFT, LCD_WF8B_BPFLCD3_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPFLCD37[5] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase F
 * - 0b1 - LCD segment on or LCD backplane active for phase F
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPFLCD37 field. */
#define LCD_RD_WF8B_BPFLCD37(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPFLCD37_MASK) >> LCD_WF8B_BPFLCD37_SHIFT)
#define LCD_BRD_WF8B_BPFLCD37(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPFLCD37_SHIFT, LCD_WF8B_BPFLCD37_WIDTH))

/*! @brief Set the BPFLCD37 field to a new value. */
#define LCD_WR_WF8B_BPFLCD37(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPFLCD37_MASK, LCD_WF8B_BPFLCD37(value)))
#define LCD_BWR_WF8B_BPFLCD37(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPFLCD37_SHIFT), LCD_WF8B_BPFLCD37_SHIFT, LCD_WF8B_BPFLCD37_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPFLCD49[5] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase F
 * - 0b1 - LCD segment on or LCD backplane active for phase F
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPFLCD49 field. */
#define LCD_RD_WF8B_BPFLCD49(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPFLCD49_MASK) >> LCD_WF8B_BPFLCD49_SHIFT)
#define LCD_BRD_WF8B_BPFLCD49(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPFLCD49_SHIFT, LCD_WF8B_BPFLCD49_WIDTH))

/*! @brief Set the BPFLCD49 field to a new value. */
#define LCD_WR_WF8B_BPFLCD49(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPFLCD49_MASK, LCD_WF8B_BPFLCD49(value)))
#define LCD_BWR_WF8B_BPFLCD49(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPFLCD49_SHIFT), LCD_WF8B_BPFLCD49_SHIFT, LCD_WF8B_BPFLCD49_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPFLCD20[5] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase F
 * - 0b1 - LCD segment on or LCD backplane active for phase F
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPFLCD20 field. */
#define LCD_RD_WF8B_BPFLCD20(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPFLCD20_MASK) >> LCD_WF8B_BPFLCD20_SHIFT)
#define LCD_BRD_WF8B_BPFLCD20(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPFLCD20_SHIFT, LCD_WF8B_BPFLCD20_WIDTH))

/*! @brief Set the BPFLCD20 field to a new value. */
#define LCD_WR_WF8B_BPFLCD20(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPFLCD20_MASK, LCD_WF8B_BPFLCD20(value)))
#define LCD_BWR_WF8B_BPFLCD20(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPFLCD20_SHIFT), LCD_WF8B_BPFLCD20_SHIFT, LCD_WF8B_BPFLCD20_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPFLCD44[5] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase F
 * - 0b1 - LCD segment on or LCD backplane active for phase F
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPFLCD44 field. */
#define LCD_RD_WF8B_BPFLCD44(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPFLCD44_MASK) >> LCD_WF8B_BPFLCD44_SHIFT)
#define LCD_BRD_WF8B_BPFLCD44(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPFLCD44_SHIFT, LCD_WF8B_BPFLCD44_WIDTH))

/*! @brief Set the BPFLCD44 field to a new value. */
#define LCD_WR_WF8B_BPFLCD44(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPFLCD44_MASK, LCD_WF8B_BPFLCD44(value)))
#define LCD_BWR_WF8B_BPFLCD44(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPFLCD44_SHIFT), LCD_WF8B_BPFLCD44_SHIFT, LCD_WF8B_BPFLCD44_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPFLCD30[5] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase F
 * - 0b1 - LCD segment on or LCD backplane active for phase F
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPFLCD30 field. */
#define LCD_RD_WF8B_BPFLCD30(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPFLCD30_MASK) >> LCD_WF8B_BPFLCD30_SHIFT)
#define LCD_BRD_WF8B_BPFLCD30(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPFLCD30_SHIFT, LCD_WF8B_BPFLCD30_WIDTH))

/*! @brief Set the BPFLCD30 field to a new value. */
#define LCD_WR_WF8B_BPFLCD30(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPFLCD30_MASK, LCD_WF8B_BPFLCD30(value)))
#define LCD_BWR_WF8B_BPFLCD30(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPFLCD30_SHIFT), LCD_WF8B_BPFLCD30_SHIFT, LCD_WF8B_BPFLCD30_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPFLCD21[5] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase F
 * - 0b1 - LCD segment on or LCD backplane active for phase F
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPFLCD21 field. */
#define LCD_RD_WF8B_BPFLCD21(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPFLCD21_MASK) >> LCD_WF8B_BPFLCD21_SHIFT)
#define LCD_BRD_WF8B_BPFLCD21(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPFLCD21_SHIFT, LCD_WF8B_BPFLCD21_WIDTH))

/*! @brief Set the BPFLCD21 field to a new value. */
#define LCD_WR_WF8B_BPFLCD21(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPFLCD21_MASK, LCD_WF8B_BPFLCD21(value)))
#define LCD_BWR_WF8B_BPFLCD21(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPFLCD21_SHIFT), LCD_WF8B_BPFLCD21_SHIFT, LCD_WF8B_BPFLCD21_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPFLCD35[5] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase F
 * - 0b1 - LCD segment on or LCD backplane active for phase F
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPFLCD35 field. */
#define LCD_RD_WF8B_BPFLCD35(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPFLCD35_MASK) >> LCD_WF8B_BPFLCD35_SHIFT)
#define LCD_BRD_WF8B_BPFLCD35(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPFLCD35_SHIFT, LCD_WF8B_BPFLCD35_WIDTH))

/*! @brief Set the BPFLCD35 field to a new value. */
#define LCD_WR_WF8B_BPFLCD35(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPFLCD35_MASK, LCD_WF8B_BPFLCD35(value)))
#define LCD_BWR_WF8B_BPFLCD35(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPFLCD35_SHIFT), LCD_WF8B_BPFLCD35_SHIFT, LCD_WF8B_BPFLCD35_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPFLCD4[5] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase F
 * - 0b1 - LCD segment on or LCD backplane active for phase F
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPFLCD4 field. */
#define LCD_RD_WF8B_BPFLCD4(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPFLCD4_MASK) >> LCD_WF8B_BPFLCD4_SHIFT)
#define LCD_BRD_WF8B_BPFLCD4(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPFLCD4_SHIFT, LCD_WF8B_BPFLCD4_WIDTH))

/*! @brief Set the BPFLCD4 field to a new value. */
#define LCD_WR_WF8B_BPFLCD4(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPFLCD4_MASK, LCD_WF8B_BPFLCD4(value)))
#define LCD_BWR_WF8B_BPFLCD4(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPFLCD4_SHIFT), LCD_WF8B_BPFLCD4_SHIFT, LCD_WF8B_BPFLCD4_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPFLCD31[5] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase F
 * - 0b1 - LCD segment on or LCD backplane active for phase F
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPFLCD31 field. */
#define LCD_RD_WF8B_BPFLCD31(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPFLCD31_MASK) >> LCD_WF8B_BPFLCD31_SHIFT)
#define LCD_BRD_WF8B_BPFLCD31(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPFLCD31_SHIFT, LCD_WF8B_BPFLCD31_WIDTH))

/*! @brief Set the BPFLCD31 field to a new value. */
#define LCD_WR_WF8B_BPFLCD31(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPFLCD31_MASK, LCD_WF8B_BPFLCD31(value)))
#define LCD_BWR_WF8B_BPFLCD31(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPFLCD31_SHIFT), LCD_WF8B_BPFLCD31_SHIFT, LCD_WF8B_BPFLCD31_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPFLCD48[5] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase F
 * - 0b1 - LCD segment on or LCD backplane active for phase F
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPFLCD48 field. */
#define LCD_RD_WF8B_BPFLCD48(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPFLCD48_MASK) >> LCD_WF8B_BPFLCD48_SHIFT)
#define LCD_BRD_WF8B_BPFLCD48(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPFLCD48_SHIFT, LCD_WF8B_BPFLCD48_WIDTH))

/*! @brief Set the BPFLCD48 field to a new value. */
#define LCD_WR_WF8B_BPFLCD48(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPFLCD48_MASK, LCD_WF8B_BPFLCD48(value)))
#define LCD_BWR_WF8B_BPFLCD48(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPFLCD48_SHIFT), LCD_WF8B_BPFLCD48_SHIFT, LCD_WF8B_BPFLCD48_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPFLCD7[5] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase F
 * - 0b1 - LCD segment on or LCD backplane active for phase F
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPFLCD7 field. */
#define LCD_RD_WF8B_BPFLCD7(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPFLCD7_MASK) >> LCD_WF8B_BPFLCD7_SHIFT)
#define LCD_BRD_WF8B_BPFLCD7(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPFLCD7_SHIFT, LCD_WF8B_BPFLCD7_WIDTH))

/*! @brief Set the BPFLCD7 field to a new value. */
#define LCD_WR_WF8B_BPFLCD7(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPFLCD7_MASK, LCD_WF8B_BPFLCD7(value)))
#define LCD_BWR_WF8B_BPFLCD7(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPFLCD7_SHIFT), LCD_WF8B_BPFLCD7_SHIFT, LCD_WF8B_BPFLCD7_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPFLCD22[5] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase F
 * - 0b1 - LCD segment on or LCD backplane active for phase F
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPFLCD22 field. */
#define LCD_RD_WF8B_BPFLCD22(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPFLCD22_MASK) >> LCD_WF8B_BPFLCD22_SHIFT)
#define LCD_BRD_WF8B_BPFLCD22(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPFLCD22_SHIFT, LCD_WF8B_BPFLCD22_WIDTH))

/*! @brief Set the BPFLCD22 field to a new value. */
#define LCD_WR_WF8B_BPFLCD22(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPFLCD22_MASK, LCD_WF8B_BPFLCD22(value)))
#define LCD_BWR_WF8B_BPFLCD22(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPFLCD22_SHIFT), LCD_WF8B_BPFLCD22_SHIFT, LCD_WF8B_BPFLCD22_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPFLCD38[5] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase F
 * - 0b1 - LCD segment on or LCD backplane active for phase F
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPFLCD38 field. */
#define LCD_RD_WF8B_BPFLCD38(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPFLCD38_MASK) >> LCD_WF8B_BPFLCD38_SHIFT)
#define LCD_BRD_WF8B_BPFLCD38(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPFLCD38_SHIFT, LCD_WF8B_BPFLCD38_WIDTH))

/*! @brief Set the BPFLCD38 field to a new value. */
#define LCD_WR_WF8B_BPFLCD38(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPFLCD38_MASK, LCD_WF8B_BPFLCD38(value)))
#define LCD_BWR_WF8B_BPFLCD38(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPFLCD38_SHIFT), LCD_WF8B_BPFLCD38_SHIFT, LCD_WF8B_BPFLCD38_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPFLCD12[5] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase F
 * - 0b1 - LCD segment on or LCD backplane active for phase F
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPFLCD12 field. */
#define LCD_RD_WF8B_BPFLCD12(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPFLCD12_MASK) >> LCD_WF8B_BPFLCD12_SHIFT)
#define LCD_BRD_WF8B_BPFLCD12(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPFLCD12_SHIFT, LCD_WF8B_BPFLCD12_WIDTH))

/*! @brief Set the BPFLCD12 field to a new value. */
#define LCD_WR_WF8B_BPFLCD12(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPFLCD12_MASK, LCD_WF8B_BPFLCD12(value)))
#define LCD_BWR_WF8B_BPFLCD12(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPFLCD12_SHIFT), LCD_WF8B_BPFLCD12_SHIFT, LCD_WF8B_BPFLCD12_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPFLCD23[5] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase F
 * - 0b1 - LCD segment on or LCD backplane active for phase F
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPFLCD23 field. */
#define LCD_RD_WF8B_BPFLCD23(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPFLCD23_MASK) >> LCD_WF8B_BPFLCD23_SHIFT)
#define LCD_BRD_WF8B_BPFLCD23(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPFLCD23_SHIFT, LCD_WF8B_BPFLCD23_WIDTH))

/*! @brief Set the BPFLCD23 field to a new value. */
#define LCD_WR_WF8B_BPFLCD23(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPFLCD23_MASK, LCD_WF8B_BPFLCD23(value)))
#define LCD_BWR_WF8B_BPFLCD23(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPFLCD23_SHIFT), LCD_WF8B_BPFLCD23_SHIFT, LCD_WF8B_BPFLCD23_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPGLCD14[6] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase G
 * - 0b1 - LCD segment on or LCD backplane active for phase G
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPGLCD14 field. */
#define LCD_RD_WF8B_BPGLCD14(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPGLCD14_MASK) >> LCD_WF8B_BPGLCD14_SHIFT)
#define LCD_BRD_WF8B_BPGLCD14(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPGLCD14_SHIFT, LCD_WF8B_BPGLCD14_WIDTH))

/*! @brief Set the BPGLCD14 field to a new value. */
#define LCD_WR_WF8B_BPGLCD14(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPGLCD14_MASK, LCD_WF8B_BPGLCD14(value)))
#define LCD_BWR_WF8B_BPGLCD14(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPGLCD14_SHIFT), LCD_WF8B_BPGLCD14_SHIFT, LCD_WF8B_BPGLCD14_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPGLCD55[6] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase G
 * - 0b1 - LCD segment on or LCD backplane active for phase G
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPGLCD55 field. */
#define LCD_RD_WF8B_BPGLCD55(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPGLCD55_MASK) >> LCD_WF8B_BPGLCD55_SHIFT)
#define LCD_BRD_WF8B_BPGLCD55(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPGLCD55_SHIFT, LCD_WF8B_BPGLCD55_WIDTH))

/*! @brief Set the BPGLCD55 field to a new value. */
#define LCD_WR_WF8B_BPGLCD55(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPGLCD55_MASK, LCD_WF8B_BPGLCD55(value)))
#define LCD_BWR_WF8B_BPGLCD55(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPGLCD55_SHIFT), LCD_WF8B_BPGLCD55_SHIFT, LCD_WF8B_BPGLCD55_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPGLCD63[6] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase G
 * - 0b1 - LCD segment on or LCD backplane active for phase G
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPGLCD63 field. */
#define LCD_RD_WF8B_BPGLCD63(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPGLCD63_MASK) >> LCD_WF8B_BPGLCD63_SHIFT)
#define LCD_BRD_WF8B_BPGLCD63(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPGLCD63_SHIFT, LCD_WF8B_BPGLCD63_WIDTH))

/*! @brief Set the BPGLCD63 field to a new value. */
#define LCD_WR_WF8B_BPGLCD63(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPGLCD63_MASK, LCD_WF8B_BPGLCD63(value)))
#define LCD_BWR_WF8B_BPGLCD63(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPGLCD63_SHIFT), LCD_WF8B_BPGLCD63_SHIFT, LCD_WF8B_BPGLCD63_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPGLCD15[6] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase G
 * - 0b1 - LCD segment on or LCD backplane active for phase G
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPGLCD15 field. */
#define LCD_RD_WF8B_BPGLCD15(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPGLCD15_MASK) >> LCD_WF8B_BPGLCD15_SHIFT)
#define LCD_BRD_WF8B_BPGLCD15(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPGLCD15_SHIFT, LCD_WF8B_BPGLCD15_WIDTH))

/*! @brief Set the BPGLCD15 field to a new value. */
#define LCD_WR_WF8B_BPGLCD15(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPGLCD15_MASK, LCD_WF8B_BPGLCD15(value)))
#define LCD_BWR_WF8B_BPGLCD15(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPGLCD15_SHIFT), LCD_WF8B_BPGLCD15_SHIFT, LCD_WF8B_BPGLCD15_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPGLCD62[6] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase G
 * - 0b1 - LCD segment on or LCD backplane active for phase G
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPGLCD62 field. */
#define LCD_RD_WF8B_BPGLCD62(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPGLCD62_MASK) >> LCD_WF8B_BPGLCD62_SHIFT)
#define LCD_BRD_WF8B_BPGLCD62(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPGLCD62_SHIFT, LCD_WF8B_BPGLCD62_WIDTH))

/*! @brief Set the BPGLCD62 field to a new value. */
#define LCD_WR_WF8B_BPGLCD62(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPGLCD62_MASK, LCD_WF8B_BPGLCD62(value)))
#define LCD_BWR_WF8B_BPGLCD62(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPGLCD62_SHIFT), LCD_WF8B_BPGLCD62_SHIFT, LCD_WF8B_BPGLCD62_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPGLCD54[6] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase G
 * - 0b1 - LCD segment on or LCD backplane active for phase G
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPGLCD54 field. */
#define LCD_RD_WF8B_BPGLCD54(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPGLCD54_MASK) >> LCD_WF8B_BPGLCD54_SHIFT)
#define LCD_BRD_WF8B_BPGLCD54(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPGLCD54_SHIFT, LCD_WF8B_BPGLCD54_WIDTH))

/*! @brief Set the BPGLCD54 field to a new value. */
#define LCD_WR_WF8B_BPGLCD54(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPGLCD54_MASK, LCD_WF8B_BPGLCD54(value)))
#define LCD_BWR_WF8B_BPGLCD54(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPGLCD54_SHIFT), LCD_WF8B_BPGLCD54_SHIFT, LCD_WF8B_BPGLCD54_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPGLCD61[6] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase G
 * - 0b1 - LCD segment on or LCD backplane active for phase G
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPGLCD61 field. */
#define LCD_RD_WF8B_BPGLCD61(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPGLCD61_MASK) >> LCD_WF8B_BPGLCD61_SHIFT)
#define LCD_BRD_WF8B_BPGLCD61(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPGLCD61_SHIFT, LCD_WF8B_BPGLCD61_WIDTH))

/*! @brief Set the BPGLCD61 field to a new value. */
#define LCD_WR_WF8B_BPGLCD61(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPGLCD61_MASK, LCD_WF8B_BPGLCD61(value)))
#define LCD_BWR_WF8B_BPGLCD61(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPGLCD61_SHIFT), LCD_WF8B_BPGLCD61_SHIFT, LCD_WF8B_BPGLCD61_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPGLCD60[6] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase G
 * - 0b1 - LCD segment on or LCD backplane active for phase G
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPGLCD60 field. */
#define LCD_RD_WF8B_BPGLCD60(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPGLCD60_MASK) >> LCD_WF8B_BPGLCD60_SHIFT)
#define LCD_BRD_WF8B_BPGLCD60(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPGLCD60_SHIFT, LCD_WF8B_BPGLCD60_WIDTH))

/*! @brief Set the BPGLCD60 field to a new value. */
#define LCD_WR_WF8B_BPGLCD60(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPGLCD60_MASK, LCD_WF8B_BPGLCD60(value)))
#define LCD_BWR_WF8B_BPGLCD60(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPGLCD60_SHIFT), LCD_WF8B_BPGLCD60_SHIFT, LCD_WF8B_BPGLCD60_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPGLCD59[6] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase G
 * - 0b1 - LCD segment on or LCD backplane active for phase G
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPGLCD59 field. */
#define LCD_RD_WF8B_BPGLCD59(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPGLCD59_MASK) >> LCD_WF8B_BPGLCD59_SHIFT)
#define LCD_BRD_WF8B_BPGLCD59(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPGLCD59_SHIFT, LCD_WF8B_BPGLCD59_WIDTH))

/*! @brief Set the BPGLCD59 field to a new value. */
#define LCD_WR_WF8B_BPGLCD59(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPGLCD59_MASK, LCD_WF8B_BPGLCD59(value)))
#define LCD_BWR_WF8B_BPGLCD59(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPGLCD59_SHIFT), LCD_WF8B_BPGLCD59_SHIFT, LCD_WF8B_BPGLCD59_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPGLCD53[6] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase G
 * - 0b1 - LCD segment on or LCD backplane active for phase G
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPGLCD53 field. */
#define LCD_RD_WF8B_BPGLCD53(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPGLCD53_MASK) >> LCD_WF8B_BPGLCD53_SHIFT)
#define LCD_BRD_WF8B_BPGLCD53(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPGLCD53_SHIFT, LCD_WF8B_BPGLCD53_WIDTH))

/*! @brief Set the BPGLCD53 field to a new value. */
#define LCD_WR_WF8B_BPGLCD53(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPGLCD53_MASK, LCD_WF8B_BPGLCD53(value)))
#define LCD_BWR_WF8B_BPGLCD53(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPGLCD53_SHIFT), LCD_WF8B_BPGLCD53_SHIFT, LCD_WF8B_BPGLCD53_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPGLCD58[6] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase G
 * - 0b1 - LCD segment on or LCD backplane active for phase G
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPGLCD58 field. */
#define LCD_RD_WF8B_BPGLCD58(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPGLCD58_MASK) >> LCD_WF8B_BPGLCD58_SHIFT)
#define LCD_BRD_WF8B_BPGLCD58(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPGLCD58_SHIFT, LCD_WF8B_BPGLCD58_WIDTH))

/*! @brief Set the BPGLCD58 field to a new value. */
#define LCD_WR_WF8B_BPGLCD58(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPGLCD58_MASK, LCD_WF8B_BPGLCD58(value)))
#define LCD_BWR_WF8B_BPGLCD58(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPGLCD58_SHIFT), LCD_WF8B_BPGLCD58_SHIFT, LCD_WF8B_BPGLCD58_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPGLCD0[6] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase G
 * - 0b1 - LCD segment on or LCD backplane active for phase G
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPGLCD0 field. */
#define LCD_RD_WF8B_BPGLCD0(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPGLCD0_MASK) >> LCD_WF8B_BPGLCD0_SHIFT)
#define LCD_BRD_WF8B_BPGLCD0(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPGLCD0_SHIFT, LCD_WF8B_BPGLCD0_WIDTH))

/*! @brief Set the BPGLCD0 field to a new value. */
#define LCD_WR_WF8B_BPGLCD0(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPGLCD0_MASK, LCD_WF8B_BPGLCD0(value)))
#define LCD_BWR_WF8B_BPGLCD0(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPGLCD0_SHIFT), LCD_WF8B_BPGLCD0_SHIFT, LCD_WF8B_BPGLCD0_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPGLCD57[6] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase G
 * - 0b1 - LCD segment on or LCD backplane active for phase G
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPGLCD57 field. */
#define LCD_RD_WF8B_BPGLCD57(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPGLCD57_MASK) >> LCD_WF8B_BPGLCD57_SHIFT)
#define LCD_BRD_WF8B_BPGLCD57(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPGLCD57_SHIFT, LCD_WF8B_BPGLCD57_WIDTH))

/*! @brief Set the BPGLCD57 field to a new value. */
#define LCD_WR_WF8B_BPGLCD57(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPGLCD57_MASK, LCD_WF8B_BPGLCD57(value)))
#define LCD_BWR_WF8B_BPGLCD57(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPGLCD57_SHIFT), LCD_WF8B_BPGLCD57_SHIFT, LCD_WF8B_BPGLCD57_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPGLCD52[6] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase G
 * - 0b1 - LCD segment on or LCD backplane active for phase G
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPGLCD52 field. */
#define LCD_RD_WF8B_BPGLCD52(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPGLCD52_MASK) >> LCD_WF8B_BPGLCD52_SHIFT)
#define LCD_BRD_WF8B_BPGLCD52(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPGLCD52_SHIFT, LCD_WF8B_BPGLCD52_WIDTH))

/*! @brief Set the BPGLCD52 field to a new value. */
#define LCD_WR_WF8B_BPGLCD52(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPGLCD52_MASK, LCD_WF8B_BPGLCD52(value)))
#define LCD_BWR_WF8B_BPGLCD52(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPGLCD52_SHIFT), LCD_WF8B_BPGLCD52_SHIFT, LCD_WF8B_BPGLCD52_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPGLCD7[6] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase G
 * - 0b1 - LCD segment on or LCD backplane active for phase G
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPGLCD7 field. */
#define LCD_RD_WF8B_BPGLCD7(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPGLCD7_MASK) >> LCD_WF8B_BPGLCD7_SHIFT)
#define LCD_BRD_WF8B_BPGLCD7(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPGLCD7_SHIFT, LCD_WF8B_BPGLCD7_WIDTH))

/*! @brief Set the BPGLCD7 field to a new value. */
#define LCD_WR_WF8B_BPGLCD7(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPGLCD7_MASK, LCD_WF8B_BPGLCD7(value)))
#define LCD_BWR_WF8B_BPGLCD7(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPGLCD7_SHIFT), LCD_WF8B_BPGLCD7_SHIFT, LCD_WF8B_BPGLCD7_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPGLCD56[6] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase G
 * - 0b1 - LCD segment on or LCD backplane active for phase G
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPGLCD56 field. */
#define LCD_RD_WF8B_BPGLCD56(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPGLCD56_MASK) >> LCD_WF8B_BPGLCD56_SHIFT)
#define LCD_BRD_WF8B_BPGLCD56(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPGLCD56_SHIFT, LCD_WF8B_BPGLCD56_WIDTH))

/*! @brief Set the BPGLCD56 field to a new value. */
#define LCD_WR_WF8B_BPGLCD56(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPGLCD56_MASK, LCD_WF8B_BPGLCD56(value)))
#define LCD_BWR_WF8B_BPGLCD56(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPGLCD56_SHIFT), LCD_WF8B_BPGLCD56_SHIFT, LCD_WF8B_BPGLCD56_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPGLCD6[6] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase G
 * - 0b1 - LCD segment on or LCD backplane active for phase G
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPGLCD6 field. */
#define LCD_RD_WF8B_BPGLCD6(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPGLCD6_MASK) >> LCD_WF8B_BPGLCD6_SHIFT)
#define LCD_BRD_WF8B_BPGLCD6(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPGLCD6_SHIFT, LCD_WF8B_BPGLCD6_WIDTH))

/*! @brief Set the BPGLCD6 field to a new value. */
#define LCD_WR_WF8B_BPGLCD6(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPGLCD6_MASK, LCD_WF8B_BPGLCD6(value)))
#define LCD_BWR_WF8B_BPGLCD6(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPGLCD6_SHIFT), LCD_WF8B_BPGLCD6_SHIFT, LCD_WF8B_BPGLCD6_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPGLCD51[6] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase G
 * - 0b1 - LCD segment on or LCD backplane active for phase G
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPGLCD51 field. */
#define LCD_RD_WF8B_BPGLCD51(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPGLCD51_MASK) >> LCD_WF8B_BPGLCD51_SHIFT)
#define LCD_BRD_WF8B_BPGLCD51(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPGLCD51_SHIFT, LCD_WF8B_BPGLCD51_WIDTH))

/*! @brief Set the BPGLCD51 field to a new value. */
#define LCD_WR_WF8B_BPGLCD51(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPGLCD51_MASK, LCD_WF8B_BPGLCD51(value)))
#define LCD_BWR_WF8B_BPGLCD51(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPGLCD51_SHIFT), LCD_WF8B_BPGLCD51_SHIFT, LCD_WF8B_BPGLCD51_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPGLCD16[6] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase G
 * - 0b1 - LCD segment on or LCD backplane active for phase G
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPGLCD16 field. */
#define LCD_RD_WF8B_BPGLCD16(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPGLCD16_MASK) >> LCD_WF8B_BPGLCD16_SHIFT)
#define LCD_BRD_WF8B_BPGLCD16(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPGLCD16_SHIFT, LCD_WF8B_BPGLCD16_WIDTH))

/*! @brief Set the BPGLCD16 field to a new value. */
#define LCD_WR_WF8B_BPGLCD16(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPGLCD16_MASK, LCD_WF8B_BPGLCD16(value)))
#define LCD_BWR_WF8B_BPGLCD16(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPGLCD16_SHIFT), LCD_WF8B_BPGLCD16_SHIFT, LCD_WF8B_BPGLCD16_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPGLCD1[6] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase G
 * - 0b1 - LCD segment on or LCD backplane active for phase G
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPGLCD1 field. */
#define LCD_RD_WF8B_BPGLCD1(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPGLCD1_MASK) >> LCD_WF8B_BPGLCD1_SHIFT)
#define LCD_BRD_WF8B_BPGLCD1(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPGLCD1_SHIFT, LCD_WF8B_BPGLCD1_WIDTH))

/*! @brief Set the BPGLCD1 field to a new value. */
#define LCD_WR_WF8B_BPGLCD1(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPGLCD1_MASK, LCD_WF8B_BPGLCD1(value)))
#define LCD_BWR_WF8B_BPGLCD1(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPGLCD1_SHIFT), LCD_WF8B_BPGLCD1_SHIFT, LCD_WF8B_BPGLCD1_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPGLCD17[6] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase G
 * - 0b1 - LCD segment on or LCD backplane active for phase G
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPGLCD17 field. */
#define LCD_RD_WF8B_BPGLCD17(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPGLCD17_MASK) >> LCD_WF8B_BPGLCD17_SHIFT)
#define LCD_BRD_WF8B_BPGLCD17(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPGLCD17_SHIFT, LCD_WF8B_BPGLCD17_WIDTH))

/*! @brief Set the BPGLCD17 field to a new value. */
#define LCD_WR_WF8B_BPGLCD17(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPGLCD17_MASK, LCD_WF8B_BPGLCD17(value)))
#define LCD_BWR_WF8B_BPGLCD17(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPGLCD17_SHIFT), LCD_WF8B_BPGLCD17_SHIFT, LCD_WF8B_BPGLCD17_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPGLCD50[6] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase G
 * - 0b1 - LCD segment on or LCD backplane active for phase G
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPGLCD50 field. */
#define LCD_RD_WF8B_BPGLCD50(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPGLCD50_MASK) >> LCD_WF8B_BPGLCD50_SHIFT)
#define LCD_BRD_WF8B_BPGLCD50(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPGLCD50_SHIFT, LCD_WF8B_BPGLCD50_WIDTH))

/*! @brief Set the BPGLCD50 field to a new value. */
#define LCD_WR_WF8B_BPGLCD50(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPGLCD50_MASK, LCD_WF8B_BPGLCD50(value)))
#define LCD_BWR_WF8B_BPGLCD50(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPGLCD50_SHIFT), LCD_WF8B_BPGLCD50_SHIFT, LCD_WF8B_BPGLCD50_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPGLCD18[6] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase G
 * - 0b1 - LCD segment on or LCD backplane active for phase G
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPGLCD18 field. */
#define LCD_RD_WF8B_BPGLCD18(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPGLCD18_MASK) >> LCD_WF8B_BPGLCD18_SHIFT)
#define LCD_BRD_WF8B_BPGLCD18(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPGLCD18_SHIFT, LCD_WF8B_BPGLCD18_WIDTH))

/*! @brief Set the BPGLCD18 field to a new value. */
#define LCD_WR_WF8B_BPGLCD18(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPGLCD18_MASK, LCD_WF8B_BPGLCD18(value)))
#define LCD_BWR_WF8B_BPGLCD18(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPGLCD18_SHIFT), LCD_WF8B_BPGLCD18_SHIFT, LCD_WF8B_BPGLCD18_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPGLCD19[6] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase G
 * - 0b1 - LCD segment on or LCD backplane active for phase G
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPGLCD19 field. */
#define LCD_RD_WF8B_BPGLCD19(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPGLCD19_MASK) >> LCD_WF8B_BPGLCD19_SHIFT)
#define LCD_BRD_WF8B_BPGLCD19(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPGLCD19_SHIFT, LCD_WF8B_BPGLCD19_WIDTH))

/*! @brief Set the BPGLCD19 field to a new value. */
#define LCD_WR_WF8B_BPGLCD19(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPGLCD19_MASK, LCD_WF8B_BPGLCD19(value)))
#define LCD_BWR_WF8B_BPGLCD19(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPGLCD19_SHIFT), LCD_WF8B_BPGLCD19_SHIFT, LCD_WF8B_BPGLCD19_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPGLCD8[6] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase G
 * - 0b1 - LCD segment on or LCD backplane active for phase G
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPGLCD8 field. */
#define LCD_RD_WF8B_BPGLCD8(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPGLCD8_MASK) >> LCD_WF8B_BPGLCD8_SHIFT)
#define LCD_BRD_WF8B_BPGLCD8(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPGLCD8_SHIFT, LCD_WF8B_BPGLCD8_WIDTH))

/*! @brief Set the BPGLCD8 field to a new value. */
#define LCD_WR_WF8B_BPGLCD8(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPGLCD8_MASK, LCD_WF8B_BPGLCD8(value)))
#define LCD_BWR_WF8B_BPGLCD8(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPGLCD8_SHIFT), LCD_WF8B_BPGLCD8_SHIFT, LCD_WF8B_BPGLCD8_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPGLCD49[6] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase G
 * - 0b1 - LCD segment on or LCD backplane active for phase G
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPGLCD49 field. */
#define LCD_RD_WF8B_BPGLCD49(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPGLCD49_MASK) >> LCD_WF8B_BPGLCD49_SHIFT)
#define LCD_BRD_WF8B_BPGLCD49(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPGLCD49_SHIFT, LCD_WF8B_BPGLCD49_WIDTH))

/*! @brief Set the BPGLCD49 field to a new value. */
#define LCD_WR_WF8B_BPGLCD49(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPGLCD49_MASK, LCD_WF8B_BPGLCD49(value)))
#define LCD_BWR_WF8B_BPGLCD49(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPGLCD49_SHIFT), LCD_WF8B_BPGLCD49_SHIFT, LCD_WF8B_BPGLCD49_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPGLCD20[6] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase G
 * - 0b1 - LCD segment on or LCD backplane active for phase G
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPGLCD20 field. */
#define LCD_RD_WF8B_BPGLCD20(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPGLCD20_MASK) >> LCD_WF8B_BPGLCD20_SHIFT)
#define LCD_BRD_WF8B_BPGLCD20(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPGLCD20_SHIFT, LCD_WF8B_BPGLCD20_WIDTH))

/*! @brief Set the BPGLCD20 field to a new value. */
#define LCD_WR_WF8B_BPGLCD20(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPGLCD20_MASK, LCD_WF8B_BPGLCD20(value)))
#define LCD_BWR_WF8B_BPGLCD20(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPGLCD20_SHIFT), LCD_WF8B_BPGLCD20_SHIFT, LCD_WF8B_BPGLCD20_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPGLCD9[6] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase G
 * - 0b1 - LCD segment on or LCD backplane active for phase G
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPGLCD9 field. */
#define LCD_RD_WF8B_BPGLCD9(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPGLCD9_MASK) >> LCD_WF8B_BPGLCD9_SHIFT)
#define LCD_BRD_WF8B_BPGLCD9(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPGLCD9_SHIFT, LCD_WF8B_BPGLCD9_WIDTH))

/*! @brief Set the BPGLCD9 field to a new value. */
#define LCD_WR_WF8B_BPGLCD9(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPGLCD9_MASK, LCD_WF8B_BPGLCD9(value)))
#define LCD_BWR_WF8B_BPGLCD9(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPGLCD9_SHIFT), LCD_WF8B_BPGLCD9_SHIFT, LCD_WF8B_BPGLCD9_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPGLCD21[6] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase G
 * - 0b1 - LCD segment on or LCD backplane active for phase G
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPGLCD21 field. */
#define LCD_RD_WF8B_BPGLCD21(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPGLCD21_MASK) >> LCD_WF8B_BPGLCD21_SHIFT)
#define LCD_BRD_WF8B_BPGLCD21(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPGLCD21_SHIFT, LCD_WF8B_BPGLCD21_WIDTH))

/*! @brief Set the BPGLCD21 field to a new value. */
#define LCD_WR_WF8B_BPGLCD21(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPGLCD21_MASK, LCD_WF8B_BPGLCD21(value)))
#define LCD_BWR_WF8B_BPGLCD21(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPGLCD21_SHIFT), LCD_WF8B_BPGLCD21_SHIFT, LCD_WF8B_BPGLCD21_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPGLCD13[6] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase G
 * - 0b1 - LCD segment on or LCD backplane active for phase G
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPGLCD13 field. */
#define LCD_RD_WF8B_BPGLCD13(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPGLCD13_MASK) >> LCD_WF8B_BPGLCD13_SHIFT)
#define LCD_BRD_WF8B_BPGLCD13(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPGLCD13_SHIFT, LCD_WF8B_BPGLCD13_WIDTH))

/*! @brief Set the BPGLCD13 field to a new value. */
#define LCD_WR_WF8B_BPGLCD13(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPGLCD13_MASK, LCD_WF8B_BPGLCD13(value)))
#define LCD_BWR_WF8B_BPGLCD13(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPGLCD13_SHIFT), LCD_WF8B_BPGLCD13_SHIFT, LCD_WF8B_BPGLCD13_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPGLCD48[6] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase G
 * - 0b1 - LCD segment on or LCD backplane active for phase G
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPGLCD48 field. */
#define LCD_RD_WF8B_BPGLCD48(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPGLCD48_MASK) >> LCD_WF8B_BPGLCD48_SHIFT)
#define LCD_BRD_WF8B_BPGLCD48(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPGLCD48_SHIFT, LCD_WF8B_BPGLCD48_WIDTH))

/*! @brief Set the BPGLCD48 field to a new value. */
#define LCD_WR_WF8B_BPGLCD48(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPGLCD48_MASK, LCD_WF8B_BPGLCD48(value)))
#define LCD_BWR_WF8B_BPGLCD48(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPGLCD48_SHIFT), LCD_WF8B_BPGLCD48_SHIFT, LCD_WF8B_BPGLCD48_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPGLCD22[6] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase G
 * - 0b1 - LCD segment on or LCD backplane active for phase G
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPGLCD22 field. */
#define LCD_RD_WF8B_BPGLCD22(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPGLCD22_MASK) >> LCD_WF8B_BPGLCD22_SHIFT)
#define LCD_BRD_WF8B_BPGLCD22(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPGLCD22_SHIFT, LCD_WF8B_BPGLCD22_WIDTH))

/*! @brief Set the BPGLCD22 field to a new value. */
#define LCD_WR_WF8B_BPGLCD22(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPGLCD22_MASK, LCD_WF8B_BPGLCD22(value)))
#define LCD_BWR_WF8B_BPGLCD22(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPGLCD22_SHIFT), LCD_WF8B_BPGLCD22_SHIFT, LCD_WF8B_BPGLCD22_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPGLCD5[6] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase G
 * - 0b1 - LCD segment on or LCD backplane active for phase G
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPGLCD5 field. */
#define LCD_RD_WF8B_BPGLCD5(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPGLCD5_MASK) >> LCD_WF8B_BPGLCD5_SHIFT)
#define LCD_BRD_WF8B_BPGLCD5(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPGLCD5_SHIFT, LCD_WF8B_BPGLCD5_WIDTH))

/*! @brief Set the BPGLCD5 field to a new value. */
#define LCD_WR_WF8B_BPGLCD5(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPGLCD5_MASK, LCD_WF8B_BPGLCD5(value)))
#define LCD_BWR_WF8B_BPGLCD5(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPGLCD5_SHIFT), LCD_WF8B_BPGLCD5_SHIFT, LCD_WF8B_BPGLCD5_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPGLCD47[6] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase G
 * - 0b1 - LCD segment on or LCD backplane active for phase G
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPGLCD47 field. */
#define LCD_RD_WF8B_BPGLCD47(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPGLCD47_MASK) >> LCD_WF8B_BPGLCD47_SHIFT)
#define LCD_BRD_WF8B_BPGLCD47(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPGLCD47_SHIFT, LCD_WF8B_BPGLCD47_WIDTH))

/*! @brief Set the BPGLCD47 field to a new value. */
#define LCD_WR_WF8B_BPGLCD47(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPGLCD47_MASK, LCD_WF8B_BPGLCD47(value)))
#define LCD_BWR_WF8B_BPGLCD47(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPGLCD47_SHIFT), LCD_WF8B_BPGLCD47_SHIFT, LCD_WF8B_BPGLCD47_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPGLCD23[6] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase G
 * - 0b1 - LCD segment on or LCD backplane active for phase G
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPGLCD23 field. */
#define LCD_RD_WF8B_BPGLCD23(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPGLCD23_MASK) >> LCD_WF8B_BPGLCD23_SHIFT)
#define LCD_BRD_WF8B_BPGLCD23(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPGLCD23_SHIFT, LCD_WF8B_BPGLCD23_WIDTH))

/*! @brief Set the BPGLCD23 field to a new value. */
#define LCD_WR_WF8B_BPGLCD23(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPGLCD23_MASK, LCD_WF8B_BPGLCD23(value)))
#define LCD_BWR_WF8B_BPGLCD23(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPGLCD23_SHIFT), LCD_WF8B_BPGLCD23_SHIFT, LCD_WF8B_BPGLCD23_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPGLCD24[6] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase G
 * - 0b1 - LCD segment on or LCD backplane active for phase G
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPGLCD24 field. */
#define LCD_RD_WF8B_BPGLCD24(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPGLCD24_MASK) >> LCD_WF8B_BPGLCD24_SHIFT)
#define LCD_BRD_WF8B_BPGLCD24(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPGLCD24_SHIFT, LCD_WF8B_BPGLCD24_WIDTH))

/*! @brief Set the BPGLCD24 field to a new value. */
#define LCD_WR_WF8B_BPGLCD24(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPGLCD24_MASK, LCD_WF8B_BPGLCD24(value)))
#define LCD_BWR_WF8B_BPGLCD24(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPGLCD24_SHIFT), LCD_WF8B_BPGLCD24_SHIFT, LCD_WF8B_BPGLCD24_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPGLCD25[6] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase G
 * - 0b1 - LCD segment on or LCD backplane active for phase G
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPGLCD25 field. */
#define LCD_RD_WF8B_BPGLCD25(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPGLCD25_MASK) >> LCD_WF8B_BPGLCD25_SHIFT)
#define LCD_BRD_WF8B_BPGLCD25(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPGLCD25_SHIFT, LCD_WF8B_BPGLCD25_WIDTH))

/*! @brief Set the BPGLCD25 field to a new value. */
#define LCD_WR_WF8B_BPGLCD25(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPGLCD25_MASK, LCD_WF8B_BPGLCD25(value)))
#define LCD_BWR_WF8B_BPGLCD25(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPGLCD25_SHIFT), LCD_WF8B_BPGLCD25_SHIFT, LCD_WF8B_BPGLCD25_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPGLCD46[6] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase G
 * - 0b1 - LCD segment on or LCD backplane active for phase G
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPGLCD46 field. */
#define LCD_RD_WF8B_BPGLCD46(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPGLCD46_MASK) >> LCD_WF8B_BPGLCD46_SHIFT)
#define LCD_BRD_WF8B_BPGLCD46(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPGLCD46_SHIFT, LCD_WF8B_BPGLCD46_WIDTH))

/*! @brief Set the BPGLCD46 field to a new value. */
#define LCD_WR_WF8B_BPGLCD46(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPGLCD46_MASK, LCD_WF8B_BPGLCD46(value)))
#define LCD_BWR_WF8B_BPGLCD46(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPGLCD46_SHIFT), LCD_WF8B_BPGLCD46_SHIFT, LCD_WF8B_BPGLCD46_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPGLCD26[6] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase G
 * - 0b1 - LCD segment on or LCD backplane active for phase G
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPGLCD26 field. */
#define LCD_RD_WF8B_BPGLCD26(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPGLCD26_MASK) >> LCD_WF8B_BPGLCD26_SHIFT)
#define LCD_BRD_WF8B_BPGLCD26(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPGLCD26_SHIFT, LCD_WF8B_BPGLCD26_WIDTH))

/*! @brief Set the BPGLCD26 field to a new value. */
#define LCD_WR_WF8B_BPGLCD26(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPGLCD26_MASK, LCD_WF8B_BPGLCD26(value)))
#define LCD_BWR_WF8B_BPGLCD26(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPGLCD26_SHIFT), LCD_WF8B_BPGLCD26_SHIFT, LCD_WF8B_BPGLCD26_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPGLCD27[6] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase G
 * - 0b1 - LCD segment on or LCD backplane active for phase G
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPGLCD27 field. */
#define LCD_RD_WF8B_BPGLCD27(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPGLCD27_MASK) >> LCD_WF8B_BPGLCD27_SHIFT)
#define LCD_BRD_WF8B_BPGLCD27(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPGLCD27_SHIFT, LCD_WF8B_BPGLCD27_WIDTH))

/*! @brief Set the BPGLCD27 field to a new value. */
#define LCD_WR_WF8B_BPGLCD27(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPGLCD27_MASK, LCD_WF8B_BPGLCD27(value)))
#define LCD_BWR_WF8B_BPGLCD27(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPGLCD27_SHIFT), LCD_WF8B_BPGLCD27_SHIFT, LCD_WF8B_BPGLCD27_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPGLCD10[6] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase G
 * - 0b1 - LCD segment on or LCD backplane active for phase G
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPGLCD10 field. */
#define LCD_RD_WF8B_BPGLCD10(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPGLCD10_MASK) >> LCD_WF8B_BPGLCD10_SHIFT)
#define LCD_BRD_WF8B_BPGLCD10(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPGLCD10_SHIFT, LCD_WF8B_BPGLCD10_WIDTH))

/*! @brief Set the BPGLCD10 field to a new value. */
#define LCD_WR_WF8B_BPGLCD10(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPGLCD10_MASK, LCD_WF8B_BPGLCD10(value)))
#define LCD_BWR_WF8B_BPGLCD10(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPGLCD10_SHIFT), LCD_WF8B_BPGLCD10_SHIFT, LCD_WF8B_BPGLCD10_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPGLCD45[6] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase G
 * - 0b1 - LCD segment on or LCD backplane active for phase G
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPGLCD45 field. */
#define LCD_RD_WF8B_BPGLCD45(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPGLCD45_MASK) >> LCD_WF8B_BPGLCD45_SHIFT)
#define LCD_BRD_WF8B_BPGLCD45(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPGLCD45_SHIFT, LCD_WF8B_BPGLCD45_WIDTH))

/*! @brief Set the BPGLCD45 field to a new value. */
#define LCD_WR_WF8B_BPGLCD45(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPGLCD45_MASK, LCD_WF8B_BPGLCD45(value)))
#define LCD_BWR_WF8B_BPGLCD45(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPGLCD45_SHIFT), LCD_WF8B_BPGLCD45_SHIFT, LCD_WF8B_BPGLCD45_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPGLCD28[6] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase G
 * - 0b1 - LCD segment on or LCD backplane active for phase G
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPGLCD28 field. */
#define LCD_RD_WF8B_BPGLCD28(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPGLCD28_MASK) >> LCD_WF8B_BPGLCD28_SHIFT)
#define LCD_BRD_WF8B_BPGLCD28(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPGLCD28_SHIFT, LCD_WF8B_BPGLCD28_WIDTH))

/*! @brief Set the BPGLCD28 field to a new value. */
#define LCD_WR_WF8B_BPGLCD28(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPGLCD28_MASK, LCD_WF8B_BPGLCD28(value)))
#define LCD_BWR_WF8B_BPGLCD28(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPGLCD28_SHIFT), LCD_WF8B_BPGLCD28_SHIFT, LCD_WF8B_BPGLCD28_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPGLCD29[6] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase G
 * - 0b1 - LCD segment on or LCD backplane active for phase G
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPGLCD29 field. */
#define LCD_RD_WF8B_BPGLCD29(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPGLCD29_MASK) >> LCD_WF8B_BPGLCD29_SHIFT)
#define LCD_BRD_WF8B_BPGLCD29(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPGLCD29_SHIFT, LCD_WF8B_BPGLCD29_WIDTH))

/*! @brief Set the BPGLCD29 field to a new value. */
#define LCD_WR_WF8B_BPGLCD29(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPGLCD29_MASK, LCD_WF8B_BPGLCD29(value)))
#define LCD_BWR_WF8B_BPGLCD29(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPGLCD29_SHIFT), LCD_WF8B_BPGLCD29_SHIFT, LCD_WF8B_BPGLCD29_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPGLCD4[6] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase G
 * - 0b1 - LCD segment on or LCD backplane active for phase G
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPGLCD4 field. */
#define LCD_RD_WF8B_BPGLCD4(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPGLCD4_MASK) >> LCD_WF8B_BPGLCD4_SHIFT)
#define LCD_BRD_WF8B_BPGLCD4(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPGLCD4_SHIFT, LCD_WF8B_BPGLCD4_WIDTH))

/*! @brief Set the BPGLCD4 field to a new value. */
#define LCD_WR_WF8B_BPGLCD4(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPGLCD4_MASK, LCD_WF8B_BPGLCD4(value)))
#define LCD_BWR_WF8B_BPGLCD4(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPGLCD4_SHIFT), LCD_WF8B_BPGLCD4_SHIFT, LCD_WF8B_BPGLCD4_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPGLCD44[6] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase G
 * - 0b1 - LCD segment on or LCD backplane active for phase G
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPGLCD44 field. */
#define LCD_RD_WF8B_BPGLCD44(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPGLCD44_MASK) >> LCD_WF8B_BPGLCD44_SHIFT)
#define LCD_BRD_WF8B_BPGLCD44(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPGLCD44_SHIFT, LCD_WF8B_BPGLCD44_WIDTH))

/*! @brief Set the BPGLCD44 field to a new value. */
#define LCD_WR_WF8B_BPGLCD44(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPGLCD44_MASK, LCD_WF8B_BPGLCD44(value)))
#define LCD_BWR_WF8B_BPGLCD44(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPGLCD44_SHIFT), LCD_WF8B_BPGLCD44_SHIFT, LCD_WF8B_BPGLCD44_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPGLCD30[6] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase G
 * - 0b1 - LCD segment on or LCD backplane active for phase G
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPGLCD30 field. */
#define LCD_RD_WF8B_BPGLCD30(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPGLCD30_MASK) >> LCD_WF8B_BPGLCD30_SHIFT)
#define LCD_BRD_WF8B_BPGLCD30(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPGLCD30_SHIFT, LCD_WF8B_BPGLCD30_WIDTH))

/*! @brief Set the BPGLCD30 field to a new value. */
#define LCD_WR_WF8B_BPGLCD30(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPGLCD30_MASK, LCD_WF8B_BPGLCD30(value)))
#define LCD_BWR_WF8B_BPGLCD30(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPGLCD30_SHIFT), LCD_WF8B_BPGLCD30_SHIFT, LCD_WF8B_BPGLCD30_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPGLCD2[6] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase G
 * - 0b1 - LCD segment on or LCD backplane active for phase G
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPGLCD2 field. */
#define LCD_RD_WF8B_BPGLCD2(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPGLCD2_MASK) >> LCD_WF8B_BPGLCD2_SHIFT)
#define LCD_BRD_WF8B_BPGLCD2(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPGLCD2_SHIFT, LCD_WF8B_BPGLCD2_WIDTH))

/*! @brief Set the BPGLCD2 field to a new value. */
#define LCD_WR_WF8B_BPGLCD2(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPGLCD2_MASK, LCD_WF8B_BPGLCD2(value)))
#define LCD_BWR_WF8B_BPGLCD2(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPGLCD2_SHIFT), LCD_WF8B_BPGLCD2_SHIFT, LCD_WF8B_BPGLCD2_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPGLCD31[6] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase G
 * - 0b1 - LCD segment on or LCD backplane active for phase G
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPGLCD31 field. */
#define LCD_RD_WF8B_BPGLCD31(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPGLCD31_MASK) >> LCD_WF8B_BPGLCD31_SHIFT)
#define LCD_BRD_WF8B_BPGLCD31(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPGLCD31_SHIFT, LCD_WF8B_BPGLCD31_WIDTH))

/*! @brief Set the BPGLCD31 field to a new value. */
#define LCD_WR_WF8B_BPGLCD31(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPGLCD31_MASK, LCD_WF8B_BPGLCD31(value)))
#define LCD_BWR_WF8B_BPGLCD31(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPGLCD31_SHIFT), LCD_WF8B_BPGLCD31_SHIFT, LCD_WF8B_BPGLCD31_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPGLCD43[6] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase G
 * - 0b1 - LCD segment on or LCD backplane active for phase G
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPGLCD43 field. */
#define LCD_RD_WF8B_BPGLCD43(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPGLCD43_MASK) >> LCD_WF8B_BPGLCD43_SHIFT)
#define LCD_BRD_WF8B_BPGLCD43(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPGLCD43_SHIFT, LCD_WF8B_BPGLCD43_WIDTH))

/*! @brief Set the BPGLCD43 field to a new value. */
#define LCD_WR_WF8B_BPGLCD43(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPGLCD43_MASK, LCD_WF8B_BPGLCD43(value)))
#define LCD_BWR_WF8B_BPGLCD43(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPGLCD43_SHIFT), LCD_WF8B_BPGLCD43_SHIFT, LCD_WF8B_BPGLCD43_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPGLCD32[6] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase G
 * - 0b1 - LCD segment on or LCD backplane active for phase G
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPGLCD32 field. */
#define LCD_RD_WF8B_BPGLCD32(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPGLCD32_MASK) >> LCD_WF8B_BPGLCD32_SHIFT)
#define LCD_BRD_WF8B_BPGLCD32(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPGLCD32_SHIFT, LCD_WF8B_BPGLCD32_WIDTH))

/*! @brief Set the BPGLCD32 field to a new value. */
#define LCD_WR_WF8B_BPGLCD32(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPGLCD32_MASK, LCD_WF8B_BPGLCD32(value)))
#define LCD_BWR_WF8B_BPGLCD32(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPGLCD32_SHIFT), LCD_WF8B_BPGLCD32_SHIFT, LCD_WF8B_BPGLCD32_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPGLCD33[6] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase G
 * - 0b1 - LCD segment on or LCD backplane active for phase G
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPGLCD33 field. */
#define LCD_RD_WF8B_BPGLCD33(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPGLCD33_MASK) >> LCD_WF8B_BPGLCD33_SHIFT)
#define LCD_BRD_WF8B_BPGLCD33(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPGLCD33_SHIFT, LCD_WF8B_BPGLCD33_WIDTH))

/*! @brief Set the BPGLCD33 field to a new value. */
#define LCD_WR_WF8B_BPGLCD33(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPGLCD33_MASK, LCD_WF8B_BPGLCD33(value)))
#define LCD_BWR_WF8B_BPGLCD33(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPGLCD33_SHIFT), LCD_WF8B_BPGLCD33_SHIFT, LCD_WF8B_BPGLCD33_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPGLCD42[6] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase G
 * - 0b1 - LCD segment on or LCD backplane active for phase G
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPGLCD42 field. */
#define LCD_RD_WF8B_BPGLCD42(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPGLCD42_MASK) >> LCD_WF8B_BPGLCD42_SHIFT)
#define LCD_BRD_WF8B_BPGLCD42(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPGLCD42_SHIFT, LCD_WF8B_BPGLCD42_WIDTH))

/*! @brief Set the BPGLCD42 field to a new value. */
#define LCD_WR_WF8B_BPGLCD42(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPGLCD42_MASK, LCD_WF8B_BPGLCD42(value)))
#define LCD_BWR_WF8B_BPGLCD42(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPGLCD42_SHIFT), LCD_WF8B_BPGLCD42_SHIFT, LCD_WF8B_BPGLCD42_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPGLCD34[6] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase G
 * - 0b1 - LCD segment on or LCD backplane active for phase G
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPGLCD34 field. */
#define LCD_RD_WF8B_BPGLCD34(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPGLCD34_MASK) >> LCD_WF8B_BPGLCD34_SHIFT)
#define LCD_BRD_WF8B_BPGLCD34(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPGLCD34_SHIFT, LCD_WF8B_BPGLCD34_WIDTH))

/*! @brief Set the BPGLCD34 field to a new value. */
#define LCD_WR_WF8B_BPGLCD34(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPGLCD34_MASK, LCD_WF8B_BPGLCD34(value)))
#define LCD_BWR_WF8B_BPGLCD34(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPGLCD34_SHIFT), LCD_WF8B_BPGLCD34_SHIFT, LCD_WF8B_BPGLCD34_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPGLCD11[6] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase G
 * - 0b1 - LCD segment on or LCD backplane active for phase G
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPGLCD11 field. */
#define LCD_RD_WF8B_BPGLCD11(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPGLCD11_MASK) >> LCD_WF8B_BPGLCD11_SHIFT)
#define LCD_BRD_WF8B_BPGLCD11(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPGLCD11_SHIFT, LCD_WF8B_BPGLCD11_WIDTH))

/*! @brief Set the BPGLCD11 field to a new value. */
#define LCD_WR_WF8B_BPGLCD11(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPGLCD11_MASK, LCD_WF8B_BPGLCD11(value)))
#define LCD_BWR_WF8B_BPGLCD11(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPGLCD11_SHIFT), LCD_WF8B_BPGLCD11_SHIFT, LCD_WF8B_BPGLCD11_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPGLCD35[6] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase G
 * - 0b1 - LCD segment on or LCD backplane active for phase G
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPGLCD35 field. */
#define LCD_RD_WF8B_BPGLCD35(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPGLCD35_MASK) >> LCD_WF8B_BPGLCD35_SHIFT)
#define LCD_BRD_WF8B_BPGLCD35(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPGLCD35_SHIFT, LCD_WF8B_BPGLCD35_WIDTH))

/*! @brief Set the BPGLCD35 field to a new value. */
#define LCD_WR_WF8B_BPGLCD35(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPGLCD35_MASK, LCD_WF8B_BPGLCD35(value)))
#define LCD_BWR_WF8B_BPGLCD35(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPGLCD35_SHIFT), LCD_WF8B_BPGLCD35_SHIFT, LCD_WF8B_BPGLCD35_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPGLCD12[6] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase G
 * - 0b1 - LCD segment on or LCD backplane active for phase G
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPGLCD12 field. */
#define LCD_RD_WF8B_BPGLCD12(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPGLCD12_MASK) >> LCD_WF8B_BPGLCD12_SHIFT)
#define LCD_BRD_WF8B_BPGLCD12(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPGLCD12_SHIFT, LCD_WF8B_BPGLCD12_WIDTH))

/*! @brief Set the BPGLCD12 field to a new value. */
#define LCD_WR_WF8B_BPGLCD12(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPGLCD12_MASK, LCD_WF8B_BPGLCD12(value)))
#define LCD_BWR_WF8B_BPGLCD12(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPGLCD12_SHIFT), LCD_WF8B_BPGLCD12_SHIFT, LCD_WF8B_BPGLCD12_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPGLCD41[6] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase G
 * - 0b1 - LCD segment on or LCD backplane active for phase G
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPGLCD41 field. */
#define LCD_RD_WF8B_BPGLCD41(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPGLCD41_MASK) >> LCD_WF8B_BPGLCD41_SHIFT)
#define LCD_BRD_WF8B_BPGLCD41(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPGLCD41_SHIFT, LCD_WF8B_BPGLCD41_WIDTH))

/*! @brief Set the BPGLCD41 field to a new value. */
#define LCD_WR_WF8B_BPGLCD41(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPGLCD41_MASK, LCD_WF8B_BPGLCD41(value)))
#define LCD_BWR_WF8B_BPGLCD41(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPGLCD41_SHIFT), LCD_WF8B_BPGLCD41_SHIFT, LCD_WF8B_BPGLCD41_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPGLCD36[6] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase G
 * - 0b1 - LCD segment on or LCD backplane active for phase G
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPGLCD36 field. */
#define LCD_RD_WF8B_BPGLCD36(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPGLCD36_MASK) >> LCD_WF8B_BPGLCD36_SHIFT)
#define LCD_BRD_WF8B_BPGLCD36(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPGLCD36_SHIFT, LCD_WF8B_BPGLCD36_WIDTH))

/*! @brief Set the BPGLCD36 field to a new value. */
#define LCD_WR_WF8B_BPGLCD36(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPGLCD36_MASK, LCD_WF8B_BPGLCD36(value)))
#define LCD_BWR_WF8B_BPGLCD36(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPGLCD36_SHIFT), LCD_WF8B_BPGLCD36_SHIFT, LCD_WF8B_BPGLCD36_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPGLCD3[6] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase G
 * - 0b1 - LCD segment on or LCD backplane active for phase G
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPGLCD3 field. */
#define LCD_RD_WF8B_BPGLCD3(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPGLCD3_MASK) >> LCD_WF8B_BPGLCD3_SHIFT)
#define LCD_BRD_WF8B_BPGLCD3(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPGLCD3_SHIFT, LCD_WF8B_BPGLCD3_WIDTH))

/*! @brief Set the BPGLCD3 field to a new value. */
#define LCD_WR_WF8B_BPGLCD3(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPGLCD3_MASK, LCD_WF8B_BPGLCD3(value)))
#define LCD_BWR_WF8B_BPGLCD3(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPGLCD3_SHIFT), LCD_WF8B_BPGLCD3_SHIFT, LCD_WF8B_BPGLCD3_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPGLCD37[6] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase G
 * - 0b1 - LCD segment on or LCD backplane active for phase G
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPGLCD37 field. */
#define LCD_RD_WF8B_BPGLCD37(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPGLCD37_MASK) >> LCD_WF8B_BPGLCD37_SHIFT)
#define LCD_BRD_WF8B_BPGLCD37(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPGLCD37_SHIFT, LCD_WF8B_BPGLCD37_WIDTH))

/*! @brief Set the BPGLCD37 field to a new value. */
#define LCD_WR_WF8B_BPGLCD37(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPGLCD37_MASK, LCD_WF8B_BPGLCD37(value)))
#define LCD_BWR_WF8B_BPGLCD37(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPGLCD37_SHIFT), LCD_WF8B_BPGLCD37_SHIFT, LCD_WF8B_BPGLCD37_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPGLCD40[6] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase G
 * - 0b1 - LCD segment on or LCD backplane active for phase G
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPGLCD40 field. */
#define LCD_RD_WF8B_BPGLCD40(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPGLCD40_MASK) >> LCD_WF8B_BPGLCD40_SHIFT)
#define LCD_BRD_WF8B_BPGLCD40(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPGLCD40_SHIFT, LCD_WF8B_BPGLCD40_WIDTH))

/*! @brief Set the BPGLCD40 field to a new value. */
#define LCD_WR_WF8B_BPGLCD40(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPGLCD40_MASK, LCD_WF8B_BPGLCD40(value)))
#define LCD_BWR_WF8B_BPGLCD40(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPGLCD40_SHIFT), LCD_WF8B_BPGLCD40_SHIFT, LCD_WF8B_BPGLCD40_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPGLCD38[6] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase G
 * - 0b1 - LCD segment on or LCD backplane active for phase G
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPGLCD38 field. */
#define LCD_RD_WF8B_BPGLCD38(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPGLCD38_MASK) >> LCD_WF8B_BPGLCD38_SHIFT)
#define LCD_BRD_WF8B_BPGLCD38(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPGLCD38_SHIFT, LCD_WF8B_BPGLCD38_WIDTH))

/*! @brief Set the BPGLCD38 field to a new value. */
#define LCD_WR_WF8B_BPGLCD38(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPGLCD38_MASK, LCD_WF8B_BPGLCD38(value)))
#define LCD_BWR_WF8B_BPGLCD38(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPGLCD38_SHIFT), LCD_WF8B_BPGLCD38_SHIFT, LCD_WF8B_BPGLCD38_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPGLCD39[6] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase G
 * - 0b1 - LCD segment on or LCD backplane active for phase G
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPGLCD39 field. */
#define LCD_RD_WF8B_BPGLCD39(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPGLCD39_MASK) >> LCD_WF8B_BPGLCD39_SHIFT)
#define LCD_BRD_WF8B_BPGLCD39(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPGLCD39_SHIFT, LCD_WF8B_BPGLCD39_WIDTH))

/*! @brief Set the BPGLCD39 field to a new value. */
#define LCD_WR_WF8B_BPGLCD39(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPGLCD39_MASK, LCD_WF8B_BPGLCD39(value)))
#define LCD_BWR_WF8B_BPGLCD39(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPGLCD39_SHIFT), LCD_WF8B_BPGLCD39_SHIFT, LCD_WF8B_BPGLCD39_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPHLCD63[7] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase H
 * - 0b1 - LCD segment on or LCD backplane active for phase H
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPHLCD63 field. */
#define LCD_RD_WF8B_BPHLCD63(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPHLCD63_MASK) >> LCD_WF8B_BPHLCD63_SHIFT)
#define LCD_BRD_WF8B_BPHLCD63(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPHLCD63_SHIFT, LCD_WF8B_BPHLCD63_WIDTH))

/*! @brief Set the BPHLCD63 field to a new value. */
#define LCD_WR_WF8B_BPHLCD63(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPHLCD63_MASK, LCD_WF8B_BPHLCD63(value)))
#define LCD_BWR_WF8B_BPHLCD63(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPHLCD63_SHIFT), LCD_WF8B_BPHLCD63_SHIFT, LCD_WF8B_BPHLCD63_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPHLCD62[7] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase H
 * - 0b1 - LCD segment on or LCD backplane active for phase H
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPHLCD62 field. */
#define LCD_RD_WF8B_BPHLCD62(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPHLCD62_MASK) >> LCD_WF8B_BPHLCD62_SHIFT)
#define LCD_BRD_WF8B_BPHLCD62(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPHLCD62_SHIFT, LCD_WF8B_BPHLCD62_WIDTH))

/*! @brief Set the BPHLCD62 field to a new value. */
#define LCD_WR_WF8B_BPHLCD62(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPHLCD62_MASK, LCD_WF8B_BPHLCD62(value)))
#define LCD_BWR_WF8B_BPHLCD62(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPHLCD62_SHIFT), LCD_WF8B_BPHLCD62_SHIFT, LCD_WF8B_BPHLCD62_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPHLCD61[7] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase H
 * - 0b1 - LCD segment on or LCD backplane active for phase H
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPHLCD61 field. */
#define LCD_RD_WF8B_BPHLCD61(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPHLCD61_MASK) >> LCD_WF8B_BPHLCD61_SHIFT)
#define LCD_BRD_WF8B_BPHLCD61(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPHLCD61_SHIFT, LCD_WF8B_BPHLCD61_WIDTH))

/*! @brief Set the BPHLCD61 field to a new value. */
#define LCD_WR_WF8B_BPHLCD61(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPHLCD61_MASK, LCD_WF8B_BPHLCD61(value)))
#define LCD_BWR_WF8B_BPHLCD61(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPHLCD61_SHIFT), LCD_WF8B_BPHLCD61_SHIFT, LCD_WF8B_BPHLCD61_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPHLCD60[7] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase H
 * - 0b1 - LCD segment on or LCD backplane active for phase H
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPHLCD60 field. */
#define LCD_RD_WF8B_BPHLCD60(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPHLCD60_MASK) >> LCD_WF8B_BPHLCD60_SHIFT)
#define LCD_BRD_WF8B_BPHLCD60(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPHLCD60_SHIFT, LCD_WF8B_BPHLCD60_WIDTH))

/*! @brief Set the BPHLCD60 field to a new value. */
#define LCD_WR_WF8B_BPHLCD60(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPHLCD60_MASK, LCD_WF8B_BPHLCD60(value)))
#define LCD_BWR_WF8B_BPHLCD60(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPHLCD60_SHIFT), LCD_WF8B_BPHLCD60_SHIFT, LCD_WF8B_BPHLCD60_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPHLCD59[7] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase H
 * - 0b1 - LCD segment on or LCD backplane active for phase H
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPHLCD59 field. */
#define LCD_RD_WF8B_BPHLCD59(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPHLCD59_MASK) >> LCD_WF8B_BPHLCD59_SHIFT)
#define LCD_BRD_WF8B_BPHLCD59(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPHLCD59_SHIFT, LCD_WF8B_BPHLCD59_WIDTH))

/*! @brief Set the BPHLCD59 field to a new value. */
#define LCD_WR_WF8B_BPHLCD59(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPHLCD59_MASK, LCD_WF8B_BPHLCD59(value)))
#define LCD_BWR_WF8B_BPHLCD59(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPHLCD59_SHIFT), LCD_WF8B_BPHLCD59_SHIFT, LCD_WF8B_BPHLCD59_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPHLCD58[7] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase H
 * - 0b1 - LCD segment on or LCD backplane active for phase H
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPHLCD58 field. */
#define LCD_RD_WF8B_BPHLCD58(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPHLCD58_MASK) >> LCD_WF8B_BPHLCD58_SHIFT)
#define LCD_BRD_WF8B_BPHLCD58(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPHLCD58_SHIFT, LCD_WF8B_BPHLCD58_WIDTH))

/*! @brief Set the BPHLCD58 field to a new value. */
#define LCD_WR_WF8B_BPHLCD58(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPHLCD58_MASK, LCD_WF8B_BPHLCD58(value)))
#define LCD_BWR_WF8B_BPHLCD58(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPHLCD58_SHIFT), LCD_WF8B_BPHLCD58_SHIFT, LCD_WF8B_BPHLCD58_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPHLCD57[7] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase H
 * - 0b1 - LCD segment on or LCD backplane active for phase H
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPHLCD57 field. */
#define LCD_RD_WF8B_BPHLCD57(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPHLCD57_MASK) >> LCD_WF8B_BPHLCD57_SHIFT)
#define LCD_BRD_WF8B_BPHLCD57(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPHLCD57_SHIFT, LCD_WF8B_BPHLCD57_WIDTH))

/*! @brief Set the BPHLCD57 field to a new value. */
#define LCD_WR_WF8B_BPHLCD57(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPHLCD57_MASK, LCD_WF8B_BPHLCD57(value)))
#define LCD_BWR_WF8B_BPHLCD57(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPHLCD57_SHIFT), LCD_WF8B_BPHLCD57_SHIFT, LCD_WF8B_BPHLCD57_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPHLCD0[7] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase H
 * - 0b1 - LCD segment on or LCD backplane active for phase H
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPHLCD0 field. */
#define LCD_RD_WF8B_BPHLCD0(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPHLCD0_MASK) >> LCD_WF8B_BPHLCD0_SHIFT)
#define LCD_BRD_WF8B_BPHLCD0(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPHLCD0_SHIFT, LCD_WF8B_BPHLCD0_WIDTH))

/*! @brief Set the BPHLCD0 field to a new value. */
#define LCD_WR_WF8B_BPHLCD0(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPHLCD0_MASK, LCD_WF8B_BPHLCD0(value)))
#define LCD_BWR_WF8B_BPHLCD0(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPHLCD0_SHIFT), LCD_WF8B_BPHLCD0_SHIFT, LCD_WF8B_BPHLCD0_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPHLCD56[7] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase H
 * - 0b1 - LCD segment on or LCD backplane active for phase H
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPHLCD56 field. */
#define LCD_RD_WF8B_BPHLCD56(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPHLCD56_MASK) >> LCD_WF8B_BPHLCD56_SHIFT)
#define LCD_BRD_WF8B_BPHLCD56(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPHLCD56_SHIFT, LCD_WF8B_BPHLCD56_WIDTH))

/*! @brief Set the BPHLCD56 field to a new value. */
#define LCD_WR_WF8B_BPHLCD56(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPHLCD56_MASK, LCD_WF8B_BPHLCD56(value)))
#define LCD_BWR_WF8B_BPHLCD56(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPHLCD56_SHIFT), LCD_WF8B_BPHLCD56_SHIFT, LCD_WF8B_BPHLCD56_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPHLCD55[7] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase H
 * - 0b1 - LCD segment on or LCD backplane active for phase H
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPHLCD55 field. */
#define LCD_RD_WF8B_BPHLCD55(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPHLCD55_MASK) >> LCD_WF8B_BPHLCD55_SHIFT)
#define LCD_BRD_WF8B_BPHLCD55(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPHLCD55_SHIFT, LCD_WF8B_BPHLCD55_WIDTH))

/*! @brief Set the BPHLCD55 field to a new value. */
#define LCD_WR_WF8B_BPHLCD55(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPHLCD55_MASK, LCD_WF8B_BPHLCD55(value)))
#define LCD_BWR_WF8B_BPHLCD55(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPHLCD55_SHIFT), LCD_WF8B_BPHLCD55_SHIFT, LCD_WF8B_BPHLCD55_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPHLCD54[7] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase H
 * - 0b1 - LCD segment on or LCD backplane active for phase H
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPHLCD54 field. */
#define LCD_RD_WF8B_BPHLCD54(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPHLCD54_MASK) >> LCD_WF8B_BPHLCD54_SHIFT)
#define LCD_BRD_WF8B_BPHLCD54(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPHLCD54_SHIFT, LCD_WF8B_BPHLCD54_WIDTH))

/*! @brief Set the BPHLCD54 field to a new value. */
#define LCD_WR_WF8B_BPHLCD54(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPHLCD54_MASK, LCD_WF8B_BPHLCD54(value)))
#define LCD_BWR_WF8B_BPHLCD54(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPHLCD54_SHIFT), LCD_WF8B_BPHLCD54_SHIFT, LCD_WF8B_BPHLCD54_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPHLCD53[7] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase H
 * - 0b1 - LCD segment on or LCD backplane active for phase H
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPHLCD53 field. */
#define LCD_RD_WF8B_BPHLCD53(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPHLCD53_MASK) >> LCD_WF8B_BPHLCD53_SHIFT)
#define LCD_BRD_WF8B_BPHLCD53(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPHLCD53_SHIFT, LCD_WF8B_BPHLCD53_WIDTH))

/*! @brief Set the BPHLCD53 field to a new value. */
#define LCD_WR_WF8B_BPHLCD53(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPHLCD53_MASK, LCD_WF8B_BPHLCD53(value)))
#define LCD_BWR_WF8B_BPHLCD53(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPHLCD53_SHIFT), LCD_WF8B_BPHLCD53_SHIFT, LCD_WF8B_BPHLCD53_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPHLCD52[7] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase H
 * - 0b1 - LCD segment on or LCD backplane active for phase H
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPHLCD52 field. */
#define LCD_RD_WF8B_BPHLCD52(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPHLCD52_MASK) >> LCD_WF8B_BPHLCD52_SHIFT)
#define LCD_BRD_WF8B_BPHLCD52(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPHLCD52_SHIFT, LCD_WF8B_BPHLCD52_WIDTH))

/*! @brief Set the BPHLCD52 field to a new value. */
#define LCD_WR_WF8B_BPHLCD52(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPHLCD52_MASK, LCD_WF8B_BPHLCD52(value)))
#define LCD_BWR_WF8B_BPHLCD52(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPHLCD52_SHIFT), LCD_WF8B_BPHLCD52_SHIFT, LCD_WF8B_BPHLCD52_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPHLCD51[7] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase H
 * - 0b1 - LCD segment on or LCD backplane active for phase H
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPHLCD51 field. */
#define LCD_RD_WF8B_BPHLCD51(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPHLCD51_MASK) >> LCD_WF8B_BPHLCD51_SHIFT)
#define LCD_BRD_WF8B_BPHLCD51(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPHLCD51_SHIFT, LCD_WF8B_BPHLCD51_WIDTH))

/*! @brief Set the BPHLCD51 field to a new value. */
#define LCD_WR_WF8B_BPHLCD51(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPHLCD51_MASK, LCD_WF8B_BPHLCD51(value)))
#define LCD_BWR_WF8B_BPHLCD51(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPHLCD51_SHIFT), LCD_WF8B_BPHLCD51_SHIFT, LCD_WF8B_BPHLCD51_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPHLCD50[7] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase H
 * - 0b1 - LCD segment on or LCD backplane active for phase H
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPHLCD50 field. */
#define LCD_RD_WF8B_BPHLCD50(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPHLCD50_MASK) >> LCD_WF8B_BPHLCD50_SHIFT)
#define LCD_BRD_WF8B_BPHLCD50(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPHLCD50_SHIFT, LCD_WF8B_BPHLCD50_WIDTH))

/*! @brief Set the BPHLCD50 field to a new value. */
#define LCD_WR_WF8B_BPHLCD50(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPHLCD50_MASK, LCD_WF8B_BPHLCD50(value)))
#define LCD_BWR_WF8B_BPHLCD50(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPHLCD50_SHIFT), LCD_WF8B_BPHLCD50_SHIFT, LCD_WF8B_BPHLCD50_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPHLCD1[7] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase H
 * - 0b1 - LCD segment on or LCD backplane active for phase H
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPHLCD1 field. */
#define LCD_RD_WF8B_BPHLCD1(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPHLCD1_MASK) >> LCD_WF8B_BPHLCD1_SHIFT)
#define LCD_BRD_WF8B_BPHLCD1(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPHLCD1_SHIFT, LCD_WF8B_BPHLCD1_WIDTH))

/*! @brief Set the BPHLCD1 field to a new value. */
#define LCD_WR_WF8B_BPHLCD1(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPHLCD1_MASK, LCD_WF8B_BPHLCD1(value)))
#define LCD_BWR_WF8B_BPHLCD1(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPHLCD1_SHIFT), LCD_WF8B_BPHLCD1_SHIFT, LCD_WF8B_BPHLCD1_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPHLCD49[7] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase H
 * - 0b1 - LCD segment on or LCD backplane active for phase H
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPHLCD49 field. */
#define LCD_RD_WF8B_BPHLCD49(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPHLCD49_MASK) >> LCD_WF8B_BPHLCD49_SHIFT)
#define LCD_BRD_WF8B_BPHLCD49(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPHLCD49_SHIFT, LCD_WF8B_BPHLCD49_WIDTH))

/*! @brief Set the BPHLCD49 field to a new value. */
#define LCD_WR_WF8B_BPHLCD49(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPHLCD49_MASK, LCD_WF8B_BPHLCD49(value)))
#define LCD_BWR_WF8B_BPHLCD49(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPHLCD49_SHIFT), LCD_WF8B_BPHLCD49_SHIFT, LCD_WF8B_BPHLCD49_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPHLCD48[7] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase H
 * - 0b1 - LCD segment on or LCD backplane active for phase H
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPHLCD48 field. */
#define LCD_RD_WF8B_BPHLCD48(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPHLCD48_MASK) >> LCD_WF8B_BPHLCD48_SHIFT)
#define LCD_BRD_WF8B_BPHLCD48(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPHLCD48_SHIFT, LCD_WF8B_BPHLCD48_WIDTH))

/*! @brief Set the BPHLCD48 field to a new value. */
#define LCD_WR_WF8B_BPHLCD48(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPHLCD48_MASK, LCD_WF8B_BPHLCD48(value)))
#define LCD_BWR_WF8B_BPHLCD48(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPHLCD48_SHIFT), LCD_WF8B_BPHLCD48_SHIFT, LCD_WF8B_BPHLCD48_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPHLCD47[7] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase H
 * - 0b1 - LCD segment on or LCD backplane active for phase H
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPHLCD47 field. */
#define LCD_RD_WF8B_BPHLCD47(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPHLCD47_MASK) >> LCD_WF8B_BPHLCD47_SHIFT)
#define LCD_BRD_WF8B_BPHLCD47(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPHLCD47_SHIFT, LCD_WF8B_BPHLCD47_WIDTH))

/*! @brief Set the BPHLCD47 field to a new value. */
#define LCD_WR_WF8B_BPHLCD47(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPHLCD47_MASK, LCD_WF8B_BPHLCD47(value)))
#define LCD_BWR_WF8B_BPHLCD47(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPHLCD47_SHIFT), LCD_WF8B_BPHLCD47_SHIFT, LCD_WF8B_BPHLCD47_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPHLCD46[7] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase H
 * - 0b1 - LCD segment on or LCD backplane active for phase H
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPHLCD46 field. */
#define LCD_RD_WF8B_BPHLCD46(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPHLCD46_MASK) >> LCD_WF8B_BPHLCD46_SHIFT)
#define LCD_BRD_WF8B_BPHLCD46(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPHLCD46_SHIFT, LCD_WF8B_BPHLCD46_WIDTH))

/*! @brief Set the BPHLCD46 field to a new value. */
#define LCD_WR_WF8B_BPHLCD46(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPHLCD46_MASK, LCD_WF8B_BPHLCD46(value)))
#define LCD_BWR_WF8B_BPHLCD46(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPHLCD46_SHIFT), LCD_WF8B_BPHLCD46_SHIFT, LCD_WF8B_BPHLCD46_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPHLCD45[7] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase H
 * - 0b1 - LCD segment on or LCD backplane active for phase H
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPHLCD45 field. */
#define LCD_RD_WF8B_BPHLCD45(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPHLCD45_MASK) >> LCD_WF8B_BPHLCD45_SHIFT)
#define LCD_BRD_WF8B_BPHLCD45(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPHLCD45_SHIFT, LCD_WF8B_BPHLCD45_WIDTH))

/*! @brief Set the BPHLCD45 field to a new value. */
#define LCD_WR_WF8B_BPHLCD45(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPHLCD45_MASK, LCD_WF8B_BPHLCD45(value)))
#define LCD_BWR_WF8B_BPHLCD45(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPHLCD45_SHIFT), LCD_WF8B_BPHLCD45_SHIFT, LCD_WF8B_BPHLCD45_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPHLCD44[7] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase H
 * - 0b1 - LCD segment on or LCD backplane active for phase H
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPHLCD44 field. */
#define LCD_RD_WF8B_BPHLCD44(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPHLCD44_MASK) >> LCD_WF8B_BPHLCD44_SHIFT)
#define LCD_BRD_WF8B_BPHLCD44(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPHLCD44_SHIFT, LCD_WF8B_BPHLCD44_WIDTH))

/*! @brief Set the BPHLCD44 field to a new value. */
#define LCD_WR_WF8B_BPHLCD44(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPHLCD44_MASK, LCD_WF8B_BPHLCD44(value)))
#define LCD_BWR_WF8B_BPHLCD44(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPHLCD44_SHIFT), LCD_WF8B_BPHLCD44_SHIFT, LCD_WF8B_BPHLCD44_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPHLCD43[7] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase H
 * - 0b1 - LCD segment on or LCD backplane active for phase H
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPHLCD43 field. */
#define LCD_RD_WF8B_BPHLCD43(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPHLCD43_MASK) >> LCD_WF8B_BPHLCD43_SHIFT)
#define LCD_BRD_WF8B_BPHLCD43(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPHLCD43_SHIFT, LCD_WF8B_BPHLCD43_WIDTH))

/*! @brief Set the BPHLCD43 field to a new value. */
#define LCD_WR_WF8B_BPHLCD43(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPHLCD43_MASK, LCD_WF8B_BPHLCD43(value)))
#define LCD_BWR_WF8B_BPHLCD43(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPHLCD43_SHIFT), LCD_WF8B_BPHLCD43_SHIFT, LCD_WF8B_BPHLCD43_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPHLCD2[7] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase H
 * - 0b1 - LCD segment on or LCD backplane active for phase H
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPHLCD2 field. */
#define LCD_RD_WF8B_BPHLCD2(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPHLCD2_MASK) >> LCD_WF8B_BPHLCD2_SHIFT)
#define LCD_BRD_WF8B_BPHLCD2(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPHLCD2_SHIFT, LCD_WF8B_BPHLCD2_WIDTH))

/*! @brief Set the BPHLCD2 field to a new value. */
#define LCD_WR_WF8B_BPHLCD2(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPHLCD2_MASK, LCD_WF8B_BPHLCD2(value)))
#define LCD_BWR_WF8B_BPHLCD2(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPHLCD2_SHIFT), LCD_WF8B_BPHLCD2_SHIFT, LCD_WF8B_BPHLCD2_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPHLCD42[7] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase H
 * - 0b1 - LCD segment on or LCD backplane active for phase H
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPHLCD42 field. */
#define LCD_RD_WF8B_BPHLCD42(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPHLCD42_MASK) >> LCD_WF8B_BPHLCD42_SHIFT)
#define LCD_BRD_WF8B_BPHLCD42(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPHLCD42_SHIFT, LCD_WF8B_BPHLCD42_WIDTH))

/*! @brief Set the BPHLCD42 field to a new value. */
#define LCD_WR_WF8B_BPHLCD42(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPHLCD42_MASK, LCD_WF8B_BPHLCD42(value)))
#define LCD_BWR_WF8B_BPHLCD42(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPHLCD42_SHIFT), LCD_WF8B_BPHLCD42_SHIFT, LCD_WF8B_BPHLCD42_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPHLCD41[7] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase H
 * - 0b1 - LCD segment on or LCD backplane active for phase H
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPHLCD41 field. */
#define LCD_RD_WF8B_BPHLCD41(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPHLCD41_MASK) >> LCD_WF8B_BPHLCD41_SHIFT)
#define LCD_BRD_WF8B_BPHLCD41(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPHLCD41_SHIFT, LCD_WF8B_BPHLCD41_WIDTH))

/*! @brief Set the BPHLCD41 field to a new value. */
#define LCD_WR_WF8B_BPHLCD41(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPHLCD41_MASK, LCD_WF8B_BPHLCD41(value)))
#define LCD_BWR_WF8B_BPHLCD41(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPHLCD41_SHIFT), LCD_WF8B_BPHLCD41_SHIFT, LCD_WF8B_BPHLCD41_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPHLCD40[7] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase H
 * - 0b1 - LCD segment on or LCD backplane active for phase H
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPHLCD40 field. */
#define LCD_RD_WF8B_BPHLCD40(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPHLCD40_MASK) >> LCD_WF8B_BPHLCD40_SHIFT)
#define LCD_BRD_WF8B_BPHLCD40(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPHLCD40_SHIFT, LCD_WF8B_BPHLCD40_WIDTH))

/*! @brief Set the BPHLCD40 field to a new value. */
#define LCD_WR_WF8B_BPHLCD40(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPHLCD40_MASK, LCD_WF8B_BPHLCD40(value)))
#define LCD_BWR_WF8B_BPHLCD40(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPHLCD40_SHIFT), LCD_WF8B_BPHLCD40_SHIFT, LCD_WF8B_BPHLCD40_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPHLCD39[7] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase H
 * - 0b1 - LCD segment on or LCD backplane active for phase H
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPHLCD39 field. */
#define LCD_RD_WF8B_BPHLCD39(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPHLCD39_MASK) >> LCD_WF8B_BPHLCD39_SHIFT)
#define LCD_BRD_WF8B_BPHLCD39(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPHLCD39_SHIFT, LCD_WF8B_BPHLCD39_WIDTH))

/*! @brief Set the BPHLCD39 field to a new value. */
#define LCD_WR_WF8B_BPHLCD39(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPHLCD39_MASK, LCD_WF8B_BPHLCD39(value)))
#define LCD_BWR_WF8B_BPHLCD39(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPHLCD39_SHIFT), LCD_WF8B_BPHLCD39_SHIFT, LCD_WF8B_BPHLCD39_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPHLCD38[7] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase H
 * - 0b1 - LCD segment on or LCD backplane active for phase H
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPHLCD38 field. */
#define LCD_RD_WF8B_BPHLCD38(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPHLCD38_MASK) >> LCD_WF8B_BPHLCD38_SHIFT)
#define LCD_BRD_WF8B_BPHLCD38(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPHLCD38_SHIFT, LCD_WF8B_BPHLCD38_WIDTH))

/*! @brief Set the BPHLCD38 field to a new value. */
#define LCD_WR_WF8B_BPHLCD38(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPHLCD38_MASK, LCD_WF8B_BPHLCD38(value)))
#define LCD_BWR_WF8B_BPHLCD38(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPHLCD38_SHIFT), LCD_WF8B_BPHLCD38_SHIFT, LCD_WF8B_BPHLCD38_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPHLCD37[7] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase H
 * - 0b1 - LCD segment on or LCD backplane active for phase H
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPHLCD37 field. */
#define LCD_RD_WF8B_BPHLCD37(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPHLCD37_MASK) >> LCD_WF8B_BPHLCD37_SHIFT)
#define LCD_BRD_WF8B_BPHLCD37(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPHLCD37_SHIFT, LCD_WF8B_BPHLCD37_WIDTH))

/*! @brief Set the BPHLCD37 field to a new value. */
#define LCD_WR_WF8B_BPHLCD37(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPHLCD37_MASK, LCD_WF8B_BPHLCD37(value)))
#define LCD_BWR_WF8B_BPHLCD37(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPHLCD37_SHIFT), LCD_WF8B_BPHLCD37_SHIFT, LCD_WF8B_BPHLCD37_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPHLCD36[7] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase H
 * - 0b1 - LCD segment on or LCD backplane active for phase H
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPHLCD36 field. */
#define LCD_RD_WF8B_BPHLCD36(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPHLCD36_MASK) >> LCD_WF8B_BPHLCD36_SHIFT)
#define LCD_BRD_WF8B_BPHLCD36(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPHLCD36_SHIFT, LCD_WF8B_BPHLCD36_WIDTH))

/*! @brief Set the BPHLCD36 field to a new value. */
#define LCD_WR_WF8B_BPHLCD36(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPHLCD36_MASK, LCD_WF8B_BPHLCD36(value)))
#define LCD_BWR_WF8B_BPHLCD36(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPHLCD36_SHIFT), LCD_WF8B_BPHLCD36_SHIFT, LCD_WF8B_BPHLCD36_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPHLCD3[7] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase H
 * - 0b1 - LCD segment on or LCD backplane active for phase H
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPHLCD3 field. */
#define LCD_RD_WF8B_BPHLCD3(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPHLCD3_MASK) >> LCD_WF8B_BPHLCD3_SHIFT)
#define LCD_BRD_WF8B_BPHLCD3(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPHLCD3_SHIFT, LCD_WF8B_BPHLCD3_WIDTH))

/*! @brief Set the BPHLCD3 field to a new value. */
#define LCD_WR_WF8B_BPHLCD3(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPHLCD3_MASK, LCD_WF8B_BPHLCD3(value)))
#define LCD_BWR_WF8B_BPHLCD3(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPHLCD3_SHIFT), LCD_WF8B_BPHLCD3_SHIFT, LCD_WF8B_BPHLCD3_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPHLCD35[7] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase H
 * - 0b1 - LCD segment on or LCD backplane active for phase H
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPHLCD35 field. */
#define LCD_RD_WF8B_BPHLCD35(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPHLCD35_MASK) >> LCD_WF8B_BPHLCD35_SHIFT)
#define LCD_BRD_WF8B_BPHLCD35(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPHLCD35_SHIFT, LCD_WF8B_BPHLCD35_WIDTH))

/*! @brief Set the BPHLCD35 field to a new value. */
#define LCD_WR_WF8B_BPHLCD35(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPHLCD35_MASK, LCD_WF8B_BPHLCD35(value)))
#define LCD_BWR_WF8B_BPHLCD35(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPHLCD35_SHIFT), LCD_WF8B_BPHLCD35_SHIFT, LCD_WF8B_BPHLCD35_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPHLCD34[7] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase H
 * - 0b1 - LCD segment on or LCD backplane active for phase H
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPHLCD34 field. */
#define LCD_RD_WF8B_BPHLCD34(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPHLCD34_MASK) >> LCD_WF8B_BPHLCD34_SHIFT)
#define LCD_BRD_WF8B_BPHLCD34(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPHLCD34_SHIFT, LCD_WF8B_BPHLCD34_WIDTH))

/*! @brief Set the BPHLCD34 field to a new value. */
#define LCD_WR_WF8B_BPHLCD34(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPHLCD34_MASK, LCD_WF8B_BPHLCD34(value)))
#define LCD_BWR_WF8B_BPHLCD34(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPHLCD34_SHIFT), LCD_WF8B_BPHLCD34_SHIFT, LCD_WF8B_BPHLCD34_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPHLCD33[7] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase H
 * - 0b1 - LCD segment on or LCD backplane active for phase H
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPHLCD33 field. */
#define LCD_RD_WF8B_BPHLCD33(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPHLCD33_MASK) >> LCD_WF8B_BPHLCD33_SHIFT)
#define LCD_BRD_WF8B_BPHLCD33(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPHLCD33_SHIFT, LCD_WF8B_BPHLCD33_WIDTH))

/*! @brief Set the BPHLCD33 field to a new value. */
#define LCD_WR_WF8B_BPHLCD33(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPHLCD33_MASK, LCD_WF8B_BPHLCD33(value)))
#define LCD_BWR_WF8B_BPHLCD33(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPHLCD33_SHIFT), LCD_WF8B_BPHLCD33_SHIFT, LCD_WF8B_BPHLCD33_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPHLCD32[7] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase H
 * - 0b1 - LCD segment on or LCD backplane active for phase H
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPHLCD32 field. */
#define LCD_RD_WF8B_BPHLCD32(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPHLCD32_MASK) >> LCD_WF8B_BPHLCD32_SHIFT)
#define LCD_BRD_WF8B_BPHLCD32(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPHLCD32_SHIFT, LCD_WF8B_BPHLCD32_WIDTH))

/*! @brief Set the BPHLCD32 field to a new value. */
#define LCD_WR_WF8B_BPHLCD32(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPHLCD32_MASK, LCD_WF8B_BPHLCD32(value)))
#define LCD_BWR_WF8B_BPHLCD32(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPHLCD32_SHIFT), LCD_WF8B_BPHLCD32_SHIFT, LCD_WF8B_BPHLCD32_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPHLCD31[7] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase H
 * - 0b1 - LCD segment on or LCD backplane active for phase H
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPHLCD31 field. */
#define LCD_RD_WF8B_BPHLCD31(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPHLCD31_MASK) >> LCD_WF8B_BPHLCD31_SHIFT)
#define LCD_BRD_WF8B_BPHLCD31(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPHLCD31_SHIFT, LCD_WF8B_BPHLCD31_WIDTH))

/*! @brief Set the BPHLCD31 field to a new value. */
#define LCD_WR_WF8B_BPHLCD31(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPHLCD31_MASK, LCD_WF8B_BPHLCD31(value)))
#define LCD_BWR_WF8B_BPHLCD31(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPHLCD31_SHIFT), LCD_WF8B_BPHLCD31_SHIFT, LCD_WF8B_BPHLCD31_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPHLCD30[7] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase H
 * - 0b1 - LCD segment on or LCD backplane active for phase H
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPHLCD30 field. */
#define LCD_RD_WF8B_BPHLCD30(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPHLCD30_MASK) >> LCD_WF8B_BPHLCD30_SHIFT)
#define LCD_BRD_WF8B_BPHLCD30(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPHLCD30_SHIFT, LCD_WF8B_BPHLCD30_WIDTH))

/*! @brief Set the BPHLCD30 field to a new value. */
#define LCD_WR_WF8B_BPHLCD30(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPHLCD30_MASK, LCD_WF8B_BPHLCD30(value)))
#define LCD_BWR_WF8B_BPHLCD30(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPHLCD30_SHIFT), LCD_WF8B_BPHLCD30_SHIFT, LCD_WF8B_BPHLCD30_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPHLCD29[7] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase H
 * - 0b1 - LCD segment on or LCD backplane active for phase H
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPHLCD29 field. */
#define LCD_RD_WF8B_BPHLCD29(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPHLCD29_MASK) >> LCD_WF8B_BPHLCD29_SHIFT)
#define LCD_BRD_WF8B_BPHLCD29(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPHLCD29_SHIFT, LCD_WF8B_BPHLCD29_WIDTH))

/*! @brief Set the BPHLCD29 field to a new value. */
#define LCD_WR_WF8B_BPHLCD29(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPHLCD29_MASK, LCD_WF8B_BPHLCD29(value)))
#define LCD_BWR_WF8B_BPHLCD29(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPHLCD29_SHIFT), LCD_WF8B_BPHLCD29_SHIFT, LCD_WF8B_BPHLCD29_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPHLCD4[7] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase H
 * - 0b1 - LCD segment on or LCD backplane active for phase H
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPHLCD4 field. */
#define LCD_RD_WF8B_BPHLCD4(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPHLCD4_MASK) >> LCD_WF8B_BPHLCD4_SHIFT)
#define LCD_BRD_WF8B_BPHLCD4(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPHLCD4_SHIFT, LCD_WF8B_BPHLCD4_WIDTH))

/*! @brief Set the BPHLCD4 field to a new value. */
#define LCD_WR_WF8B_BPHLCD4(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPHLCD4_MASK, LCD_WF8B_BPHLCD4(value)))
#define LCD_BWR_WF8B_BPHLCD4(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPHLCD4_SHIFT), LCD_WF8B_BPHLCD4_SHIFT, LCD_WF8B_BPHLCD4_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPHLCD28[7] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase H
 * - 0b1 - LCD segment on or LCD backplane active for phase H
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPHLCD28 field. */
#define LCD_RD_WF8B_BPHLCD28(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPHLCD28_MASK) >> LCD_WF8B_BPHLCD28_SHIFT)
#define LCD_BRD_WF8B_BPHLCD28(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPHLCD28_SHIFT, LCD_WF8B_BPHLCD28_WIDTH))

/*! @brief Set the BPHLCD28 field to a new value. */
#define LCD_WR_WF8B_BPHLCD28(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPHLCD28_MASK, LCD_WF8B_BPHLCD28(value)))
#define LCD_BWR_WF8B_BPHLCD28(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPHLCD28_SHIFT), LCD_WF8B_BPHLCD28_SHIFT, LCD_WF8B_BPHLCD28_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPHLCD27[7] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase H
 * - 0b1 - LCD segment on or LCD backplane active for phase H
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPHLCD27 field. */
#define LCD_RD_WF8B_BPHLCD27(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPHLCD27_MASK) >> LCD_WF8B_BPHLCD27_SHIFT)
#define LCD_BRD_WF8B_BPHLCD27(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPHLCD27_SHIFT, LCD_WF8B_BPHLCD27_WIDTH))

/*! @brief Set the BPHLCD27 field to a new value. */
#define LCD_WR_WF8B_BPHLCD27(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPHLCD27_MASK, LCD_WF8B_BPHLCD27(value)))
#define LCD_BWR_WF8B_BPHLCD27(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPHLCD27_SHIFT), LCD_WF8B_BPHLCD27_SHIFT, LCD_WF8B_BPHLCD27_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPHLCD26[7] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase H
 * - 0b1 - LCD segment on or LCD backplane active for phase H
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPHLCD26 field. */
#define LCD_RD_WF8B_BPHLCD26(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPHLCD26_MASK) >> LCD_WF8B_BPHLCD26_SHIFT)
#define LCD_BRD_WF8B_BPHLCD26(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPHLCD26_SHIFT, LCD_WF8B_BPHLCD26_WIDTH))

/*! @brief Set the BPHLCD26 field to a new value. */
#define LCD_WR_WF8B_BPHLCD26(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPHLCD26_MASK, LCD_WF8B_BPHLCD26(value)))
#define LCD_BWR_WF8B_BPHLCD26(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPHLCD26_SHIFT), LCD_WF8B_BPHLCD26_SHIFT, LCD_WF8B_BPHLCD26_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPHLCD25[7] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase H
 * - 0b1 - LCD segment on or LCD backplane active for phase H
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPHLCD25 field. */
#define LCD_RD_WF8B_BPHLCD25(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPHLCD25_MASK) >> LCD_WF8B_BPHLCD25_SHIFT)
#define LCD_BRD_WF8B_BPHLCD25(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPHLCD25_SHIFT, LCD_WF8B_BPHLCD25_WIDTH))

/*! @brief Set the BPHLCD25 field to a new value. */
#define LCD_WR_WF8B_BPHLCD25(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPHLCD25_MASK, LCD_WF8B_BPHLCD25(value)))
#define LCD_BWR_WF8B_BPHLCD25(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPHLCD25_SHIFT), LCD_WF8B_BPHLCD25_SHIFT, LCD_WF8B_BPHLCD25_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPHLCD24[7] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase H
 * - 0b1 - LCD segment on or LCD backplane active for phase H
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPHLCD24 field. */
#define LCD_RD_WF8B_BPHLCD24(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPHLCD24_MASK) >> LCD_WF8B_BPHLCD24_SHIFT)
#define LCD_BRD_WF8B_BPHLCD24(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPHLCD24_SHIFT, LCD_WF8B_BPHLCD24_WIDTH))

/*! @brief Set the BPHLCD24 field to a new value. */
#define LCD_WR_WF8B_BPHLCD24(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPHLCD24_MASK, LCD_WF8B_BPHLCD24(value)))
#define LCD_BWR_WF8B_BPHLCD24(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPHLCD24_SHIFT), LCD_WF8B_BPHLCD24_SHIFT, LCD_WF8B_BPHLCD24_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPHLCD23[7] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase H
 * - 0b1 - LCD segment on or LCD backplane active for phase H
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPHLCD23 field. */
#define LCD_RD_WF8B_BPHLCD23(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPHLCD23_MASK) >> LCD_WF8B_BPHLCD23_SHIFT)
#define LCD_BRD_WF8B_BPHLCD23(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPHLCD23_SHIFT, LCD_WF8B_BPHLCD23_WIDTH))

/*! @brief Set the BPHLCD23 field to a new value. */
#define LCD_WR_WF8B_BPHLCD23(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPHLCD23_MASK, LCD_WF8B_BPHLCD23(value)))
#define LCD_BWR_WF8B_BPHLCD23(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPHLCD23_SHIFT), LCD_WF8B_BPHLCD23_SHIFT, LCD_WF8B_BPHLCD23_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPHLCD22[7] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase H
 * - 0b1 - LCD segment on or LCD backplane active for phase H
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPHLCD22 field. */
#define LCD_RD_WF8B_BPHLCD22(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPHLCD22_MASK) >> LCD_WF8B_BPHLCD22_SHIFT)
#define LCD_BRD_WF8B_BPHLCD22(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPHLCD22_SHIFT, LCD_WF8B_BPHLCD22_WIDTH))

/*! @brief Set the BPHLCD22 field to a new value. */
#define LCD_WR_WF8B_BPHLCD22(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPHLCD22_MASK, LCD_WF8B_BPHLCD22(value)))
#define LCD_BWR_WF8B_BPHLCD22(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPHLCD22_SHIFT), LCD_WF8B_BPHLCD22_SHIFT, LCD_WF8B_BPHLCD22_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPHLCD5[7] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase H
 * - 0b1 - LCD segment on or LCD backplane active for phase H
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPHLCD5 field. */
#define LCD_RD_WF8B_BPHLCD5(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPHLCD5_MASK) >> LCD_WF8B_BPHLCD5_SHIFT)
#define LCD_BRD_WF8B_BPHLCD5(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPHLCD5_SHIFT, LCD_WF8B_BPHLCD5_WIDTH))

/*! @brief Set the BPHLCD5 field to a new value. */
#define LCD_WR_WF8B_BPHLCD5(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPHLCD5_MASK, LCD_WF8B_BPHLCD5(value)))
#define LCD_BWR_WF8B_BPHLCD5(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPHLCD5_SHIFT), LCD_WF8B_BPHLCD5_SHIFT, LCD_WF8B_BPHLCD5_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPHLCD21[7] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase H
 * - 0b1 - LCD segment on or LCD backplane active for phase H
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPHLCD21 field. */
#define LCD_RD_WF8B_BPHLCD21(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPHLCD21_MASK) >> LCD_WF8B_BPHLCD21_SHIFT)
#define LCD_BRD_WF8B_BPHLCD21(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPHLCD21_SHIFT, LCD_WF8B_BPHLCD21_WIDTH))

/*! @brief Set the BPHLCD21 field to a new value. */
#define LCD_WR_WF8B_BPHLCD21(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPHLCD21_MASK, LCD_WF8B_BPHLCD21(value)))
#define LCD_BWR_WF8B_BPHLCD21(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPHLCD21_SHIFT), LCD_WF8B_BPHLCD21_SHIFT, LCD_WF8B_BPHLCD21_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPHLCD20[7] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase H
 * - 0b1 - LCD segment on or LCD backplane active for phase H
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPHLCD20 field. */
#define LCD_RD_WF8B_BPHLCD20(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPHLCD20_MASK) >> LCD_WF8B_BPHLCD20_SHIFT)
#define LCD_BRD_WF8B_BPHLCD20(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPHLCD20_SHIFT, LCD_WF8B_BPHLCD20_WIDTH))

/*! @brief Set the BPHLCD20 field to a new value. */
#define LCD_WR_WF8B_BPHLCD20(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPHLCD20_MASK, LCD_WF8B_BPHLCD20(value)))
#define LCD_BWR_WF8B_BPHLCD20(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPHLCD20_SHIFT), LCD_WF8B_BPHLCD20_SHIFT, LCD_WF8B_BPHLCD20_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPHLCD19[7] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase H
 * - 0b1 - LCD segment on or LCD backplane active for phase H
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPHLCD19 field. */
#define LCD_RD_WF8B_BPHLCD19(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPHLCD19_MASK) >> LCD_WF8B_BPHLCD19_SHIFT)
#define LCD_BRD_WF8B_BPHLCD19(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPHLCD19_SHIFT, LCD_WF8B_BPHLCD19_WIDTH))

/*! @brief Set the BPHLCD19 field to a new value. */
#define LCD_WR_WF8B_BPHLCD19(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPHLCD19_MASK, LCD_WF8B_BPHLCD19(value)))
#define LCD_BWR_WF8B_BPHLCD19(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPHLCD19_SHIFT), LCD_WF8B_BPHLCD19_SHIFT, LCD_WF8B_BPHLCD19_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPHLCD18[7] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase H
 * - 0b1 - LCD segment on or LCD backplane active for phase H
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPHLCD18 field. */
#define LCD_RD_WF8B_BPHLCD18(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPHLCD18_MASK) >> LCD_WF8B_BPHLCD18_SHIFT)
#define LCD_BRD_WF8B_BPHLCD18(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPHLCD18_SHIFT, LCD_WF8B_BPHLCD18_WIDTH))

/*! @brief Set the BPHLCD18 field to a new value. */
#define LCD_WR_WF8B_BPHLCD18(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPHLCD18_MASK, LCD_WF8B_BPHLCD18(value)))
#define LCD_BWR_WF8B_BPHLCD18(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPHLCD18_SHIFT), LCD_WF8B_BPHLCD18_SHIFT, LCD_WF8B_BPHLCD18_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPHLCD17[7] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase H
 * - 0b1 - LCD segment on or LCD backplane active for phase H
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPHLCD17 field. */
#define LCD_RD_WF8B_BPHLCD17(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPHLCD17_MASK) >> LCD_WF8B_BPHLCD17_SHIFT)
#define LCD_BRD_WF8B_BPHLCD17(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPHLCD17_SHIFT, LCD_WF8B_BPHLCD17_WIDTH))

/*! @brief Set the BPHLCD17 field to a new value. */
#define LCD_WR_WF8B_BPHLCD17(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPHLCD17_MASK, LCD_WF8B_BPHLCD17(value)))
#define LCD_BWR_WF8B_BPHLCD17(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPHLCD17_SHIFT), LCD_WF8B_BPHLCD17_SHIFT, LCD_WF8B_BPHLCD17_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPHLCD16[7] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase H
 * - 0b1 - LCD segment on or LCD backplane active for phase H
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPHLCD16 field. */
#define LCD_RD_WF8B_BPHLCD16(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPHLCD16_MASK) >> LCD_WF8B_BPHLCD16_SHIFT)
#define LCD_BRD_WF8B_BPHLCD16(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPHLCD16_SHIFT, LCD_WF8B_BPHLCD16_WIDTH))

/*! @brief Set the BPHLCD16 field to a new value. */
#define LCD_WR_WF8B_BPHLCD16(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPHLCD16_MASK, LCD_WF8B_BPHLCD16(value)))
#define LCD_BWR_WF8B_BPHLCD16(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPHLCD16_SHIFT), LCD_WF8B_BPHLCD16_SHIFT, LCD_WF8B_BPHLCD16_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPHLCD15[7] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase H
 * - 0b1 - LCD segment on or LCD backplane active for phase H
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPHLCD15 field. */
#define LCD_RD_WF8B_BPHLCD15(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPHLCD15_MASK) >> LCD_WF8B_BPHLCD15_SHIFT)
#define LCD_BRD_WF8B_BPHLCD15(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPHLCD15_SHIFT, LCD_WF8B_BPHLCD15_WIDTH))

/*! @brief Set the BPHLCD15 field to a new value. */
#define LCD_WR_WF8B_BPHLCD15(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPHLCD15_MASK, LCD_WF8B_BPHLCD15(value)))
#define LCD_BWR_WF8B_BPHLCD15(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPHLCD15_SHIFT), LCD_WF8B_BPHLCD15_SHIFT, LCD_WF8B_BPHLCD15_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPHLCD6[7] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase H
 * - 0b1 - LCD segment on or LCD backplane active for phase H
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPHLCD6 field. */
#define LCD_RD_WF8B_BPHLCD6(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPHLCD6_MASK) >> LCD_WF8B_BPHLCD6_SHIFT)
#define LCD_BRD_WF8B_BPHLCD6(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPHLCD6_SHIFT, LCD_WF8B_BPHLCD6_WIDTH))

/*! @brief Set the BPHLCD6 field to a new value. */
#define LCD_WR_WF8B_BPHLCD6(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPHLCD6_MASK, LCD_WF8B_BPHLCD6(value)))
#define LCD_BWR_WF8B_BPHLCD6(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPHLCD6_SHIFT), LCD_WF8B_BPHLCD6_SHIFT, LCD_WF8B_BPHLCD6_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPHLCD14[7] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase H
 * - 0b1 - LCD segment on or LCD backplane active for phase H
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPHLCD14 field. */
#define LCD_RD_WF8B_BPHLCD14(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPHLCD14_MASK) >> LCD_WF8B_BPHLCD14_SHIFT)
#define LCD_BRD_WF8B_BPHLCD14(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPHLCD14_SHIFT, LCD_WF8B_BPHLCD14_WIDTH))

/*! @brief Set the BPHLCD14 field to a new value. */
#define LCD_WR_WF8B_BPHLCD14(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPHLCD14_MASK, LCD_WF8B_BPHLCD14(value)))
#define LCD_BWR_WF8B_BPHLCD14(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPHLCD14_SHIFT), LCD_WF8B_BPHLCD14_SHIFT, LCD_WF8B_BPHLCD14_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPHLCD13[7] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase H
 * - 0b1 - LCD segment on or LCD backplane active for phase H
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPHLCD13 field. */
#define LCD_RD_WF8B_BPHLCD13(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPHLCD13_MASK) >> LCD_WF8B_BPHLCD13_SHIFT)
#define LCD_BRD_WF8B_BPHLCD13(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPHLCD13_SHIFT, LCD_WF8B_BPHLCD13_WIDTH))

/*! @brief Set the BPHLCD13 field to a new value. */
#define LCD_WR_WF8B_BPHLCD13(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPHLCD13_MASK, LCD_WF8B_BPHLCD13(value)))
#define LCD_BWR_WF8B_BPHLCD13(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPHLCD13_SHIFT), LCD_WF8B_BPHLCD13_SHIFT, LCD_WF8B_BPHLCD13_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPHLCD12[7] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase H
 * - 0b1 - LCD segment on or LCD backplane active for phase H
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPHLCD12 field. */
#define LCD_RD_WF8B_BPHLCD12(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPHLCD12_MASK) >> LCD_WF8B_BPHLCD12_SHIFT)
#define LCD_BRD_WF8B_BPHLCD12(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPHLCD12_SHIFT, LCD_WF8B_BPHLCD12_WIDTH))

/*! @brief Set the BPHLCD12 field to a new value. */
#define LCD_WR_WF8B_BPHLCD12(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPHLCD12_MASK, LCD_WF8B_BPHLCD12(value)))
#define LCD_BWR_WF8B_BPHLCD12(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPHLCD12_SHIFT), LCD_WF8B_BPHLCD12_SHIFT, LCD_WF8B_BPHLCD12_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPHLCD11[7] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase H
 * - 0b1 - LCD segment on or LCD backplane active for phase H
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPHLCD11 field. */
#define LCD_RD_WF8B_BPHLCD11(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPHLCD11_MASK) >> LCD_WF8B_BPHLCD11_SHIFT)
#define LCD_BRD_WF8B_BPHLCD11(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPHLCD11_SHIFT, LCD_WF8B_BPHLCD11_WIDTH))

/*! @brief Set the BPHLCD11 field to a new value. */
#define LCD_WR_WF8B_BPHLCD11(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPHLCD11_MASK, LCD_WF8B_BPHLCD11(value)))
#define LCD_BWR_WF8B_BPHLCD11(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPHLCD11_SHIFT), LCD_WF8B_BPHLCD11_SHIFT, LCD_WF8B_BPHLCD11_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPHLCD10[7] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase H
 * - 0b1 - LCD segment on or LCD backplane active for phase H
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPHLCD10 field. */
#define LCD_RD_WF8B_BPHLCD10(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPHLCD10_MASK) >> LCD_WF8B_BPHLCD10_SHIFT)
#define LCD_BRD_WF8B_BPHLCD10(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPHLCD10_SHIFT, LCD_WF8B_BPHLCD10_WIDTH))

/*! @brief Set the BPHLCD10 field to a new value. */
#define LCD_WR_WF8B_BPHLCD10(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPHLCD10_MASK, LCD_WF8B_BPHLCD10(value)))
#define LCD_BWR_WF8B_BPHLCD10(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPHLCD10_SHIFT), LCD_WF8B_BPHLCD10_SHIFT, LCD_WF8B_BPHLCD10_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPHLCD9[7] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase H
 * - 0b1 - LCD segment on or LCD backplane active for phase H
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPHLCD9 field. */
#define LCD_RD_WF8B_BPHLCD9(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPHLCD9_MASK) >> LCD_WF8B_BPHLCD9_SHIFT)
#define LCD_BRD_WF8B_BPHLCD9(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPHLCD9_SHIFT, LCD_WF8B_BPHLCD9_WIDTH))

/*! @brief Set the BPHLCD9 field to a new value. */
#define LCD_WR_WF8B_BPHLCD9(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPHLCD9_MASK, LCD_WF8B_BPHLCD9(value)))
#define LCD_BWR_WF8B_BPHLCD9(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPHLCD9_SHIFT), LCD_WF8B_BPHLCD9_SHIFT, LCD_WF8B_BPHLCD9_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPHLCD8[7] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase H
 * - 0b1 - LCD segment on or LCD backplane active for phase H
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPHLCD8 field. */
#define LCD_RD_WF8B_BPHLCD8(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPHLCD8_MASK) >> LCD_WF8B_BPHLCD8_SHIFT)
#define LCD_BRD_WF8B_BPHLCD8(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPHLCD8_SHIFT, LCD_WF8B_BPHLCD8_WIDTH))

/*! @brief Set the BPHLCD8 field to a new value. */
#define LCD_WR_WF8B_BPHLCD8(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPHLCD8_MASK, LCD_WF8B_BPHLCD8(value)))
#define LCD_BWR_WF8B_BPHLCD8(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPHLCD8_SHIFT), LCD_WF8B_BPHLCD8_SHIFT, LCD_WF8B_BPHLCD8_WIDTH))
/*@}*/

/*!
 * @name Register LCD_WF8B, field BPHLCD7[7] (RW)
 *
 * Values:
 * - 0b0 - LCD segment off or LCD backplane inactive for phase H
 * - 0b1 - LCD segment on or LCD backplane active for phase H
 */
/*@{*/
/*! @brief Read current value of the LCD_WF8B_BPHLCD7 field. */
#define LCD_RD_WF8B_BPHLCD7(base, index) ((LCD_WF8B_REG(base, index) & LCD_WF8B_BPHLCD7_MASK) >> LCD_WF8B_BPHLCD7_SHIFT)
#define LCD_BRD_WF8B_BPHLCD7(base, index) (BME_UBFX8(&LCD_WF8B_REG(base, index), LCD_WF8B_BPHLCD7_SHIFT, LCD_WF8B_BPHLCD7_WIDTH))

/*! @brief Set the BPHLCD7 field to a new value. */
#define LCD_WR_WF8B_BPHLCD7(base, index, value) (LCD_RMW_WF8B(base, index, LCD_WF8B_BPHLCD7_MASK, LCD_WF8B_BPHLCD7(value)))
#define LCD_BWR_WF8B_BPHLCD7(base, index, value) (BME_BFI8(&LCD_WF8B_REG(base, index), ((uint8_t)(value) << LCD_WF8B_BPHLCD7_SHIFT), LCD_WF8B_BPHLCD7_SHIFT, LCD_WF8B_BPHLCD7_WIDTH))
/*@}*/

/* SLCD */
/* Unified SLCD WF register access macros */
#define LCD_RD_WF8B_BPLCD(base, index, phaseIndex) ((LCD_WF8B_REG((base), (index)) & (1U << (phaseIndex))) >> (phaseIndex))
#define LCD_BRD_WF8B_BPLCD(base, index, phaseIndex) (BME_UBFX8(&LCD_WF8B_REG((base), (index)), (phaseIndex), 1))
#define LCD_WR_WF8B_BPLCD(base, index, phaseIndex, value) (LCD_WF8B_REG((base), (index)) = (LCD_WF8B_REG((base), (index)) & ~(1U << (phaseIndex))) | ((uint32_t)(value) << (phaseIndex)))
#define LCD_BWR_WF8B_BPLCD(base, index, phaseIndex, value) (BME_BFI8(&LCD_WF8B_REG((base), (index)), ((uint32_t)(value) << (phaseIndex)), (phaseIndex), 1))

/*
 * MKM34Z7 LLWU
 *
 * Low leakage wakeup unit
 *
 * Registers defined in this header file:
 * - LLWU_PE1 - LLWU Pin Enable 1 register
 * - LLWU_PE2 - LLWU Pin Enable 2 register
 * - LLWU_PE3 - LLWU Pin Enable 3 register
 * - LLWU_PE4 - LLWU Pin Enable 4 register
 * - LLWU_PE5 - LLWU Pin Enable 5 register
 * - LLWU_PE6 - LLWU Pin Enable 6 register
 * - LLWU_ME - LLWU Module Enable register
 * - LLWU_PF1 - LLWU Pin Flag 1 register
 * - LLWU_PF2 - LLWU Pin Flag 2 register
 * - LLWU_PF3 - LLWU Pin Flag 3 register
 * - LLWU_MF5 - LLWU Module Flag 5 register
 * - LLWU_FILT1 - LLWU Pin Filter 1 register
 * - LLWU_FILT2 - LLWU Pin Filter 2 register
 */

#define LLWU_INSTANCE_COUNT (1U) /*!< Number of instances of the LLWU module. */
#define LLWU_IDX (0U) /*!< Instance number for LLWU. */

/*******************************************************************************
 * LLWU_PE1 - LLWU Pin Enable 1 register
 ******************************************************************************/

/*!
 * @brief LLWU_PE1 - LLWU Pin Enable 1 register (RW)
 *
 * Reset value: 0x00U
 *
 * LLWU_PE1 contains the field to enable and select the edge detect type for the
 * external wakeup input pins LLWU_P3-LLWU_P0. This register is reset on Chip
 * Reset not VLLS and by reset types that trigger Chip Reset not VLLS. It is
 * unaffected by reset types that do not trigger Chip Reset not VLLS. See the
 * IntroductionInformation found here describes the registers of the Reset Control Module
 * (RCM). The RCM implements many of the reset functions for the chip. See the
 * chip's reset chapter for more information. details for more information.
 */
/*!
 * @name Constants and macros for entire LLWU_PE1 register
 */
/*@{*/
#define LLWU_RD_PE1(base)        (LLWU_PE1_REG(base))
#define LLWU_WR_PE1(base, value) (LLWU_PE1_REG(base) = (value))
#define LLWU_RMW_PE1(base, mask, value) (LLWU_WR_PE1(base, (LLWU_RD_PE1(base) & ~(mask)) | (value)))
#define LLWU_SET_PE1(base, value) (BME_OR8(&LLWU_PE1_REG(base), (uint8_t)(value)))
#define LLWU_CLR_PE1(base, value) (BME_AND8(&LLWU_PE1_REG(base), (uint8_t)(~(value))))
#define LLWU_TOG_PE1(base, value) (BME_XOR8(&LLWU_PE1_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual LLWU_PE1 bitfields
 */

/*!
 * @name Register LLWU_PE1, field WUPE0[1:0] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 0b00 - External input pin disabled as wakeup input
 * - 0b01 - External input pin enabled with rising edge detection
 * - 0b10 - External input pin enabled with falling edge detection
 * - 0b11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE1_WUPE0 field. */
#define LLWU_RD_PE1_WUPE0(base) ((LLWU_PE1_REG(base) & LLWU_PE1_WUPE0_MASK) >> LLWU_PE1_WUPE0_SHIFT)
#define LLWU_BRD_PE1_WUPE0(base) (BME_UBFX8(&LLWU_PE1_REG(base), LLWU_PE1_WUPE0_SHIFT, LLWU_PE1_WUPE0_WIDTH))

/*! @brief Set the WUPE0 field to a new value. */
#define LLWU_WR_PE1_WUPE0(base, value) (LLWU_RMW_PE1(base, LLWU_PE1_WUPE0_MASK, LLWU_PE1_WUPE0(value)))
#define LLWU_BWR_PE1_WUPE0(base, value) (BME_BFI8(&LLWU_PE1_REG(base), ((uint8_t)(value) << LLWU_PE1_WUPE0_SHIFT), LLWU_PE1_WUPE0_SHIFT, LLWU_PE1_WUPE0_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PE1, field WUPE1[3:2] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 0b00 - External input pin disabled as wakeup input
 * - 0b01 - External input pin enabled with rising edge detection
 * - 0b10 - External input pin enabled with falling edge detection
 * - 0b11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE1_WUPE1 field. */
#define LLWU_RD_PE1_WUPE1(base) ((LLWU_PE1_REG(base) & LLWU_PE1_WUPE1_MASK) >> LLWU_PE1_WUPE1_SHIFT)
#define LLWU_BRD_PE1_WUPE1(base) (BME_UBFX8(&LLWU_PE1_REG(base), LLWU_PE1_WUPE1_SHIFT, LLWU_PE1_WUPE1_WIDTH))

/*! @brief Set the WUPE1 field to a new value. */
#define LLWU_WR_PE1_WUPE1(base, value) (LLWU_RMW_PE1(base, LLWU_PE1_WUPE1_MASK, LLWU_PE1_WUPE1(value)))
#define LLWU_BWR_PE1_WUPE1(base, value) (BME_BFI8(&LLWU_PE1_REG(base), ((uint8_t)(value) << LLWU_PE1_WUPE1_SHIFT), LLWU_PE1_WUPE1_SHIFT, LLWU_PE1_WUPE1_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PE1, field WUPE2[5:4] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 0b00 - External input pin disabled as wakeup input
 * - 0b01 - External input pin enabled with rising edge detection
 * - 0b10 - External input pin enabled with falling edge detection
 * - 0b11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE1_WUPE2 field. */
#define LLWU_RD_PE1_WUPE2(base) ((LLWU_PE1_REG(base) & LLWU_PE1_WUPE2_MASK) >> LLWU_PE1_WUPE2_SHIFT)
#define LLWU_BRD_PE1_WUPE2(base) (BME_UBFX8(&LLWU_PE1_REG(base), LLWU_PE1_WUPE2_SHIFT, LLWU_PE1_WUPE2_WIDTH))

/*! @brief Set the WUPE2 field to a new value. */
#define LLWU_WR_PE1_WUPE2(base, value) (LLWU_RMW_PE1(base, LLWU_PE1_WUPE2_MASK, LLWU_PE1_WUPE2(value)))
#define LLWU_BWR_PE1_WUPE2(base, value) (BME_BFI8(&LLWU_PE1_REG(base), ((uint8_t)(value) << LLWU_PE1_WUPE2_SHIFT), LLWU_PE1_WUPE2_SHIFT, LLWU_PE1_WUPE2_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PE1, field WUPE3[7:6] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 0b00 - External input pin disabled as wakeup input
 * - 0b01 - External input pin enabled with rising edge detection
 * - 0b10 - External input pin enabled with falling edge detection
 * - 0b11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE1_WUPE3 field. */
#define LLWU_RD_PE1_WUPE3(base) ((LLWU_PE1_REG(base) & LLWU_PE1_WUPE3_MASK) >> LLWU_PE1_WUPE3_SHIFT)
#define LLWU_BRD_PE1_WUPE3(base) (BME_UBFX8(&LLWU_PE1_REG(base), LLWU_PE1_WUPE3_SHIFT, LLWU_PE1_WUPE3_WIDTH))

/*! @brief Set the WUPE3 field to a new value. */
#define LLWU_WR_PE1_WUPE3(base, value) (LLWU_RMW_PE1(base, LLWU_PE1_WUPE3_MASK, LLWU_PE1_WUPE3(value)))
#define LLWU_BWR_PE1_WUPE3(base, value) (BME_BFI8(&LLWU_PE1_REG(base), ((uint8_t)(value) << LLWU_PE1_WUPE3_SHIFT), LLWU_PE1_WUPE3_SHIFT, LLWU_PE1_WUPE3_WIDTH))
/*@}*/

/*******************************************************************************
 * LLWU_PE2 - LLWU Pin Enable 2 register
 ******************************************************************************/

/*!
 * @brief LLWU_PE2 - LLWU Pin Enable 2 register (RW)
 *
 * Reset value: 0x00U
 *
 * LLWU_PE2 contains the field to enable and select the edge detect type for the
 * external wakeup input pins LLWU_P7-LLWU_P4. This register is reset on Chip
 * Reset not VLLS and by reset types that trigger Chip Reset not VLLS. It is
 * unaffected by reset types that do not trigger Chip Reset not VLLS. See the
 * IntroductionInformation found here describes the registers of the Reset Control Module
 * (RCM). The RCM implements many of the reset functions for the chip. See the
 * chip's reset chapter for more information. details for more information.
 */
/*!
 * @name Constants and macros for entire LLWU_PE2 register
 */
/*@{*/
#define LLWU_RD_PE2(base)        (LLWU_PE2_REG(base))
#define LLWU_WR_PE2(base, value) (LLWU_PE2_REG(base) = (value))
#define LLWU_RMW_PE2(base, mask, value) (LLWU_WR_PE2(base, (LLWU_RD_PE2(base) & ~(mask)) | (value)))
#define LLWU_SET_PE2(base, value) (BME_OR8(&LLWU_PE2_REG(base), (uint8_t)(value)))
#define LLWU_CLR_PE2(base, value) (BME_AND8(&LLWU_PE2_REG(base), (uint8_t)(~(value))))
#define LLWU_TOG_PE2(base, value) (BME_XOR8(&LLWU_PE2_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual LLWU_PE2 bitfields
 */

/*!
 * @name Register LLWU_PE2, field WUPE4[1:0] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 0b00 - External input pin disabled as wakeup input
 * - 0b01 - External input pin enabled with rising edge detection
 * - 0b10 - External input pin enabled with falling edge detection
 * - 0b11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE2_WUPE4 field. */
#define LLWU_RD_PE2_WUPE4(base) ((LLWU_PE2_REG(base) & LLWU_PE2_WUPE4_MASK) >> LLWU_PE2_WUPE4_SHIFT)
#define LLWU_BRD_PE2_WUPE4(base) (BME_UBFX8(&LLWU_PE2_REG(base), LLWU_PE2_WUPE4_SHIFT, LLWU_PE2_WUPE4_WIDTH))

/*! @brief Set the WUPE4 field to a new value. */
#define LLWU_WR_PE2_WUPE4(base, value) (LLWU_RMW_PE2(base, LLWU_PE2_WUPE4_MASK, LLWU_PE2_WUPE4(value)))
#define LLWU_BWR_PE2_WUPE4(base, value) (BME_BFI8(&LLWU_PE2_REG(base), ((uint8_t)(value) << LLWU_PE2_WUPE4_SHIFT), LLWU_PE2_WUPE4_SHIFT, LLWU_PE2_WUPE4_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PE2, field WUPE5[3:2] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 0b00 - External input pin disabled as wakeup input
 * - 0b01 - External input pin enabled with rising edge detection
 * - 0b10 - External input pin enabled with falling edge detection
 * - 0b11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE2_WUPE5 field. */
#define LLWU_RD_PE2_WUPE5(base) ((LLWU_PE2_REG(base) & LLWU_PE2_WUPE5_MASK) >> LLWU_PE2_WUPE5_SHIFT)
#define LLWU_BRD_PE2_WUPE5(base) (BME_UBFX8(&LLWU_PE2_REG(base), LLWU_PE2_WUPE5_SHIFT, LLWU_PE2_WUPE5_WIDTH))

/*! @brief Set the WUPE5 field to a new value. */
#define LLWU_WR_PE2_WUPE5(base, value) (LLWU_RMW_PE2(base, LLWU_PE2_WUPE5_MASK, LLWU_PE2_WUPE5(value)))
#define LLWU_BWR_PE2_WUPE5(base, value) (BME_BFI8(&LLWU_PE2_REG(base), ((uint8_t)(value) << LLWU_PE2_WUPE5_SHIFT), LLWU_PE2_WUPE5_SHIFT, LLWU_PE2_WUPE5_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PE2, field WUPE6[5:4] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 0b00 - External input pin disabled as wakeup input
 * - 0b01 - External input pin enabled with rising edge detection
 * - 0b10 - External input pin enabled with falling edge detection
 * - 0b11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE2_WUPE6 field. */
#define LLWU_RD_PE2_WUPE6(base) ((LLWU_PE2_REG(base) & LLWU_PE2_WUPE6_MASK) >> LLWU_PE2_WUPE6_SHIFT)
#define LLWU_BRD_PE2_WUPE6(base) (BME_UBFX8(&LLWU_PE2_REG(base), LLWU_PE2_WUPE6_SHIFT, LLWU_PE2_WUPE6_WIDTH))

/*! @brief Set the WUPE6 field to a new value. */
#define LLWU_WR_PE2_WUPE6(base, value) (LLWU_RMW_PE2(base, LLWU_PE2_WUPE6_MASK, LLWU_PE2_WUPE6(value)))
#define LLWU_BWR_PE2_WUPE6(base, value) (BME_BFI8(&LLWU_PE2_REG(base), ((uint8_t)(value) << LLWU_PE2_WUPE6_SHIFT), LLWU_PE2_WUPE6_SHIFT, LLWU_PE2_WUPE6_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PE2, field WUPE7[7:6] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 0b00 - External input pin disabled as wakeup input
 * - 0b01 - External input pin enabled with rising edge detection
 * - 0b10 - External input pin enabled with falling edge detection
 * - 0b11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE2_WUPE7 field. */
#define LLWU_RD_PE2_WUPE7(base) ((LLWU_PE2_REG(base) & LLWU_PE2_WUPE7_MASK) >> LLWU_PE2_WUPE7_SHIFT)
#define LLWU_BRD_PE2_WUPE7(base) (BME_UBFX8(&LLWU_PE2_REG(base), LLWU_PE2_WUPE7_SHIFT, LLWU_PE2_WUPE7_WIDTH))

/*! @brief Set the WUPE7 field to a new value. */
#define LLWU_WR_PE2_WUPE7(base, value) (LLWU_RMW_PE2(base, LLWU_PE2_WUPE7_MASK, LLWU_PE2_WUPE7(value)))
#define LLWU_BWR_PE2_WUPE7(base, value) (BME_BFI8(&LLWU_PE2_REG(base), ((uint8_t)(value) << LLWU_PE2_WUPE7_SHIFT), LLWU_PE2_WUPE7_SHIFT, LLWU_PE2_WUPE7_WIDTH))
/*@}*/

/*******************************************************************************
 * LLWU_PE3 - LLWU Pin Enable 3 register
 ******************************************************************************/

/*!
 * @brief LLWU_PE3 - LLWU Pin Enable 3 register (RW)
 *
 * Reset value: 0x00U
 *
 * LLWU_PE3 contains the field to enable and select the edge detect type for the
 * external wakeup input pins LLWU_P11-LLWU_P8. This register is reset on Chip
 * Reset not VLLS and by reset types that trigger Chip Reset not VLLS. It is
 * unaffected by reset types that do not trigger Chip Reset not VLLS. See the
 * IntroductionInformation found here describes the registers of the Reset Control Module
 * (RCM). The RCM implements many of the reset functions for the chip. See the
 * chip's reset chapter for more information. details for more information.
 */
/*!
 * @name Constants and macros for entire LLWU_PE3 register
 */
/*@{*/
#define LLWU_RD_PE3(base)        (LLWU_PE3_REG(base))
#define LLWU_WR_PE3(base, value) (LLWU_PE3_REG(base) = (value))
#define LLWU_RMW_PE3(base, mask, value) (LLWU_WR_PE3(base, (LLWU_RD_PE3(base) & ~(mask)) | (value)))
#define LLWU_SET_PE3(base, value) (BME_OR8(&LLWU_PE3_REG(base), (uint8_t)(value)))
#define LLWU_CLR_PE3(base, value) (BME_AND8(&LLWU_PE3_REG(base), (uint8_t)(~(value))))
#define LLWU_TOG_PE3(base, value) (BME_XOR8(&LLWU_PE3_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual LLWU_PE3 bitfields
 */

/*!
 * @name Register LLWU_PE3, field WUPE8[1:0] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 0b00 - External input pin disabled as wakeup input
 * - 0b01 - External input pin enabled with rising edge detection
 * - 0b10 - External input pin enabled with falling edge detection
 * - 0b11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE3_WUPE8 field. */
#define LLWU_RD_PE3_WUPE8(base) ((LLWU_PE3_REG(base) & LLWU_PE3_WUPE8_MASK) >> LLWU_PE3_WUPE8_SHIFT)
#define LLWU_BRD_PE3_WUPE8(base) (BME_UBFX8(&LLWU_PE3_REG(base), LLWU_PE3_WUPE8_SHIFT, LLWU_PE3_WUPE8_WIDTH))

/*! @brief Set the WUPE8 field to a new value. */
#define LLWU_WR_PE3_WUPE8(base, value) (LLWU_RMW_PE3(base, LLWU_PE3_WUPE8_MASK, LLWU_PE3_WUPE8(value)))
#define LLWU_BWR_PE3_WUPE8(base, value) (BME_BFI8(&LLWU_PE3_REG(base), ((uint8_t)(value) << LLWU_PE3_WUPE8_SHIFT), LLWU_PE3_WUPE8_SHIFT, LLWU_PE3_WUPE8_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PE3, field WUPE9[3:2] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 0b00 - External input pin disabled as wakeup input
 * - 0b01 - External input pin enabled with rising edge detection
 * - 0b10 - External input pin enabled with falling edge detection
 * - 0b11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE3_WUPE9 field. */
#define LLWU_RD_PE3_WUPE9(base) ((LLWU_PE3_REG(base) & LLWU_PE3_WUPE9_MASK) >> LLWU_PE3_WUPE9_SHIFT)
#define LLWU_BRD_PE3_WUPE9(base) (BME_UBFX8(&LLWU_PE3_REG(base), LLWU_PE3_WUPE9_SHIFT, LLWU_PE3_WUPE9_WIDTH))

/*! @brief Set the WUPE9 field to a new value. */
#define LLWU_WR_PE3_WUPE9(base, value) (LLWU_RMW_PE3(base, LLWU_PE3_WUPE9_MASK, LLWU_PE3_WUPE9(value)))
#define LLWU_BWR_PE3_WUPE9(base, value) (BME_BFI8(&LLWU_PE3_REG(base), ((uint8_t)(value) << LLWU_PE3_WUPE9_SHIFT), LLWU_PE3_WUPE9_SHIFT, LLWU_PE3_WUPE9_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PE3, field WUPE10[5:4] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 0b00 - External input pin disabled as wakeup input
 * - 0b01 - External input pin enabled with rising edge detection
 * - 0b10 - External input pin enabled with falling edge detection
 * - 0b11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE3_WUPE10 field. */
#define LLWU_RD_PE3_WUPE10(base) ((LLWU_PE3_REG(base) & LLWU_PE3_WUPE10_MASK) >> LLWU_PE3_WUPE10_SHIFT)
#define LLWU_BRD_PE3_WUPE10(base) (BME_UBFX8(&LLWU_PE3_REG(base), LLWU_PE3_WUPE10_SHIFT, LLWU_PE3_WUPE10_WIDTH))

/*! @brief Set the WUPE10 field to a new value. */
#define LLWU_WR_PE3_WUPE10(base, value) (LLWU_RMW_PE3(base, LLWU_PE3_WUPE10_MASK, LLWU_PE3_WUPE10(value)))
#define LLWU_BWR_PE3_WUPE10(base, value) (BME_BFI8(&LLWU_PE3_REG(base), ((uint8_t)(value) << LLWU_PE3_WUPE10_SHIFT), LLWU_PE3_WUPE10_SHIFT, LLWU_PE3_WUPE10_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PE3, field WUPE11[7:6] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 0b00 - External input pin disabled as wakeup input
 * - 0b01 - External input pin enabled with rising edge detection
 * - 0b10 - External input pin enabled with falling edge detection
 * - 0b11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE3_WUPE11 field. */
#define LLWU_RD_PE3_WUPE11(base) ((LLWU_PE3_REG(base) & LLWU_PE3_WUPE11_MASK) >> LLWU_PE3_WUPE11_SHIFT)
#define LLWU_BRD_PE3_WUPE11(base) (BME_UBFX8(&LLWU_PE3_REG(base), LLWU_PE3_WUPE11_SHIFT, LLWU_PE3_WUPE11_WIDTH))

/*! @brief Set the WUPE11 field to a new value. */
#define LLWU_WR_PE3_WUPE11(base, value) (LLWU_RMW_PE3(base, LLWU_PE3_WUPE11_MASK, LLWU_PE3_WUPE11(value)))
#define LLWU_BWR_PE3_WUPE11(base, value) (BME_BFI8(&LLWU_PE3_REG(base), ((uint8_t)(value) << LLWU_PE3_WUPE11_SHIFT), LLWU_PE3_WUPE11_SHIFT, LLWU_PE3_WUPE11_WIDTH))
/*@}*/

/*******************************************************************************
 * LLWU_PE4 - LLWU Pin Enable 4 register
 ******************************************************************************/

/*!
 * @brief LLWU_PE4 - LLWU Pin Enable 4 register (RW)
 *
 * Reset value: 0x00U
 *
 * LLWU_PE4 contains the field to enable and select the edge detect type for the
 * external wakeup input pins LLWU_P15-LLWU_P12. This register is reset on Chip
 * Reset not VLLS and by reset types that trigger Chip Reset not VLLS. It is
 * unaffected by reset types that do not trigger Chip Reset not VLLS. See the
 * IntroductionInformation found here describes the registers of the Reset Control
 * Module (RCM). The RCM implements many of the reset functions for the chip. See the
 * chip's reset chapter for more information. details for more information.
 */
/*!
 * @name Constants and macros for entire LLWU_PE4 register
 */
/*@{*/
#define LLWU_RD_PE4(base)        (LLWU_PE4_REG(base))
#define LLWU_WR_PE4(base, value) (LLWU_PE4_REG(base) = (value))
#define LLWU_RMW_PE4(base, mask, value) (LLWU_WR_PE4(base, (LLWU_RD_PE4(base) & ~(mask)) | (value)))
#define LLWU_SET_PE4(base, value) (BME_OR8(&LLWU_PE4_REG(base), (uint8_t)(value)))
#define LLWU_CLR_PE4(base, value) (BME_AND8(&LLWU_PE4_REG(base), (uint8_t)(~(value))))
#define LLWU_TOG_PE4(base, value) (BME_XOR8(&LLWU_PE4_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual LLWU_PE4 bitfields
 */

/*!
 * @name Register LLWU_PE4, field WUPE12[1:0] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 0b00 - External input pin disabled as wakeup input
 * - 0b01 - External input pin enabled with rising edge detection
 * - 0b10 - External input pin enabled with falling edge detection
 * - 0b11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE4_WUPE12 field. */
#define LLWU_RD_PE4_WUPE12(base) ((LLWU_PE4_REG(base) & LLWU_PE4_WUPE12_MASK) >> LLWU_PE4_WUPE12_SHIFT)
#define LLWU_BRD_PE4_WUPE12(base) (BME_UBFX8(&LLWU_PE4_REG(base), LLWU_PE4_WUPE12_SHIFT, LLWU_PE4_WUPE12_WIDTH))

/*! @brief Set the WUPE12 field to a new value. */
#define LLWU_WR_PE4_WUPE12(base, value) (LLWU_RMW_PE4(base, LLWU_PE4_WUPE12_MASK, LLWU_PE4_WUPE12(value)))
#define LLWU_BWR_PE4_WUPE12(base, value) (BME_BFI8(&LLWU_PE4_REG(base), ((uint8_t)(value) << LLWU_PE4_WUPE12_SHIFT), LLWU_PE4_WUPE12_SHIFT, LLWU_PE4_WUPE12_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PE4, field WUPE13[3:2] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 0b00 - External input pin disabled as wakeup input
 * - 0b01 - External input pin enabled with rising edge detection
 * - 0b10 - External input pin enabled with falling edge detection
 * - 0b11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE4_WUPE13 field. */
#define LLWU_RD_PE4_WUPE13(base) ((LLWU_PE4_REG(base) & LLWU_PE4_WUPE13_MASK) >> LLWU_PE4_WUPE13_SHIFT)
#define LLWU_BRD_PE4_WUPE13(base) (BME_UBFX8(&LLWU_PE4_REG(base), LLWU_PE4_WUPE13_SHIFT, LLWU_PE4_WUPE13_WIDTH))

/*! @brief Set the WUPE13 field to a new value. */
#define LLWU_WR_PE4_WUPE13(base, value) (LLWU_RMW_PE4(base, LLWU_PE4_WUPE13_MASK, LLWU_PE4_WUPE13(value)))
#define LLWU_BWR_PE4_WUPE13(base, value) (BME_BFI8(&LLWU_PE4_REG(base), ((uint8_t)(value) << LLWU_PE4_WUPE13_SHIFT), LLWU_PE4_WUPE13_SHIFT, LLWU_PE4_WUPE13_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PE4, field WUPE14[5:4] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 0b00 - External input pin disabled as wakeup input
 * - 0b01 - External input pin enabled with rising edge detection
 * - 0b10 - External input pin enabled with falling edge detection
 * - 0b11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE4_WUPE14 field. */
#define LLWU_RD_PE4_WUPE14(base) ((LLWU_PE4_REG(base) & LLWU_PE4_WUPE14_MASK) >> LLWU_PE4_WUPE14_SHIFT)
#define LLWU_BRD_PE4_WUPE14(base) (BME_UBFX8(&LLWU_PE4_REG(base), LLWU_PE4_WUPE14_SHIFT, LLWU_PE4_WUPE14_WIDTH))

/*! @brief Set the WUPE14 field to a new value. */
#define LLWU_WR_PE4_WUPE14(base, value) (LLWU_RMW_PE4(base, LLWU_PE4_WUPE14_MASK, LLWU_PE4_WUPE14(value)))
#define LLWU_BWR_PE4_WUPE14(base, value) (BME_BFI8(&LLWU_PE4_REG(base), ((uint8_t)(value) << LLWU_PE4_WUPE14_SHIFT), LLWU_PE4_WUPE14_SHIFT, LLWU_PE4_WUPE14_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PE4, field WUPE15[7:6] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 0b00 - External input pin disabled as wakeup input
 * - 0b01 - External input pin enabled with rising edge detection
 * - 0b10 - External input pin enabled with falling edge detection
 * - 0b11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE4_WUPE15 field. */
#define LLWU_RD_PE4_WUPE15(base) ((LLWU_PE4_REG(base) & LLWU_PE4_WUPE15_MASK) >> LLWU_PE4_WUPE15_SHIFT)
#define LLWU_BRD_PE4_WUPE15(base) (BME_UBFX8(&LLWU_PE4_REG(base), LLWU_PE4_WUPE15_SHIFT, LLWU_PE4_WUPE15_WIDTH))

/*! @brief Set the WUPE15 field to a new value. */
#define LLWU_WR_PE4_WUPE15(base, value) (LLWU_RMW_PE4(base, LLWU_PE4_WUPE15_MASK, LLWU_PE4_WUPE15(value)))
#define LLWU_BWR_PE4_WUPE15(base, value) (BME_BFI8(&LLWU_PE4_REG(base), ((uint8_t)(value) << LLWU_PE4_WUPE15_SHIFT), LLWU_PE4_WUPE15_SHIFT, LLWU_PE4_WUPE15_WIDTH))
/*@}*/

/*******************************************************************************
 * LLWU_PE5 - LLWU Pin Enable 5 register
 ******************************************************************************/

/*!
 * @brief LLWU_PE5 - LLWU Pin Enable 5 register (RW)
 *
 * Reset value: 0x00U
 *
 * LLWU_PE5 contains the field to enable and select the edge detect type for the
 * external wakeup input pins LLWU_P19-LLWU_P16. This register is reset on Chip
 * Reset not VLLS and by reset types that trigger Chip Reset not VLLS. It is
 * unaffected by reset types that do not trigger Chip Reset not VLLS. See the
 * IntroductionInformation found here describes the registers of the Reset Control
 * Module (RCM). The RCM implements many of the reset functions for the chip. See the
 * chip's reset chapter for more information. details for more information.
 */
/*!
 * @name Constants and macros for entire LLWU_PE5 register
 */
/*@{*/
#define LLWU_RD_PE5(base)        (LLWU_PE5_REG(base))
#define LLWU_WR_PE5(base, value) (LLWU_PE5_REG(base) = (value))
#define LLWU_RMW_PE5(base, mask, value) (LLWU_WR_PE5(base, (LLWU_RD_PE5(base) & ~(mask)) | (value)))
#define LLWU_SET_PE5(base, value) (BME_OR8(&LLWU_PE5_REG(base), (uint8_t)(value)))
#define LLWU_CLR_PE5(base, value) (BME_AND8(&LLWU_PE5_REG(base), (uint8_t)(~(value))))
#define LLWU_TOG_PE5(base, value) (BME_XOR8(&LLWU_PE5_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual LLWU_PE5 bitfields
 */

/*!
 * @name Register LLWU_PE5, field WUPE16[1:0] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 0b00 - External input pin disabled as wakeup input
 * - 0b01 - External input pin enabled with rising edge detection
 * - 0b10 - External input pin enabled with falling edge detection
 * - 0b11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE5_WUPE16 field. */
#define LLWU_RD_PE5_WUPE16(base) ((LLWU_PE5_REG(base) & LLWU_PE5_WUPE16_MASK) >> LLWU_PE5_WUPE16_SHIFT)
#define LLWU_BRD_PE5_WUPE16(base) (BME_UBFX8(&LLWU_PE5_REG(base), LLWU_PE5_WUPE16_SHIFT, LLWU_PE5_WUPE16_WIDTH))

/*! @brief Set the WUPE16 field to a new value. */
#define LLWU_WR_PE5_WUPE16(base, value) (LLWU_RMW_PE5(base, LLWU_PE5_WUPE16_MASK, LLWU_PE5_WUPE16(value)))
#define LLWU_BWR_PE5_WUPE16(base, value) (BME_BFI8(&LLWU_PE5_REG(base), ((uint8_t)(value) << LLWU_PE5_WUPE16_SHIFT), LLWU_PE5_WUPE16_SHIFT, LLWU_PE5_WUPE16_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PE5, field WUPE17[3:2] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 0b00 - External input pin disabled as wakeup input
 * - 0b01 - External input pin enabled with rising edge detection
 * - 0b10 - External input pin enabled with falling edge detection
 * - 0b11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE5_WUPE17 field. */
#define LLWU_RD_PE5_WUPE17(base) ((LLWU_PE5_REG(base) & LLWU_PE5_WUPE17_MASK) >> LLWU_PE5_WUPE17_SHIFT)
#define LLWU_BRD_PE5_WUPE17(base) (BME_UBFX8(&LLWU_PE5_REG(base), LLWU_PE5_WUPE17_SHIFT, LLWU_PE5_WUPE17_WIDTH))

/*! @brief Set the WUPE17 field to a new value. */
#define LLWU_WR_PE5_WUPE17(base, value) (LLWU_RMW_PE5(base, LLWU_PE5_WUPE17_MASK, LLWU_PE5_WUPE17(value)))
#define LLWU_BWR_PE5_WUPE17(base, value) (BME_BFI8(&LLWU_PE5_REG(base), ((uint8_t)(value) << LLWU_PE5_WUPE17_SHIFT), LLWU_PE5_WUPE17_SHIFT, LLWU_PE5_WUPE17_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PE5, field WUPE18[5:4] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 0b00 - External input pin disabled as wakeup input
 * - 0b01 - External input pin enabled with rising edge detection
 * - 0b10 - External input pin enabled with falling edge detection
 * - 0b11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE5_WUPE18 field. */
#define LLWU_RD_PE5_WUPE18(base) ((LLWU_PE5_REG(base) & LLWU_PE5_WUPE18_MASK) >> LLWU_PE5_WUPE18_SHIFT)
#define LLWU_BRD_PE5_WUPE18(base) (BME_UBFX8(&LLWU_PE5_REG(base), LLWU_PE5_WUPE18_SHIFT, LLWU_PE5_WUPE18_WIDTH))

/*! @brief Set the WUPE18 field to a new value. */
#define LLWU_WR_PE5_WUPE18(base, value) (LLWU_RMW_PE5(base, LLWU_PE5_WUPE18_MASK, LLWU_PE5_WUPE18(value)))
#define LLWU_BWR_PE5_WUPE18(base, value) (BME_BFI8(&LLWU_PE5_REG(base), ((uint8_t)(value) << LLWU_PE5_WUPE18_SHIFT), LLWU_PE5_WUPE18_SHIFT, LLWU_PE5_WUPE18_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PE5, field WUPE19[7:6] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 0b00 - External input pin disabled as wakeup input
 * - 0b01 - External input pin enabled with rising edge detection
 * - 0b10 - External input pin enabled with falling edge detection
 * - 0b11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE5_WUPE19 field. */
#define LLWU_RD_PE5_WUPE19(base) ((LLWU_PE5_REG(base) & LLWU_PE5_WUPE19_MASK) >> LLWU_PE5_WUPE19_SHIFT)
#define LLWU_BRD_PE5_WUPE19(base) (BME_UBFX8(&LLWU_PE5_REG(base), LLWU_PE5_WUPE19_SHIFT, LLWU_PE5_WUPE19_WIDTH))

/*! @brief Set the WUPE19 field to a new value. */
#define LLWU_WR_PE5_WUPE19(base, value) (LLWU_RMW_PE5(base, LLWU_PE5_WUPE19_MASK, LLWU_PE5_WUPE19(value)))
#define LLWU_BWR_PE5_WUPE19(base, value) (BME_BFI8(&LLWU_PE5_REG(base), ((uint8_t)(value) << LLWU_PE5_WUPE19_SHIFT), LLWU_PE5_WUPE19_SHIFT, LLWU_PE5_WUPE19_WIDTH))
/*@}*/

/*******************************************************************************
 * LLWU_PE6 - LLWU Pin Enable 6 register
 ******************************************************************************/

/*!
 * @brief LLWU_PE6 - LLWU Pin Enable 6 register (RW)
 *
 * Reset value: 0x00U
 *
 * LLWU_PE6 contains the field to enable and select the edge detect type for the
 * external wakeup input pins LLWU_P23-LLWU_P20. This register is reset on Chip
 * Reset not VLLS and by reset types that trigger Chip Reset not VLLS. It is
 * unaffected by reset types that do not trigger Chip Reset not VLLS. See the
 * IntroductionInformation found here describes the registers of the Reset Control
 * Module (RCM). The RCM implements many of the reset functions for the chip. See the
 * chip's reset chapter for more information. details for more information.
 */
/*!
 * @name Constants and macros for entire LLWU_PE6 register
 */
/*@{*/
#define LLWU_RD_PE6(base)        (LLWU_PE6_REG(base))
#define LLWU_WR_PE6(base, value) (LLWU_PE6_REG(base) = (value))
#define LLWU_RMW_PE6(base, mask, value) (LLWU_WR_PE6(base, (LLWU_RD_PE6(base) & ~(mask)) | (value)))
#define LLWU_SET_PE6(base, value) (BME_OR8(&LLWU_PE6_REG(base), (uint8_t)(value)))
#define LLWU_CLR_PE6(base, value) (BME_AND8(&LLWU_PE6_REG(base), (uint8_t)(~(value))))
#define LLWU_TOG_PE6(base, value) (BME_XOR8(&LLWU_PE6_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual LLWU_PE6 bitfields
 */

/*!
 * @name Register LLWU_PE6, field WUPE20[1:0] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 0b00 - External input pin disabled as wakeup input
 * - 0b01 - External input pin enabled with rising edge detection
 * - 0b10 - External input pin enabled with falling edge detection
 * - 0b11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE6_WUPE20 field. */
#define LLWU_RD_PE6_WUPE20(base) ((LLWU_PE6_REG(base) & LLWU_PE6_WUPE20_MASK) >> LLWU_PE6_WUPE20_SHIFT)
#define LLWU_BRD_PE6_WUPE20(base) (BME_UBFX8(&LLWU_PE6_REG(base), LLWU_PE6_WUPE20_SHIFT, LLWU_PE6_WUPE20_WIDTH))

/*! @brief Set the WUPE20 field to a new value. */
#define LLWU_WR_PE6_WUPE20(base, value) (LLWU_RMW_PE6(base, LLWU_PE6_WUPE20_MASK, LLWU_PE6_WUPE20(value)))
#define LLWU_BWR_PE6_WUPE20(base, value) (BME_BFI8(&LLWU_PE6_REG(base), ((uint8_t)(value) << LLWU_PE6_WUPE20_SHIFT), LLWU_PE6_WUPE20_SHIFT, LLWU_PE6_WUPE20_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PE6, field WUPE21[3:2] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 0b00 - External input pin disabled as wakeup input
 * - 0b01 - External input pin enabled with rising edge detection
 * - 0b10 - External input pin enabled with falling edge detection
 * - 0b11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE6_WUPE21 field. */
#define LLWU_RD_PE6_WUPE21(base) ((LLWU_PE6_REG(base) & LLWU_PE6_WUPE21_MASK) >> LLWU_PE6_WUPE21_SHIFT)
#define LLWU_BRD_PE6_WUPE21(base) (BME_UBFX8(&LLWU_PE6_REG(base), LLWU_PE6_WUPE21_SHIFT, LLWU_PE6_WUPE21_WIDTH))

/*! @brief Set the WUPE21 field to a new value. */
#define LLWU_WR_PE6_WUPE21(base, value) (LLWU_RMW_PE6(base, LLWU_PE6_WUPE21_MASK, LLWU_PE6_WUPE21(value)))
#define LLWU_BWR_PE6_WUPE21(base, value) (BME_BFI8(&LLWU_PE6_REG(base), ((uint8_t)(value) << LLWU_PE6_WUPE21_SHIFT), LLWU_PE6_WUPE21_SHIFT, LLWU_PE6_WUPE21_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PE6, field WUPE22[5:4] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 0b00 - External input pin disabled as wakeup input
 * - 0b01 - External input pin enabled with rising edge detection
 * - 0b10 - External input pin enabled with falling edge detection
 * - 0b11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE6_WUPE22 field. */
#define LLWU_RD_PE6_WUPE22(base) ((LLWU_PE6_REG(base) & LLWU_PE6_WUPE22_MASK) >> LLWU_PE6_WUPE22_SHIFT)
#define LLWU_BRD_PE6_WUPE22(base) (BME_UBFX8(&LLWU_PE6_REG(base), LLWU_PE6_WUPE22_SHIFT, LLWU_PE6_WUPE22_WIDTH))

/*! @brief Set the WUPE22 field to a new value. */
#define LLWU_WR_PE6_WUPE22(base, value) (LLWU_RMW_PE6(base, LLWU_PE6_WUPE22_MASK, LLWU_PE6_WUPE22(value)))
#define LLWU_BWR_PE6_WUPE22(base, value) (BME_BFI8(&LLWU_PE6_REG(base), ((uint8_t)(value) << LLWU_PE6_WUPE22_SHIFT), LLWU_PE6_WUPE22_SHIFT, LLWU_PE6_WUPE22_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PE6, field WUPE23[7:6] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 0b00 - External input pin disabled as wakeup input
 * - 0b01 - External input pin enabled with rising edge detection
 * - 0b10 - External input pin enabled with falling edge detection
 * - 0b11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE6_WUPE23 field. */
#define LLWU_RD_PE6_WUPE23(base) ((LLWU_PE6_REG(base) & LLWU_PE6_WUPE23_MASK) >> LLWU_PE6_WUPE23_SHIFT)
#define LLWU_BRD_PE6_WUPE23(base) (BME_UBFX8(&LLWU_PE6_REG(base), LLWU_PE6_WUPE23_SHIFT, LLWU_PE6_WUPE23_WIDTH))

/*! @brief Set the WUPE23 field to a new value. */
#define LLWU_WR_PE6_WUPE23(base, value) (LLWU_RMW_PE6(base, LLWU_PE6_WUPE23_MASK, LLWU_PE6_WUPE23(value)))
#define LLWU_BWR_PE6_WUPE23(base, value) (BME_BFI8(&LLWU_PE6_REG(base), ((uint8_t)(value) << LLWU_PE6_WUPE23_SHIFT), LLWU_PE6_WUPE23_SHIFT, LLWU_PE6_WUPE23_WIDTH))
/*@}*/

/*******************************************************************************
 * LLWU_ME - LLWU Module Enable register
 ******************************************************************************/

/*!
 * @brief LLWU_ME - LLWU Module Enable register (RW)
 *
 * Reset value: 0x00U
 *
 * LLWU_ME contains the bits to enable the internal module flag as a wakeup
 * input source for inputs MWUF7-MWUF0. This register is reset on Chip Reset not VLLS
 * and by reset types that trigger Chip Reset not VLLS. It is unaffected by
 * reset types that do not trigger Chip Reset not VLLS. See the
 * IntroductionInformation found here describes the registers of the Reset Control Module (RCM). The
 * RCM implements many of the reset functions for the chip. See the chip's reset
 * chapter for more information. details for more information.
 */
/*!
 * @name Constants and macros for entire LLWU_ME register
 */
/*@{*/
#define LLWU_RD_ME(base)         (LLWU_ME_REG(base))
#define LLWU_WR_ME(base, value)  (LLWU_ME_REG(base) = (value))
#define LLWU_RMW_ME(base, mask, value) (LLWU_WR_ME(base, (LLWU_RD_ME(base) & ~(mask)) | (value)))
#define LLWU_SET_ME(base, value) (BME_OR8(&LLWU_ME_REG(base), (uint8_t)(value)))
#define LLWU_CLR_ME(base, value) (BME_AND8(&LLWU_ME_REG(base), (uint8_t)(~(value))))
#define LLWU_TOG_ME(base, value) (BME_XOR8(&LLWU_ME_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual LLWU_ME bitfields
 */

/*!
 * @name Register LLWU_ME, field WUME0[0] (RW)
 *
 * Enables an internal module as a wakeup source input.
 *
 * Values:
 * - 0b0 - Internal module flag not used as wakeup source
 * - 0b1 - Internal module flag used as wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_ME_WUME0 field. */
#define LLWU_RD_ME_WUME0(base) ((LLWU_ME_REG(base) & LLWU_ME_WUME0_MASK) >> LLWU_ME_WUME0_SHIFT)
#define LLWU_BRD_ME_WUME0(base) (BME_UBFX8(&LLWU_ME_REG(base), LLWU_ME_WUME0_SHIFT, LLWU_ME_WUME0_WIDTH))

/*! @brief Set the WUME0 field to a new value. */
#define LLWU_WR_ME_WUME0(base, value) (LLWU_RMW_ME(base, LLWU_ME_WUME0_MASK, LLWU_ME_WUME0(value)))
#define LLWU_BWR_ME_WUME0(base, value) (BME_BFI8(&LLWU_ME_REG(base), ((uint8_t)(value) << LLWU_ME_WUME0_SHIFT), LLWU_ME_WUME0_SHIFT, LLWU_ME_WUME0_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_ME, field WUME1[1] (RW)
 *
 * Enables an internal module as a wakeup source input.
 *
 * Values:
 * - 0b0 - Internal module flag not used as wakeup source
 * - 0b1 - Internal module flag used as wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_ME_WUME1 field. */
#define LLWU_RD_ME_WUME1(base) ((LLWU_ME_REG(base) & LLWU_ME_WUME1_MASK) >> LLWU_ME_WUME1_SHIFT)
#define LLWU_BRD_ME_WUME1(base) (BME_UBFX8(&LLWU_ME_REG(base), LLWU_ME_WUME1_SHIFT, LLWU_ME_WUME1_WIDTH))

/*! @brief Set the WUME1 field to a new value. */
#define LLWU_WR_ME_WUME1(base, value) (LLWU_RMW_ME(base, LLWU_ME_WUME1_MASK, LLWU_ME_WUME1(value)))
#define LLWU_BWR_ME_WUME1(base, value) (BME_BFI8(&LLWU_ME_REG(base), ((uint8_t)(value) << LLWU_ME_WUME1_SHIFT), LLWU_ME_WUME1_SHIFT, LLWU_ME_WUME1_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_ME, field WUME2[2] (RW)
 *
 * Enables an internal module as a wakeup source input.
 *
 * Values:
 * - 0b0 - Internal module flag not used as wakeup source
 * - 0b1 - Internal module flag used as wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_ME_WUME2 field. */
#define LLWU_RD_ME_WUME2(base) ((LLWU_ME_REG(base) & LLWU_ME_WUME2_MASK) >> LLWU_ME_WUME2_SHIFT)
#define LLWU_BRD_ME_WUME2(base) (BME_UBFX8(&LLWU_ME_REG(base), LLWU_ME_WUME2_SHIFT, LLWU_ME_WUME2_WIDTH))

/*! @brief Set the WUME2 field to a new value. */
#define LLWU_WR_ME_WUME2(base, value) (LLWU_RMW_ME(base, LLWU_ME_WUME2_MASK, LLWU_ME_WUME2(value)))
#define LLWU_BWR_ME_WUME2(base, value) (BME_BFI8(&LLWU_ME_REG(base), ((uint8_t)(value) << LLWU_ME_WUME2_SHIFT), LLWU_ME_WUME2_SHIFT, LLWU_ME_WUME2_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_ME, field WUME3[3] (RW)
 *
 * Enables an internal module as a wakeup source input.
 *
 * Values:
 * - 0b0 - Internal module flag not used as wakeup source
 * - 0b1 - Internal module flag used as wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_ME_WUME3 field. */
#define LLWU_RD_ME_WUME3(base) ((LLWU_ME_REG(base) & LLWU_ME_WUME3_MASK) >> LLWU_ME_WUME3_SHIFT)
#define LLWU_BRD_ME_WUME3(base) (BME_UBFX8(&LLWU_ME_REG(base), LLWU_ME_WUME3_SHIFT, LLWU_ME_WUME3_WIDTH))

/*! @brief Set the WUME3 field to a new value. */
#define LLWU_WR_ME_WUME3(base, value) (LLWU_RMW_ME(base, LLWU_ME_WUME3_MASK, LLWU_ME_WUME3(value)))
#define LLWU_BWR_ME_WUME3(base, value) (BME_BFI8(&LLWU_ME_REG(base), ((uint8_t)(value) << LLWU_ME_WUME3_SHIFT), LLWU_ME_WUME3_SHIFT, LLWU_ME_WUME3_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_ME, field WUME4[4] (RW)
 *
 * Enables an internal module as a wakeup source input.
 *
 * Values:
 * - 0b0 - Internal module flag not used as wakeup source
 * - 0b1 - Internal module flag used as wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_ME_WUME4 field. */
#define LLWU_RD_ME_WUME4(base) ((LLWU_ME_REG(base) & LLWU_ME_WUME4_MASK) >> LLWU_ME_WUME4_SHIFT)
#define LLWU_BRD_ME_WUME4(base) (BME_UBFX8(&LLWU_ME_REG(base), LLWU_ME_WUME4_SHIFT, LLWU_ME_WUME4_WIDTH))

/*! @brief Set the WUME4 field to a new value. */
#define LLWU_WR_ME_WUME4(base, value) (LLWU_RMW_ME(base, LLWU_ME_WUME4_MASK, LLWU_ME_WUME4(value)))
#define LLWU_BWR_ME_WUME4(base, value) (BME_BFI8(&LLWU_ME_REG(base), ((uint8_t)(value) << LLWU_ME_WUME4_SHIFT), LLWU_ME_WUME4_SHIFT, LLWU_ME_WUME4_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_ME, field WUME5[5] (RW)
 *
 * Enables an internal module as a wakeup source input.
 *
 * Values:
 * - 0b0 - Internal module flag not used as wakeup source
 * - 0b1 - Internal module flag used as wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_ME_WUME5 field. */
#define LLWU_RD_ME_WUME5(base) ((LLWU_ME_REG(base) & LLWU_ME_WUME5_MASK) >> LLWU_ME_WUME5_SHIFT)
#define LLWU_BRD_ME_WUME5(base) (BME_UBFX8(&LLWU_ME_REG(base), LLWU_ME_WUME5_SHIFT, LLWU_ME_WUME5_WIDTH))

/*! @brief Set the WUME5 field to a new value. */
#define LLWU_WR_ME_WUME5(base, value) (LLWU_RMW_ME(base, LLWU_ME_WUME5_MASK, LLWU_ME_WUME5(value)))
#define LLWU_BWR_ME_WUME5(base, value) (BME_BFI8(&LLWU_ME_REG(base), ((uint8_t)(value) << LLWU_ME_WUME5_SHIFT), LLWU_ME_WUME5_SHIFT, LLWU_ME_WUME5_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_ME, field WUME6[6] (RW)
 *
 * Enables an internal module as a wakeup source input.
 *
 * Values:
 * - 0b0 - Internal module flag not used as wakeup source
 * - 0b1 - Internal module flag used as wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_ME_WUME6 field. */
#define LLWU_RD_ME_WUME6(base) ((LLWU_ME_REG(base) & LLWU_ME_WUME6_MASK) >> LLWU_ME_WUME6_SHIFT)
#define LLWU_BRD_ME_WUME6(base) (BME_UBFX8(&LLWU_ME_REG(base), LLWU_ME_WUME6_SHIFT, LLWU_ME_WUME6_WIDTH))

/*! @brief Set the WUME6 field to a new value. */
#define LLWU_WR_ME_WUME6(base, value) (LLWU_RMW_ME(base, LLWU_ME_WUME6_MASK, LLWU_ME_WUME6(value)))
#define LLWU_BWR_ME_WUME6(base, value) (BME_BFI8(&LLWU_ME_REG(base), ((uint8_t)(value) << LLWU_ME_WUME6_SHIFT), LLWU_ME_WUME6_SHIFT, LLWU_ME_WUME6_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_ME, field WUME7[7] (RW)
 *
 * Enables an internal module as a wakeup source input.
 *
 * Values:
 * - 0b0 - Internal module flag not used as wakeup source
 * - 0b1 - Internal module flag used as wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_ME_WUME7 field. */
#define LLWU_RD_ME_WUME7(base) ((LLWU_ME_REG(base) & LLWU_ME_WUME7_MASK) >> LLWU_ME_WUME7_SHIFT)
#define LLWU_BRD_ME_WUME7(base) (BME_UBFX8(&LLWU_ME_REG(base), LLWU_ME_WUME7_SHIFT, LLWU_ME_WUME7_WIDTH))

/*! @brief Set the WUME7 field to a new value. */
#define LLWU_WR_ME_WUME7(base, value) (LLWU_RMW_ME(base, LLWU_ME_WUME7_MASK, LLWU_ME_WUME7(value)))
#define LLWU_BWR_ME_WUME7(base, value) (BME_BFI8(&LLWU_ME_REG(base), ((uint8_t)(value) << LLWU_ME_WUME7_SHIFT), LLWU_ME_WUME7_SHIFT, LLWU_ME_WUME7_WIDTH))
/*@}*/

/*******************************************************************************
 * LLWU_PF1 - LLWU Pin Flag 1 register
 ******************************************************************************/

/*!
 * @brief LLWU_PF1 - LLWU Pin Flag 1 register (W1C)
 *
 * Reset value: 0x00U
 *
 * LLWU_PF1 contains the wakeup flags indicating which wakeup source caused the
 * MCU to exit VLLS mode. For VLLS, this is the source causing the MCU reset
 * flow. The external wakeup flags are read-only and clearing a flag is accomplished
 * by a write of a 1 to the corresponding WUFx bit. The wakeup flag (WUFx), if
 * set, will remain set if the associated WUPEx bit is cleared. This register is
 * reset on Chip Reset not VLLS and by reset types that trigger Chip Reset not
 * VLLS. It is unaffected by reset types that do not trigger Chip Reset not VLLS. See
 * the IntroductionInformation found here describes the registers of the Reset
 * Control Module (RCM). The RCM implements many of the reset functions for the
 * chip. See the chip's reset chapter for more information. details for more
 * information.
 */
/*!
 * @name Constants and macros for entire LLWU_PF1 register
 */
/*@{*/
#define LLWU_RD_PF1(base)        (LLWU_PF1_REG(base))
#define LLWU_WR_PF1(base, value) (LLWU_PF1_REG(base) = (value))
#define LLWU_RMW_PF1(base, mask, value) (LLWU_WR_PF1(base, (LLWU_RD_PF1(base) & ~(mask)) | (value)))
#define LLWU_SET_PF1(base, value) (BME_OR8(&LLWU_PF1_REG(base), (uint8_t)(value)))
#define LLWU_CLR_PF1(base, value) (BME_AND8(&LLWU_PF1_REG(base), (uint8_t)(~(value))))
#define LLWU_TOG_PF1(base, value) (BME_XOR8(&LLWU_PF1_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual LLWU_PF1 bitfields
 */

/*!
 * @name Register LLWU_PF1, field WUF0[0] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag write a one to WUF0.
 *
 * Values:
 * - 0b0 - LLWU_P0 input was not a wakeup source
 * - 0b1 - LLWU_P0 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_PF1_WUF0 field. */
#define LLWU_RD_PF1_WUF0(base) ((LLWU_PF1_REG(base) & LLWU_PF1_WUF0_MASK) >> LLWU_PF1_WUF0_SHIFT)
#define LLWU_BRD_PF1_WUF0(base) (BME_UBFX8(&LLWU_PF1_REG(base), LLWU_PF1_WUF0_SHIFT, LLWU_PF1_WUF0_WIDTH))

/*! @brief Set the WUF0 field to a new value. */
#define LLWU_WR_PF1_WUF0(base, value) (LLWU_RMW_PF1(base, (LLWU_PF1_WUF0_MASK | LLWU_PF1_WUF1_MASK | LLWU_PF1_WUF2_MASK | LLWU_PF1_WUF3_MASK | LLWU_PF1_WUF4_MASK | LLWU_PF1_WUF5_MASK | LLWU_PF1_WUF6_MASK | LLWU_PF1_WUF7_MASK), LLWU_PF1_WUF0(value)))
#define LLWU_BWR_PF1_WUF0(base, value) (BME_BFI8(&LLWU_PF1_REG(base), ((uint8_t)(value) << LLWU_PF1_WUF0_SHIFT), LLWU_PF1_WUF0_SHIFT, LLWU_PF1_WUF0_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PF1, field WUF1[1] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag write a one to WUF1.
 *
 * Values:
 * - 0b0 - LLWU_P1 input was not a wakeup source
 * - 0b1 - LLWU_P1 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_PF1_WUF1 field. */
#define LLWU_RD_PF1_WUF1(base) ((LLWU_PF1_REG(base) & LLWU_PF1_WUF1_MASK) >> LLWU_PF1_WUF1_SHIFT)
#define LLWU_BRD_PF1_WUF1(base) (BME_UBFX8(&LLWU_PF1_REG(base), LLWU_PF1_WUF1_SHIFT, LLWU_PF1_WUF1_WIDTH))

/*! @brief Set the WUF1 field to a new value. */
#define LLWU_WR_PF1_WUF1(base, value) (LLWU_RMW_PF1(base, (LLWU_PF1_WUF1_MASK | LLWU_PF1_WUF0_MASK | LLWU_PF1_WUF2_MASK | LLWU_PF1_WUF3_MASK | LLWU_PF1_WUF4_MASK | LLWU_PF1_WUF5_MASK | LLWU_PF1_WUF6_MASK | LLWU_PF1_WUF7_MASK), LLWU_PF1_WUF1(value)))
#define LLWU_BWR_PF1_WUF1(base, value) (BME_BFI8(&LLWU_PF1_REG(base), ((uint8_t)(value) << LLWU_PF1_WUF1_SHIFT), LLWU_PF1_WUF1_SHIFT, LLWU_PF1_WUF1_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PF1, field WUF2[2] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag write a one to WUF2.
 *
 * Values:
 * - 0b0 - LLWU_P2 input was not a wakeup source
 * - 0b1 - LLWU_P2 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_PF1_WUF2 field. */
#define LLWU_RD_PF1_WUF2(base) ((LLWU_PF1_REG(base) & LLWU_PF1_WUF2_MASK) >> LLWU_PF1_WUF2_SHIFT)
#define LLWU_BRD_PF1_WUF2(base) (BME_UBFX8(&LLWU_PF1_REG(base), LLWU_PF1_WUF2_SHIFT, LLWU_PF1_WUF2_WIDTH))

/*! @brief Set the WUF2 field to a new value. */
#define LLWU_WR_PF1_WUF2(base, value) (LLWU_RMW_PF1(base, (LLWU_PF1_WUF2_MASK | LLWU_PF1_WUF0_MASK | LLWU_PF1_WUF1_MASK | LLWU_PF1_WUF3_MASK | LLWU_PF1_WUF4_MASK | LLWU_PF1_WUF5_MASK | LLWU_PF1_WUF6_MASK | LLWU_PF1_WUF7_MASK), LLWU_PF1_WUF2(value)))
#define LLWU_BWR_PF1_WUF2(base, value) (BME_BFI8(&LLWU_PF1_REG(base), ((uint8_t)(value) << LLWU_PF1_WUF2_SHIFT), LLWU_PF1_WUF2_SHIFT, LLWU_PF1_WUF2_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PF1, field WUF3[3] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag write a one to WUF3.
 *
 * Values:
 * - 0b0 - LLWU_P3 input was not a wakeup source
 * - 0b1 - LLWU_P3 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_PF1_WUF3 field. */
#define LLWU_RD_PF1_WUF3(base) ((LLWU_PF1_REG(base) & LLWU_PF1_WUF3_MASK) >> LLWU_PF1_WUF3_SHIFT)
#define LLWU_BRD_PF1_WUF3(base) (BME_UBFX8(&LLWU_PF1_REG(base), LLWU_PF1_WUF3_SHIFT, LLWU_PF1_WUF3_WIDTH))

/*! @brief Set the WUF3 field to a new value. */
#define LLWU_WR_PF1_WUF3(base, value) (LLWU_RMW_PF1(base, (LLWU_PF1_WUF3_MASK | LLWU_PF1_WUF0_MASK | LLWU_PF1_WUF1_MASK | LLWU_PF1_WUF2_MASK | LLWU_PF1_WUF4_MASK | LLWU_PF1_WUF5_MASK | LLWU_PF1_WUF6_MASK | LLWU_PF1_WUF7_MASK), LLWU_PF1_WUF3(value)))
#define LLWU_BWR_PF1_WUF3(base, value) (BME_BFI8(&LLWU_PF1_REG(base), ((uint8_t)(value) << LLWU_PF1_WUF3_SHIFT), LLWU_PF1_WUF3_SHIFT, LLWU_PF1_WUF3_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PF1, field WUF4[4] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag write a one to WUF4.
 *
 * Values:
 * - 0b0 - LLWU_P4 input was not a wakeup source
 * - 0b1 - LLWU_P4 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_PF1_WUF4 field. */
#define LLWU_RD_PF1_WUF4(base) ((LLWU_PF1_REG(base) & LLWU_PF1_WUF4_MASK) >> LLWU_PF1_WUF4_SHIFT)
#define LLWU_BRD_PF1_WUF4(base) (BME_UBFX8(&LLWU_PF1_REG(base), LLWU_PF1_WUF4_SHIFT, LLWU_PF1_WUF4_WIDTH))

/*! @brief Set the WUF4 field to a new value. */
#define LLWU_WR_PF1_WUF4(base, value) (LLWU_RMW_PF1(base, (LLWU_PF1_WUF4_MASK | LLWU_PF1_WUF0_MASK | LLWU_PF1_WUF1_MASK | LLWU_PF1_WUF2_MASK | LLWU_PF1_WUF3_MASK | LLWU_PF1_WUF5_MASK | LLWU_PF1_WUF6_MASK | LLWU_PF1_WUF7_MASK), LLWU_PF1_WUF4(value)))
#define LLWU_BWR_PF1_WUF4(base, value) (BME_BFI8(&LLWU_PF1_REG(base), ((uint8_t)(value) << LLWU_PF1_WUF4_SHIFT), LLWU_PF1_WUF4_SHIFT, LLWU_PF1_WUF4_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PF1, field WUF5[5] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag write a one to WUF5.
 *
 * Values:
 * - 0b0 - LLWU_P5 input was not a wakeup source
 * - 0b1 - LLWU_P5 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_PF1_WUF5 field. */
#define LLWU_RD_PF1_WUF5(base) ((LLWU_PF1_REG(base) & LLWU_PF1_WUF5_MASK) >> LLWU_PF1_WUF5_SHIFT)
#define LLWU_BRD_PF1_WUF5(base) (BME_UBFX8(&LLWU_PF1_REG(base), LLWU_PF1_WUF5_SHIFT, LLWU_PF1_WUF5_WIDTH))

/*! @brief Set the WUF5 field to a new value. */
#define LLWU_WR_PF1_WUF5(base, value) (LLWU_RMW_PF1(base, (LLWU_PF1_WUF5_MASK | LLWU_PF1_WUF0_MASK | LLWU_PF1_WUF1_MASK | LLWU_PF1_WUF2_MASK | LLWU_PF1_WUF3_MASK | LLWU_PF1_WUF4_MASK | LLWU_PF1_WUF6_MASK | LLWU_PF1_WUF7_MASK), LLWU_PF1_WUF5(value)))
#define LLWU_BWR_PF1_WUF5(base, value) (BME_BFI8(&LLWU_PF1_REG(base), ((uint8_t)(value) << LLWU_PF1_WUF5_SHIFT), LLWU_PF1_WUF5_SHIFT, LLWU_PF1_WUF5_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PF1, field WUF6[6] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag write a one to WUF6.
 *
 * Values:
 * - 0b0 - LLWU_P6 input was not a wakeup source
 * - 0b1 - LLWU_P6 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_PF1_WUF6 field. */
#define LLWU_RD_PF1_WUF6(base) ((LLWU_PF1_REG(base) & LLWU_PF1_WUF6_MASK) >> LLWU_PF1_WUF6_SHIFT)
#define LLWU_BRD_PF1_WUF6(base) (BME_UBFX8(&LLWU_PF1_REG(base), LLWU_PF1_WUF6_SHIFT, LLWU_PF1_WUF6_WIDTH))

/*! @brief Set the WUF6 field to a new value. */
#define LLWU_WR_PF1_WUF6(base, value) (LLWU_RMW_PF1(base, (LLWU_PF1_WUF6_MASK | LLWU_PF1_WUF0_MASK | LLWU_PF1_WUF1_MASK | LLWU_PF1_WUF2_MASK | LLWU_PF1_WUF3_MASK | LLWU_PF1_WUF4_MASK | LLWU_PF1_WUF5_MASK | LLWU_PF1_WUF7_MASK), LLWU_PF1_WUF6(value)))
#define LLWU_BWR_PF1_WUF6(base, value) (BME_BFI8(&LLWU_PF1_REG(base), ((uint8_t)(value) << LLWU_PF1_WUF6_SHIFT), LLWU_PF1_WUF6_SHIFT, LLWU_PF1_WUF6_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PF1, field WUF7[7] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag write a one to WUF7.
 *
 * Values:
 * - 0b0 - LLWU_P7 input was not a wakeup source
 * - 0b1 - LLWU_P7 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_PF1_WUF7 field. */
#define LLWU_RD_PF1_WUF7(base) ((LLWU_PF1_REG(base) & LLWU_PF1_WUF7_MASK) >> LLWU_PF1_WUF7_SHIFT)
#define LLWU_BRD_PF1_WUF7(base) (BME_UBFX8(&LLWU_PF1_REG(base), LLWU_PF1_WUF7_SHIFT, LLWU_PF1_WUF7_WIDTH))

/*! @brief Set the WUF7 field to a new value. */
#define LLWU_WR_PF1_WUF7(base, value) (LLWU_RMW_PF1(base, (LLWU_PF1_WUF7_MASK | LLWU_PF1_WUF0_MASK | LLWU_PF1_WUF1_MASK | LLWU_PF1_WUF2_MASK | LLWU_PF1_WUF3_MASK | LLWU_PF1_WUF4_MASK | LLWU_PF1_WUF5_MASK | LLWU_PF1_WUF6_MASK), LLWU_PF1_WUF7(value)))
#define LLWU_BWR_PF1_WUF7(base, value) (BME_BFI8(&LLWU_PF1_REG(base), ((uint8_t)(value) << LLWU_PF1_WUF7_SHIFT), LLWU_PF1_WUF7_SHIFT, LLWU_PF1_WUF7_WIDTH))
/*@}*/

/*******************************************************************************
 * LLWU_PF2 - LLWU Pin Flag 2 register
 ******************************************************************************/

/*!
 * @brief LLWU_PF2 - LLWU Pin Flag 2 register (W1C)
 *
 * Reset value: 0x00U
 *
 * LLWU_PF2 contains the wakeup flags indicating which wakeup source caused the
 * MCU to exit or VLLS mode. For VLLS, this is the source causing the MCU reset
 * flow. The external wakeup flags are read-only and clearing a flag is
 * accomplished by a write of a 1 to the corresponding WUFx bit. The wakeup flag (WUFx), if
 * set, will remain set if the associated WUPEx bit is cleared. This register is
 * reset on Chip Reset not VLLS and by reset types that trigger Chip Reset not
 * VLLS. It is unaffected by reset types that do not trigger Chip Reset not VLLS.
 * See the IntroductionInformation found here describes the registers of the
 * Reset Control Module (RCM). The RCM implements many of the reset functions for the
 * chip. See the chip's reset chapter for more information. details for more
 * information.
 */
/*!
 * @name Constants and macros for entire LLWU_PF2 register
 */
/*@{*/
#define LLWU_RD_PF2(base)        (LLWU_PF2_REG(base))
#define LLWU_WR_PF2(base, value) (LLWU_PF2_REG(base) = (value))
#define LLWU_RMW_PF2(base, mask, value) (LLWU_WR_PF2(base, (LLWU_RD_PF2(base) & ~(mask)) | (value)))
#define LLWU_SET_PF2(base, value) (BME_OR8(&LLWU_PF2_REG(base), (uint8_t)(value)))
#define LLWU_CLR_PF2(base, value) (BME_AND8(&LLWU_PF2_REG(base), (uint8_t)(~(value))))
#define LLWU_TOG_PF2(base, value) (BME_XOR8(&LLWU_PF2_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual LLWU_PF2 bitfields
 */

/*!
 * @name Register LLWU_PF2, field WUF8[0] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag write a one to WUF8.
 *
 * Values:
 * - 0b0 - LLWU_P8 input was not a wakeup source
 * - 0b1 - LLWU_P8 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_PF2_WUF8 field. */
#define LLWU_RD_PF2_WUF8(base) ((LLWU_PF2_REG(base) & LLWU_PF2_WUF8_MASK) >> LLWU_PF2_WUF8_SHIFT)
#define LLWU_BRD_PF2_WUF8(base) (BME_UBFX8(&LLWU_PF2_REG(base), LLWU_PF2_WUF8_SHIFT, LLWU_PF2_WUF8_WIDTH))

/*! @brief Set the WUF8 field to a new value. */
#define LLWU_WR_PF2_WUF8(base, value) (LLWU_RMW_PF2(base, (LLWU_PF2_WUF8_MASK | LLWU_PF2_WUF9_MASK | LLWU_PF2_WUF10_MASK | LLWU_PF2_WUF11_MASK | LLWU_PF2_WUF12_MASK | LLWU_PF2_WUF13_MASK | LLWU_PF2_WUF14_MASK | LLWU_PF2_WUF15_MASK), LLWU_PF2_WUF8(value)))
#define LLWU_BWR_PF2_WUF8(base, value) (BME_BFI8(&LLWU_PF2_REG(base), ((uint8_t)(value) << LLWU_PF2_WUF8_SHIFT), LLWU_PF2_WUF8_SHIFT, LLWU_PF2_WUF8_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PF2, field WUF9[1] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag write a one to WUF9.
 *
 * Values:
 * - 0b0 - LLWU_P9 input was not a wakeup source
 * - 0b1 - LLWU_P9 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_PF2_WUF9 field. */
#define LLWU_RD_PF2_WUF9(base) ((LLWU_PF2_REG(base) & LLWU_PF2_WUF9_MASK) >> LLWU_PF2_WUF9_SHIFT)
#define LLWU_BRD_PF2_WUF9(base) (BME_UBFX8(&LLWU_PF2_REG(base), LLWU_PF2_WUF9_SHIFT, LLWU_PF2_WUF9_WIDTH))

/*! @brief Set the WUF9 field to a new value. */
#define LLWU_WR_PF2_WUF9(base, value) (LLWU_RMW_PF2(base, (LLWU_PF2_WUF9_MASK | LLWU_PF2_WUF8_MASK | LLWU_PF2_WUF10_MASK | LLWU_PF2_WUF11_MASK | LLWU_PF2_WUF12_MASK | LLWU_PF2_WUF13_MASK | LLWU_PF2_WUF14_MASK | LLWU_PF2_WUF15_MASK), LLWU_PF2_WUF9(value)))
#define LLWU_BWR_PF2_WUF9(base, value) (BME_BFI8(&LLWU_PF2_REG(base), ((uint8_t)(value) << LLWU_PF2_WUF9_SHIFT), LLWU_PF2_WUF9_SHIFT, LLWU_PF2_WUF9_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PF2, field WUF10[2] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag write a one to WUF10.
 *
 * Values:
 * - 0b0 - LLWU_P10 input was not a wakeup source
 * - 0b1 - LLWU_P10 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_PF2_WUF10 field. */
#define LLWU_RD_PF2_WUF10(base) ((LLWU_PF2_REG(base) & LLWU_PF2_WUF10_MASK) >> LLWU_PF2_WUF10_SHIFT)
#define LLWU_BRD_PF2_WUF10(base) (BME_UBFX8(&LLWU_PF2_REG(base), LLWU_PF2_WUF10_SHIFT, LLWU_PF2_WUF10_WIDTH))

/*! @brief Set the WUF10 field to a new value. */
#define LLWU_WR_PF2_WUF10(base, value) (LLWU_RMW_PF2(base, (LLWU_PF2_WUF10_MASK | LLWU_PF2_WUF8_MASK | LLWU_PF2_WUF9_MASK | LLWU_PF2_WUF11_MASK | LLWU_PF2_WUF12_MASK | LLWU_PF2_WUF13_MASK | LLWU_PF2_WUF14_MASK | LLWU_PF2_WUF15_MASK), LLWU_PF2_WUF10(value)))
#define LLWU_BWR_PF2_WUF10(base, value) (BME_BFI8(&LLWU_PF2_REG(base), ((uint8_t)(value) << LLWU_PF2_WUF10_SHIFT), LLWU_PF2_WUF10_SHIFT, LLWU_PF2_WUF10_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PF2, field WUF11[3] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag write a one to WUF11.
 *
 * Values:
 * - 0b0 - LLWU_P11 input was not a wakeup source
 * - 0b1 - LLWU_P11 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_PF2_WUF11 field. */
#define LLWU_RD_PF2_WUF11(base) ((LLWU_PF2_REG(base) & LLWU_PF2_WUF11_MASK) >> LLWU_PF2_WUF11_SHIFT)
#define LLWU_BRD_PF2_WUF11(base) (BME_UBFX8(&LLWU_PF2_REG(base), LLWU_PF2_WUF11_SHIFT, LLWU_PF2_WUF11_WIDTH))

/*! @brief Set the WUF11 field to a new value. */
#define LLWU_WR_PF2_WUF11(base, value) (LLWU_RMW_PF2(base, (LLWU_PF2_WUF11_MASK | LLWU_PF2_WUF8_MASK | LLWU_PF2_WUF9_MASK | LLWU_PF2_WUF10_MASK | LLWU_PF2_WUF12_MASK | LLWU_PF2_WUF13_MASK | LLWU_PF2_WUF14_MASK | LLWU_PF2_WUF15_MASK), LLWU_PF2_WUF11(value)))
#define LLWU_BWR_PF2_WUF11(base, value) (BME_BFI8(&LLWU_PF2_REG(base), ((uint8_t)(value) << LLWU_PF2_WUF11_SHIFT), LLWU_PF2_WUF11_SHIFT, LLWU_PF2_WUF11_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PF2, field WUF12[4] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag write a one to WUF12.
 *
 * Values:
 * - 0b0 - LLWU_P12 input was not a wakeup source
 * - 0b1 - LLWU_P12 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_PF2_WUF12 field. */
#define LLWU_RD_PF2_WUF12(base) ((LLWU_PF2_REG(base) & LLWU_PF2_WUF12_MASK) >> LLWU_PF2_WUF12_SHIFT)
#define LLWU_BRD_PF2_WUF12(base) (BME_UBFX8(&LLWU_PF2_REG(base), LLWU_PF2_WUF12_SHIFT, LLWU_PF2_WUF12_WIDTH))

/*! @brief Set the WUF12 field to a new value. */
#define LLWU_WR_PF2_WUF12(base, value) (LLWU_RMW_PF2(base, (LLWU_PF2_WUF12_MASK | LLWU_PF2_WUF8_MASK | LLWU_PF2_WUF9_MASK | LLWU_PF2_WUF10_MASK | LLWU_PF2_WUF11_MASK | LLWU_PF2_WUF13_MASK | LLWU_PF2_WUF14_MASK | LLWU_PF2_WUF15_MASK), LLWU_PF2_WUF12(value)))
#define LLWU_BWR_PF2_WUF12(base, value) (BME_BFI8(&LLWU_PF2_REG(base), ((uint8_t)(value) << LLWU_PF2_WUF12_SHIFT), LLWU_PF2_WUF12_SHIFT, LLWU_PF2_WUF12_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PF2, field WUF13[5] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag write a one to WUF13.
 *
 * Values:
 * - 0b0 - LLWU_P13 input was not a wakeup source
 * - 0b1 - LLWU_P13 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_PF2_WUF13 field. */
#define LLWU_RD_PF2_WUF13(base) ((LLWU_PF2_REG(base) & LLWU_PF2_WUF13_MASK) >> LLWU_PF2_WUF13_SHIFT)
#define LLWU_BRD_PF2_WUF13(base) (BME_UBFX8(&LLWU_PF2_REG(base), LLWU_PF2_WUF13_SHIFT, LLWU_PF2_WUF13_WIDTH))

/*! @brief Set the WUF13 field to a new value. */
#define LLWU_WR_PF2_WUF13(base, value) (LLWU_RMW_PF2(base, (LLWU_PF2_WUF13_MASK | LLWU_PF2_WUF8_MASK | LLWU_PF2_WUF9_MASK | LLWU_PF2_WUF10_MASK | LLWU_PF2_WUF11_MASK | LLWU_PF2_WUF12_MASK | LLWU_PF2_WUF14_MASK | LLWU_PF2_WUF15_MASK), LLWU_PF2_WUF13(value)))
#define LLWU_BWR_PF2_WUF13(base, value) (BME_BFI8(&LLWU_PF2_REG(base), ((uint8_t)(value) << LLWU_PF2_WUF13_SHIFT), LLWU_PF2_WUF13_SHIFT, LLWU_PF2_WUF13_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PF2, field WUF14[6] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag write a one to WUF14.
 *
 * Values:
 * - 0b0 - LLWU_P14 input was not a wakeup source
 * - 0b1 - LLWU_P14 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_PF2_WUF14 field. */
#define LLWU_RD_PF2_WUF14(base) ((LLWU_PF2_REG(base) & LLWU_PF2_WUF14_MASK) >> LLWU_PF2_WUF14_SHIFT)
#define LLWU_BRD_PF2_WUF14(base) (BME_UBFX8(&LLWU_PF2_REG(base), LLWU_PF2_WUF14_SHIFT, LLWU_PF2_WUF14_WIDTH))

/*! @brief Set the WUF14 field to a new value. */
#define LLWU_WR_PF2_WUF14(base, value) (LLWU_RMW_PF2(base, (LLWU_PF2_WUF14_MASK | LLWU_PF2_WUF8_MASK | LLWU_PF2_WUF9_MASK | LLWU_PF2_WUF10_MASK | LLWU_PF2_WUF11_MASK | LLWU_PF2_WUF12_MASK | LLWU_PF2_WUF13_MASK | LLWU_PF2_WUF15_MASK), LLWU_PF2_WUF14(value)))
#define LLWU_BWR_PF2_WUF14(base, value) (BME_BFI8(&LLWU_PF2_REG(base), ((uint8_t)(value) << LLWU_PF2_WUF14_SHIFT), LLWU_PF2_WUF14_SHIFT, LLWU_PF2_WUF14_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PF2, field WUF15[7] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag write a one to WUF15.
 *
 * Values:
 * - 0b0 - LLWU_P15 input was not a wakeup source
 * - 0b1 - LLWU_P15 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_PF2_WUF15 field. */
#define LLWU_RD_PF2_WUF15(base) ((LLWU_PF2_REG(base) & LLWU_PF2_WUF15_MASK) >> LLWU_PF2_WUF15_SHIFT)
#define LLWU_BRD_PF2_WUF15(base) (BME_UBFX8(&LLWU_PF2_REG(base), LLWU_PF2_WUF15_SHIFT, LLWU_PF2_WUF15_WIDTH))

/*! @brief Set the WUF15 field to a new value. */
#define LLWU_WR_PF2_WUF15(base, value) (LLWU_RMW_PF2(base, (LLWU_PF2_WUF15_MASK | LLWU_PF2_WUF8_MASK | LLWU_PF2_WUF9_MASK | LLWU_PF2_WUF10_MASK | LLWU_PF2_WUF11_MASK | LLWU_PF2_WUF12_MASK | LLWU_PF2_WUF13_MASK | LLWU_PF2_WUF14_MASK), LLWU_PF2_WUF15(value)))
#define LLWU_BWR_PF2_WUF15(base, value) (BME_BFI8(&LLWU_PF2_REG(base), ((uint8_t)(value) << LLWU_PF2_WUF15_SHIFT), LLWU_PF2_WUF15_SHIFT, LLWU_PF2_WUF15_WIDTH))
/*@}*/

/*******************************************************************************
 * LLWU_PF3 - LLWU Pin Flag 3 register
 ******************************************************************************/

/*!
 * @brief LLWU_PF3 - LLWU Pin Flag 3 register (W1C)
 *
 * Reset value: 0x00U
 *
 * LLWU_PF3 contains the wakeup flags indicating which wakeup source caused the
 * MCU to exit VLLS mode. For VLLS, this is the source causing the MCU reset
 * flow. The external wakeup flags are read-only and clearing a flag is accomplished
 * by a write of a 1 to the corresponding WUFx bit. The wakeup flag (WUFx), if
 * set, will remain set if the associated WUPEx bit is cleared. This register is
 * reset on Chip Reset not VLLS and by reset types that trigger Chip Reset not
 * VLLS. It is unaffected by reset types that do not trigger Chip Reset not VLLS. See
 * the IntroductionInformation found here describes the registers of the Reset
 * Control Module (RCM). The RCM implements many of the reset functions for the
 * chip. See the chip's reset chapter for more information. details for more
 * information.
 */
/*!
 * @name Constants and macros for entire LLWU_PF3 register
 */
/*@{*/
#define LLWU_RD_PF3(base)        (LLWU_PF3_REG(base))
#define LLWU_WR_PF3(base, value) (LLWU_PF3_REG(base) = (value))
#define LLWU_RMW_PF3(base, mask, value) (LLWU_WR_PF3(base, (LLWU_RD_PF3(base) & ~(mask)) | (value)))
#define LLWU_SET_PF3(base, value) (BME_OR8(&LLWU_PF3_REG(base), (uint8_t)(value)))
#define LLWU_CLR_PF3(base, value) (BME_AND8(&LLWU_PF3_REG(base), (uint8_t)(~(value))))
#define LLWU_TOG_PF3(base, value) (BME_XOR8(&LLWU_PF3_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual LLWU_PF3 bitfields
 */

/*!
 * @name Register LLWU_PF3, field WUF16[0] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag write a one to WUF16.
 *
 * Values:
 * - 0b0 - LLWU_P16 input was not a wakeup source
 * - 0b1 - LLWU_P16 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_PF3_WUF16 field. */
#define LLWU_RD_PF3_WUF16(base) ((LLWU_PF3_REG(base) & LLWU_PF3_WUF16_MASK) >> LLWU_PF3_WUF16_SHIFT)
#define LLWU_BRD_PF3_WUF16(base) (BME_UBFX8(&LLWU_PF3_REG(base), LLWU_PF3_WUF16_SHIFT, LLWU_PF3_WUF16_WIDTH))

/*! @brief Set the WUF16 field to a new value. */
#define LLWU_WR_PF3_WUF16(base, value) (LLWU_RMW_PF3(base, (LLWU_PF3_WUF16_MASK | LLWU_PF3_WUF17_MASK | LLWU_PF3_WUF18_MASK | LLWU_PF3_WUF19_MASK | LLWU_PF3_WUF20_MASK | LLWU_PF3_WUF21_MASK | LLWU_PF3_WUF22_MASK | LLWU_PF3_WUF23_MASK), LLWU_PF3_WUF16(value)))
#define LLWU_BWR_PF3_WUF16(base, value) (BME_BFI8(&LLWU_PF3_REG(base), ((uint8_t)(value) << LLWU_PF3_WUF16_SHIFT), LLWU_PF3_WUF16_SHIFT, LLWU_PF3_WUF16_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PF3, field WUF17[1] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag write a one to WUF17.
 *
 * Values:
 * - 0b0 - LLWU_P17 input was not a wakeup source
 * - 0b1 - LLWU_P17 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_PF3_WUF17 field. */
#define LLWU_RD_PF3_WUF17(base) ((LLWU_PF3_REG(base) & LLWU_PF3_WUF17_MASK) >> LLWU_PF3_WUF17_SHIFT)
#define LLWU_BRD_PF3_WUF17(base) (BME_UBFX8(&LLWU_PF3_REG(base), LLWU_PF3_WUF17_SHIFT, LLWU_PF3_WUF17_WIDTH))

/*! @brief Set the WUF17 field to a new value. */
#define LLWU_WR_PF3_WUF17(base, value) (LLWU_RMW_PF3(base, (LLWU_PF3_WUF17_MASK | LLWU_PF3_WUF16_MASK | LLWU_PF3_WUF18_MASK | LLWU_PF3_WUF19_MASK | LLWU_PF3_WUF20_MASK | LLWU_PF3_WUF21_MASK | LLWU_PF3_WUF22_MASK | LLWU_PF3_WUF23_MASK), LLWU_PF3_WUF17(value)))
#define LLWU_BWR_PF3_WUF17(base, value) (BME_BFI8(&LLWU_PF3_REG(base), ((uint8_t)(value) << LLWU_PF3_WUF17_SHIFT), LLWU_PF3_WUF17_SHIFT, LLWU_PF3_WUF17_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PF3, field WUF18[2] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag write a one to WUF18.
 *
 * Values:
 * - 0b0 - LLWU_P18 input was not a wakeup source
 * - 0b1 - LLWU_P18 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_PF3_WUF18 field. */
#define LLWU_RD_PF3_WUF18(base) ((LLWU_PF3_REG(base) & LLWU_PF3_WUF18_MASK) >> LLWU_PF3_WUF18_SHIFT)
#define LLWU_BRD_PF3_WUF18(base) (BME_UBFX8(&LLWU_PF3_REG(base), LLWU_PF3_WUF18_SHIFT, LLWU_PF3_WUF18_WIDTH))

/*! @brief Set the WUF18 field to a new value. */
#define LLWU_WR_PF3_WUF18(base, value) (LLWU_RMW_PF3(base, (LLWU_PF3_WUF18_MASK | LLWU_PF3_WUF16_MASK | LLWU_PF3_WUF17_MASK | LLWU_PF3_WUF19_MASK | LLWU_PF3_WUF20_MASK | LLWU_PF3_WUF21_MASK | LLWU_PF3_WUF22_MASK | LLWU_PF3_WUF23_MASK), LLWU_PF3_WUF18(value)))
#define LLWU_BWR_PF3_WUF18(base, value) (BME_BFI8(&LLWU_PF3_REG(base), ((uint8_t)(value) << LLWU_PF3_WUF18_SHIFT), LLWU_PF3_WUF18_SHIFT, LLWU_PF3_WUF18_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PF3, field WUF19[3] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag write a one to WUF19.
 *
 * Values:
 * - 0b0 - LLWU_P19 input was not a wakeup source
 * - 0b1 - LLWU_P19 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_PF3_WUF19 field. */
#define LLWU_RD_PF3_WUF19(base) ((LLWU_PF3_REG(base) & LLWU_PF3_WUF19_MASK) >> LLWU_PF3_WUF19_SHIFT)
#define LLWU_BRD_PF3_WUF19(base) (BME_UBFX8(&LLWU_PF3_REG(base), LLWU_PF3_WUF19_SHIFT, LLWU_PF3_WUF19_WIDTH))

/*! @brief Set the WUF19 field to a new value. */
#define LLWU_WR_PF3_WUF19(base, value) (LLWU_RMW_PF3(base, (LLWU_PF3_WUF19_MASK | LLWU_PF3_WUF16_MASK | LLWU_PF3_WUF17_MASK | LLWU_PF3_WUF18_MASK | LLWU_PF3_WUF20_MASK | LLWU_PF3_WUF21_MASK | LLWU_PF3_WUF22_MASK | LLWU_PF3_WUF23_MASK), LLWU_PF3_WUF19(value)))
#define LLWU_BWR_PF3_WUF19(base, value) (BME_BFI8(&LLWU_PF3_REG(base), ((uint8_t)(value) << LLWU_PF3_WUF19_SHIFT), LLWU_PF3_WUF19_SHIFT, LLWU_PF3_WUF19_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PF3, field WUF20[4] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag write a one to WUF20.
 *
 * Values:
 * - 0b0 - LLWU_P20 input was not a wakeup source
 * - 0b1 - LLWU_P20 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_PF3_WUF20 field. */
#define LLWU_RD_PF3_WUF20(base) ((LLWU_PF3_REG(base) & LLWU_PF3_WUF20_MASK) >> LLWU_PF3_WUF20_SHIFT)
#define LLWU_BRD_PF3_WUF20(base) (BME_UBFX8(&LLWU_PF3_REG(base), LLWU_PF3_WUF20_SHIFT, LLWU_PF3_WUF20_WIDTH))

/*! @brief Set the WUF20 field to a new value. */
#define LLWU_WR_PF3_WUF20(base, value) (LLWU_RMW_PF3(base, (LLWU_PF3_WUF20_MASK | LLWU_PF3_WUF16_MASK | LLWU_PF3_WUF17_MASK | LLWU_PF3_WUF18_MASK | LLWU_PF3_WUF19_MASK | LLWU_PF3_WUF21_MASK | LLWU_PF3_WUF22_MASK | LLWU_PF3_WUF23_MASK), LLWU_PF3_WUF20(value)))
#define LLWU_BWR_PF3_WUF20(base, value) (BME_BFI8(&LLWU_PF3_REG(base), ((uint8_t)(value) << LLWU_PF3_WUF20_SHIFT), LLWU_PF3_WUF20_SHIFT, LLWU_PF3_WUF20_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PF3, field WUF21[5] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag write a one to WUF21.
 *
 * Values:
 * - 0b0 - LLWU_P21 input was not a wakeup source
 * - 0b1 - LLWU_P21 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_PF3_WUF21 field. */
#define LLWU_RD_PF3_WUF21(base) ((LLWU_PF3_REG(base) & LLWU_PF3_WUF21_MASK) >> LLWU_PF3_WUF21_SHIFT)
#define LLWU_BRD_PF3_WUF21(base) (BME_UBFX8(&LLWU_PF3_REG(base), LLWU_PF3_WUF21_SHIFT, LLWU_PF3_WUF21_WIDTH))

/*! @brief Set the WUF21 field to a new value. */
#define LLWU_WR_PF3_WUF21(base, value) (LLWU_RMW_PF3(base, (LLWU_PF3_WUF21_MASK | LLWU_PF3_WUF16_MASK | LLWU_PF3_WUF17_MASK | LLWU_PF3_WUF18_MASK | LLWU_PF3_WUF19_MASK | LLWU_PF3_WUF20_MASK | LLWU_PF3_WUF22_MASK | LLWU_PF3_WUF23_MASK), LLWU_PF3_WUF21(value)))
#define LLWU_BWR_PF3_WUF21(base, value) (BME_BFI8(&LLWU_PF3_REG(base), ((uint8_t)(value) << LLWU_PF3_WUF21_SHIFT), LLWU_PF3_WUF21_SHIFT, LLWU_PF3_WUF21_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PF3, field WUF22[6] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag write a one to WUF22.
 *
 * Values:
 * - 0b0 - LLWU_P22 input was not a wakeup source
 * - 0b1 - LLWU_P22 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_PF3_WUF22 field. */
#define LLWU_RD_PF3_WUF22(base) ((LLWU_PF3_REG(base) & LLWU_PF3_WUF22_MASK) >> LLWU_PF3_WUF22_SHIFT)
#define LLWU_BRD_PF3_WUF22(base) (BME_UBFX8(&LLWU_PF3_REG(base), LLWU_PF3_WUF22_SHIFT, LLWU_PF3_WUF22_WIDTH))

/*! @brief Set the WUF22 field to a new value. */
#define LLWU_WR_PF3_WUF22(base, value) (LLWU_RMW_PF3(base, (LLWU_PF3_WUF22_MASK | LLWU_PF3_WUF16_MASK | LLWU_PF3_WUF17_MASK | LLWU_PF3_WUF18_MASK | LLWU_PF3_WUF19_MASK | LLWU_PF3_WUF20_MASK | LLWU_PF3_WUF21_MASK | LLWU_PF3_WUF23_MASK), LLWU_PF3_WUF22(value)))
#define LLWU_BWR_PF3_WUF22(base, value) (BME_BFI8(&LLWU_PF3_REG(base), ((uint8_t)(value) << LLWU_PF3_WUF22_SHIFT), LLWU_PF3_WUF22_SHIFT, LLWU_PF3_WUF22_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PF3, field WUF23[7] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag write a one to WUF23.
 *
 * Values:
 * - 0b0 - LLWU_P23 input was not a wakeup source
 * - 0b1 - LLWU_P23 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_PF3_WUF23 field. */
#define LLWU_RD_PF3_WUF23(base) ((LLWU_PF3_REG(base) & LLWU_PF3_WUF23_MASK) >> LLWU_PF3_WUF23_SHIFT)
#define LLWU_BRD_PF3_WUF23(base) (BME_UBFX8(&LLWU_PF3_REG(base), LLWU_PF3_WUF23_SHIFT, LLWU_PF3_WUF23_WIDTH))

/*! @brief Set the WUF23 field to a new value. */
#define LLWU_WR_PF3_WUF23(base, value) (LLWU_RMW_PF3(base, (LLWU_PF3_WUF23_MASK | LLWU_PF3_WUF16_MASK | LLWU_PF3_WUF17_MASK | LLWU_PF3_WUF18_MASK | LLWU_PF3_WUF19_MASK | LLWU_PF3_WUF20_MASK | LLWU_PF3_WUF21_MASK | LLWU_PF3_WUF22_MASK), LLWU_PF3_WUF23(value)))
#define LLWU_BWR_PF3_WUF23(base, value) (BME_BFI8(&LLWU_PF3_REG(base), ((uint8_t)(value) << LLWU_PF3_WUF23_SHIFT), LLWU_PF3_WUF23_SHIFT, LLWU_PF3_WUF23_WIDTH))
/*@}*/

/*******************************************************************************
 * LLWU_MF5 - LLWU Module Flag 5 register
 ******************************************************************************/

/*!
 * @brief LLWU_MF5 - LLWU Module Flag 5 register (RO)
 *
 * Reset value: 0x00U
 *
 * LLWU_MF5 contains the wakeup flags indicating which internal wakeup source
 * caused the MCU to exit VLLS mode. For VLLS, this is the source causing the MCU
 * reset flow. For internal peripherals that are capable of running in a
 * low-leakage power mode, such as a real time clock module or CMP module, the flag from
 * the associated peripheral is accessible as the MWUFx bit. The flag will need to
 * be cleared in the peripheral instead of writing a 1 to the MWUFx bit. This
 * register is reset on Chip Reset not VLLS and by reset types that trigger Chip
 * Reset not VLLS. It is unaffected by reset types that do not trigger Chip Reset
 * not VLLS. See the IntroductionInformation found here describes the registers of
 * the Reset Control Module (RCM). The RCM implements many of the reset
 * functions for the chip. See the chip's reset chapter for more information. details for
 * more information.
 */
/*!
 * @name Constants and macros for entire LLWU_MF5 register
 */
/*@{*/
#define LLWU_RD_MF5(base)        (LLWU_MF5_REG(base))
/*@}*/

/*
 * Constants & macros for individual LLWU_MF5 bitfields
 */

/*!
 * @name Register LLWU_MF5, field MWUF0[0] (RO)
 *
 * Indicates that an enabled internal peripheral was a source of exiting a
 * low-leakage power mode. To clear the flag, follow the internal peripheral flag
 * clearing mechanism.
 *
 * Values:
 * - 0b0 - Module 0 input was not a wakeup source
 * - 0b1 - Module 0 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_MF5_MWUF0 field. */
#define LLWU_RD_MF5_MWUF0(base) ((LLWU_MF5_REG(base) & LLWU_MF5_MWUF0_MASK) >> LLWU_MF5_MWUF0_SHIFT)
#define LLWU_BRD_MF5_MWUF0(base) (BME_UBFX8(&LLWU_MF5_REG(base), LLWU_MF5_MWUF0_SHIFT, LLWU_MF5_MWUF0_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_MF5, field MWUF1[1] (RO)
 *
 * Indicates that an enabled internal peripheral was a source of exiting a
 * low-leakage power mode. To clear the flag, follow the internal peripheral flag
 * clearing mechanism.
 *
 * Values:
 * - 0b0 - Module 1 input was not a wakeup source
 * - 0b1 - Module 1 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_MF5_MWUF1 field. */
#define LLWU_RD_MF5_MWUF1(base) ((LLWU_MF5_REG(base) & LLWU_MF5_MWUF1_MASK) >> LLWU_MF5_MWUF1_SHIFT)
#define LLWU_BRD_MF5_MWUF1(base) (BME_UBFX8(&LLWU_MF5_REG(base), LLWU_MF5_MWUF1_SHIFT, LLWU_MF5_MWUF1_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_MF5, field MWUF2[2] (RO)
 *
 * Indicates that an enabled internal peripheral was a source of exiting a
 * low-leakage power mode. To clear the flag, follow the internal peripheral flag
 * clearing mechanism.
 *
 * Values:
 * - 0b0 - Module 2 input was not a wakeup source
 * - 0b1 - Module 2 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_MF5_MWUF2 field. */
#define LLWU_RD_MF5_MWUF2(base) ((LLWU_MF5_REG(base) & LLWU_MF5_MWUF2_MASK) >> LLWU_MF5_MWUF2_SHIFT)
#define LLWU_BRD_MF5_MWUF2(base) (BME_UBFX8(&LLWU_MF5_REG(base), LLWU_MF5_MWUF2_SHIFT, LLWU_MF5_MWUF2_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_MF5, field MWUF3[3] (RO)
 *
 * Indicates that an enabled internal peripheral was a source of exiting a
 * low-leakage power mode. To clear the flag, follow the internal peripheral flag
 * clearing mechanism.
 *
 * Values:
 * - 0b0 - Module 3 input was not a wakeup source
 * - 0b1 - Module 3 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_MF5_MWUF3 field. */
#define LLWU_RD_MF5_MWUF3(base) ((LLWU_MF5_REG(base) & LLWU_MF5_MWUF3_MASK) >> LLWU_MF5_MWUF3_SHIFT)
#define LLWU_BRD_MF5_MWUF3(base) (BME_UBFX8(&LLWU_MF5_REG(base), LLWU_MF5_MWUF3_SHIFT, LLWU_MF5_MWUF3_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_MF5, field MWUF4[4] (RO)
 *
 * Indicates that an enabled internal peripheral was a source of exiting a
 * low-leakage power mode. To clear the flag, follow the internal peripheral flag
 * clearing mechanism.
 *
 * Values:
 * - 0b0 - Module 4 input was not a wakeup source
 * - 0b1 - Module 4 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_MF5_MWUF4 field. */
#define LLWU_RD_MF5_MWUF4(base) ((LLWU_MF5_REG(base) & LLWU_MF5_MWUF4_MASK) >> LLWU_MF5_MWUF4_SHIFT)
#define LLWU_BRD_MF5_MWUF4(base) (BME_UBFX8(&LLWU_MF5_REG(base), LLWU_MF5_MWUF4_SHIFT, LLWU_MF5_MWUF4_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_MF5, field MWUF5[5] (RO)
 *
 * Indicates that an enabled internal peripheral was a source of exiting a
 * low-leakage power mode. To clear the flag, follow the internal peripheral flag
 * clearing mechanism.
 *
 * Values:
 * - 0b0 - Module 5 input was not a wakeup source
 * - 0b1 - Module 5 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_MF5_MWUF5 field. */
#define LLWU_RD_MF5_MWUF5(base) ((LLWU_MF5_REG(base) & LLWU_MF5_MWUF5_MASK) >> LLWU_MF5_MWUF5_SHIFT)
#define LLWU_BRD_MF5_MWUF5(base) (BME_UBFX8(&LLWU_MF5_REG(base), LLWU_MF5_MWUF5_SHIFT, LLWU_MF5_MWUF5_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_MF5, field MWUF6[6] (RO)
 *
 * Indicates that an enabled internal peripheral was a source of exiting a
 * low-leakage power mode. To clear the flag, follow the internal peripheral flag
 * clearing mechanism.
 *
 * Values:
 * - 0b0 - Module 6 input was not a wakeup source
 * - 0b1 - Module 6 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_MF5_MWUF6 field. */
#define LLWU_RD_MF5_MWUF6(base) ((LLWU_MF5_REG(base) & LLWU_MF5_MWUF6_MASK) >> LLWU_MF5_MWUF6_SHIFT)
#define LLWU_BRD_MF5_MWUF6(base) (BME_UBFX8(&LLWU_MF5_REG(base), LLWU_MF5_MWUF6_SHIFT, LLWU_MF5_MWUF6_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_MF5, field MWUF7[7] (RO)
 *
 * Indicates that an enabled internal peripheral was a source of exiting a
 * low-leakage power mode. To clear the flag, follow the internal peripheral flag
 * clearing mechanism.
 *
 * Values:
 * - 0b0 - Module 7 input was not a wakeup source
 * - 0b1 - Module 7 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_MF5_MWUF7 field. */
#define LLWU_RD_MF5_MWUF7(base) ((LLWU_MF5_REG(base) & LLWU_MF5_MWUF7_MASK) >> LLWU_MF5_MWUF7_SHIFT)
#define LLWU_BRD_MF5_MWUF7(base) (BME_UBFX8(&LLWU_MF5_REG(base), LLWU_MF5_MWUF7_SHIFT, LLWU_MF5_MWUF7_WIDTH))
/*@}*/

/*******************************************************************************
 * LLWU_FILT1 - LLWU Pin Filter 1 register
 ******************************************************************************/

/*!
 * @brief LLWU_FILT1 - LLWU Pin Filter 1 register (RW)
 *
 * Reset value: 0x00U
 *
 * LLWU_FILT1 is a control and status register that is used to enable/disable
 * the digital filter 1 features for an external pin. This register is reset on
 * Chip Reset not VLLS and by reset types that trigger Chip Reset not VLLS. It is
 * unaffected by reset types that do not trigger Chip Reset not VLLS. See the
 * IntroductionInformation found here describes the registers of the Reset Control
 * Module (RCM). The RCM implements many of the reset functions for the chip. See
 * the chip's reset chapter for more information. details for more information.
 */
/*!
 * @name Constants and macros for entire LLWU_FILT1 register
 */
/*@{*/
#define LLWU_RD_FILT1(base)      (LLWU_FILT1_REG(base))
#define LLWU_WR_FILT1(base, value) (LLWU_FILT1_REG(base) = (value))
#define LLWU_RMW_FILT1(base, mask, value) (LLWU_WR_FILT1(base, (LLWU_RD_FILT1(base) & ~(mask)) | (value)))
#define LLWU_SET_FILT1(base, value) (BME_OR8(&LLWU_FILT1_REG(base), (uint8_t)(value)))
#define LLWU_CLR_FILT1(base, value) (BME_AND8(&LLWU_FILT1_REG(base), (uint8_t)(~(value))))
#define LLWU_TOG_FILT1(base, value) (BME_XOR8(&LLWU_FILT1_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual LLWU_FILT1 bitfields
 */

/*!
 * @name Register LLWU_FILT1, field FILTSEL[4:0] (RW)
 *
 * Selects 1 of the wakeup pins to be muxed into the filter.
 *
 * Values:
 * - 0b00000 - Select LLWU_P0 for filter
 * - 0b11111 - Select LLWU_P31 for filter
 */
/*@{*/
/*! @brief Read current value of the LLWU_FILT1_FILTSEL field. */
#define LLWU_RD_FILT1_FILTSEL(base) ((LLWU_FILT1_REG(base) & LLWU_FILT1_FILTSEL_MASK) >> LLWU_FILT1_FILTSEL_SHIFT)
#define LLWU_BRD_FILT1_FILTSEL(base) (BME_UBFX8(&LLWU_FILT1_REG(base), LLWU_FILT1_FILTSEL_SHIFT, LLWU_FILT1_FILTSEL_WIDTH))

/*! @brief Set the FILTSEL field to a new value. */
#define LLWU_WR_FILT1_FILTSEL(base, value) (LLWU_RMW_FILT1(base, (LLWU_FILT1_FILTSEL_MASK | LLWU_FILT1_FILTF_MASK), LLWU_FILT1_FILTSEL(value)))
#define LLWU_BWR_FILT1_FILTSEL(base, value) (BME_BFI8(&LLWU_FILT1_REG(base), ((uint8_t)(value) << LLWU_FILT1_FILTSEL_SHIFT), LLWU_FILT1_FILTSEL_SHIFT, LLWU_FILT1_FILTSEL_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_FILT1, field FILTE[6:5] (RW)
 *
 * Controls the digital filter options for the external pin detect.
 *
 * Values:
 * - 0b00 - Filter disabled
 * - 0b01 - Filter posedge detect enabled
 * - 0b10 - Filter negedge detect enabled
 * - 0b11 - Filter any edge detect enabled
 */
/*@{*/
/*! @brief Read current value of the LLWU_FILT1_FILTE field. */
#define LLWU_RD_FILT1_FILTE(base) ((LLWU_FILT1_REG(base) & LLWU_FILT1_FILTE_MASK) >> LLWU_FILT1_FILTE_SHIFT)
#define LLWU_BRD_FILT1_FILTE(base) (BME_UBFX8(&LLWU_FILT1_REG(base), LLWU_FILT1_FILTE_SHIFT, LLWU_FILT1_FILTE_WIDTH))

/*! @brief Set the FILTE field to a new value. */
#define LLWU_WR_FILT1_FILTE(base, value) (LLWU_RMW_FILT1(base, (LLWU_FILT1_FILTE_MASK | LLWU_FILT1_FILTF_MASK), LLWU_FILT1_FILTE(value)))
#define LLWU_BWR_FILT1_FILTE(base, value) (BME_BFI8(&LLWU_FILT1_REG(base), ((uint8_t)(value) << LLWU_FILT1_FILTE_SHIFT), LLWU_FILT1_FILTE_SHIFT, LLWU_FILT1_FILTE_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_FILT1, field FILTF[7] (W1C)
 *
 * Indicates that the filtered external wakeup pin, selected by FILTSEL, was a
 * source of exiting a low-leakage power mode. To clear the flag write a one to
 * FILTF.
 *
 * Values:
 * - 0b0 - Pin Filter 1 was not a wakeup source
 * - 0b1 - Pin Filter 1 was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_FILT1_FILTF field. */
#define LLWU_RD_FILT1_FILTF(base) ((LLWU_FILT1_REG(base) & LLWU_FILT1_FILTF_MASK) >> LLWU_FILT1_FILTF_SHIFT)
#define LLWU_BRD_FILT1_FILTF(base) (BME_UBFX8(&LLWU_FILT1_REG(base), LLWU_FILT1_FILTF_SHIFT, LLWU_FILT1_FILTF_WIDTH))

/*! @brief Set the FILTF field to a new value. */
#define LLWU_WR_FILT1_FILTF(base, value) (LLWU_RMW_FILT1(base, LLWU_FILT1_FILTF_MASK, LLWU_FILT1_FILTF(value)))
#define LLWU_BWR_FILT1_FILTF(base, value) (BME_BFI8(&LLWU_FILT1_REG(base), ((uint8_t)(value) << LLWU_FILT1_FILTF_SHIFT), LLWU_FILT1_FILTF_SHIFT, LLWU_FILT1_FILTF_WIDTH))
/*@}*/

/*******************************************************************************
 * LLWU_FILT2 - LLWU Pin Filter 2 register
 ******************************************************************************/

/*!
 * @brief LLWU_FILT2 - LLWU Pin Filter 2 register (RW)
 *
 * Reset value: 0x00U
 *
 * LLWU_FILT2 is a control and status register that is used to enable/disable
 * the digital filter 2 features for an external pin. This register is reset on
 * Chip Reset not VLLS and by reset types that trigger Chip Reset not VLLS. It is
 * unaffected by reset types that do not trigger Chip Reset not VLLS. See the
 * IntroductionInformation found here describes the registers of the Reset Control
 * Module (RCM). The RCM implements many of the reset functions for the chip. See
 * the chip's reset chapter for more information. details for more information.
 */
/*!
 * @name Constants and macros for entire LLWU_FILT2 register
 */
/*@{*/
#define LLWU_RD_FILT2(base)      (LLWU_FILT2_REG(base))
#define LLWU_WR_FILT2(base, value) (LLWU_FILT2_REG(base) = (value))
#define LLWU_RMW_FILT2(base, mask, value) (LLWU_WR_FILT2(base, (LLWU_RD_FILT2(base) & ~(mask)) | (value)))
#define LLWU_SET_FILT2(base, value) (BME_OR8(&LLWU_FILT2_REG(base), (uint8_t)(value)))
#define LLWU_CLR_FILT2(base, value) (BME_AND8(&LLWU_FILT2_REG(base), (uint8_t)(~(value))))
#define LLWU_TOG_FILT2(base, value) (BME_XOR8(&LLWU_FILT2_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual LLWU_FILT2 bitfields
 */

/*!
 * @name Register LLWU_FILT2, field FILTSEL[4:0] (RW)
 *
 * Selects 1 of the wakeup pins to be muxed into the filter.
 *
 * Values:
 * - 0b00000 - Select LLWU_P0 for filter
 * - 0b11111 - Select LLWU_P31 for filter
 */
/*@{*/
/*! @brief Read current value of the LLWU_FILT2_FILTSEL field. */
#define LLWU_RD_FILT2_FILTSEL(base) ((LLWU_FILT2_REG(base) & LLWU_FILT2_FILTSEL_MASK) >> LLWU_FILT2_FILTSEL_SHIFT)
#define LLWU_BRD_FILT2_FILTSEL(base) (BME_UBFX8(&LLWU_FILT2_REG(base), LLWU_FILT2_FILTSEL_SHIFT, LLWU_FILT2_FILTSEL_WIDTH))

/*! @brief Set the FILTSEL field to a new value. */
#define LLWU_WR_FILT2_FILTSEL(base, value) (LLWU_RMW_FILT2(base, (LLWU_FILT2_FILTSEL_MASK | LLWU_FILT2_FILTF_MASK), LLWU_FILT2_FILTSEL(value)))
#define LLWU_BWR_FILT2_FILTSEL(base, value) (BME_BFI8(&LLWU_FILT2_REG(base), ((uint8_t)(value) << LLWU_FILT2_FILTSEL_SHIFT), LLWU_FILT2_FILTSEL_SHIFT, LLWU_FILT2_FILTSEL_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_FILT2, field FILTE[6:5] (RW)
 *
 * Controls the digital filter options for the external pin detect.
 *
 * Values:
 * - 0b00 - Filter disabled
 * - 0b01 - Filter posedge detect enabled
 * - 0b10 - Filter negedge detect enabled
 * - 0b11 - Filter any edge detect enabled
 */
/*@{*/
/*! @brief Read current value of the LLWU_FILT2_FILTE field. */
#define LLWU_RD_FILT2_FILTE(base) ((LLWU_FILT2_REG(base) & LLWU_FILT2_FILTE_MASK) >> LLWU_FILT2_FILTE_SHIFT)
#define LLWU_BRD_FILT2_FILTE(base) (BME_UBFX8(&LLWU_FILT2_REG(base), LLWU_FILT2_FILTE_SHIFT, LLWU_FILT2_FILTE_WIDTH))

/*! @brief Set the FILTE field to a new value. */
#define LLWU_WR_FILT2_FILTE(base, value) (LLWU_RMW_FILT2(base, (LLWU_FILT2_FILTE_MASK | LLWU_FILT2_FILTF_MASK), LLWU_FILT2_FILTE(value)))
#define LLWU_BWR_FILT2_FILTE(base, value) (BME_BFI8(&LLWU_FILT2_REG(base), ((uint8_t)(value) << LLWU_FILT2_FILTE_SHIFT), LLWU_FILT2_FILTE_SHIFT, LLWU_FILT2_FILTE_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_FILT2, field FILTF[7] (W1C)
 *
 * Indicates that the filtered external wakeup pin, selected by FILTSEL, was a
 * source of exiting a low-leakage power mode. To clear the flag write a one to
 * FILTF.
 *
 * Values:
 * - 0b0 - Pin Filter 2 was not a wakeup source
 * - 0b1 - Pin Filter 2 was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_FILT2_FILTF field. */
#define LLWU_RD_FILT2_FILTF(base) ((LLWU_FILT2_REG(base) & LLWU_FILT2_FILTF_MASK) >> LLWU_FILT2_FILTF_SHIFT)
#define LLWU_BRD_FILT2_FILTF(base) (BME_UBFX8(&LLWU_FILT2_REG(base), LLWU_FILT2_FILTF_SHIFT, LLWU_FILT2_FILTF_WIDTH))

/*! @brief Set the FILTF field to a new value. */
#define LLWU_WR_FILT2_FILTF(base, value) (LLWU_RMW_FILT2(base, LLWU_FILT2_FILTF_MASK, LLWU_FILT2_FILTF(value)))
#define LLWU_BWR_FILT2_FILTF(base, value) (BME_BFI8(&LLWU_FILT2_REG(base), ((uint8_t)(value) << LLWU_FILT2_FILTF_SHIFT), LLWU_FILT2_FILTF_SHIFT, LLWU_FILT2_FILTF_WIDTH))
/*@}*/

/*
 * MKM34Z7 LPTMR
 *
 * Low Power Timer
 *
 * Registers defined in this header file:
 * - LPTMR_CSR - Low Power Timer Control Status Register
 * - LPTMR_PSR - Low Power Timer Prescale Register
 * - LPTMR_CMR - Low Power Timer Compare Register
 * - LPTMR_CNR - Low Power Timer Counter Register
 */

#define LPTMR_INSTANCE_COUNT (1U) /*!< Number of instances of the LPTMR module. */
#define LPTMR0_IDX (0U) /*!< Instance number for LPTMR0. */

/*******************************************************************************
 * LPTMR_CSR - Low Power Timer Control Status Register
 ******************************************************************************/

/*!
 * @brief LPTMR_CSR - Low Power Timer Control Status Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire LPTMR_CSR register
 */
/*@{*/
#define LPTMR_RD_CSR(base)       (LPTMR_CSR_REG(base))
#define LPTMR_WR_CSR(base, value) (LPTMR_CSR_REG(base) = (value))
#define LPTMR_RMW_CSR(base, mask, value) (LPTMR_WR_CSR(base, (LPTMR_RD_CSR(base) & ~(mask)) | (value)))
#define LPTMR_SET_CSR(base, value) (BME_OR32(&LPTMR_CSR_REG(base), (uint32_t)(value)))
#define LPTMR_CLR_CSR(base, value) (BME_AND32(&LPTMR_CSR_REG(base), (uint32_t)(~(value))))
#define LPTMR_TOG_CSR(base, value) (BME_XOR32(&LPTMR_CSR_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual LPTMR_CSR bitfields
 */

/*!
 * @name Register LPTMR_CSR, field TEN[0] (RW)
 *
 * When TEN is clear, it resets the LPTMR internal logic, including the CNR and
 * TCF. When TEN is set, the LPTMR is enabled. While writing 1 to this field,
 * CSR[5:1] must not be altered.
 *
 * Values:
 * - 0b0 - LPTMR is disabled and internal logic is reset.
 * - 0b1 - LPTMR is enabled.
 */
/*@{*/
/*! @brief Read current value of the LPTMR_CSR_TEN field. */
#define LPTMR_RD_CSR_TEN(base) ((LPTMR_CSR_REG(base) & LPTMR_CSR_TEN_MASK) >> LPTMR_CSR_TEN_SHIFT)
#define LPTMR_BRD_CSR_TEN(base) (BME_UBFX32(&LPTMR_CSR_REG(base), LPTMR_CSR_TEN_SHIFT, LPTMR_CSR_TEN_WIDTH))

/*! @brief Set the TEN field to a new value. */
#define LPTMR_WR_CSR_TEN(base, value) (LPTMR_RMW_CSR(base, (LPTMR_CSR_TEN_MASK | LPTMR_CSR_TCF_MASK), LPTMR_CSR_TEN(value)))
#define LPTMR_BWR_CSR_TEN(base, value) (BME_BFI32(&LPTMR_CSR_REG(base), ((uint32_t)(value) << LPTMR_CSR_TEN_SHIFT), LPTMR_CSR_TEN_SHIFT, LPTMR_CSR_TEN_WIDTH))
/*@}*/

/*!
 * @name Register LPTMR_CSR, field TMS[1] (RW)
 *
 * Configures the mode of the LPTMR. TMS must be altered only when the LPTMR is
 * disabled.
 *
 * Values:
 * - 0b0 - Time Counter mode.
 * - 0b1 - Pulse Counter mode.
 */
/*@{*/
/*! @brief Read current value of the LPTMR_CSR_TMS field. */
#define LPTMR_RD_CSR_TMS(base) ((LPTMR_CSR_REG(base) & LPTMR_CSR_TMS_MASK) >> LPTMR_CSR_TMS_SHIFT)
#define LPTMR_BRD_CSR_TMS(base) (BME_UBFX32(&LPTMR_CSR_REG(base), LPTMR_CSR_TMS_SHIFT, LPTMR_CSR_TMS_WIDTH))

/*! @brief Set the TMS field to a new value. */
#define LPTMR_WR_CSR_TMS(base, value) (LPTMR_RMW_CSR(base, (LPTMR_CSR_TMS_MASK | LPTMR_CSR_TCF_MASK), LPTMR_CSR_TMS(value)))
#define LPTMR_BWR_CSR_TMS(base, value) (BME_BFI32(&LPTMR_CSR_REG(base), ((uint32_t)(value) << LPTMR_CSR_TMS_SHIFT), LPTMR_CSR_TMS_SHIFT, LPTMR_CSR_TMS_WIDTH))
/*@}*/

/*!
 * @name Register LPTMR_CSR, field TFC[2] (RW)
 *
 * When clear, TFC configures the CNR to reset whenever TCF is set. When set,
 * TFC configures the CNR to reset on overflow. TFC must be altered only when the
 * LPTMR is disabled.
 *
 * Values:
 * - 0b0 - CNR is reset whenever TCF is set.
 * - 0b1 - CNR is reset on overflow.
 */
/*@{*/
/*! @brief Read current value of the LPTMR_CSR_TFC field. */
#define LPTMR_RD_CSR_TFC(base) ((LPTMR_CSR_REG(base) & LPTMR_CSR_TFC_MASK) >> LPTMR_CSR_TFC_SHIFT)
#define LPTMR_BRD_CSR_TFC(base) (BME_UBFX32(&LPTMR_CSR_REG(base), LPTMR_CSR_TFC_SHIFT, LPTMR_CSR_TFC_WIDTH))

/*! @brief Set the TFC field to a new value. */
#define LPTMR_WR_CSR_TFC(base, value) (LPTMR_RMW_CSR(base, (LPTMR_CSR_TFC_MASK | LPTMR_CSR_TCF_MASK), LPTMR_CSR_TFC(value)))
#define LPTMR_BWR_CSR_TFC(base, value) (BME_BFI32(&LPTMR_CSR_REG(base), ((uint32_t)(value) << LPTMR_CSR_TFC_SHIFT), LPTMR_CSR_TFC_SHIFT, LPTMR_CSR_TFC_WIDTH))
/*@}*/

/*!
 * @name Register LPTMR_CSR, field TPP[3] (RW)
 *
 * Configures the polarity of the input source in Pulse Counter mode. TPP must
 * be changed only when the LPTMR is disabled.
 *
 * Values:
 * - 0b0 - Pulse Counter input source is active-high, and the CNR will increment
 *     on the rising-edge.
 * - 0b1 - Pulse Counter input source is active-low, and the CNR will increment
 *     on the falling-edge.
 */
/*@{*/
/*! @brief Read current value of the LPTMR_CSR_TPP field. */
#define LPTMR_RD_CSR_TPP(base) ((LPTMR_CSR_REG(base) & LPTMR_CSR_TPP_MASK) >> LPTMR_CSR_TPP_SHIFT)
#define LPTMR_BRD_CSR_TPP(base) (BME_UBFX32(&LPTMR_CSR_REG(base), LPTMR_CSR_TPP_SHIFT, LPTMR_CSR_TPP_WIDTH))

/*! @brief Set the TPP field to a new value. */
#define LPTMR_WR_CSR_TPP(base, value) (LPTMR_RMW_CSR(base, (LPTMR_CSR_TPP_MASK | LPTMR_CSR_TCF_MASK), LPTMR_CSR_TPP(value)))
#define LPTMR_BWR_CSR_TPP(base, value) (BME_BFI32(&LPTMR_CSR_REG(base), ((uint32_t)(value) << LPTMR_CSR_TPP_SHIFT), LPTMR_CSR_TPP_SHIFT, LPTMR_CSR_TPP_WIDTH))
/*@}*/

/*!
 * @name Register LPTMR_CSR, field TPS[5:4] (RW)
 *
 * Configures the input source to be used in Pulse Counter mode. TPS must be
 * altered only when the LPTMR is disabled. The input connections vary by device.
 * See the for information on the connections to these inputs.
 *
 * Values:
 * - 0b00 - Pulse counter input 0 is selected.
 * - 0b01 - Pulse counter input 1 is selected.
 * - 0b10 - Pulse counter input 2 is selected.
 * - 0b11 - Pulse counter input 3 is selected.
 */
/*@{*/
/*! @brief Read current value of the LPTMR_CSR_TPS field. */
#define LPTMR_RD_CSR_TPS(base) ((LPTMR_CSR_REG(base) & LPTMR_CSR_TPS_MASK) >> LPTMR_CSR_TPS_SHIFT)
#define LPTMR_BRD_CSR_TPS(base) (BME_UBFX32(&LPTMR_CSR_REG(base), LPTMR_CSR_TPS_SHIFT, LPTMR_CSR_TPS_WIDTH))

/*! @brief Set the TPS field to a new value. */
#define LPTMR_WR_CSR_TPS(base, value) (LPTMR_RMW_CSR(base, (LPTMR_CSR_TPS_MASK | LPTMR_CSR_TCF_MASK), LPTMR_CSR_TPS(value)))
#define LPTMR_BWR_CSR_TPS(base, value) (BME_BFI32(&LPTMR_CSR_REG(base), ((uint32_t)(value) << LPTMR_CSR_TPS_SHIFT), LPTMR_CSR_TPS_SHIFT, LPTMR_CSR_TPS_WIDTH))
/*@}*/

/*!
 * @name Register LPTMR_CSR, field TIE[6] (RW)
 *
 * When TIE is set, the LPTMR Interrupt is generated whenever TCF is also set.
 *
 * Values:
 * - 0b0 - Timer interrupt disabled.
 * - 0b1 - Timer interrupt enabled.
 */
/*@{*/
/*! @brief Read current value of the LPTMR_CSR_TIE field. */
#define LPTMR_RD_CSR_TIE(base) ((LPTMR_CSR_REG(base) & LPTMR_CSR_TIE_MASK) >> LPTMR_CSR_TIE_SHIFT)
#define LPTMR_BRD_CSR_TIE(base) (BME_UBFX32(&LPTMR_CSR_REG(base), LPTMR_CSR_TIE_SHIFT, LPTMR_CSR_TIE_WIDTH))

/*! @brief Set the TIE field to a new value. */
#define LPTMR_WR_CSR_TIE(base, value) (LPTMR_RMW_CSR(base, (LPTMR_CSR_TIE_MASK | LPTMR_CSR_TCF_MASK), LPTMR_CSR_TIE(value)))
#define LPTMR_BWR_CSR_TIE(base, value) (BME_BFI32(&LPTMR_CSR_REG(base), ((uint32_t)(value) << LPTMR_CSR_TIE_SHIFT), LPTMR_CSR_TIE_SHIFT, LPTMR_CSR_TIE_WIDTH))
/*@}*/

/*!
 * @name Register LPTMR_CSR, field TCF[7] (W1C)
 *
 * TCF is set when the LPTMR is enabled and the CNR equals the CMR and
 * increments. TCF is cleared when the LPTMR is disabled or a logic 1 is written to it.
 *
 * Values:
 * - 0b0 - The value of CNR is not equal to CMR and increments.
 * - 0b1 - The value of CNR is equal to CMR and increments.
 */
/*@{*/
/*! @brief Read current value of the LPTMR_CSR_TCF field. */
#define LPTMR_RD_CSR_TCF(base) ((LPTMR_CSR_REG(base) & LPTMR_CSR_TCF_MASK) >> LPTMR_CSR_TCF_SHIFT)
#define LPTMR_BRD_CSR_TCF(base) (BME_UBFX32(&LPTMR_CSR_REG(base), LPTMR_CSR_TCF_SHIFT, LPTMR_CSR_TCF_WIDTH))

/*! @brief Set the TCF field to a new value. */
#define LPTMR_WR_CSR_TCF(base, value) (LPTMR_RMW_CSR(base, LPTMR_CSR_TCF_MASK, LPTMR_CSR_TCF(value)))
#define LPTMR_BWR_CSR_TCF(base, value) (BME_BFI32(&LPTMR_CSR_REG(base), ((uint32_t)(value) << LPTMR_CSR_TCF_SHIFT), LPTMR_CSR_TCF_SHIFT, LPTMR_CSR_TCF_WIDTH))
/*@}*/

/*******************************************************************************
 * LPTMR_PSR - Low Power Timer Prescale Register
 ******************************************************************************/

/*!
 * @brief LPTMR_PSR - Low Power Timer Prescale Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire LPTMR_PSR register
 */
/*@{*/
#define LPTMR_RD_PSR(base)       (LPTMR_PSR_REG(base))
#define LPTMR_WR_PSR(base, value) (LPTMR_PSR_REG(base) = (value))
#define LPTMR_RMW_PSR(base, mask, value) (LPTMR_WR_PSR(base, (LPTMR_RD_PSR(base) & ~(mask)) | (value)))
#define LPTMR_SET_PSR(base, value) (BME_OR32(&LPTMR_PSR_REG(base), (uint32_t)(value)))
#define LPTMR_CLR_PSR(base, value) (BME_AND32(&LPTMR_PSR_REG(base), (uint32_t)(~(value))))
#define LPTMR_TOG_PSR(base, value) (BME_XOR32(&LPTMR_PSR_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual LPTMR_PSR bitfields
 */

/*!
 * @name Register LPTMR_PSR, field PCS[1:0] (RW)
 *
 * Selects the clock to be used by the LPTMR prescaler/glitch filter. PCS must
 * be altered only when the LPTMR is disabled. The clock connections vary by
 * device. See the chip configuration details for information on the connections to
 * these inputs.
 *
 * Values:
 * - 0b00 - Prescaler/glitch filter clock 0 selected.
 * - 0b01 - Prescaler/glitch filter clock 1 selected.
 * - 0b10 - Prescaler/glitch filter clock 2 selected.
 * - 0b11 - Prescaler/glitch filter clock 3 selected.
 */
/*@{*/
/*! @brief Read current value of the LPTMR_PSR_PCS field. */
#define LPTMR_RD_PSR_PCS(base) ((LPTMR_PSR_REG(base) & LPTMR_PSR_PCS_MASK) >> LPTMR_PSR_PCS_SHIFT)
#define LPTMR_BRD_PSR_PCS(base) (BME_UBFX32(&LPTMR_PSR_REG(base), LPTMR_PSR_PCS_SHIFT, LPTMR_PSR_PCS_WIDTH))

/*! @brief Set the PCS field to a new value. */
#define LPTMR_WR_PSR_PCS(base, value) (LPTMR_RMW_PSR(base, LPTMR_PSR_PCS_MASK, LPTMR_PSR_PCS(value)))
#define LPTMR_BWR_PSR_PCS(base, value) (BME_BFI32(&LPTMR_PSR_REG(base), ((uint32_t)(value) << LPTMR_PSR_PCS_SHIFT), LPTMR_PSR_PCS_SHIFT, LPTMR_PSR_PCS_WIDTH))
/*@}*/

/*!
 * @name Register LPTMR_PSR, field PBYP[2] (RW)
 *
 * When PBYP is set, the selected prescaler clock in Time Counter mode or
 * selected input source in Pulse Counter mode directly clocks the CNR. When PBYP is
 * clear, the CNR is clocked by the output of the prescaler/glitch filter. PBYP
 * must be altered only when the LPTMR is disabled.
 *
 * Values:
 * - 0b0 - Prescaler/glitch filter is enabled.
 * - 0b1 - Prescaler/glitch filter is bypassed.
 */
/*@{*/
/*! @brief Read current value of the LPTMR_PSR_PBYP field. */
#define LPTMR_RD_PSR_PBYP(base) ((LPTMR_PSR_REG(base) & LPTMR_PSR_PBYP_MASK) >> LPTMR_PSR_PBYP_SHIFT)
#define LPTMR_BRD_PSR_PBYP(base) (BME_UBFX32(&LPTMR_PSR_REG(base), LPTMR_PSR_PBYP_SHIFT, LPTMR_PSR_PBYP_WIDTH))

/*! @brief Set the PBYP field to a new value. */
#define LPTMR_WR_PSR_PBYP(base, value) (LPTMR_RMW_PSR(base, LPTMR_PSR_PBYP_MASK, LPTMR_PSR_PBYP(value)))
#define LPTMR_BWR_PSR_PBYP(base, value) (BME_BFI32(&LPTMR_PSR_REG(base), ((uint32_t)(value) << LPTMR_PSR_PBYP_SHIFT), LPTMR_PSR_PBYP_SHIFT, LPTMR_PSR_PBYP_WIDTH))
/*@}*/

/*!
 * @name Register LPTMR_PSR, field PRESCALE[6:3] (RW)
 *
 * Configures the size of the Prescaler in Time Counter mode or width of the
 * glitch filter in Pulse Counter mode. PRESCALE must be altered only when the LPTMR
 * is disabled.
 *
 * Values:
 * - 0b0000 - Prescaler divides the prescaler clock by 2; glitch filter does not
 *     support this configuration.
 * - 0b0001 - Prescaler divides the prescaler clock by 4; glitch filter
 *     recognizes change on input pin after 2 rising clock edges.
 * - 0b0010 - Prescaler divides the prescaler clock by 8; glitch filter
 *     recognizes change on input pin after 4 rising clock edges.
 * - 0b0011 - Prescaler divides the prescaler clock by 16; glitch filter
 *     recognizes change on input pin after 8 rising clock edges.
 * - 0b0100 - Prescaler divides the prescaler clock by 32; glitch filter
 *     recognizes change on input pin after 16 rising clock edges.
 * - 0b0101 - Prescaler divides the prescaler clock by 64; glitch filter
 *     recognizes change on input pin after 32 rising clock edges.
 * - 0b0110 - Prescaler divides the prescaler clock by 128; glitch filter
 *     recognizes change on input pin after 64 rising clock edges.
 * - 0b0111 - Prescaler divides the prescaler clock by 256; glitch filter
 *     recognizes change on input pin after 128 rising clock edges.
 * - 0b1000 - Prescaler divides the prescaler clock by 512; glitch filter
 *     recognizes change on input pin after 256 rising clock edges.
 * - 0b1001 - Prescaler divides the prescaler clock by 1024; glitch filter
 *     recognizes change on input pin after 512 rising clock edges.
 * - 0b1010 - Prescaler divides the prescaler clock by 2048; glitch filter
 *     recognizes change on input pin after 1024 rising clock edges.
 * - 0b1011 - Prescaler divides the prescaler clock by 4096; glitch filter
 *     recognizes change on input pin after 2048 rising clock edges.
 * - 0b1100 - Prescaler divides the prescaler clock by 8192; glitch filter
 *     recognizes change on input pin after 4096 rising clock edges.
 * - 0b1101 - Prescaler divides the prescaler clock by 16,384; glitch filter
 *     recognizes change on input pin after 8192 rising clock edges.
 * - 0b1110 - Prescaler divides the prescaler clock by 32,768; glitch filter
 *     recognizes change on input pin after 16,384 rising clock edges.
 * - 0b1111 - Prescaler divides the prescaler clock by 65,536; glitch filter
 *     recognizes change on input pin after 32,768 rising clock edges.
 */
/*@{*/
/*! @brief Read current value of the LPTMR_PSR_PRESCALE field. */
#define LPTMR_RD_PSR_PRESCALE(base) ((LPTMR_PSR_REG(base) & LPTMR_PSR_PRESCALE_MASK) >> LPTMR_PSR_PRESCALE_SHIFT)
#define LPTMR_BRD_PSR_PRESCALE(base) (BME_UBFX32(&LPTMR_PSR_REG(base), LPTMR_PSR_PRESCALE_SHIFT, LPTMR_PSR_PRESCALE_WIDTH))

/*! @brief Set the PRESCALE field to a new value. */
#define LPTMR_WR_PSR_PRESCALE(base, value) (LPTMR_RMW_PSR(base, LPTMR_PSR_PRESCALE_MASK, LPTMR_PSR_PRESCALE(value)))
#define LPTMR_BWR_PSR_PRESCALE(base, value) (BME_BFI32(&LPTMR_PSR_REG(base), ((uint32_t)(value) << LPTMR_PSR_PRESCALE_SHIFT), LPTMR_PSR_PRESCALE_SHIFT, LPTMR_PSR_PRESCALE_WIDTH))
/*@}*/

/*******************************************************************************
 * LPTMR_CMR - Low Power Timer Compare Register
 ******************************************************************************/

/*!
 * @brief LPTMR_CMR - Low Power Timer Compare Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire LPTMR_CMR register
 */
/*@{*/
#define LPTMR_RD_CMR(base)       (LPTMR_CMR_REG(base))
#define LPTMR_WR_CMR(base, value) (LPTMR_CMR_REG(base) = (value))
#define LPTMR_RMW_CMR(base, mask, value) (LPTMR_WR_CMR(base, (LPTMR_RD_CMR(base) & ~(mask)) | (value)))
#define LPTMR_SET_CMR(base, value) (BME_OR32(&LPTMR_CMR_REG(base), (uint32_t)(value)))
#define LPTMR_CLR_CMR(base, value) (BME_AND32(&LPTMR_CMR_REG(base), (uint32_t)(~(value))))
#define LPTMR_TOG_CMR(base, value) (BME_XOR32(&LPTMR_CMR_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual LPTMR_CMR bitfields
 */

/*!
 * @name Register LPTMR_CMR, field COMPARE[15:0] (RW)
 *
 * When the LPTMR is enabled and the CNR equals the value in the CMR and
 * increments, TCF is set and the hardware trigger asserts until the next time the CNR
 * increments. If the CMR is 0, the hardware trigger will remain asserted until
 * the LPTMR is disabled. If the LPTMR is enabled, the CMR must be altered only
 * when TCF is set.
 */
/*@{*/
/*! @brief Read current value of the LPTMR_CMR_COMPARE field. */
#define LPTMR_RD_CMR_COMPARE(base) ((LPTMR_CMR_REG(base) & LPTMR_CMR_COMPARE_MASK) >> LPTMR_CMR_COMPARE_SHIFT)
#define LPTMR_BRD_CMR_COMPARE(base) (BME_UBFX32(&LPTMR_CMR_REG(base), LPTMR_CMR_COMPARE_SHIFT, LPTMR_CMR_COMPARE_WIDTH))

/*! @brief Set the COMPARE field to a new value. */
#define LPTMR_WR_CMR_COMPARE(base, value) (LPTMR_RMW_CMR(base, LPTMR_CMR_COMPARE_MASK, LPTMR_CMR_COMPARE(value)))
#define LPTMR_BWR_CMR_COMPARE(base, value) (BME_BFI32(&LPTMR_CMR_REG(base), ((uint32_t)(value) << LPTMR_CMR_COMPARE_SHIFT), LPTMR_CMR_COMPARE_SHIFT, LPTMR_CMR_COMPARE_WIDTH))
/*@}*/

/*******************************************************************************
 * LPTMR_CNR - Low Power Timer Counter Register
 ******************************************************************************/

/*!
 * @brief LPTMR_CNR - Low Power Timer Counter Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire LPTMR_CNR register
 */
/*@{*/
#define LPTMR_RD_CNR(base)       (LPTMR_CNR_REG(base))
#define LPTMR_WR_CNR(base, value) (LPTMR_CNR_REG(base) = (value))
#define LPTMR_RMW_CNR(base, mask, value) (LPTMR_WR_CNR(base, (LPTMR_RD_CNR(base) & ~(mask)) | (value)))
#define LPTMR_SET_CNR(base, value) (BME_OR32(&LPTMR_CNR_REG(base), (uint32_t)(value)))
#define LPTMR_CLR_CNR(base, value) (BME_AND32(&LPTMR_CNR_REG(base), (uint32_t)(~(value))))
#define LPTMR_TOG_CNR(base, value) (BME_XOR32(&LPTMR_CNR_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual LPTMR_CNR bitfields
 */

/*!
 * @name Register LPTMR_CNR, field COUNTER[15:0] (RW)
 */
/*@{*/
/*! @brief Read current value of the LPTMR_CNR_COUNTER field. */
#define LPTMR_RD_CNR_COUNTER(base) ((LPTMR_CNR_REG(base) & LPTMR_CNR_COUNTER_MASK) >> LPTMR_CNR_COUNTER_SHIFT)
#define LPTMR_BRD_CNR_COUNTER(base) (BME_UBFX32(&LPTMR_CNR_REG(base), LPTMR_CNR_COUNTER_SHIFT, LPTMR_CNR_COUNTER_WIDTH))

/*! @brief Set the COUNTER field to a new value. */
#define LPTMR_WR_CNR_COUNTER(base, value) (LPTMR_RMW_CNR(base, LPTMR_CNR_COUNTER_MASK, LPTMR_CNR_COUNTER(value)))
#define LPTMR_BWR_CNR_COUNTER(base, value) (BME_BFI32(&LPTMR_CNR_REG(base), ((uint32_t)(value) << LPTMR_CNR_COUNTER_SHIFT), LPTMR_CNR_COUNTER_SHIFT, LPTMR_CNR_COUNTER_WIDTH))
/*@}*/

/*
 * MKM34Z7 LPUART
 *
 * Universal Asynchronous Receiver/Transmitter
 *
 * Registers defined in this header file:
 * - LPUART_BAUD - LPUART Baud Rate Register
 * - LPUART_STAT - LPUART Status Register
 * - LPUART_CTRL - LPUART Control Register
 * - LPUART_DATA - LPUART Data Register
 * - LPUART_MATCH - LPUART Match Address Register
 * - LPUART_MODIR - LPUART Modem IrDA Register
 */

#define LPUART_INSTANCE_COUNT (1U) /*!< Number of instances of the LPUART module. */
#define LPUART0_IDX (0U) /*!< Instance number for LPUART0. */

/*******************************************************************************
 * LPUART_BAUD - LPUART Baud Rate Register
 ******************************************************************************/

/*!
 * @brief LPUART_BAUD - LPUART Baud Rate Register (RW)
 *
 * Reset value: 0x0F000004U
 */
/*!
 * @name Constants and macros for entire LPUART_BAUD register
 */
/*@{*/
#define LPUART_RD_BAUD(base)     (LPUART_BAUD_REG(base))
#define LPUART_WR_BAUD(base, value) (LPUART_BAUD_REG(base) = (value))
#define LPUART_RMW_BAUD(base, mask, value) (LPUART_WR_BAUD(base, (LPUART_RD_BAUD(base) & ~(mask)) | (value)))
#define LPUART_SET_BAUD(base, value) (BME_OR32(&LPUART_BAUD_REG(base), (uint32_t)(value)))
#define LPUART_CLR_BAUD(base, value) (BME_AND32(&LPUART_BAUD_REG(base), (uint32_t)(~(value))))
#define LPUART_TOG_BAUD(base, value) (BME_XOR32(&LPUART_BAUD_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual LPUART_BAUD bitfields
 */

/*!
 * @name Register LPUART_BAUD, field SBR[12:0] (RW)
 *
 * The 13 bits in SBR[12:0] set the modulo divide rate for the baud rate
 * generator. When SBR is 1 - 8191, the baud rate equals "baud clock / ((OSR+1) * SBR)".
 * The 13-bit baud rate setting [SBR12:SBR0] must only be updated when the
 * transmitter and receiver are both disabled (LPUART_CTRL[RE] and LPUART_CTRL[TE] are
 * both 0).
 */
/*@{*/
/*! @brief Read current value of the LPUART_BAUD_SBR field. */
#define LPUART_RD_BAUD_SBR(base) ((LPUART_BAUD_REG(base) & LPUART_BAUD_SBR_MASK) >> LPUART_BAUD_SBR_SHIFT)
#define LPUART_BRD_BAUD_SBR(base) (BME_UBFX32(&LPUART_BAUD_REG(base), LPUART_BAUD_SBR_SHIFT, LPUART_BAUD_SBR_WIDTH))

/*! @brief Set the SBR field to a new value. */
#define LPUART_WR_BAUD_SBR(base, value) (LPUART_RMW_BAUD(base, LPUART_BAUD_SBR_MASK, LPUART_BAUD_SBR(value)))
#define LPUART_BWR_BAUD_SBR(base, value) (BME_BFI32(&LPUART_BAUD_REG(base), ((uint32_t)(value) << LPUART_BAUD_SBR_SHIFT), LPUART_BAUD_SBR_SHIFT, LPUART_BAUD_SBR_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_BAUD, field SBNS[13] (RW)
 *
 * SBNS determines whether data characters are one or two stop bits. This bit
 * should only be changed when the transmitter and receiver are both disabled.
 *
 * Values:
 * - 0b0 - One stop bit.
 * - 0b1 - Two stop bits.
 */
/*@{*/
/*! @brief Read current value of the LPUART_BAUD_SBNS field. */
#define LPUART_RD_BAUD_SBNS(base) ((LPUART_BAUD_REG(base) & LPUART_BAUD_SBNS_MASK) >> LPUART_BAUD_SBNS_SHIFT)
#define LPUART_BRD_BAUD_SBNS(base) (BME_UBFX32(&LPUART_BAUD_REG(base), LPUART_BAUD_SBNS_SHIFT, LPUART_BAUD_SBNS_WIDTH))

/*! @brief Set the SBNS field to a new value. */
#define LPUART_WR_BAUD_SBNS(base, value) (LPUART_RMW_BAUD(base, LPUART_BAUD_SBNS_MASK, LPUART_BAUD_SBNS(value)))
#define LPUART_BWR_BAUD_SBNS(base, value) (BME_BFI32(&LPUART_BAUD_REG(base), ((uint32_t)(value) << LPUART_BAUD_SBNS_SHIFT), LPUART_BAUD_SBNS_SHIFT, LPUART_BAUD_SBNS_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_BAUD, field RXEDGIE[14] (RW)
 *
 * Enables the receive input active edge, RXEDGIF, to generate interrupt
 * requests. Changing CTRL[LOOP] or CTRL[RSRC] when RXEDGIE is set can cause the RXEDGIF
 * to set.
 *
 * Values:
 * - 0b0 - Hardware interrupts from LPUART_STAT[RXEDGIF] disabled (use polling).
 * - 0b1 - Hardware interrupt requested when LPUART_STAT[RXEDGIF] flag is 1.
 */
/*@{*/
/*! @brief Read current value of the LPUART_BAUD_RXEDGIE field. */
#define LPUART_RD_BAUD_RXEDGIE(base) ((LPUART_BAUD_REG(base) & LPUART_BAUD_RXEDGIE_MASK) >> LPUART_BAUD_RXEDGIE_SHIFT)
#define LPUART_BRD_BAUD_RXEDGIE(base) (BME_UBFX32(&LPUART_BAUD_REG(base), LPUART_BAUD_RXEDGIE_SHIFT, LPUART_BAUD_RXEDGIE_WIDTH))

/*! @brief Set the RXEDGIE field to a new value. */
#define LPUART_WR_BAUD_RXEDGIE(base, value) (LPUART_RMW_BAUD(base, LPUART_BAUD_RXEDGIE_MASK, LPUART_BAUD_RXEDGIE(value)))
#define LPUART_BWR_BAUD_RXEDGIE(base, value) (BME_BFI32(&LPUART_BAUD_REG(base), ((uint32_t)(value) << LPUART_BAUD_RXEDGIE_SHIFT), LPUART_BAUD_RXEDGIE_SHIFT, LPUART_BAUD_RXEDGIE_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_BAUD, field LBKDIE[15] (RW)
 *
 * LBKDIE enables the LIN break detect flag, LBKDIF, to generate interrupt
 * requests.
 *
 * Values:
 * - 0b0 - Hardware interrupts from LPUART_STAT[LBKDIF] disabled (use polling).
 * - 0b1 - Hardware interrupt requested when LPUART_STAT[LBKDIF] flag is 1.
 */
/*@{*/
/*! @brief Read current value of the LPUART_BAUD_LBKDIE field. */
#define LPUART_RD_BAUD_LBKDIE(base) ((LPUART_BAUD_REG(base) & LPUART_BAUD_LBKDIE_MASK) >> LPUART_BAUD_LBKDIE_SHIFT)
#define LPUART_BRD_BAUD_LBKDIE(base) (BME_UBFX32(&LPUART_BAUD_REG(base), LPUART_BAUD_LBKDIE_SHIFT, LPUART_BAUD_LBKDIE_WIDTH))

/*! @brief Set the LBKDIE field to a new value. */
#define LPUART_WR_BAUD_LBKDIE(base, value) (LPUART_RMW_BAUD(base, LPUART_BAUD_LBKDIE_MASK, LPUART_BAUD_LBKDIE(value)))
#define LPUART_BWR_BAUD_LBKDIE(base, value) (BME_BFI32(&LPUART_BAUD_REG(base), ((uint32_t)(value) << LPUART_BAUD_LBKDIE_SHIFT), LPUART_BAUD_LBKDIE_SHIFT, LPUART_BAUD_LBKDIE_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_BAUD, field RESYNCDIS[16] (RW)
 *
 * When set, disables the resynchronization of the received data word when a
 * data one followed by data zero transition is detected. This bit should only be
 * changed when the receiver is disabled.
 *
 * Values:
 * - 0b0 - Resynchronization during received data word is supported
 * - 0b1 - Resynchronization during received data word is disabled
 */
/*@{*/
/*! @brief Read current value of the LPUART_BAUD_RESYNCDIS field. */
#define LPUART_RD_BAUD_RESYNCDIS(base) ((LPUART_BAUD_REG(base) & LPUART_BAUD_RESYNCDIS_MASK) >> LPUART_BAUD_RESYNCDIS_SHIFT)
#define LPUART_BRD_BAUD_RESYNCDIS(base) (BME_UBFX32(&LPUART_BAUD_REG(base), LPUART_BAUD_RESYNCDIS_SHIFT, LPUART_BAUD_RESYNCDIS_WIDTH))

/*! @brief Set the RESYNCDIS field to a new value. */
#define LPUART_WR_BAUD_RESYNCDIS(base, value) (LPUART_RMW_BAUD(base, LPUART_BAUD_RESYNCDIS_MASK, LPUART_BAUD_RESYNCDIS(value)))
#define LPUART_BWR_BAUD_RESYNCDIS(base, value) (BME_BFI32(&LPUART_BAUD_REG(base), ((uint32_t)(value) << LPUART_BAUD_RESYNCDIS_SHIFT), LPUART_BAUD_RESYNCDIS_SHIFT, LPUART_BAUD_RESYNCDIS_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_BAUD, field BOTHEDGE[17] (RW)
 *
 * Enables sampling of the received data on both edges of the baud rate clock,
 * effectively doubling the number of times the receiver samples the input data
 * for a given oversampling ratio. This bit must be set for oversampling ratios
 * between x4 and x7 and is optional for higher oversampling ratios. This bit should
 * only be changed when the receiver is disabled.
 *
 * Values:
 * - 0b0 - Receiver samples input data using the rising edge of the baud rate
 *     clock.
 * - 0b1 - Receiver samples input data using the rising and falling edge of the
 *     baud rate clock.
 */
/*@{*/
/*! @brief Read current value of the LPUART_BAUD_BOTHEDGE field. */
#define LPUART_RD_BAUD_BOTHEDGE(base) ((LPUART_BAUD_REG(base) & LPUART_BAUD_BOTHEDGE_MASK) >> LPUART_BAUD_BOTHEDGE_SHIFT)
#define LPUART_BRD_BAUD_BOTHEDGE(base) (BME_UBFX32(&LPUART_BAUD_REG(base), LPUART_BAUD_BOTHEDGE_SHIFT, LPUART_BAUD_BOTHEDGE_WIDTH))

/*! @brief Set the BOTHEDGE field to a new value. */
#define LPUART_WR_BAUD_BOTHEDGE(base, value) (LPUART_RMW_BAUD(base, LPUART_BAUD_BOTHEDGE_MASK, LPUART_BAUD_BOTHEDGE(value)))
#define LPUART_BWR_BAUD_BOTHEDGE(base, value) (BME_BFI32(&LPUART_BAUD_REG(base), ((uint32_t)(value) << LPUART_BAUD_BOTHEDGE_SHIFT), LPUART_BAUD_BOTHEDGE_SHIFT, LPUART_BAUD_BOTHEDGE_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_BAUD, field MATCFG[19:18] (RW)
 *
 * Configures the match addressing mode used.
 *
 * Values:
 * - 0b00 - Address Match Wakeup
 * - 0b01 - Idle Match Wakeup
 * - 0b10 - Match On and Match Off
 * - 0b11 - Enables RWU on Data Match and Match On/Off for transmitter CTS input
 */
/*@{*/
/*! @brief Read current value of the LPUART_BAUD_MATCFG field. */
#define LPUART_RD_BAUD_MATCFG(base) ((LPUART_BAUD_REG(base) & LPUART_BAUD_MATCFG_MASK) >> LPUART_BAUD_MATCFG_SHIFT)
#define LPUART_BRD_BAUD_MATCFG(base) (BME_UBFX32(&LPUART_BAUD_REG(base), LPUART_BAUD_MATCFG_SHIFT, LPUART_BAUD_MATCFG_WIDTH))

/*! @brief Set the MATCFG field to a new value. */
#define LPUART_WR_BAUD_MATCFG(base, value) (LPUART_RMW_BAUD(base, LPUART_BAUD_MATCFG_MASK, LPUART_BAUD_MATCFG(value)))
#define LPUART_BWR_BAUD_MATCFG(base, value) (BME_BFI32(&LPUART_BAUD_REG(base), ((uint32_t)(value) << LPUART_BAUD_MATCFG_SHIFT), LPUART_BAUD_MATCFG_SHIFT, LPUART_BAUD_MATCFG_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_BAUD, field RDMAE[21] (RW)
 *
 * RDMAE configures the receiver data register full flag, LPUART_STAT[RDRF], to
 * generate a DMA request.
 *
 * Values:
 * - 0b0 - DMA request disabled.
 * - 0b1 - DMA request enabled.
 */
/*@{*/
/*! @brief Read current value of the LPUART_BAUD_RDMAE field. */
#define LPUART_RD_BAUD_RDMAE(base) ((LPUART_BAUD_REG(base) & LPUART_BAUD_RDMAE_MASK) >> LPUART_BAUD_RDMAE_SHIFT)
#define LPUART_BRD_BAUD_RDMAE(base) (BME_UBFX32(&LPUART_BAUD_REG(base), LPUART_BAUD_RDMAE_SHIFT, LPUART_BAUD_RDMAE_WIDTH))

/*! @brief Set the RDMAE field to a new value. */
#define LPUART_WR_BAUD_RDMAE(base, value) (LPUART_RMW_BAUD(base, LPUART_BAUD_RDMAE_MASK, LPUART_BAUD_RDMAE(value)))
#define LPUART_BWR_BAUD_RDMAE(base, value) (BME_BFI32(&LPUART_BAUD_REG(base), ((uint32_t)(value) << LPUART_BAUD_RDMAE_SHIFT), LPUART_BAUD_RDMAE_SHIFT, LPUART_BAUD_RDMAE_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_BAUD, field TDMAE[23] (RW)
 *
 * TDMAE configures the transmit data register empty flag, LPUART_STAT[TDRE], to
 * generate a DMA request.
 *
 * Values:
 * - 0b0 - DMA request disabled.
 * - 0b1 - DMA request enabled.
 */
/*@{*/
/*! @brief Read current value of the LPUART_BAUD_TDMAE field. */
#define LPUART_RD_BAUD_TDMAE(base) ((LPUART_BAUD_REG(base) & LPUART_BAUD_TDMAE_MASK) >> LPUART_BAUD_TDMAE_SHIFT)
#define LPUART_BRD_BAUD_TDMAE(base) (BME_UBFX32(&LPUART_BAUD_REG(base), LPUART_BAUD_TDMAE_SHIFT, LPUART_BAUD_TDMAE_WIDTH))

/*! @brief Set the TDMAE field to a new value. */
#define LPUART_WR_BAUD_TDMAE(base, value) (LPUART_RMW_BAUD(base, LPUART_BAUD_TDMAE_MASK, LPUART_BAUD_TDMAE(value)))
#define LPUART_BWR_BAUD_TDMAE(base, value) (BME_BFI32(&LPUART_BAUD_REG(base), ((uint32_t)(value) << LPUART_BAUD_TDMAE_SHIFT), LPUART_BAUD_TDMAE_SHIFT, LPUART_BAUD_TDMAE_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_BAUD, field OSR[28:24] (RW)
 *
 * This field configures the oversampling ratio for the receiver between 4x
 * (00011) and 32x (11111). Writing an invalid oversampling ratio will default to an
 * oversampling ratio of 16 (01111). This field should only be changed when the
 * transmitter and receiver are both disabled.
 */
/*@{*/
/*! @brief Read current value of the LPUART_BAUD_OSR field. */
#define LPUART_RD_BAUD_OSR(base) ((LPUART_BAUD_REG(base) & LPUART_BAUD_OSR_MASK) >> LPUART_BAUD_OSR_SHIFT)
#define LPUART_BRD_BAUD_OSR(base) (BME_UBFX32(&LPUART_BAUD_REG(base), LPUART_BAUD_OSR_SHIFT, LPUART_BAUD_OSR_WIDTH))

/*! @brief Set the OSR field to a new value. */
#define LPUART_WR_BAUD_OSR(base, value) (LPUART_RMW_BAUD(base, LPUART_BAUD_OSR_MASK, LPUART_BAUD_OSR(value)))
#define LPUART_BWR_BAUD_OSR(base, value) (BME_BFI32(&LPUART_BAUD_REG(base), ((uint32_t)(value) << LPUART_BAUD_OSR_SHIFT), LPUART_BAUD_OSR_SHIFT, LPUART_BAUD_OSR_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_BAUD, field M10[29] (RW)
 *
 * The M10 bit causes a tenth bit to be part of the serial transmission. This
 * bit should only be changed when the transmitter and receiver are both disabled.
 *
 * Values:
 * - 0b0 - Receiver and transmitter use 8-bit or 9-bit data characters.
 * - 0b1 - Receiver and transmitter use 10-bit data characters.
 */
/*@{*/
/*! @brief Read current value of the LPUART_BAUD_M10 field. */
#define LPUART_RD_BAUD_M10(base) ((LPUART_BAUD_REG(base) & LPUART_BAUD_M10_MASK) >> LPUART_BAUD_M10_SHIFT)
#define LPUART_BRD_BAUD_M10(base) (BME_UBFX32(&LPUART_BAUD_REG(base), LPUART_BAUD_M10_SHIFT, LPUART_BAUD_M10_WIDTH))

/*! @brief Set the M10 field to a new value. */
#define LPUART_WR_BAUD_M10(base, value) (LPUART_RMW_BAUD(base, LPUART_BAUD_M10_MASK, LPUART_BAUD_M10(value)))
#define LPUART_BWR_BAUD_M10(base, value) (BME_BFI32(&LPUART_BAUD_REG(base), ((uint32_t)(value) << LPUART_BAUD_M10_SHIFT), LPUART_BAUD_M10_SHIFT, LPUART_BAUD_M10_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_BAUD, field MAEN2[30] (RW)
 *
 * Values:
 * - 0b0 - Normal operation.
 * - 0b1 - Enables automatic address matching or data matching mode for
 *     MATCH[MA2].
 */
/*@{*/
/*! @brief Read current value of the LPUART_BAUD_MAEN2 field. */
#define LPUART_RD_BAUD_MAEN2(base) ((LPUART_BAUD_REG(base) & LPUART_BAUD_MAEN2_MASK) >> LPUART_BAUD_MAEN2_SHIFT)
#define LPUART_BRD_BAUD_MAEN2(base) (BME_UBFX32(&LPUART_BAUD_REG(base), LPUART_BAUD_MAEN2_SHIFT, LPUART_BAUD_MAEN2_WIDTH))

/*! @brief Set the MAEN2 field to a new value. */
#define LPUART_WR_BAUD_MAEN2(base, value) (LPUART_RMW_BAUD(base, LPUART_BAUD_MAEN2_MASK, LPUART_BAUD_MAEN2(value)))
#define LPUART_BWR_BAUD_MAEN2(base, value) (BME_BFI32(&LPUART_BAUD_REG(base), ((uint32_t)(value) << LPUART_BAUD_MAEN2_SHIFT), LPUART_BAUD_MAEN2_SHIFT, LPUART_BAUD_MAEN2_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_BAUD, field MAEN1[31] (RW)
 *
 * Values:
 * - 0b0 - Normal operation.
 * - 0b1 - Enables automatic address matching or data matching mode for
 *     MATCH[MA1].
 */
/*@{*/
/*! @brief Read current value of the LPUART_BAUD_MAEN1 field. */
#define LPUART_RD_BAUD_MAEN1(base) ((LPUART_BAUD_REG(base) & LPUART_BAUD_MAEN1_MASK) >> LPUART_BAUD_MAEN1_SHIFT)
#define LPUART_BRD_BAUD_MAEN1(base) (BME_UBFX32(&LPUART_BAUD_REG(base), LPUART_BAUD_MAEN1_SHIFT, LPUART_BAUD_MAEN1_WIDTH))

/*! @brief Set the MAEN1 field to a new value. */
#define LPUART_WR_BAUD_MAEN1(base, value) (LPUART_RMW_BAUD(base, LPUART_BAUD_MAEN1_MASK, LPUART_BAUD_MAEN1(value)))
#define LPUART_BWR_BAUD_MAEN1(base, value) (BME_BFI32(&LPUART_BAUD_REG(base), ((uint32_t)(value) << LPUART_BAUD_MAEN1_SHIFT), LPUART_BAUD_MAEN1_SHIFT, LPUART_BAUD_MAEN1_WIDTH))
/*@}*/

/*******************************************************************************
 * LPUART_STAT - LPUART Status Register
 ******************************************************************************/

/*!
 * @brief LPUART_STAT - LPUART Status Register (RW)
 *
 * Reset value: 0x00C00000U
 */
/*!
 * @name Constants and macros for entire LPUART_STAT register
 */
/*@{*/
#define LPUART_RD_STAT(base)     (LPUART_STAT_REG(base))
#define LPUART_WR_STAT(base, value) (LPUART_STAT_REG(base) = (value))
#define LPUART_RMW_STAT(base, mask, value) (LPUART_WR_STAT(base, (LPUART_RD_STAT(base) & ~(mask)) | (value)))
#define LPUART_SET_STAT(base, value) (BME_OR32(&LPUART_STAT_REG(base), (uint32_t)(value)))
#define LPUART_CLR_STAT(base, value) (BME_AND32(&LPUART_STAT_REG(base), (uint32_t)(~(value))))
#define LPUART_TOG_STAT(base, value) (BME_XOR32(&LPUART_STAT_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual LPUART_STAT bitfields
 */

/*!
 * @name Register LPUART_STAT, field MA2F[14] (W1C)
 *
 * MA2F is set whenever the next character to be read from LPUART_DATA matches
 * MA2. To clear MA2F, write a logic one to the MA2F.
 *
 * Values:
 * - 0b0 - Received data is not equal to MA2
 * - 0b1 - Received data is equal to MA2
 */
/*@{*/
/*! @brief Read current value of the LPUART_STAT_MA2F field. */
#define LPUART_RD_STAT_MA2F(base) ((LPUART_STAT_REG(base) & LPUART_STAT_MA2F_MASK) >> LPUART_STAT_MA2F_SHIFT)
#define LPUART_BRD_STAT_MA2F(base) (BME_UBFX32(&LPUART_STAT_REG(base), LPUART_STAT_MA2F_SHIFT, LPUART_STAT_MA2F_WIDTH))

/*! @brief Set the MA2F field to a new value. */
#define LPUART_WR_STAT_MA2F(base, value) (LPUART_RMW_STAT(base, (LPUART_STAT_MA2F_MASK | LPUART_STAT_MA1F_MASK | LPUART_STAT_PF_MASK | LPUART_STAT_FE_MASK | LPUART_STAT_NF_MASK | LPUART_STAT_OR_MASK | LPUART_STAT_IDLE_MASK | LPUART_STAT_RXEDGIF_MASK | LPUART_STAT_LBKDIF_MASK), LPUART_STAT_MA2F(value)))
#define LPUART_BWR_STAT_MA2F(base, value) (BME_BFI32(&LPUART_STAT_REG(base), ((uint32_t)(value) << LPUART_STAT_MA2F_SHIFT), LPUART_STAT_MA2F_SHIFT, LPUART_STAT_MA2F_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_STAT, field MA1F[15] (W1C)
 *
 * MA1F is set whenever the next character to be read from LPUART_DATA matches
 * MA1. To clear MA1F, write a logic one to the MA1F.
 *
 * Values:
 * - 0b0 - Received data is not equal to MA1
 * - 0b1 - Received data is equal to MA1
 */
/*@{*/
/*! @brief Read current value of the LPUART_STAT_MA1F field. */
#define LPUART_RD_STAT_MA1F(base) ((LPUART_STAT_REG(base) & LPUART_STAT_MA1F_MASK) >> LPUART_STAT_MA1F_SHIFT)
#define LPUART_BRD_STAT_MA1F(base) (BME_UBFX32(&LPUART_STAT_REG(base), LPUART_STAT_MA1F_SHIFT, LPUART_STAT_MA1F_WIDTH))

/*! @brief Set the MA1F field to a new value. */
#define LPUART_WR_STAT_MA1F(base, value) (LPUART_RMW_STAT(base, (LPUART_STAT_MA1F_MASK | LPUART_STAT_MA2F_MASK | LPUART_STAT_PF_MASK | LPUART_STAT_FE_MASK | LPUART_STAT_NF_MASK | LPUART_STAT_OR_MASK | LPUART_STAT_IDLE_MASK | LPUART_STAT_RXEDGIF_MASK | LPUART_STAT_LBKDIF_MASK), LPUART_STAT_MA1F(value)))
#define LPUART_BWR_STAT_MA1F(base, value) (BME_BFI32(&LPUART_STAT_REG(base), ((uint32_t)(value) << LPUART_STAT_MA1F_SHIFT), LPUART_STAT_MA1F_SHIFT, LPUART_STAT_MA1F_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_STAT, field PF[16] (W1C)
 *
 * PF is set whenever the next character to be read from LPUART_DATA was
 * received when parity is enabled (PE = 1) and the parity bit in the received character
 * does not agree with the expected parity value. To clear PF, write a logic one
 * to the PF.
 *
 * Values:
 * - 0b0 - No parity error.
 * - 0b1 - Parity error.
 */
/*@{*/
/*! @brief Read current value of the LPUART_STAT_PF field. */
#define LPUART_RD_STAT_PF(base) ((LPUART_STAT_REG(base) & LPUART_STAT_PF_MASK) >> LPUART_STAT_PF_SHIFT)
#define LPUART_BRD_STAT_PF(base) (BME_UBFX32(&LPUART_STAT_REG(base), LPUART_STAT_PF_SHIFT, LPUART_STAT_PF_WIDTH))

/*! @brief Set the PF field to a new value. */
#define LPUART_WR_STAT_PF(base, value) (LPUART_RMW_STAT(base, (LPUART_STAT_PF_MASK | LPUART_STAT_MA2F_MASK | LPUART_STAT_MA1F_MASK | LPUART_STAT_FE_MASK | LPUART_STAT_NF_MASK | LPUART_STAT_OR_MASK | LPUART_STAT_IDLE_MASK | LPUART_STAT_RXEDGIF_MASK | LPUART_STAT_LBKDIF_MASK), LPUART_STAT_PF(value)))
#define LPUART_BWR_STAT_PF(base, value) (BME_BFI32(&LPUART_STAT_REG(base), ((uint32_t)(value) << LPUART_STAT_PF_SHIFT), LPUART_STAT_PF_SHIFT, LPUART_STAT_PF_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_STAT, field FE[17] (W1C)
 *
 * FE is set whenever the next character to be read from LPUART_DATA was
 * received with logic 0 detected where a stop bit was expected. To clear NF, write
 * logic one to the NF.
 *
 * Values:
 * - 0b0 - No framing error detected. This does not guarantee the framing is
 *     correct.
 * - 0b1 - Framing error.
 */
/*@{*/
/*! @brief Read current value of the LPUART_STAT_FE field. */
#define LPUART_RD_STAT_FE(base) ((LPUART_STAT_REG(base) & LPUART_STAT_FE_MASK) >> LPUART_STAT_FE_SHIFT)
#define LPUART_BRD_STAT_FE(base) (BME_UBFX32(&LPUART_STAT_REG(base), LPUART_STAT_FE_SHIFT, LPUART_STAT_FE_WIDTH))

/*! @brief Set the FE field to a new value. */
#define LPUART_WR_STAT_FE(base, value) (LPUART_RMW_STAT(base, (LPUART_STAT_FE_MASK | LPUART_STAT_MA2F_MASK | LPUART_STAT_MA1F_MASK | LPUART_STAT_PF_MASK | LPUART_STAT_NF_MASK | LPUART_STAT_OR_MASK | LPUART_STAT_IDLE_MASK | LPUART_STAT_RXEDGIF_MASK | LPUART_STAT_LBKDIF_MASK), LPUART_STAT_FE(value)))
#define LPUART_BWR_STAT_FE(base, value) (BME_BFI32(&LPUART_STAT_REG(base), ((uint32_t)(value) << LPUART_STAT_FE_SHIFT), LPUART_STAT_FE_SHIFT, LPUART_STAT_FE_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_STAT, field NF[18] (W1C)
 *
 * The advanced sampling technique used in the receiver takes three samples in
 * each of the received bits. If any of these samples disagrees with the rest of
 * the samples within any bit time in the frame then noise is detected for that
 * character. NF is set whenever the next character to be read from LPUART_DATA was
 * received with noise detected within the character. To clear NF, write logic
 * one to the NF.
 *
 * Values:
 * - 0b0 - No noise detected.
 * - 0b1 - Noise detected in the received character in LPUART_DATA.
 */
/*@{*/
/*! @brief Read current value of the LPUART_STAT_NF field. */
#define LPUART_RD_STAT_NF(base) ((LPUART_STAT_REG(base) & LPUART_STAT_NF_MASK) >> LPUART_STAT_NF_SHIFT)
#define LPUART_BRD_STAT_NF(base) (BME_UBFX32(&LPUART_STAT_REG(base), LPUART_STAT_NF_SHIFT, LPUART_STAT_NF_WIDTH))

/*! @brief Set the NF field to a new value. */
#define LPUART_WR_STAT_NF(base, value) (LPUART_RMW_STAT(base, (LPUART_STAT_NF_MASK | LPUART_STAT_MA2F_MASK | LPUART_STAT_MA1F_MASK | LPUART_STAT_PF_MASK | LPUART_STAT_FE_MASK | LPUART_STAT_OR_MASK | LPUART_STAT_IDLE_MASK | LPUART_STAT_RXEDGIF_MASK | LPUART_STAT_LBKDIF_MASK), LPUART_STAT_NF(value)))
#define LPUART_BWR_STAT_NF(base, value) (BME_BFI32(&LPUART_STAT_REG(base), ((uint32_t)(value) << LPUART_STAT_NF_SHIFT), LPUART_STAT_NF_SHIFT, LPUART_STAT_NF_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_STAT, field OR[19] (W1C)
 *
 * OR is set when software fails to prevent the receive data register from
 * overflowing with data. The OR bit is set immediately after the stop bit has been
 * completely received for the dataword that overflows the buffer and all the other
 * error flags (FE, NF, and PF) are prevented from setting. The data in the
 * shift register is lost, but the data already in the LPUART data registers is not
 * affected. If LBKDE is enabled and a LIN Break is detected, the OR field asserts
 * if LBKDIF is not cleared before the next data character is received. While
 * the OR flag is set, no additional data is stored in the data buffer even if
 * sufficient room exists. To clear OR, write logic 1 to the OR flag.
 *
 * Values:
 * - 0b0 - No overrun.
 * - 0b1 - Receive overrun (new LPUART data lost).
 */
/*@{*/
/*! @brief Read current value of the LPUART_STAT_OR field. */
#define LPUART_RD_STAT_OR(base) ((LPUART_STAT_REG(base) & LPUART_STAT_OR_MASK) >> LPUART_STAT_OR_SHIFT)
#define LPUART_BRD_STAT_OR(base) (BME_UBFX32(&LPUART_STAT_REG(base), LPUART_STAT_OR_SHIFT, LPUART_STAT_OR_WIDTH))

/*! @brief Set the OR field to a new value. */
#define LPUART_WR_STAT_OR(base, value) (LPUART_RMW_STAT(base, (LPUART_STAT_OR_MASK | LPUART_STAT_MA2F_MASK | LPUART_STAT_MA1F_MASK | LPUART_STAT_PF_MASK | LPUART_STAT_FE_MASK | LPUART_STAT_NF_MASK | LPUART_STAT_IDLE_MASK | LPUART_STAT_RXEDGIF_MASK | LPUART_STAT_LBKDIF_MASK), LPUART_STAT_OR(value)))
#define LPUART_BWR_STAT_OR(base, value) (BME_BFI32(&LPUART_STAT_REG(base), ((uint32_t)(value) << LPUART_STAT_OR_SHIFT), LPUART_STAT_OR_SHIFT, LPUART_STAT_OR_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_STAT, field IDLE[20] (W1C)
 *
 * IDLE is set when the LPUART receive line becomes idle for a full character
 * time after a period of activity. When ILT is cleared, the receiver starts
 * counting idle bit times after the start bit. If the receive character is all 1s,
 * these bit times and the stop bits time count toward the full character time of
 * logic high, 10 to 13 bit times, needed for the receiver to detect an idle line.
 * When ILT is set, the receiver doesn't start counting idle bit times until
 * after the stop bits. The stop bits and any logic high bit times at the end of the
 * previous character do not count toward the full character time of logic high
 * needed for the receiver to detect an idle line. To clear IDLE, write logic 1 to
 * the IDLE flag. After IDLE has been cleared, it cannot become set again until
 * after a new character has been stored in the receive buffer or a LIN break
 * character has set the LBKDIF flag . IDLE is set only once even if the receive
 * line remains idle for an extended period.
 *
 * Values:
 * - 0b0 - No idle line detected.
 * - 0b1 - Idle line was detected.
 */
/*@{*/
/*! @brief Read current value of the LPUART_STAT_IDLE field. */
#define LPUART_RD_STAT_IDLE(base) ((LPUART_STAT_REG(base) & LPUART_STAT_IDLE_MASK) >> LPUART_STAT_IDLE_SHIFT)
#define LPUART_BRD_STAT_IDLE(base) (BME_UBFX32(&LPUART_STAT_REG(base), LPUART_STAT_IDLE_SHIFT, LPUART_STAT_IDLE_WIDTH))

/*! @brief Set the IDLE field to a new value. */
#define LPUART_WR_STAT_IDLE(base, value) (LPUART_RMW_STAT(base, (LPUART_STAT_IDLE_MASK | LPUART_STAT_MA2F_MASK | LPUART_STAT_MA1F_MASK | LPUART_STAT_PF_MASK | LPUART_STAT_FE_MASK | LPUART_STAT_NF_MASK | LPUART_STAT_OR_MASK | LPUART_STAT_RXEDGIF_MASK | LPUART_STAT_LBKDIF_MASK), LPUART_STAT_IDLE(value)))
#define LPUART_BWR_STAT_IDLE(base, value) (BME_BFI32(&LPUART_STAT_REG(base), ((uint32_t)(value) << LPUART_STAT_IDLE_SHIFT), LPUART_STAT_IDLE_SHIFT, LPUART_STAT_IDLE_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_STAT, field RDRF[21] (RO)
 *
 * RDRF is set when the receive buffer (LPUART_DATA) is full. To clear RDRF,
 * read the LPUART_DATA register. A character that is in the process of being
 * received does not cause a change in RDRF until the entire character is received.
 * Even if RDRF is set, the character will continue to be received until an overrun
 * condition occurs once the entire character is received.
 *
 * Values:
 * - 0b0 - Receive data buffer empty.
 * - 0b1 - Receive data buffer full.
 */
/*@{*/
/*! @brief Read current value of the LPUART_STAT_RDRF field. */
#define LPUART_RD_STAT_RDRF(base) ((LPUART_STAT_REG(base) & LPUART_STAT_RDRF_MASK) >> LPUART_STAT_RDRF_SHIFT)
#define LPUART_BRD_STAT_RDRF(base) (BME_UBFX32(&LPUART_STAT_REG(base), LPUART_STAT_RDRF_SHIFT, LPUART_STAT_RDRF_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_STAT, field TC[22] (RO)
 *
 * TC is cleared when there is a transmission in progress or when a preamble or
 * break character is loaded. TC is set when the transmit buffer is empty and no
 * data, preamble, or break character is being transmitted. When TC is set, the
 * transmit data output signal becomes idle (logic 1). TC is cleared by writing to
 * LPUART_DATA to transmit new data, queuing a preamble by clearing and then
 * setting LPUART_CTRL[TE], queuing a break character by writing 1 to
 * LPUART_CTRL[SBK].
 *
 * Values:
 * - 0b0 - Transmitter active (sending data, a preamble, or a break).
 * - 0b1 - Transmitter idle (transmission activity complete).
 */
/*@{*/
/*! @brief Read current value of the LPUART_STAT_TC field. */
#define LPUART_RD_STAT_TC(base) ((LPUART_STAT_REG(base) & LPUART_STAT_TC_MASK) >> LPUART_STAT_TC_SHIFT)
#define LPUART_BRD_STAT_TC(base) (BME_UBFX32(&LPUART_STAT_REG(base), LPUART_STAT_TC_SHIFT, LPUART_STAT_TC_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_STAT, field TDRE[23] (RO)
 *
 * TDRE will set when the transmit data register (LPUART_DATA) is empty. To
 * clear TDRE, write to the LPUART data register (LPUART_DATA). TDRE is not affected
 * by a character that is in the process of being transmitted, it is updated at
 * the start of each transmitted character.
 *
 * Values:
 * - 0b0 - Transmit data buffer full.
 * - 0b1 - Transmit data buffer empty.
 */
/*@{*/
/*! @brief Read current value of the LPUART_STAT_TDRE field. */
#define LPUART_RD_STAT_TDRE(base) ((LPUART_STAT_REG(base) & LPUART_STAT_TDRE_MASK) >> LPUART_STAT_TDRE_SHIFT)
#define LPUART_BRD_STAT_TDRE(base) (BME_UBFX32(&LPUART_STAT_REG(base), LPUART_STAT_TDRE_SHIFT, LPUART_STAT_TDRE_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_STAT, field RAF[24] (RO)
 *
 * RAF is set when the receiver detects the beginning of a valid start bit, and
 * RAF is cleared automatically when the receiver detects an idle line.
 *
 * Values:
 * - 0b0 - LPUART receiver idle waiting for a start bit.
 * - 0b1 - LPUART receiver active (LPUART_RX input not idle).
 */
/*@{*/
/*! @brief Read current value of the LPUART_STAT_RAF field. */
#define LPUART_RD_STAT_RAF(base) ((LPUART_STAT_REG(base) & LPUART_STAT_RAF_MASK) >> LPUART_STAT_RAF_SHIFT)
#define LPUART_BRD_STAT_RAF(base) (BME_UBFX32(&LPUART_STAT_REG(base), LPUART_STAT_RAF_SHIFT, LPUART_STAT_RAF_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_STAT, field LBKDE[25] (RW)
 *
 * LBKDE selects a longer break character detection length. While LBKDE is set,
 * receive data is not stored in the receive data buffer.
 *
 * Values:
 * - 0b0 - Break character is detected at length 10 bit times (if M = 0, SBNS =
 *     0) or 11 (if M = 1, SBNS = 0 or M = 0, SBNS = 1) or 12 (if M = 1, SBNS = 1
 *     or M10 = 1, SNBS = 0) or 13 (if M10 = 1, SNBS = 1).
 * - 0b1 - Break character is detected at length of 11 bit times (if M = 0, SBNS
 *     = 0) or 12 (if M = 1, SBNS = 0 or M = 0, SBNS = 1) or 14 (if M = 1, SBNS
 *     = 1 or M10 = 1, SNBS = 0) or 15 (if M10 = 1, SNBS = 1).
 */
/*@{*/
/*! @brief Read current value of the LPUART_STAT_LBKDE field. */
#define LPUART_RD_STAT_LBKDE(base) ((LPUART_STAT_REG(base) & LPUART_STAT_LBKDE_MASK) >> LPUART_STAT_LBKDE_SHIFT)
#define LPUART_BRD_STAT_LBKDE(base) (BME_UBFX32(&LPUART_STAT_REG(base), LPUART_STAT_LBKDE_SHIFT, LPUART_STAT_LBKDE_WIDTH))

/*! @brief Set the LBKDE field to a new value. */
#define LPUART_WR_STAT_LBKDE(base, value) (LPUART_RMW_STAT(base, (LPUART_STAT_LBKDE_MASK | LPUART_STAT_MA2F_MASK | LPUART_STAT_MA1F_MASK | LPUART_STAT_PF_MASK | LPUART_STAT_FE_MASK | LPUART_STAT_NF_MASK | LPUART_STAT_OR_MASK | LPUART_STAT_IDLE_MASK | LPUART_STAT_RXEDGIF_MASK | LPUART_STAT_LBKDIF_MASK), LPUART_STAT_LBKDE(value)))
#define LPUART_BWR_STAT_LBKDE(base, value) (BME_BFI32(&LPUART_STAT_REG(base), ((uint32_t)(value) << LPUART_STAT_LBKDE_SHIFT), LPUART_STAT_LBKDE_SHIFT, LPUART_STAT_LBKDE_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_STAT, field BRK13[26] (RW)
 *
 * BRK13 selects a longer transmitted break character length. Detection of a
 * framing error is not affected by the state of this bit. This bit should only be
 * changed when the transmitter is disabled.
 *
 * Values:
 * - 0b0 - Break character is transmitted with length of 10 bit times (if M = 0,
 *     SBNS = 0) or 11 (if M = 1, SBNS = 0 or M = 0, SBNS = 1) or 12 (if M = 1,
 *     SBNS = 1 or M10 = 1, SNBS = 0) or 13 (if M10 = 1, SNBS = 1).
 * - 0b1 - Break character is transmitted with length of 13 bit times (if M = 0,
 *     SBNS = 0) or 14 (if M = 1, SBNS = 0 or M = 0, SBNS = 1) or 15 (if M = 1,
 *     SBNS = 1 or M10 = 1, SNBS = 0) or 16 (if M10 = 1, SNBS = 1).
 */
/*@{*/
/*! @brief Read current value of the LPUART_STAT_BRK13 field. */
#define LPUART_RD_STAT_BRK13(base) ((LPUART_STAT_REG(base) & LPUART_STAT_BRK13_MASK) >> LPUART_STAT_BRK13_SHIFT)
#define LPUART_BRD_STAT_BRK13(base) (BME_UBFX32(&LPUART_STAT_REG(base), LPUART_STAT_BRK13_SHIFT, LPUART_STAT_BRK13_WIDTH))

/*! @brief Set the BRK13 field to a new value. */
#define LPUART_WR_STAT_BRK13(base, value) (LPUART_RMW_STAT(base, (LPUART_STAT_BRK13_MASK | LPUART_STAT_MA2F_MASK | LPUART_STAT_MA1F_MASK | LPUART_STAT_PF_MASK | LPUART_STAT_FE_MASK | LPUART_STAT_NF_MASK | LPUART_STAT_OR_MASK | LPUART_STAT_IDLE_MASK | LPUART_STAT_RXEDGIF_MASK | LPUART_STAT_LBKDIF_MASK), LPUART_STAT_BRK13(value)))
#define LPUART_BWR_STAT_BRK13(base, value) (BME_BFI32(&LPUART_STAT_REG(base), ((uint32_t)(value) << LPUART_STAT_BRK13_SHIFT), LPUART_STAT_BRK13_SHIFT, LPUART_STAT_BRK13_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_STAT, field RWUID[27] (RW)
 *
 * For RWU on idle character, RWUID controls whether the idle character that
 * wakes up the receiver sets the IDLE bit. For address match wakeup, RWUID controls
 * if the IDLE bit is set when the address does not match. This bit should only
 * be changed when the receiver is disabled.
 *
 * Values:
 * - 0b0 - During receive standby state (RWU = 1), the IDLE bit does not get set
 *     upon detection of an idle character. During address match wakeup, the
 *     IDLE bit does not get set when an address does not match.
 * - 0b1 - During receive standby state (RWU = 1), the IDLE bit gets set upon
 *     detection of an idle character. During address match wakeup, the IDLE bit
 *     does get set when an address does not match.
 */
/*@{*/
/*! @brief Read current value of the LPUART_STAT_RWUID field. */
#define LPUART_RD_STAT_RWUID(base) ((LPUART_STAT_REG(base) & LPUART_STAT_RWUID_MASK) >> LPUART_STAT_RWUID_SHIFT)
#define LPUART_BRD_STAT_RWUID(base) (BME_UBFX32(&LPUART_STAT_REG(base), LPUART_STAT_RWUID_SHIFT, LPUART_STAT_RWUID_WIDTH))

/*! @brief Set the RWUID field to a new value. */
#define LPUART_WR_STAT_RWUID(base, value) (LPUART_RMW_STAT(base, (LPUART_STAT_RWUID_MASK | LPUART_STAT_MA2F_MASK | LPUART_STAT_MA1F_MASK | LPUART_STAT_PF_MASK | LPUART_STAT_FE_MASK | LPUART_STAT_NF_MASK | LPUART_STAT_OR_MASK | LPUART_STAT_IDLE_MASK | LPUART_STAT_RXEDGIF_MASK | LPUART_STAT_LBKDIF_MASK), LPUART_STAT_RWUID(value)))
#define LPUART_BWR_STAT_RWUID(base, value) (BME_BFI32(&LPUART_STAT_REG(base), ((uint32_t)(value) << LPUART_STAT_RWUID_SHIFT), LPUART_STAT_RWUID_SHIFT, LPUART_STAT_RWUID_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_STAT, field RXINV[28] (RW)
 *
 * Setting this bit reverses the polarity of the received data input. Setting
 * RXINV inverts the LPUART_RX input for all cases: data bits, start and stop bits,
 * break, and idle.
 *
 * Values:
 * - 0b0 - Receive data not inverted.
 * - 0b1 - Receive data inverted.
 */
/*@{*/
/*! @brief Read current value of the LPUART_STAT_RXINV field. */
#define LPUART_RD_STAT_RXINV(base) ((LPUART_STAT_REG(base) & LPUART_STAT_RXINV_MASK) >> LPUART_STAT_RXINV_SHIFT)
#define LPUART_BRD_STAT_RXINV(base) (BME_UBFX32(&LPUART_STAT_REG(base), LPUART_STAT_RXINV_SHIFT, LPUART_STAT_RXINV_WIDTH))

/*! @brief Set the RXINV field to a new value. */
#define LPUART_WR_STAT_RXINV(base, value) (LPUART_RMW_STAT(base, (LPUART_STAT_RXINV_MASK | LPUART_STAT_MA2F_MASK | LPUART_STAT_MA1F_MASK | LPUART_STAT_PF_MASK | LPUART_STAT_FE_MASK | LPUART_STAT_NF_MASK | LPUART_STAT_OR_MASK | LPUART_STAT_IDLE_MASK | LPUART_STAT_RXEDGIF_MASK | LPUART_STAT_LBKDIF_MASK), LPUART_STAT_RXINV(value)))
#define LPUART_BWR_STAT_RXINV(base, value) (BME_BFI32(&LPUART_STAT_REG(base), ((uint32_t)(value) << LPUART_STAT_RXINV_SHIFT), LPUART_STAT_RXINV_SHIFT, LPUART_STAT_RXINV_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_STAT, field MSBF[29] (RW)
 *
 * Setting this bit reverses the order of the bits that are transmitted and
 * received on the wire. This bit does not affect the polarity of the bits, the
 * location of the parity bit or the location of the start or stop bits. This bit
 * should only be changed when the transmitter and receiver are both disabled.
 *
 * Values:
 * - 0b0 - LSB (bit0) is the first bit that is transmitted following the start
 *     bit. Further, the first bit received after the start bit is identified as
 *     bit0.
 * - 0b1 - MSB (bit9, bit8, bit7 or bit6) is the first bit that is transmitted
 *     following the start bit depending on the setting of CTRL[M], CTRL[PE] and
 *     BAUD[M10]. Further, the first bit received after the start bit is
 *     identified as bit9, bit8, bit7 or bit6 depending on the setting of CTRL[M] and
 *     CTRL[PE].
 */
/*@{*/
/*! @brief Read current value of the LPUART_STAT_MSBF field. */
#define LPUART_RD_STAT_MSBF(base) ((LPUART_STAT_REG(base) & LPUART_STAT_MSBF_MASK) >> LPUART_STAT_MSBF_SHIFT)
#define LPUART_BRD_STAT_MSBF(base) (BME_UBFX32(&LPUART_STAT_REG(base), LPUART_STAT_MSBF_SHIFT, LPUART_STAT_MSBF_WIDTH))

/*! @brief Set the MSBF field to a new value. */
#define LPUART_WR_STAT_MSBF(base, value) (LPUART_RMW_STAT(base, (LPUART_STAT_MSBF_MASK | LPUART_STAT_MA2F_MASK | LPUART_STAT_MA1F_MASK | LPUART_STAT_PF_MASK | LPUART_STAT_FE_MASK | LPUART_STAT_NF_MASK | LPUART_STAT_OR_MASK | LPUART_STAT_IDLE_MASK | LPUART_STAT_RXEDGIF_MASK | LPUART_STAT_LBKDIF_MASK), LPUART_STAT_MSBF(value)))
#define LPUART_BWR_STAT_MSBF(base, value) (BME_BFI32(&LPUART_STAT_REG(base), ((uint32_t)(value) << LPUART_STAT_MSBF_SHIFT), LPUART_STAT_MSBF_SHIFT, LPUART_STAT_MSBF_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_STAT, field RXEDGIF[30] (W1C)
 *
 * RXEDGIF is set when an active edge, falling if RXINV = 0, rising if RXINV=1,
 * on the LPUART_RX pin occurs. RXEDGIF is cleared by writing a 1 to it.
 *
 * Values:
 * - 0b0 - No active edge on the receive pin has occurred.
 * - 0b1 - An active edge on the receive pin has occurred.
 */
/*@{*/
/*! @brief Read current value of the LPUART_STAT_RXEDGIF field. */
#define LPUART_RD_STAT_RXEDGIF(base) ((LPUART_STAT_REG(base) & LPUART_STAT_RXEDGIF_MASK) >> LPUART_STAT_RXEDGIF_SHIFT)
#define LPUART_BRD_STAT_RXEDGIF(base) (BME_UBFX32(&LPUART_STAT_REG(base), LPUART_STAT_RXEDGIF_SHIFT, LPUART_STAT_RXEDGIF_WIDTH))

/*! @brief Set the RXEDGIF field to a new value. */
#define LPUART_WR_STAT_RXEDGIF(base, value) (LPUART_RMW_STAT(base, (LPUART_STAT_RXEDGIF_MASK | LPUART_STAT_MA2F_MASK | LPUART_STAT_MA1F_MASK | LPUART_STAT_PF_MASK | LPUART_STAT_FE_MASK | LPUART_STAT_NF_MASK | LPUART_STAT_OR_MASK | LPUART_STAT_IDLE_MASK | LPUART_STAT_LBKDIF_MASK), LPUART_STAT_RXEDGIF(value)))
#define LPUART_BWR_STAT_RXEDGIF(base, value) (BME_BFI32(&LPUART_STAT_REG(base), ((uint32_t)(value) << LPUART_STAT_RXEDGIF_SHIFT), LPUART_STAT_RXEDGIF_SHIFT, LPUART_STAT_RXEDGIF_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_STAT, field LBKDIF[31] (W1C)
 *
 * LBKDIF is set when the LIN break detect circuitry is enabled and a LIN break
 * character is detected. LBKDIF is cleared by writing a 1 to it.
 *
 * Values:
 * - 0b0 - No LIN break character has been detected.
 * - 0b1 - LIN break character has been detected.
 */
/*@{*/
/*! @brief Read current value of the LPUART_STAT_LBKDIF field. */
#define LPUART_RD_STAT_LBKDIF(base) ((LPUART_STAT_REG(base) & LPUART_STAT_LBKDIF_MASK) >> LPUART_STAT_LBKDIF_SHIFT)
#define LPUART_BRD_STAT_LBKDIF(base) (BME_UBFX32(&LPUART_STAT_REG(base), LPUART_STAT_LBKDIF_SHIFT, LPUART_STAT_LBKDIF_WIDTH))

/*! @brief Set the LBKDIF field to a new value. */
#define LPUART_WR_STAT_LBKDIF(base, value) (LPUART_RMW_STAT(base, (LPUART_STAT_LBKDIF_MASK | LPUART_STAT_MA2F_MASK | LPUART_STAT_MA1F_MASK | LPUART_STAT_PF_MASK | LPUART_STAT_FE_MASK | LPUART_STAT_NF_MASK | LPUART_STAT_OR_MASK | LPUART_STAT_IDLE_MASK | LPUART_STAT_RXEDGIF_MASK), LPUART_STAT_LBKDIF(value)))
#define LPUART_BWR_STAT_LBKDIF(base, value) (BME_BFI32(&LPUART_STAT_REG(base), ((uint32_t)(value) << LPUART_STAT_LBKDIF_SHIFT), LPUART_STAT_LBKDIF_SHIFT, LPUART_STAT_LBKDIF_WIDTH))
/*@}*/

/*******************************************************************************
 * LPUART_CTRL - LPUART Control Register
 ******************************************************************************/

/*!
 * @brief LPUART_CTRL - LPUART Control Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This read/write register controls various optional features of the LPUART
 * system. This register should only be altered when the transmitter and receiver
 * are both disabled.
 */
/*!
 * @name Constants and macros for entire LPUART_CTRL register
 */
/*@{*/
#define LPUART_RD_CTRL(base)     (LPUART_CTRL_REG(base))
#define LPUART_WR_CTRL(base, value) (LPUART_CTRL_REG(base) = (value))
#define LPUART_RMW_CTRL(base, mask, value) (LPUART_WR_CTRL(base, (LPUART_RD_CTRL(base) & ~(mask)) | (value)))
#define LPUART_SET_CTRL(base, value) (BME_OR32(&LPUART_CTRL_REG(base), (uint32_t)(value)))
#define LPUART_CLR_CTRL(base, value) (BME_AND32(&LPUART_CTRL_REG(base), (uint32_t)(~(value))))
#define LPUART_TOG_CTRL(base, value) (BME_XOR32(&LPUART_CTRL_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual LPUART_CTRL bitfields
 */

/*!
 * @name Register LPUART_CTRL, field PT[0] (RW)
 *
 * Provided parity is enabled (PE = 1), this bit selects even or odd parity. Odd
 * parity means the total number of 1s in the data character, including the
 * parity bit, is odd. Even parity means the total number of 1s in the data
 * character, including the parity bit, is even.
 *
 * Values:
 * - 0b0 - Even parity.
 * - 0b1 - Odd parity.
 */
/*@{*/
/*! @brief Read current value of the LPUART_CTRL_PT field. */
#define LPUART_RD_CTRL_PT(base) ((LPUART_CTRL_REG(base) & LPUART_CTRL_PT_MASK) >> LPUART_CTRL_PT_SHIFT)
#define LPUART_BRD_CTRL_PT(base) (BME_UBFX32(&LPUART_CTRL_REG(base), LPUART_CTRL_PT_SHIFT, LPUART_CTRL_PT_WIDTH))

/*! @brief Set the PT field to a new value. */
#define LPUART_WR_CTRL_PT(base, value) (LPUART_RMW_CTRL(base, LPUART_CTRL_PT_MASK, LPUART_CTRL_PT(value)))
#define LPUART_BWR_CTRL_PT(base, value) (BME_BFI32(&LPUART_CTRL_REG(base), ((uint32_t)(value) << LPUART_CTRL_PT_SHIFT), LPUART_CTRL_PT_SHIFT, LPUART_CTRL_PT_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field PE[1] (RW)
 *
 * Enables hardware parity generation and checking. When parity is enabled, the
 * bit immediately before the stop bit is treated as the parity bit.
 *
 * Values:
 * - 0b0 - No hardware parity generation or checking.
 * - 0b1 - Parity enabled.
 */
/*@{*/
/*! @brief Read current value of the LPUART_CTRL_PE field. */
#define LPUART_RD_CTRL_PE(base) ((LPUART_CTRL_REG(base) & LPUART_CTRL_PE_MASK) >> LPUART_CTRL_PE_SHIFT)
#define LPUART_BRD_CTRL_PE(base) (BME_UBFX32(&LPUART_CTRL_REG(base), LPUART_CTRL_PE_SHIFT, LPUART_CTRL_PE_WIDTH))

/*! @brief Set the PE field to a new value. */
#define LPUART_WR_CTRL_PE(base, value) (LPUART_RMW_CTRL(base, LPUART_CTRL_PE_MASK, LPUART_CTRL_PE(value)))
#define LPUART_BWR_CTRL_PE(base, value) (BME_BFI32(&LPUART_CTRL_REG(base), ((uint32_t)(value) << LPUART_CTRL_PE_SHIFT), LPUART_CTRL_PE_SHIFT, LPUART_CTRL_PE_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field ILT[2] (RW)
 *
 * Determines when the receiver starts counting logic 1s as idle character bits.
 * The count begins either after a valid start bit or after the stop bit. If the
 * count begins after the start bit, then a string of logic 1s preceding the
 * stop bit can cause false recognition of an idle character. Beginning the count
 * after the stop bit avoids false idle character recognition, but requires
 * properly synchronized transmissions. In case the LPUART is programmed with ILT = 1, a
 * logic 0 is automatically shifted after a received stop bit, therefore
 * resetting the idle count.
 *
 * Values:
 * - 0b0 - Idle character bit count starts after start bit.
 * - 0b1 - Idle character bit count starts after stop bit.
 */
/*@{*/
/*! @brief Read current value of the LPUART_CTRL_ILT field. */
#define LPUART_RD_CTRL_ILT(base) ((LPUART_CTRL_REG(base) & LPUART_CTRL_ILT_MASK) >> LPUART_CTRL_ILT_SHIFT)
#define LPUART_BRD_CTRL_ILT(base) (BME_UBFX32(&LPUART_CTRL_REG(base), LPUART_CTRL_ILT_SHIFT, LPUART_CTRL_ILT_WIDTH))

/*! @brief Set the ILT field to a new value. */
#define LPUART_WR_CTRL_ILT(base, value) (LPUART_RMW_CTRL(base, LPUART_CTRL_ILT_MASK, LPUART_CTRL_ILT(value)))
#define LPUART_BWR_CTRL_ILT(base, value) (BME_BFI32(&LPUART_CTRL_REG(base), ((uint32_t)(value) << LPUART_CTRL_ILT_SHIFT), LPUART_CTRL_ILT_SHIFT, LPUART_CTRL_ILT_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field WAKE[3] (RW)
 *
 * Determines which condition wakes the LPUART when RWU=1: Address mark in the
 * most significant bit position of a received data character, or An idle
 * condition on the receive pin input signal.
 *
 * Values:
 * - 0b0 - Configures RWU for idle-line wakeup.
 * - 0b1 - Configures RWU with address-mark wakeup.
 */
/*@{*/
/*! @brief Read current value of the LPUART_CTRL_WAKE field. */
#define LPUART_RD_CTRL_WAKE(base) ((LPUART_CTRL_REG(base) & LPUART_CTRL_WAKE_MASK) >> LPUART_CTRL_WAKE_SHIFT)
#define LPUART_BRD_CTRL_WAKE(base) (BME_UBFX32(&LPUART_CTRL_REG(base), LPUART_CTRL_WAKE_SHIFT, LPUART_CTRL_WAKE_WIDTH))

/*! @brief Set the WAKE field to a new value. */
#define LPUART_WR_CTRL_WAKE(base, value) (LPUART_RMW_CTRL(base, LPUART_CTRL_WAKE_MASK, LPUART_CTRL_WAKE(value)))
#define LPUART_BWR_CTRL_WAKE(base, value) (BME_BFI32(&LPUART_CTRL_REG(base), ((uint32_t)(value) << LPUART_CTRL_WAKE_SHIFT), LPUART_CTRL_WAKE_SHIFT, LPUART_CTRL_WAKE_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field M[4] (RW)
 *
 * Values:
 * - 0b0 - Receiver and transmitter use 8-bit data characters.
 * - 0b1 - Receiver and transmitter use 9-bit data characters.
 */
/*@{*/
/*! @brief Read current value of the LPUART_CTRL_M field. */
#define LPUART_RD_CTRL_M(base) ((LPUART_CTRL_REG(base) & LPUART_CTRL_M_MASK) >> LPUART_CTRL_M_SHIFT)
#define LPUART_BRD_CTRL_M(base) (BME_UBFX32(&LPUART_CTRL_REG(base), LPUART_CTRL_M_SHIFT, LPUART_CTRL_M_WIDTH))

/*! @brief Set the M field to a new value. */
#define LPUART_WR_CTRL_M(base, value) (LPUART_RMW_CTRL(base, LPUART_CTRL_M_MASK, LPUART_CTRL_M(value)))
#define LPUART_BWR_CTRL_M(base, value) (BME_BFI32(&LPUART_CTRL_REG(base), ((uint32_t)(value) << LPUART_CTRL_M_SHIFT), LPUART_CTRL_M_SHIFT, LPUART_CTRL_M_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field RSRC[5] (RW)
 *
 * This field has no meaning or effect unless the LOOPS field is set. When LOOPS
 * is set, the RSRC field determines the source for the receiver shift register
 * input.
 *
 * Values:
 * - 0b0 - Provided LOOPS is set, RSRC is cleared, selects internal loop back
 *     mode and the LPUART does not use the LPUART_RX pin.
 * - 0b1 - Single-wire LPUART mode where the LPUART_TX pin is connected to the
 *     transmitter output and receiver input.
 */
/*@{*/
/*! @brief Read current value of the LPUART_CTRL_RSRC field. */
#define LPUART_RD_CTRL_RSRC(base) ((LPUART_CTRL_REG(base) & LPUART_CTRL_RSRC_MASK) >> LPUART_CTRL_RSRC_SHIFT)
#define LPUART_BRD_CTRL_RSRC(base) (BME_UBFX32(&LPUART_CTRL_REG(base), LPUART_CTRL_RSRC_SHIFT, LPUART_CTRL_RSRC_WIDTH))

/*! @brief Set the RSRC field to a new value. */
#define LPUART_WR_CTRL_RSRC(base, value) (LPUART_RMW_CTRL(base, LPUART_CTRL_RSRC_MASK, LPUART_CTRL_RSRC(value)))
#define LPUART_BWR_CTRL_RSRC(base, value) (BME_BFI32(&LPUART_CTRL_REG(base), ((uint32_t)(value) << LPUART_CTRL_RSRC_SHIFT), LPUART_CTRL_RSRC_SHIFT, LPUART_CTRL_RSRC_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field DOZEEN[6] (RW)
 *
 * Values:
 * - 0b0 - LPUART is enabled in Doze mode.
 * - 0b1 - LPUART is disabled in Doze mode.
 */
/*@{*/
/*! @brief Read current value of the LPUART_CTRL_DOZEEN field. */
#define LPUART_RD_CTRL_DOZEEN(base) ((LPUART_CTRL_REG(base) & LPUART_CTRL_DOZEEN_MASK) >> LPUART_CTRL_DOZEEN_SHIFT)
#define LPUART_BRD_CTRL_DOZEEN(base) (BME_UBFX32(&LPUART_CTRL_REG(base), LPUART_CTRL_DOZEEN_SHIFT, LPUART_CTRL_DOZEEN_WIDTH))

/*! @brief Set the DOZEEN field to a new value. */
#define LPUART_WR_CTRL_DOZEEN(base, value) (LPUART_RMW_CTRL(base, LPUART_CTRL_DOZEEN_MASK, LPUART_CTRL_DOZEEN(value)))
#define LPUART_BWR_CTRL_DOZEEN(base, value) (BME_BFI32(&LPUART_CTRL_REG(base), ((uint32_t)(value) << LPUART_CTRL_DOZEEN_SHIFT), LPUART_CTRL_DOZEEN_SHIFT, LPUART_CTRL_DOZEEN_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field LOOPS[7] (RW)
 *
 * When LOOPS is set, the LPUART_RX pin is disconnected from the LPUART and the
 * transmitter output is internally connected to the receiver input. The
 * transmitter and the receiver must be enabled to use the loop function.
 *
 * Values:
 * - 0b0 - Normal operation - LPUART_RX and LPUART_TX use separate pins.
 * - 0b1 - Loop mode or single-wire mode where transmitter outputs are
 *     internally connected to receiver input (see RSRC bit).
 */
/*@{*/
/*! @brief Read current value of the LPUART_CTRL_LOOPS field. */
#define LPUART_RD_CTRL_LOOPS(base) ((LPUART_CTRL_REG(base) & LPUART_CTRL_LOOPS_MASK) >> LPUART_CTRL_LOOPS_SHIFT)
#define LPUART_BRD_CTRL_LOOPS(base) (BME_UBFX32(&LPUART_CTRL_REG(base), LPUART_CTRL_LOOPS_SHIFT, LPUART_CTRL_LOOPS_WIDTH))

/*! @brief Set the LOOPS field to a new value. */
#define LPUART_WR_CTRL_LOOPS(base, value) (LPUART_RMW_CTRL(base, LPUART_CTRL_LOOPS_MASK, LPUART_CTRL_LOOPS(value)))
#define LPUART_BWR_CTRL_LOOPS(base, value) (BME_BFI32(&LPUART_CTRL_REG(base), ((uint32_t)(value) << LPUART_CTRL_LOOPS_SHIFT), LPUART_CTRL_LOOPS_SHIFT, LPUART_CTRL_LOOPS_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field IDLECFG[10:8] (RW)
 *
 * Configures the number of idle characters that must be received before the
 * IDLE flag is set.
 *
 * Values:
 * - 0b000 - 1 idle character
 * - 0b001 - 2 idle characters
 * - 0b010 - 4 idle characters
 * - 0b011 - 8 idle characters
 * - 0b100 - 16 idle characters
 * - 0b101 - 32 idle characters
 * - 0b110 - 64 idle characters
 * - 0b111 - 128 idle characters
 */
/*@{*/
/*! @brief Read current value of the LPUART_CTRL_IDLECFG field. */
#define LPUART_RD_CTRL_IDLECFG(base) ((LPUART_CTRL_REG(base) & LPUART_CTRL_IDLECFG_MASK) >> LPUART_CTRL_IDLECFG_SHIFT)
#define LPUART_BRD_CTRL_IDLECFG(base) (BME_UBFX32(&LPUART_CTRL_REG(base), LPUART_CTRL_IDLECFG_SHIFT, LPUART_CTRL_IDLECFG_WIDTH))

/*! @brief Set the IDLECFG field to a new value. */
#define LPUART_WR_CTRL_IDLECFG(base, value) (LPUART_RMW_CTRL(base, LPUART_CTRL_IDLECFG_MASK, LPUART_CTRL_IDLECFG(value)))
#define LPUART_BWR_CTRL_IDLECFG(base, value) (BME_BFI32(&LPUART_CTRL_REG(base), ((uint32_t)(value) << LPUART_CTRL_IDLECFG_SHIFT), LPUART_CTRL_IDLECFG_SHIFT, LPUART_CTRL_IDLECFG_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field MA2IE[14] (RW)
 *
 * Values:
 * - 0b0 - MA2F interrupt disabled
 * - 0b1 - MA2F interrupt enabled
 */
/*@{*/
/*! @brief Read current value of the LPUART_CTRL_MA2IE field. */
#define LPUART_RD_CTRL_MA2IE(base) ((LPUART_CTRL_REG(base) & LPUART_CTRL_MA2IE_MASK) >> LPUART_CTRL_MA2IE_SHIFT)
#define LPUART_BRD_CTRL_MA2IE(base) (BME_UBFX32(&LPUART_CTRL_REG(base), LPUART_CTRL_MA2IE_SHIFT, LPUART_CTRL_MA2IE_WIDTH))

/*! @brief Set the MA2IE field to a new value. */
#define LPUART_WR_CTRL_MA2IE(base, value) (LPUART_RMW_CTRL(base, LPUART_CTRL_MA2IE_MASK, LPUART_CTRL_MA2IE(value)))
#define LPUART_BWR_CTRL_MA2IE(base, value) (BME_BFI32(&LPUART_CTRL_REG(base), ((uint32_t)(value) << LPUART_CTRL_MA2IE_SHIFT), LPUART_CTRL_MA2IE_SHIFT, LPUART_CTRL_MA2IE_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field MA1IE[15] (RW)
 *
 * Values:
 * - 0b0 - MA1F interrupt disabled
 * - 0b1 - MA1F interrupt enabled
 */
/*@{*/
/*! @brief Read current value of the LPUART_CTRL_MA1IE field. */
#define LPUART_RD_CTRL_MA1IE(base) ((LPUART_CTRL_REG(base) & LPUART_CTRL_MA1IE_MASK) >> LPUART_CTRL_MA1IE_SHIFT)
#define LPUART_BRD_CTRL_MA1IE(base) (BME_UBFX32(&LPUART_CTRL_REG(base), LPUART_CTRL_MA1IE_SHIFT, LPUART_CTRL_MA1IE_WIDTH))

/*! @brief Set the MA1IE field to a new value. */
#define LPUART_WR_CTRL_MA1IE(base, value) (LPUART_RMW_CTRL(base, LPUART_CTRL_MA1IE_MASK, LPUART_CTRL_MA1IE(value)))
#define LPUART_BWR_CTRL_MA1IE(base, value) (BME_BFI32(&LPUART_CTRL_REG(base), ((uint32_t)(value) << LPUART_CTRL_MA1IE_SHIFT), LPUART_CTRL_MA1IE_SHIFT, LPUART_CTRL_MA1IE_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field SBK[16] (RW)
 *
 * Writing a 1 and then a 0 to SBK queues a break character in the transmit data
 * stream. Additional break characters of 10 to 13, or 13 to 16 if
 * LPUART_STATBRK13] is set, bit times of logic 0 are queued as long as SBK is set. Depending
 * on the timing of the set and clear of SBK relative to the information
 * currently being transmitted, a second break character may be queued before software
 * clears SBK.
 *
 * Values:
 * - 0b0 - Normal transmitter operation.
 * - 0b1 - Queue break character(s) to be sent.
 */
/*@{*/
/*! @brief Read current value of the LPUART_CTRL_SBK field. */
#define LPUART_RD_CTRL_SBK(base) ((LPUART_CTRL_REG(base) & LPUART_CTRL_SBK_MASK) >> LPUART_CTRL_SBK_SHIFT)
#define LPUART_BRD_CTRL_SBK(base) (BME_UBFX32(&LPUART_CTRL_REG(base), LPUART_CTRL_SBK_SHIFT, LPUART_CTRL_SBK_WIDTH))

/*! @brief Set the SBK field to a new value. */
#define LPUART_WR_CTRL_SBK(base, value) (LPUART_RMW_CTRL(base, LPUART_CTRL_SBK_MASK, LPUART_CTRL_SBK(value)))
#define LPUART_BWR_CTRL_SBK(base, value) (BME_BFI32(&LPUART_CTRL_REG(base), ((uint32_t)(value) << LPUART_CTRL_SBK_SHIFT), LPUART_CTRL_SBK_SHIFT, LPUART_CTRL_SBK_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field RWU[17] (RW)
 *
 * This field can be set to place the LPUART receiver in a standby state. RWU
 * automatically clears when an RWU event occurs, that is, an IDLE event when
 * CTRL[WAKE] is clear or an address match when CTRL[WAKE] is set with STAT[RWUID] is
 * clear. RWU must be set only with CTRL[WAKE] = 0 (wakeup on idle) if the
 * channel is currently not idle. This can be determined by STAT[RAF]. If the flag is
 * set to wake up an IDLE event and the channel is already idle, it is possible
 * that the LPUART will discard data. This is because the data must be received or
 * a LIN break detected after an IDLE is detected before IDLE is allowed to
 * reasserted.
 *
 * Values:
 * - 0b0 - Normal receiver operation.
 * - 0b1 - LPUART receiver in standby waiting for wakeup condition.
 */
/*@{*/
/*! @brief Read current value of the LPUART_CTRL_RWU field. */
#define LPUART_RD_CTRL_RWU(base) ((LPUART_CTRL_REG(base) & LPUART_CTRL_RWU_MASK) >> LPUART_CTRL_RWU_SHIFT)
#define LPUART_BRD_CTRL_RWU(base) (BME_UBFX32(&LPUART_CTRL_REG(base), LPUART_CTRL_RWU_SHIFT, LPUART_CTRL_RWU_WIDTH))

/*! @brief Set the RWU field to a new value. */
#define LPUART_WR_CTRL_RWU(base, value) (LPUART_RMW_CTRL(base, LPUART_CTRL_RWU_MASK, LPUART_CTRL_RWU(value)))
#define LPUART_BWR_CTRL_RWU(base, value) (BME_BFI32(&LPUART_CTRL_REG(base), ((uint32_t)(value) << LPUART_CTRL_RWU_SHIFT), LPUART_CTRL_RWU_SHIFT, LPUART_CTRL_RWU_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field RE[18] (RW)
 *
 * Enables the LPUART receiver. When RE is written to 0, this register bit will
 * read as 1 until the receiver finishes receiving the current character (if any).
 *
 * Values:
 * - 0b0 - Receiver disabled.
 * - 0b1 - Receiver enabled.
 */
/*@{*/
/*! @brief Read current value of the LPUART_CTRL_RE field. */
#define LPUART_RD_CTRL_RE(base) ((LPUART_CTRL_REG(base) & LPUART_CTRL_RE_MASK) >> LPUART_CTRL_RE_SHIFT)
#define LPUART_BRD_CTRL_RE(base) (BME_UBFX32(&LPUART_CTRL_REG(base), LPUART_CTRL_RE_SHIFT, LPUART_CTRL_RE_WIDTH))

/*! @brief Set the RE field to a new value. */
#define LPUART_WR_CTRL_RE(base, value) (LPUART_RMW_CTRL(base, LPUART_CTRL_RE_MASK, LPUART_CTRL_RE(value)))
#define LPUART_BWR_CTRL_RE(base, value) (BME_BFI32(&LPUART_CTRL_REG(base), ((uint32_t)(value) << LPUART_CTRL_RE_SHIFT), LPUART_CTRL_RE_SHIFT, LPUART_CTRL_RE_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field TE[19] (RW)
 *
 * Enables the LPUART transmitter. TE can also be used to queue an idle preamble
 * by clearing and then setting TE. When TE is cleared, this register bit will
 * read as 1 until the transmitter has completed the current character and the
 * LPUART_TX pin is tristated.
 *
 * Values:
 * - 0b0 - Transmitter disabled.
 * - 0b1 - Transmitter enabled.
 */
/*@{*/
/*! @brief Read current value of the LPUART_CTRL_TE field. */
#define LPUART_RD_CTRL_TE(base) ((LPUART_CTRL_REG(base) & LPUART_CTRL_TE_MASK) >> LPUART_CTRL_TE_SHIFT)
#define LPUART_BRD_CTRL_TE(base) (BME_UBFX32(&LPUART_CTRL_REG(base), LPUART_CTRL_TE_SHIFT, LPUART_CTRL_TE_WIDTH))

/*! @brief Set the TE field to a new value. */
#define LPUART_WR_CTRL_TE(base, value) (LPUART_RMW_CTRL(base, LPUART_CTRL_TE_MASK, LPUART_CTRL_TE(value)))
#define LPUART_BWR_CTRL_TE(base, value) (BME_BFI32(&LPUART_CTRL_REG(base), ((uint32_t)(value) << LPUART_CTRL_TE_SHIFT), LPUART_CTRL_TE_SHIFT, LPUART_CTRL_TE_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field ILIE[20] (RW)
 *
 * ILIE enables the idle line flag, STAT[IDLE], to generate interrupt requests.
 *
 * Values:
 * - 0b0 - Hardware interrupts from IDLE disabled; use polling.
 * - 0b1 - Hardware interrupt requested when IDLE flag is 1.
 */
/*@{*/
/*! @brief Read current value of the LPUART_CTRL_ILIE field. */
#define LPUART_RD_CTRL_ILIE(base) ((LPUART_CTRL_REG(base) & LPUART_CTRL_ILIE_MASK) >> LPUART_CTRL_ILIE_SHIFT)
#define LPUART_BRD_CTRL_ILIE(base) (BME_UBFX32(&LPUART_CTRL_REG(base), LPUART_CTRL_ILIE_SHIFT, LPUART_CTRL_ILIE_WIDTH))

/*! @brief Set the ILIE field to a new value. */
#define LPUART_WR_CTRL_ILIE(base, value) (LPUART_RMW_CTRL(base, LPUART_CTRL_ILIE_MASK, LPUART_CTRL_ILIE(value)))
#define LPUART_BWR_CTRL_ILIE(base, value) (BME_BFI32(&LPUART_CTRL_REG(base), ((uint32_t)(value) << LPUART_CTRL_ILIE_SHIFT), LPUART_CTRL_ILIE_SHIFT, LPUART_CTRL_ILIE_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field RIE[21] (RW)
 *
 * Enables STAT[RDRF] to generate interrupt requests.
 *
 * Values:
 * - 0b0 - Hardware interrupts from RDRF disabled; use polling.
 * - 0b1 - Hardware interrupt requested when RDRF flag is 1.
 */
/*@{*/
/*! @brief Read current value of the LPUART_CTRL_RIE field. */
#define LPUART_RD_CTRL_RIE(base) ((LPUART_CTRL_REG(base) & LPUART_CTRL_RIE_MASK) >> LPUART_CTRL_RIE_SHIFT)
#define LPUART_BRD_CTRL_RIE(base) (BME_UBFX32(&LPUART_CTRL_REG(base), LPUART_CTRL_RIE_SHIFT, LPUART_CTRL_RIE_WIDTH))

/*! @brief Set the RIE field to a new value. */
#define LPUART_WR_CTRL_RIE(base, value) (LPUART_RMW_CTRL(base, LPUART_CTRL_RIE_MASK, LPUART_CTRL_RIE(value)))
#define LPUART_BWR_CTRL_RIE(base, value) (BME_BFI32(&LPUART_CTRL_REG(base), ((uint32_t)(value) << LPUART_CTRL_RIE_SHIFT), LPUART_CTRL_RIE_SHIFT, LPUART_CTRL_RIE_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field TCIE[22] (RW)
 *
 * TCIE enables the transmission complete flag, TC, to generate interrupt
 * requests.
 *
 * Values:
 * - 0b0 - Hardware interrupts from TC disabled; use polling.
 * - 0b1 - Hardware interrupt requested when TC flag is 1.
 */
/*@{*/
/*! @brief Read current value of the LPUART_CTRL_TCIE field. */
#define LPUART_RD_CTRL_TCIE(base) ((LPUART_CTRL_REG(base) & LPUART_CTRL_TCIE_MASK) >> LPUART_CTRL_TCIE_SHIFT)
#define LPUART_BRD_CTRL_TCIE(base) (BME_UBFX32(&LPUART_CTRL_REG(base), LPUART_CTRL_TCIE_SHIFT, LPUART_CTRL_TCIE_WIDTH))

/*! @brief Set the TCIE field to a new value. */
#define LPUART_WR_CTRL_TCIE(base, value) (LPUART_RMW_CTRL(base, LPUART_CTRL_TCIE_MASK, LPUART_CTRL_TCIE(value)))
#define LPUART_BWR_CTRL_TCIE(base, value) (BME_BFI32(&LPUART_CTRL_REG(base), ((uint32_t)(value) << LPUART_CTRL_TCIE_SHIFT), LPUART_CTRL_TCIE_SHIFT, LPUART_CTRL_TCIE_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field TIE[23] (RW)
 *
 * Enables STAT[TDRE] to generate interrupt requests.
 *
 * Values:
 * - 0b0 - Hardware interrupts from TDRE disabled; use polling.
 * - 0b1 - Hardware interrupt requested when TDRE flag is 1.
 */
/*@{*/
/*! @brief Read current value of the LPUART_CTRL_TIE field. */
#define LPUART_RD_CTRL_TIE(base) ((LPUART_CTRL_REG(base) & LPUART_CTRL_TIE_MASK) >> LPUART_CTRL_TIE_SHIFT)
#define LPUART_BRD_CTRL_TIE(base) (BME_UBFX32(&LPUART_CTRL_REG(base), LPUART_CTRL_TIE_SHIFT, LPUART_CTRL_TIE_WIDTH))

/*! @brief Set the TIE field to a new value. */
#define LPUART_WR_CTRL_TIE(base, value) (LPUART_RMW_CTRL(base, LPUART_CTRL_TIE_MASK, LPUART_CTRL_TIE(value)))
#define LPUART_BWR_CTRL_TIE(base, value) (BME_BFI32(&LPUART_CTRL_REG(base), ((uint32_t)(value) << LPUART_CTRL_TIE_SHIFT), LPUART_CTRL_TIE_SHIFT, LPUART_CTRL_TIE_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field PEIE[24] (RW)
 *
 * This bit enables the parity error flag (PF) to generate hardware interrupt
 * requests.
 *
 * Values:
 * - 0b0 - PF interrupts disabled; use polling).
 * - 0b1 - Hardware interrupt requested when PF is set.
 */
/*@{*/
/*! @brief Read current value of the LPUART_CTRL_PEIE field. */
#define LPUART_RD_CTRL_PEIE(base) ((LPUART_CTRL_REG(base) & LPUART_CTRL_PEIE_MASK) >> LPUART_CTRL_PEIE_SHIFT)
#define LPUART_BRD_CTRL_PEIE(base) (BME_UBFX32(&LPUART_CTRL_REG(base), LPUART_CTRL_PEIE_SHIFT, LPUART_CTRL_PEIE_WIDTH))

/*! @brief Set the PEIE field to a new value. */
#define LPUART_WR_CTRL_PEIE(base, value) (LPUART_RMW_CTRL(base, LPUART_CTRL_PEIE_MASK, LPUART_CTRL_PEIE(value)))
#define LPUART_BWR_CTRL_PEIE(base, value) (BME_BFI32(&LPUART_CTRL_REG(base), ((uint32_t)(value) << LPUART_CTRL_PEIE_SHIFT), LPUART_CTRL_PEIE_SHIFT, LPUART_CTRL_PEIE_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field FEIE[25] (RW)
 *
 * This bit enables the framing error flag (FE) to generate hardware interrupt
 * requests.
 *
 * Values:
 * - 0b0 - FE interrupts disabled; use polling.
 * - 0b1 - Hardware interrupt requested when FE is set.
 */
/*@{*/
/*! @brief Read current value of the LPUART_CTRL_FEIE field. */
#define LPUART_RD_CTRL_FEIE(base) ((LPUART_CTRL_REG(base) & LPUART_CTRL_FEIE_MASK) >> LPUART_CTRL_FEIE_SHIFT)
#define LPUART_BRD_CTRL_FEIE(base) (BME_UBFX32(&LPUART_CTRL_REG(base), LPUART_CTRL_FEIE_SHIFT, LPUART_CTRL_FEIE_WIDTH))

/*! @brief Set the FEIE field to a new value. */
#define LPUART_WR_CTRL_FEIE(base, value) (LPUART_RMW_CTRL(base, LPUART_CTRL_FEIE_MASK, LPUART_CTRL_FEIE(value)))
#define LPUART_BWR_CTRL_FEIE(base, value) (BME_BFI32(&LPUART_CTRL_REG(base), ((uint32_t)(value) << LPUART_CTRL_FEIE_SHIFT), LPUART_CTRL_FEIE_SHIFT, LPUART_CTRL_FEIE_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field NEIE[26] (RW)
 *
 * This bit enables the noise flag (NF) to generate hardware interrupt requests.
 *
 * Values:
 * - 0b0 - NF interrupts disabled; use polling.
 * - 0b1 - Hardware interrupt requested when NF is set.
 */
/*@{*/
/*! @brief Read current value of the LPUART_CTRL_NEIE field. */
#define LPUART_RD_CTRL_NEIE(base) ((LPUART_CTRL_REG(base) & LPUART_CTRL_NEIE_MASK) >> LPUART_CTRL_NEIE_SHIFT)
#define LPUART_BRD_CTRL_NEIE(base) (BME_UBFX32(&LPUART_CTRL_REG(base), LPUART_CTRL_NEIE_SHIFT, LPUART_CTRL_NEIE_WIDTH))

/*! @brief Set the NEIE field to a new value. */
#define LPUART_WR_CTRL_NEIE(base, value) (LPUART_RMW_CTRL(base, LPUART_CTRL_NEIE_MASK, LPUART_CTRL_NEIE(value)))
#define LPUART_BWR_CTRL_NEIE(base, value) (BME_BFI32(&LPUART_CTRL_REG(base), ((uint32_t)(value) << LPUART_CTRL_NEIE_SHIFT), LPUART_CTRL_NEIE_SHIFT, LPUART_CTRL_NEIE_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field ORIE[27] (RW)
 *
 * This bit enables the overrun flag (OR) to generate hardware interrupt
 * requests.
 *
 * Values:
 * - 0b0 - OR interrupts disabled; use polling.
 * - 0b1 - Hardware interrupt requested when OR is set.
 */
/*@{*/
/*! @brief Read current value of the LPUART_CTRL_ORIE field. */
#define LPUART_RD_CTRL_ORIE(base) ((LPUART_CTRL_REG(base) & LPUART_CTRL_ORIE_MASK) >> LPUART_CTRL_ORIE_SHIFT)
#define LPUART_BRD_CTRL_ORIE(base) (BME_UBFX32(&LPUART_CTRL_REG(base), LPUART_CTRL_ORIE_SHIFT, LPUART_CTRL_ORIE_WIDTH))

/*! @brief Set the ORIE field to a new value. */
#define LPUART_WR_CTRL_ORIE(base, value) (LPUART_RMW_CTRL(base, LPUART_CTRL_ORIE_MASK, LPUART_CTRL_ORIE(value)))
#define LPUART_BWR_CTRL_ORIE(base, value) (BME_BFI32(&LPUART_CTRL_REG(base), ((uint32_t)(value) << LPUART_CTRL_ORIE_SHIFT), LPUART_CTRL_ORIE_SHIFT, LPUART_CTRL_ORIE_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field TXINV[28] (RW)
 *
 * Setting this bit reverses the polarity of the transmitted data output.
 * Setting TXINV inverts the LPUART_TX output for all cases: data bits, start and stop
 * bits, break, and idle.
 *
 * Values:
 * - 0b0 - Transmit data not inverted.
 * - 0b1 - Transmit data inverted.
 */
/*@{*/
/*! @brief Read current value of the LPUART_CTRL_TXINV field. */
#define LPUART_RD_CTRL_TXINV(base) ((LPUART_CTRL_REG(base) & LPUART_CTRL_TXINV_MASK) >> LPUART_CTRL_TXINV_SHIFT)
#define LPUART_BRD_CTRL_TXINV(base) (BME_UBFX32(&LPUART_CTRL_REG(base), LPUART_CTRL_TXINV_SHIFT, LPUART_CTRL_TXINV_WIDTH))

/*! @brief Set the TXINV field to a new value. */
#define LPUART_WR_CTRL_TXINV(base, value) (LPUART_RMW_CTRL(base, LPUART_CTRL_TXINV_MASK, LPUART_CTRL_TXINV(value)))
#define LPUART_BWR_CTRL_TXINV(base, value) (BME_BFI32(&LPUART_CTRL_REG(base), ((uint32_t)(value) << LPUART_CTRL_TXINV_SHIFT), LPUART_CTRL_TXINV_SHIFT, LPUART_CTRL_TXINV_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field TXDIR[29] (RW)
 *
 * When the LPUART is configured for single-wire half-duplex operation (LOOPS =
 * RSRC = 1), this bit determines the direction of data at the LPUART_TX pin.
 * When clearing TXDIR, the transmitter will finish receiving the current character
 * (if any) before the receiver starts receiving data from the LPUART_TX pin.
 *
 * Values:
 * - 0b0 - LPUART_TX pin is an input in single-wire mode.
 * - 0b1 - LPUART_TX pin is an output in single-wire mode.
 */
/*@{*/
/*! @brief Read current value of the LPUART_CTRL_TXDIR field. */
#define LPUART_RD_CTRL_TXDIR(base) ((LPUART_CTRL_REG(base) & LPUART_CTRL_TXDIR_MASK) >> LPUART_CTRL_TXDIR_SHIFT)
#define LPUART_BRD_CTRL_TXDIR(base) (BME_UBFX32(&LPUART_CTRL_REG(base), LPUART_CTRL_TXDIR_SHIFT, LPUART_CTRL_TXDIR_WIDTH))

/*! @brief Set the TXDIR field to a new value. */
#define LPUART_WR_CTRL_TXDIR(base, value) (LPUART_RMW_CTRL(base, LPUART_CTRL_TXDIR_MASK, LPUART_CTRL_TXDIR(value)))
#define LPUART_BWR_CTRL_TXDIR(base, value) (BME_BFI32(&LPUART_CTRL_REG(base), ((uint32_t)(value) << LPUART_CTRL_TXDIR_SHIFT), LPUART_CTRL_TXDIR_SHIFT, LPUART_CTRL_TXDIR_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field R9T8[30] (RW)
 *
 * R9 is the tenth data bit received when the LPUART is configured for 10-bit
 * data formats. When reading 10-bit data, read R9 before reading LPUART_DATA T8 is
 * the ninth data bit received when the LPUART is configured for 9-bit or 10-bit
 * data formats. When writing 9-bit or 10-bit data, write T8 before writing
 * LPUART_DATA. If T8 does not need to change from its previous value, such as when
 * it is used to generate address mark or parity, they it need not be written each
 * time LPUART_DATA is written.
 */
/*@{*/
/*! @brief Read current value of the LPUART_CTRL_R9T8 field. */
#define LPUART_RD_CTRL_R9T8(base) ((LPUART_CTRL_REG(base) & LPUART_CTRL_R9T8_MASK) >> LPUART_CTRL_R9T8_SHIFT)
#define LPUART_BRD_CTRL_R9T8(base) (BME_UBFX32(&LPUART_CTRL_REG(base), LPUART_CTRL_R9T8_SHIFT, LPUART_CTRL_R9T8_WIDTH))

/*! @brief Set the R9T8 field to a new value. */
#define LPUART_WR_CTRL_R9T8(base, value) (LPUART_RMW_CTRL(base, LPUART_CTRL_R9T8_MASK, LPUART_CTRL_R9T8(value)))
#define LPUART_BWR_CTRL_R9T8(base, value) (BME_BFI32(&LPUART_CTRL_REG(base), ((uint32_t)(value) << LPUART_CTRL_R9T8_SHIFT), LPUART_CTRL_R9T8_SHIFT, LPUART_CTRL_R9T8_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field R8T9[31] (RW)
 *
 * R8 is the ninth data bit received when the LPUART is configured for 9-bit or
 * 10-bit data formats. When reading 9-bit or 10-bit data, read R8 before reading
 * LPUART_DATA. T9 is the tenth data bit received when the LPUART is configured
 * for 10-bit data formats. When writing 10-bit data, write T9 before writing
 * LPUART_DATA. If T9 does not need to change from its previous value, such as when
 * it is used to generate address mark or parity, they it need not be written
 * each time LPUART_DATA is written.
 */
/*@{*/
/*! @brief Read current value of the LPUART_CTRL_R8T9 field. */
#define LPUART_RD_CTRL_R8T9(base) ((LPUART_CTRL_REG(base) & LPUART_CTRL_R8T9_MASK) >> LPUART_CTRL_R8T9_SHIFT)
#define LPUART_BRD_CTRL_R8T9(base) (BME_UBFX32(&LPUART_CTRL_REG(base), LPUART_CTRL_R8T9_SHIFT, LPUART_CTRL_R8T9_WIDTH))

/*! @brief Set the R8T9 field to a new value. */
#define LPUART_WR_CTRL_R8T9(base, value) (LPUART_RMW_CTRL(base, LPUART_CTRL_R8T9_MASK, LPUART_CTRL_R8T9(value)))
#define LPUART_BWR_CTRL_R8T9(base, value) (BME_BFI32(&LPUART_CTRL_REG(base), ((uint32_t)(value) << LPUART_CTRL_R8T9_SHIFT), LPUART_CTRL_R8T9_SHIFT, LPUART_CTRL_R8T9_WIDTH))
/*@}*/

/*******************************************************************************
 * LPUART_DATA - LPUART Data Register
 ******************************************************************************/

/*!
 * @brief LPUART_DATA - LPUART Data Register (RW)
 *
 * Reset value: 0x00001000U
 *
 * This register is actually two separate registers. Reads return the contents
 * of the read-only receive data buffer and writes go to the write-only transmit
 * data buffer. Reads and writes of this register are also involved in the
 * automatic flag clearing mechanisms for some of the LPUART status flags.
 */
/*!
 * @name Constants and macros for entire LPUART_DATA register
 */
/*@{*/
#define LPUART_RD_DATA(base)     (LPUART_DATA_REG(base))
#define LPUART_WR_DATA(base, value) (LPUART_DATA_REG(base) = (value))
#define LPUART_RMW_DATA(base, mask, value) (LPUART_WR_DATA(base, (LPUART_RD_DATA(base) & ~(mask)) | (value)))
#define LPUART_SET_DATA(base, value) (BME_OR32(&LPUART_DATA_REG(base), (uint32_t)(value)))
#define LPUART_CLR_DATA(base, value) (BME_AND32(&LPUART_DATA_REG(base), (uint32_t)(~(value))))
#define LPUART_TOG_DATA(base, value) (BME_XOR32(&LPUART_DATA_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual LPUART_DATA bitfields
 */

/*!
 * @name Register LPUART_DATA, field R0T0[0] (RW)
 *
 * Read receive data buffer 0 or write transmit data buffer 0.
 */
/*@{*/
/*! @brief Read current value of the LPUART_DATA_R0T0 field. */
#define LPUART_RD_DATA_R0T0(base) ((LPUART_DATA_REG(base) & LPUART_DATA_R0T0_MASK) >> LPUART_DATA_R0T0_SHIFT)
#define LPUART_BRD_DATA_R0T0(base) (BME_UBFX32(&LPUART_DATA_REG(base), LPUART_DATA_R0T0_SHIFT, LPUART_DATA_R0T0_WIDTH))

/*! @brief Set the R0T0 field to a new value. */
#define LPUART_WR_DATA_R0T0(base, value) (LPUART_RMW_DATA(base, LPUART_DATA_R0T0_MASK, LPUART_DATA_R0T0(value)))
#define LPUART_BWR_DATA_R0T0(base, value) (BME_BFI32(&LPUART_DATA_REG(base), ((uint32_t)(value) << LPUART_DATA_R0T0_SHIFT), LPUART_DATA_R0T0_SHIFT, LPUART_DATA_R0T0_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_DATA, field R1T1[1] (RW)
 *
 * Read receive data buffer 1 or write transmit data buffer 1.
 */
/*@{*/
/*! @brief Read current value of the LPUART_DATA_R1T1 field. */
#define LPUART_RD_DATA_R1T1(base) ((LPUART_DATA_REG(base) & LPUART_DATA_R1T1_MASK) >> LPUART_DATA_R1T1_SHIFT)
#define LPUART_BRD_DATA_R1T1(base) (BME_UBFX32(&LPUART_DATA_REG(base), LPUART_DATA_R1T1_SHIFT, LPUART_DATA_R1T1_WIDTH))

/*! @brief Set the R1T1 field to a new value. */
#define LPUART_WR_DATA_R1T1(base, value) (LPUART_RMW_DATA(base, LPUART_DATA_R1T1_MASK, LPUART_DATA_R1T1(value)))
#define LPUART_BWR_DATA_R1T1(base, value) (BME_BFI32(&LPUART_DATA_REG(base), ((uint32_t)(value) << LPUART_DATA_R1T1_SHIFT), LPUART_DATA_R1T1_SHIFT, LPUART_DATA_R1T1_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_DATA, field R2T2[2] (RW)
 *
 * Read receive data buffer 2 or write transmit data buffer 2.
 */
/*@{*/
/*! @brief Read current value of the LPUART_DATA_R2T2 field. */
#define LPUART_RD_DATA_R2T2(base) ((LPUART_DATA_REG(base) & LPUART_DATA_R2T2_MASK) >> LPUART_DATA_R2T2_SHIFT)
#define LPUART_BRD_DATA_R2T2(base) (BME_UBFX32(&LPUART_DATA_REG(base), LPUART_DATA_R2T2_SHIFT, LPUART_DATA_R2T2_WIDTH))

/*! @brief Set the R2T2 field to a new value. */
#define LPUART_WR_DATA_R2T2(base, value) (LPUART_RMW_DATA(base, LPUART_DATA_R2T2_MASK, LPUART_DATA_R2T2(value)))
#define LPUART_BWR_DATA_R2T2(base, value) (BME_BFI32(&LPUART_DATA_REG(base), ((uint32_t)(value) << LPUART_DATA_R2T2_SHIFT), LPUART_DATA_R2T2_SHIFT, LPUART_DATA_R2T2_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_DATA, field R3T3[3] (RW)
 *
 * Read receive data buffer 3 or write transmit data buffer 3.
 */
/*@{*/
/*! @brief Read current value of the LPUART_DATA_R3T3 field. */
#define LPUART_RD_DATA_R3T3(base) ((LPUART_DATA_REG(base) & LPUART_DATA_R3T3_MASK) >> LPUART_DATA_R3T3_SHIFT)
#define LPUART_BRD_DATA_R3T3(base) (BME_UBFX32(&LPUART_DATA_REG(base), LPUART_DATA_R3T3_SHIFT, LPUART_DATA_R3T3_WIDTH))

/*! @brief Set the R3T3 field to a new value. */
#define LPUART_WR_DATA_R3T3(base, value) (LPUART_RMW_DATA(base, LPUART_DATA_R3T3_MASK, LPUART_DATA_R3T3(value)))
#define LPUART_BWR_DATA_R3T3(base, value) (BME_BFI32(&LPUART_DATA_REG(base), ((uint32_t)(value) << LPUART_DATA_R3T3_SHIFT), LPUART_DATA_R3T3_SHIFT, LPUART_DATA_R3T3_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_DATA, field R4T4[4] (RW)
 *
 * Read receive data buffer 4 or write transmit data buffer 4.
 */
/*@{*/
/*! @brief Read current value of the LPUART_DATA_R4T4 field. */
#define LPUART_RD_DATA_R4T4(base) ((LPUART_DATA_REG(base) & LPUART_DATA_R4T4_MASK) >> LPUART_DATA_R4T4_SHIFT)
#define LPUART_BRD_DATA_R4T4(base) (BME_UBFX32(&LPUART_DATA_REG(base), LPUART_DATA_R4T4_SHIFT, LPUART_DATA_R4T4_WIDTH))

/*! @brief Set the R4T4 field to a new value. */
#define LPUART_WR_DATA_R4T4(base, value) (LPUART_RMW_DATA(base, LPUART_DATA_R4T4_MASK, LPUART_DATA_R4T4(value)))
#define LPUART_BWR_DATA_R4T4(base, value) (BME_BFI32(&LPUART_DATA_REG(base), ((uint32_t)(value) << LPUART_DATA_R4T4_SHIFT), LPUART_DATA_R4T4_SHIFT, LPUART_DATA_R4T4_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_DATA, field R5T5[5] (RW)
 *
 * Read receive data buffer 5 or write transmit data buffer 5.
 */
/*@{*/
/*! @brief Read current value of the LPUART_DATA_R5T5 field. */
#define LPUART_RD_DATA_R5T5(base) ((LPUART_DATA_REG(base) & LPUART_DATA_R5T5_MASK) >> LPUART_DATA_R5T5_SHIFT)
#define LPUART_BRD_DATA_R5T5(base) (BME_UBFX32(&LPUART_DATA_REG(base), LPUART_DATA_R5T5_SHIFT, LPUART_DATA_R5T5_WIDTH))

/*! @brief Set the R5T5 field to a new value. */
#define LPUART_WR_DATA_R5T5(base, value) (LPUART_RMW_DATA(base, LPUART_DATA_R5T5_MASK, LPUART_DATA_R5T5(value)))
#define LPUART_BWR_DATA_R5T5(base, value) (BME_BFI32(&LPUART_DATA_REG(base), ((uint32_t)(value) << LPUART_DATA_R5T5_SHIFT), LPUART_DATA_R5T5_SHIFT, LPUART_DATA_R5T5_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_DATA, field R6T6[6] (RW)
 *
 * Read receive data buffer 6 or write transmit data buffer 6.
 */
/*@{*/
/*! @brief Read current value of the LPUART_DATA_R6T6 field. */
#define LPUART_RD_DATA_R6T6(base) ((LPUART_DATA_REG(base) & LPUART_DATA_R6T6_MASK) >> LPUART_DATA_R6T6_SHIFT)
#define LPUART_BRD_DATA_R6T6(base) (BME_UBFX32(&LPUART_DATA_REG(base), LPUART_DATA_R6T6_SHIFT, LPUART_DATA_R6T6_WIDTH))

/*! @brief Set the R6T6 field to a new value. */
#define LPUART_WR_DATA_R6T6(base, value) (LPUART_RMW_DATA(base, LPUART_DATA_R6T6_MASK, LPUART_DATA_R6T6(value)))
#define LPUART_BWR_DATA_R6T6(base, value) (BME_BFI32(&LPUART_DATA_REG(base), ((uint32_t)(value) << LPUART_DATA_R6T6_SHIFT), LPUART_DATA_R6T6_SHIFT, LPUART_DATA_R6T6_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_DATA, field R7T7[7] (RW)
 *
 * Read receive data buffer 7 or write transmit data buffer 7.
 */
/*@{*/
/*! @brief Read current value of the LPUART_DATA_R7T7 field. */
#define LPUART_RD_DATA_R7T7(base) ((LPUART_DATA_REG(base) & LPUART_DATA_R7T7_MASK) >> LPUART_DATA_R7T7_SHIFT)
#define LPUART_BRD_DATA_R7T7(base) (BME_UBFX32(&LPUART_DATA_REG(base), LPUART_DATA_R7T7_SHIFT, LPUART_DATA_R7T7_WIDTH))

/*! @brief Set the R7T7 field to a new value. */
#define LPUART_WR_DATA_R7T7(base, value) (LPUART_RMW_DATA(base, LPUART_DATA_R7T7_MASK, LPUART_DATA_R7T7(value)))
#define LPUART_BWR_DATA_R7T7(base, value) (BME_BFI32(&LPUART_DATA_REG(base), ((uint32_t)(value) << LPUART_DATA_R7T7_SHIFT), LPUART_DATA_R7T7_SHIFT, LPUART_DATA_R7T7_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_DATA, field R8T8[8] (RW)
 *
 * Read receive data buffer 8 or write transmit data buffer 8.
 */
/*@{*/
/*! @brief Read current value of the LPUART_DATA_R8T8 field. */
#define LPUART_RD_DATA_R8T8(base) ((LPUART_DATA_REG(base) & LPUART_DATA_R8T8_MASK) >> LPUART_DATA_R8T8_SHIFT)
#define LPUART_BRD_DATA_R8T8(base) (BME_UBFX32(&LPUART_DATA_REG(base), LPUART_DATA_R8T8_SHIFT, LPUART_DATA_R8T8_WIDTH))

/*! @brief Set the R8T8 field to a new value. */
#define LPUART_WR_DATA_R8T8(base, value) (LPUART_RMW_DATA(base, LPUART_DATA_R8T8_MASK, LPUART_DATA_R8T8(value)))
#define LPUART_BWR_DATA_R8T8(base, value) (BME_BFI32(&LPUART_DATA_REG(base), ((uint32_t)(value) << LPUART_DATA_R8T8_SHIFT), LPUART_DATA_R8T8_SHIFT, LPUART_DATA_R8T8_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_DATA, field R9T9[9] (RW)
 *
 * Read receive data buffer 9 or write transmit data buffer 9.
 */
/*@{*/
/*! @brief Read current value of the LPUART_DATA_R9T9 field. */
#define LPUART_RD_DATA_R9T9(base) ((LPUART_DATA_REG(base) & LPUART_DATA_R9T9_MASK) >> LPUART_DATA_R9T9_SHIFT)
#define LPUART_BRD_DATA_R9T9(base) (BME_UBFX32(&LPUART_DATA_REG(base), LPUART_DATA_R9T9_SHIFT, LPUART_DATA_R9T9_WIDTH))

/*! @brief Set the R9T9 field to a new value. */
#define LPUART_WR_DATA_R9T9(base, value) (LPUART_RMW_DATA(base, LPUART_DATA_R9T9_MASK, LPUART_DATA_R9T9(value)))
#define LPUART_BWR_DATA_R9T9(base, value) (BME_BFI32(&LPUART_DATA_REG(base), ((uint32_t)(value) << LPUART_DATA_R9T9_SHIFT), LPUART_DATA_R9T9_SHIFT, LPUART_DATA_R9T9_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_DATA, field IDLINE[11] (RO)
 *
 * Indicates the receiver line was idle before receiving the character in
 * DATA[9:0]. Unlike the IDLE flag, this bit can set for the first character received
 * when the receiver is first enabled.
 *
 * Values:
 * - 0b0 - Receiver was not idle before receiving this character.
 * - 0b1 - Receiver was idle before receiving this character.
 */
/*@{*/
/*! @brief Read current value of the LPUART_DATA_IDLINE field. */
#define LPUART_RD_DATA_IDLINE(base) ((LPUART_DATA_REG(base) & LPUART_DATA_IDLINE_MASK) >> LPUART_DATA_IDLINE_SHIFT)
#define LPUART_BRD_DATA_IDLINE(base) (BME_UBFX32(&LPUART_DATA_REG(base), LPUART_DATA_IDLINE_SHIFT, LPUART_DATA_IDLINE_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_DATA, field RXEMPT[12] (RO)
 *
 * Asserts when there is no data in the receive buffer. This field does not take
 * into account data that is in the receive shift register.
 *
 * Values:
 * - 0b0 - Receive buffer contains valid data.
 * - 0b1 - Receive buffer is empty, data returned on read is not valid.
 */
/*@{*/
/*! @brief Read current value of the LPUART_DATA_RXEMPT field. */
#define LPUART_RD_DATA_RXEMPT(base) ((LPUART_DATA_REG(base) & LPUART_DATA_RXEMPT_MASK) >> LPUART_DATA_RXEMPT_SHIFT)
#define LPUART_BRD_DATA_RXEMPT(base) (BME_UBFX32(&LPUART_DATA_REG(base), LPUART_DATA_RXEMPT_SHIFT, LPUART_DATA_RXEMPT_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_DATA, field FRETSC[13] (RW)
 *
 * For reads, indicates the current received dataword contained in DATA[R9:R0]
 * was received with a frame error. For writes, indicates a break or idle
 * character is to be transmitted instead of the contents in DATA[T9:T0]. T9 is used to
 * indicate a break character when 0 and a idle character when 1, he contents of
 * DATA[T8:T0] should be zero.
 *
 * Values:
 * - 0b0 - The dataword was received without a frame error on read, transmit a
 *     normal character on write.
 * - 0b1 - The dataword was received with a frame error, transmit an idle or
 *     break character on transmit.
 */
/*@{*/
/*! @brief Read current value of the LPUART_DATA_FRETSC field. */
#define LPUART_RD_DATA_FRETSC(base) ((LPUART_DATA_REG(base) & LPUART_DATA_FRETSC_MASK) >> LPUART_DATA_FRETSC_SHIFT)
#define LPUART_BRD_DATA_FRETSC(base) (BME_UBFX32(&LPUART_DATA_REG(base), LPUART_DATA_FRETSC_SHIFT, LPUART_DATA_FRETSC_WIDTH))

/*! @brief Set the FRETSC field to a new value. */
#define LPUART_WR_DATA_FRETSC(base, value) (LPUART_RMW_DATA(base, LPUART_DATA_FRETSC_MASK, LPUART_DATA_FRETSC(value)))
#define LPUART_BWR_DATA_FRETSC(base, value) (BME_BFI32(&LPUART_DATA_REG(base), ((uint32_t)(value) << LPUART_DATA_FRETSC_SHIFT), LPUART_DATA_FRETSC_SHIFT, LPUART_DATA_FRETSC_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_DATA, field PARITYE[14] (RO)
 *
 * The current received dataword contained in DATA[R9:R0] was received with a
 * parity error.
 *
 * Values:
 * - 0b0 - The dataword was received without a parity error.
 * - 0b1 - The dataword was received with a parity error.
 */
/*@{*/
/*! @brief Read current value of the LPUART_DATA_PARITYE field. */
#define LPUART_RD_DATA_PARITYE(base) ((LPUART_DATA_REG(base) & LPUART_DATA_PARITYE_MASK) >> LPUART_DATA_PARITYE_SHIFT)
#define LPUART_BRD_DATA_PARITYE(base) (BME_UBFX32(&LPUART_DATA_REG(base), LPUART_DATA_PARITYE_SHIFT, LPUART_DATA_PARITYE_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_DATA, field NOISY[15] (RO)
 *
 * The current received dataword contained in DATA[R9:R0] was received with
 * noise.
 *
 * Values:
 * - 0b0 - The dataword was received without noise.
 * - 0b1 - The data was received with noise.
 */
/*@{*/
/*! @brief Read current value of the LPUART_DATA_NOISY field. */
#define LPUART_RD_DATA_NOISY(base) ((LPUART_DATA_REG(base) & LPUART_DATA_NOISY_MASK) >> LPUART_DATA_NOISY_SHIFT)
#define LPUART_BRD_DATA_NOISY(base) (BME_UBFX32(&LPUART_DATA_REG(base), LPUART_DATA_NOISY_SHIFT, LPUART_DATA_NOISY_WIDTH))
/*@}*/

/*******************************************************************************
 * LPUART_MATCH - LPUART Match Address Register
 ******************************************************************************/

/*!
 * @brief LPUART_MATCH - LPUART Match Address Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire LPUART_MATCH register
 */
/*@{*/
#define LPUART_RD_MATCH(base)    (LPUART_MATCH_REG(base))
#define LPUART_WR_MATCH(base, value) (LPUART_MATCH_REG(base) = (value))
#define LPUART_RMW_MATCH(base, mask, value) (LPUART_WR_MATCH(base, (LPUART_RD_MATCH(base) & ~(mask)) | (value)))
#define LPUART_SET_MATCH(base, value) (BME_OR32(&LPUART_MATCH_REG(base), (uint32_t)(value)))
#define LPUART_CLR_MATCH(base, value) (BME_AND32(&LPUART_MATCH_REG(base), (uint32_t)(~(value))))
#define LPUART_TOG_MATCH(base, value) (BME_XOR32(&LPUART_MATCH_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual LPUART_MATCH bitfields
 */

/*!
 * @name Register LPUART_MATCH, field MA1[9:0] (RW)
 *
 * The MA1 and MA2 registers are compared to input data addresses when the most
 * significant bit is set and the associated BAUD[MAEN] bit is set. If a match
 * occurs, the following data is transferred to the data register. If a match
 * fails, the following data is discarded. Software should only write a MA register
 * when the associated BAUD[MAEN] bit is clear.
 */
/*@{*/
/*! @brief Read current value of the LPUART_MATCH_MA1 field. */
#define LPUART_RD_MATCH_MA1(base) ((LPUART_MATCH_REG(base) & LPUART_MATCH_MA1_MASK) >> LPUART_MATCH_MA1_SHIFT)
#define LPUART_BRD_MATCH_MA1(base) (BME_UBFX32(&LPUART_MATCH_REG(base), LPUART_MATCH_MA1_SHIFT, LPUART_MATCH_MA1_WIDTH))

/*! @brief Set the MA1 field to a new value. */
#define LPUART_WR_MATCH_MA1(base, value) (LPUART_RMW_MATCH(base, LPUART_MATCH_MA1_MASK, LPUART_MATCH_MA1(value)))
#define LPUART_BWR_MATCH_MA1(base, value) (BME_BFI32(&LPUART_MATCH_REG(base), ((uint32_t)(value) << LPUART_MATCH_MA1_SHIFT), LPUART_MATCH_MA1_SHIFT, LPUART_MATCH_MA1_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_MATCH, field MA2[25:16] (RW)
 *
 * The MA1 and MA2 registers are compared to input data addresses when the most
 * significant bit is set and the associated BAUD[MAEN] bit is set. If a match
 * occurs, the following data is transferred to the data register. If a match
 * fails, the following data is discarded. Software should only write a MA register
 * when the associated BAUD[MAEN] bit is clear.
 */
/*@{*/
/*! @brief Read current value of the LPUART_MATCH_MA2 field. */
#define LPUART_RD_MATCH_MA2(base) ((LPUART_MATCH_REG(base) & LPUART_MATCH_MA2_MASK) >> LPUART_MATCH_MA2_SHIFT)
#define LPUART_BRD_MATCH_MA2(base) (BME_UBFX32(&LPUART_MATCH_REG(base), LPUART_MATCH_MA2_SHIFT, LPUART_MATCH_MA2_WIDTH))

/*! @brief Set the MA2 field to a new value. */
#define LPUART_WR_MATCH_MA2(base, value) (LPUART_RMW_MATCH(base, LPUART_MATCH_MA2_MASK, LPUART_MATCH_MA2(value)))
#define LPUART_BWR_MATCH_MA2(base, value) (BME_BFI32(&LPUART_MATCH_REG(base), ((uint32_t)(value) << LPUART_MATCH_MA2_SHIFT), LPUART_MATCH_MA2_SHIFT, LPUART_MATCH_MA2_WIDTH))
/*@}*/

/*******************************************************************************
 * LPUART_MODIR - LPUART Modem IrDA Register
 ******************************************************************************/

/*!
 * @brief LPUART_MODIR - LPUART Modem IrDA Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The MODEM register controls options for setting the modem configuration.
 */
/*!
 * @name Constants and macros for entire LPUART_MODIR register
 */
/*@{*/
#define LPUART_RD_MODIR(base)    (LPUART_MODIR_REG(base))
#define LPUART_WR_MODIR(base, value) (LPUART_MODIR_REG(base) = (value))
#define LPUART_RMW_MODIR(base, mask, value) (LPUART_WR_MODIR(base, (LPUART_RD_MODIR(base) & ~(mask)) | (value)))
#define LPUART_SET_MODIR(base, value) (BME_OR32(&LPUART_MODIR_REG(base), (uint32_t)(value)))
#define LPUART_CLR_MODIR(base, value) (BME_AND32(&LPUART_MODIR_REG(base), (uint32_t)(~(value))))
#define LPUART_TOG_MODIR(base, value) (BME_XOR32(&LPUART_MODIR_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual LPUART_MODIR bitfields
 */

/*!
 * @name Register LPUART_MODIR, field TXCTSE[0] (RW)
 *
 * TXCTSE controls the operation of the transmitter. TXCTSE can be set
 * independently from the state of TXRTSE and RXRTSE.
 *
 * Values:
 * - 0b0 - CTS has no effect on the transmitter.
 * - 0b1 - Enables clear-to-send operation. The transmitter checks the state of
 *     CTS each time it is ready to send a character. If CTS is asserted, the
 *     character is sent. If CTS is deasserted, the signal TXD remains in the mark
 *     state and transmission is delayed until CTS is asserted. Changes in CTS as
 *     a character is being sent do not affect its transmission.
 */
/*@{*/
/*! @brief Read current value of the LPUART_MODIR_TXCTSE field. */
#define LPUART_RD_MODIR_TXCTSE(base) ((LPUART_MODIR_REG(base) & LPUART_MODIR_TXCTSE_MASK) >> LPUART_MODIR_TXCTSE_SHIFT)
#define LPUART_BRD_MODIR_TXCTSE(base) (BME_UBFX32(&LPUART_MODIR_REG(base), LPUART_MODIR_TXCTSE_SHIFT, LPUART_MODIR_TXCTSE_WIDTH))

/*! @brief Set the TXCTSE field to a new value. */
#define LPUART_WR_MODIR_TXCTSE(base, value) (LPUART_RMW_MODIR(base, LPUART_MODIR_TXCTSE_MASK, LPUART_MODIR_TXCTSE(value)))
#define LPUART_BWR_MODIR_TXCTSE(base, value) (BME_BFI32(&LPUART_MODIR_REG(base), ((uint32_t)(value) << LPUART_MODIR_TXCTSE_SHIFT), LPUART_MODIR_TXCTSE_SHIFT, LPUART_MODIR_TXCTSE_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_MODIR, field TXRTSE[1] (RW)
 *
 * Controls RTS before and after a transmission.
 *
 * Values:
 * - 0b0 - The transmitter has no effect on RTS.
 * - 0b1 - When a character is placed into an empty transmitter data buffer ,
 *     RTS asserts one bit time before the start bit is transmitted. RTS deasserts
 *     one bit time after all characters in the transmitter data buffer and shift
 *     register are completely sent, including the last stop bit.
 */
/*@{*/
/*! @brief Read current value of the LPUART_MODIR_TXRTSE field. */
#define LPUART_RD_MODIR_TXRTSE(base) ((LPUART_MODIR_REG(base) & LPUART_MODIR_TXRTSE_MASK) >> LPUART_MODIR_TXRTSE_SHIFT)
#define LPUART_BRD_MODIR_TXRTSE(base) (BME_UBFX32(&LPUART_MODIR_REG(base), LPUART_MODIR_TXRTSE_SHIFT, LPUART_MODIR_TXRTSE_WIDTH))

/*! @brief Set the TXRTSE field to a new value. */
#define LPUART_WR_MODIR_TXRTSE(base, value) (LPUART_RMW_MODIR(base, LPUART_MODIR_TXRTSE_MASK, LPUART_MODIR_TXRTSE(value)))
#define LPUART_BWR_MODIR_TXRTSE(base, value) (BME_BFI32(&LPUART_MODIR_REG(base), ((uint32_t)(value) << LPUART_MODIR_TXRTSE_SHIFT), LPUART_MODIR_TXRTSE_SHIFT, LPUART_MODIR_TXRTSE_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_MODIR, field TXRTSPOL[2] (RW)
 *
 * Controls the polarity of the transmitter RTS. TXRTSPOL does not affect the
 * polarity of the receiver RTS. RTS will remain negated in the active low state
 * unless TXRTSE is set.
 *
 * Values:
 * - 0b0 - Transmitter RTS is active low.
 * - 0b1 - Transmitter RTS is active high.
 */
/*@{*/
/*! @brief Read current value of the LPUART_MODIR_TXRTSPOL field. */
#define LPUART_RD_MODIR_TXRTSPOL(base) ((LPUART_MODIR_REG(base) & LPUART_MODIR_TXRTSPOL_MASK) >> LPUART_MODIR_TXRTSPOL_SHIFT)
#define LPUART_BRD_MODIR_TXRTSPOL(base) (BME_UBFX32(&LPUART_MODIR_REG(base), LPUART_MODIR_TXRTSPOL_SHIFT, LPUART_MODIR_TXRTSPOL_WIDTH))

/*! @brief Set the TXRTSPOL field to a new value. */
#define LPUART_WR_MODIR_TXRTSPOL(base, value) (LPUART_RMW_MODIR(base, LPUART_MODIR_TXRTSPOL_MASK, LPUART_MODIR_TXRTSPOL(value)))
#define LPUART_BWR_MODIR_TXRTSPOL(base, value) (BME_BFI32(&LPUART_MODIR_REG(base), ((uint32_t)(value) << LPUART_MODIR_TXRTSPOL_SHIFT), LPUART_MODIR_TXRTSPOL_SHIFT, LPUART_MODIR_TXRTSPOL_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_MODIR, field RXRTSE[3] (RW)
 *
 * Allows the RTS output to control the CTS input of the transmitting device to
 * prevent receiver overrun. Do not set both RXRTSE and TXRTSE.
 *
 * Values:
 * - 0b0 - The receiver has no effect on RTS.
 * - 0b1 - RTS is deasserted if the receiver data register is full or a start
 *     bit has been detected that would cause the receiver data register to become
 *     full. RTS is asserted if the receiver data register is not full and has
 *     not detected a start bit that would cause the receiver data register to
 *     become full.
 */
/*@{*/
/*! @brief Read current value of the LPUART_MODIR_RXRTSE field. */
#define LPUART_RD_MODIR_RXRTSE(base) ((LPUART_MODIR_REG(base) & LPUART_MODIR_RXRTSE_MASK) >> LPUART_MODIR_RXRTSE_SHIFT)
#define LPUART_BRD_MODIR_RXRTSE(base) (BME_UBFX32(&LPUART_MODIR_REG(base), LPUART_MODIR_RXRTSE_SHIFT, LPUART_MODIR_RXRTSE_WIDTH))

/*! @brief Set the RXRTSE field to a new value. */
#define LPUART_WR_MODIR_RXRTSE(base, value) (LPUART_RMW_MODIR(base, LPUART_MODIR_RXRTSE_MASK, LPUART_MODIR_RXRTSE(value)))
#define LPUART_BWR_MODIR_RXRTSE(base, value) (BME_BFI32(&LPUART_MODIR_REG(base), ((uint32_t)(value) << LPUART_MODIR_RXRTSE_SHIFT), LPUART_MODIR_RXRTSE_SHIFT, LPUART_MODIR_RXRTSE_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_MODIR, field TXCTSC[4] (RW)
 *
 * Configures if the CTS state is checked at the start of each character or only
 * when the transmitter is idle.
 *
 * Values:
 * - 0b0 - CTS input is sampled at the start of each character.
 * - 0b1 - CTS input is sampled when the transmitter is idle.
 */
/*@{*/
/*! @brief Read current value of the LPUART_MODIR_TXCTSC field. */
#define LPUART_RD_MODIR_TXCTSC(base) ((LPUART_MODIR_REG(base) & LPUART_MODIR_TXCTSC_MASK) >> LPUART_MODIR_TXCTSC_SHIFT)
#define LPUART_BRD_MODIR_TXCTSC(base) (BME_UBFX32(&LPUART_MODIR_REG(base), LPUART_MODIR_TXCTSC_SHIFT, LPUART_MODIR_TXCTSC_WIDTH))

/*! @brief Set the TXCTSC field to a new value. */
#define LPUART_WR_MODIR_TXCTSC(base, value) (LPUART_RMW_MODIR(base, LPUART_MODIR_TXCTSC_MASK, LPUART_MODIR_TXCTSC(value)))
#define LPUART_BWR_MODIR_TXCTSC(base, value) (BME_BFI32(&LPUART_MODIR_REG(base), ((uint32_t)(value) << LPUART_MODIR_TXCTSC_SHIFT), LPUART_MODIR_TXCTSC_SHIFT, LPUART_MODIR_TXCTSC_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_MODIR, field TXCTSSRC[5] (RW)
 *
 * Configures the source of the CTS input.
 *
 * Values:
 * - 0b0 - CTS input is the LPUART_CTS pin.
 * - 0b1 - CTS input is the inverted Receiver Match result.
 */
/*@{*/
/*! @brief Read current value of the LPUART_MODIR_TXCTSSRC field. */
#define LPUART_RD_MODIR_TXCTSSRC(base) ((LPUART_MODIR_REG(base) & LPUART_MODIR_TXCTSSRC_MASK) >> LPUART_MODIR_TXCTSSRC_SHIFT)
#define LPUART_BRD_MODIR_TXCTSSRC(base) (BME_UBFX32(&LPUART_MODIR_REG(base), LPUART_MODIR_TXCTSSRC_SHIFT, LPUART_MODIR_TXCTSSRC_WIDTH))

/*! @brief Set the TXCTSSRC field to a new value. */
#define LPUART_WR_MODIR_TXCTSSRC(base, value) (LPUART_RMW_MODIR(base, LPUART_MODIR_TXCTSSRC_MASK, LPUART_MODIR_TXCTSSRC(value)))
#define LPUART_BWR_MODIR_TXCTSSRC(base, value) (BME_BFI32(&LPUART_MODIR_REG(base), ((uint32_t)(value) << LPUART_MODIR_TXCTSSRC_SHIFT), LPUART_MODIR_TXCTSSRC_SHIFT, LPUART_MODIR_TXCTSSRC_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_MODIR, field TNP[17:16] (RW)
 *
 * Enables whether the LPUART transmits a 1/OSR, 2/OSR, 3/OSR or 4/OSR narrow
 * pulse.
 *
 * Values:
 * - 0b00 - 1/OSR.
 * - 0b01 - 2/OSR.
 * - 0b10 - 3/OSR.
 * - 0b11 - 4/OSR.
 */
/*@{*/
/*! @brief Read current value of the LPUART_MODIR_TNP field. */
#define LPUART_RD_MODIR_TNP(base) ((LPUART_MODIR_REG(base) & LPUART_MODIR_TNP_MASK) >> LPUART_MODIR_TNP_SHIFT)
#define LPUART_BRD_MODIR_TNP(base) (BME_UBFX32(&LPUART_MODIR_REG(base), LPUART_MODIR_TNP_SHIFT, LPUART_MODIR_TNP_WIDTH))

/*! @brief Set the TNP field to a new value. */
#define LPUART_WR_MODIR_TNP(base, value) (LPUART_RMW_MODIR(base, LPUART_MODIR_TNP_MASK, LPUART_MODIR_TNP(value)))
#define LPUART_BWR_MODIR_TNP(base, value) (BME_BFI32(&LPUART_MODIR_REG(base), ((uint32_t)(value) << LPUART_MODIR_TNP_SHIFT), LPUART_MODIR_TNP_SHIFT, LPUART_MODIR_TNP_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_MODIR, field IREN[18] (RW)
 *
 * Enables/disables the infrared modulation/demodulation.
 *
 * Values:
 * - 0b0 - IR disabled.
 * - 0b1 - IR enabled.
 */
/*@{*/
/*! @brief Read current value of the LPUART_MODIR_IREN field. */
#define LPUART_RD_MODIR_IREN(base) ((LPUART_MODIR_REG(base) & LPUART_MODIR_IREN_MASK) >> LPUART_MODIR_IREN_SHIFT)
#define LPUART_BRD_MODIR_IREN(base) (BME_UBFX32(&LPUART_MODIR_REG(base), LPUART_MODIR_IREN_SHIFT, LPUART_MODIR_IREN_WIDTH))

/*! @brief Set the IREN field to a new value. */
#define LPUART_WR_MODIR_IREN(base, value) (LPUART_RMW_MODIR(base, LPUART_MODIR_IREN_MASK, LPUART_MODIR_IREN(value)))
#define LPUART_BWR_MODIR_IREN(base, value) (BME_BFI32(&LPUART_MODIR_REG(base), ((uint32_t)(value) << LPUART_MODIR_IREN_SHIFT), LPUART_MODIR_IREN_SHIFT, LPUART_MODIR_IREN_WIDTH))
/*@}*/

/*
 * MKM34Z7 MCG
 *
 * Multipurpose Clock Generator module
 *
 * Registers defined in this header file:
 * - MCG_C1 - MCG Control 1 Register
 * - MCG_C2 - MCG Control 2 Register
 * - MCG_C3 - MCG Control 3 Register
 * - MCG_C4 - MCG Control 4 Register
 * - MCG_C5 - MCG Control 5 Register
 * - MCG_C6 - MCG Control 6 Register
 * - MCG_S - MCG Status Register
 * - MCG_SC - MCG Status and Control Register
 * - MCG_ATCVH - MCG Auto Trim Compare Value High Register
 * - MCG_ATCVL - MCG Auto Trim Compare Value Low Register
 * - MCG_C7 - MCG Control 7 Register
 * - MCG_C8 - MCG Control 8 Register
 * - MCG_C9 - MCG Control 9 Register
 */

#define MCG_INSTANCE_COUNT (1U) /*!< Number of instances of the MCG module. */
#define MCG_IDX (0U) /*!< Instance number for MCG. */

/*******************************************************************************
 * MCG_C1 - MCG Control 1 Register
 ******************************************************************************/

/*!
 * @brief MCG_C1 - MCG Control 1 Register (RW)
 *
 * Reset value: 0x44U
 */
/*!
 * @name Constants and macros for entire MCG_C1 register
 */
/*@{*/
#define MCG_RD_C1(base)          (MCG_C1_REG(base))
#define MCG_WR_C1(base, value)   (MCG_C1_REG(base) = (value))
#define MCG_RMW_C1(base, mask, value) (MCG_WR_C1(base, (MCG_RD_C1(base) & ~(mask)) | (value)))
#define MCG_SET_C1(base, value)  (BME_OR8(&MCG_C1_REG(base), (uint8_t)(value)))
#define MCG_CLR_C1(base, value)  (BME_AND8(&MCG_C1_REG(base), (uint8_t)(~(value))))
#define MCG_TOG_C1(base, value)  (BME_XOR8(&MCG_C1_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual MCG_C1 bitfields
 */

/*!
 * @name Register MCG_C1, field IREFSTEN[0] (RW)
 *
 * Controls whether or not the internal reference clock remains enabled when the
 * MCG enters Stop mode.
 *
 * Values:
 * - 0b0 - Internal reference clock is disabled in Stop mode.
 * - 0b1 - Internal reference clock is enabled in Stop mode if IRCLKEN is set or
 *     if MCG is in FEI, FBI, or BLPI modes before entering Stop mode.
 */
/*@{*/
/*! @brief Read current value of the MCG_C1_IREFSTEN field. */
#define MCG_RD_C1_IREFSTEN(base) ((MCG_C1_REG(base) & MCG_C1_IREFSTEN_MASK) >> MCG_C1_IREFSTEN_SHIFT)
#define MCG_BRD_C1_IREFSTEN(base) (BME_UBFX8(&MCG_C1_REG(base), MCG_C1_IREFSTEN_SHIFT, MCG_C1_IREFSTEN_WIDTH))

/*! @brief Set the IREFSTEN field to a new value. */
#define MCG_WR_C1_IREFSTEN(base, value) (MCG_RMW_C1(base, MCG_C1_IREFSTEN_MASK, MCG_C1_IREFSTEN(value)))
#define MCG_BWR_C1_IREFSTEN(base, value) (BME_BFI8(&MCG_C1_REG(base), ((uint8_t)(value) << MCG_C1_IREFSTEN_SHIFT), MCG_C1_IREFSTEN_SHIFT, MCG_C1_IREFSTEN_WIDTH))
/*@}*/

/*!
 * @name Register MCG_C1, field IRCLKEN[1] (RW)
 *
 * Enables the internal reference clock for use as MCGIRCLK.
 *
 * Values:
 * - 0b0 - MCGIRCLK inactive.
 * - 0b1 - MCGIRCLK active.
 */
/*@{*/
/*! @brief Read current value of the MCG_C1_IRCLKEN field. */
#define MCG_RD_C1_IRCLKEN(base) ((MCG_C1_REG(base) & MCG_C1_IRCLKEN_MASK) >> MCG_C1_IRCLKEN_SHIFT)
#define MCG_BRD_C1_IRCLKEN(base) (BME_UBFX8(&MCG_C1_REG(base), MCG_C1_IRCLKEN_SHIFT, MCG_C1_IRCLKEN_WIDTH))

/*! @brief Set the IRCLKEN field to a new value. */
#define MCG_WR_C1_IRCLKEN(base, value) (MCG_RMW_C1(base, MCG_C1_IRCLKEN_MASK, MCG_C1_IRCLKEN(value)))
#define MCG_BWR_C1_IRCLKEN(base, value) (BME_BFI8(&MCG_C1_REG(base), ((uint8_t)(value) << MCG_C1_IRCLKEN_SHIFT), MCG_C1_IRCLKEN_SHIFT, MCG_C1_IRCLKEN_WIDTH))
/*@}*/

/*!
 * @name Register MCG_C1, field IREFS[2] (RW)
 *
 * Selects the reference clock source for the FLL.
 *
 * Values:
 * - 0b0 - External reference clock is selected.
 * - 0b1 - The slow internal reference clock is selected.
 */
/*@{*/
/*! @brief Read current value of the MCG_C1_IREFS field. */
#define MCG_RD_C1_IREFS(base) ((MCG_C1_REG(base) & MCG_C1_IREFS_MASK) >> MCG_C1_IREFS_SHIFT)
#define MCG_BRD_C1_IREFS(base) (BME_UBFX8(&MCG_C1_REG(base), MCG_C1_IREFS_SHIFT, MCG_C1_IREFS_WIDTH))

/*! @brief Set the IREFS field to a new value. */
#define MCG_WR_C1_IREFS(base, value) (MCG_RMW_C1(base, MCG_C1_IREFS_MASK, MCG_C1_IREFS(value)))
#define MCG_BWR_C1_IREFS(base, value) (BME_BFI8(&MCG_C1_REG(base), ((uint8_t)(value) << MCG_C1_IREFS_SHIFT), MCG_C1_IREFS_SHIFT, MCG_C1_IREFS_WIDTH))
/*@}*/

/*!
 * @name Register MCG_C1, field FRDIV[5:3] (RW)
 *
 * Selects the amount to divide down the external reference clock for the FLL.
 * The resulting frequency must be in the range 31.25 kHz to 39.0625 kHz (This is
 * required when FLL/DCO is the clock source for MCGOUTCLK. In FBE mode, it is
 * not required to meet this range, but it is recommended in the cases when trying
 * to enter a FLL mode from FBE).
 *
 * Values:
 * - 0b000 - If RANGE = 0 or OSCSEL=1 , Divide Factor is 1; for all other RANGE
 *     values, Divide Factor is 32.
 * - 0b001 - If RANGE = 0 or OSCSEL=1 , Divide Factor is 2; for all other RANGE
 *     values, Divide Factor is 64.
 * - 0b010 - If RANGE = 0 or OSCSEL=1 , Divide Factor is 4; for all other RANGE
 *     values, Divide Factor is 128.
 * - 0b011 - If RANGE = 0 or OSCSEL=1 , Divide Factor is 8; for all other RANGE
 *     values, Divide Factor is 256.
 * - 0b100 - If RANGE = 0 or OSCSEL=1 , Divide Factor is 16; for all other RANGE
 *     values, Divide Factor is 512.
 * - 0b101 - If RANGE = 0 or OSCSEL=1 , Divide Factor is 32; for all other RANGE
 *     values, Divide Factor is 1024.
 * - 0b110 - If RANGE = 0 or OSCSEL=1 , Divide Factor is 64; for all other RANGE
 *     values, Divide Factor is 1280 .
 * - 0b111 - If RANGE = 0 or OSCSEL=1 , Divide Factor is 128; for all other
 *     RANGE values, Divide Factor is 1536 .
 */
/*@{*/
/*! @brief Read current value of the MCG_C1_FRDIV field. */
#define MCG_RD_C1_FRDIV(base) ((MCG_C1_REG(base) & MCG_C1_FRDIV_MASK) >> MCG_C1_FRDIV_SHIFT)
#define MCG_BRD_C1_FRDIV(base) (BME_UBFX8(&MCG_C1_REG(base), MCG_C1_FRDIV_SHIFT, MCG_C1_FRDIV_WIDTH))

/*! @brief Set the FRDIV field to a new value. */
#define MCG_WR_C1_FRDIV(base, value) (MCG_RMW_C1(base, MCG_C1_FRDIV_MASK, MCG_C1_FRDIV(value)))
#define MCG_BWR_C1_FRDIV(base, value) (BME_BFI8(&MCG_C1_REG(base), ((uint8_t)(value) << MCG_C1_FRDIV_SHIFT), MCG_C1_FRDIV_SHIFT, MCG_C1_FRDIV_WIDTH))
/*@}*/

/*!
 * @name Register MCG_C1, field CLKS[7:6] (RW)
 *
 * Selects the clock source for MCGOUTCLK.
 *
 * Values:
 * - 0b00 - Encoding 0 - Output of FLL or PLL is selected (depends on PLLS
 *     control bit).
 * - 0b01 - Encoding 1 - Internal reference clock is selected.
 * - 0b10 - Encoding 2 - External reference clock is selected.
 * - 0b11 - Encoding 3 - Reserved.
 */
/*@{*/
/*! @brief Read current value of the MCG_C1_CLKS field. */
#define MCG_RD_C1_CLKS(base) ((MCG_C1_REG(base) & MCG_C1_CLKS_MASK) >> MCG_C1_CLKS_SHIFT)
#define MCG_BRD_C1_CLKS(base) (BME_UBFX8(&MCG_C1_REG(base), MCG_C1_CLKS_SHIFT, MCG_C1_CLKS_WIDTH))

/*! @brief Set the CLKS field to a new value. */
#define MCG_WR_C1_CLKS(base, value) (MCG_RMW_C1(base, MCG_C1_CLKS_MASK, MCG_C1_CLKS(value)))
#define MCG_BWR_C1_CLKS(base, value) (BME_BFI8(&MCG_C1_REG(base), ((uint8_t)(value) << MCG_C1_CLKS_SHIFT), MCG_C1_CLKS_SHIFT, MCG_C1_CLKS_WIDTH))
/*@}*/

/*******************************************************************************
 * MCG_C2 - MCG Control 2 Register
 ******************************************************************************/

/*!
 * @brief MCG_C2 - MCG Control 2 Register (RW)
 *
 * Reset value: 0x83U
 */
/*!
 * @name Constants and macros for entire MCG_C2 register
 */
/*@{*/
#define MCG_RD_C2(base)          (MCG_C2_REG(base))
#define MCG_WR_C2(base, value)   (MCG_C2_REG(base) = (value))
#define MCG_RMW_C2(base, mask, value) (MCG_WR_C2(base, (MCG_RD_C2(base) & ~(mask)) | (value)))
#define MCG_SET_C2(base, value)  (BME_OR8(&MCG_C2_REG(base), (uint8_t)(value)))
#define MCG_CLR_C2(base, value)  (BME_AND8(&MCG_C2_REG(base), (uint8_t)(~(value))))
#define MCG_TOG_C2(base, value)  (BME_XOR8(&MCG_C2_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual MCG_C2 bitfields
 */

/*!
 * @name Register MCG_C2, field IRCS[0] (RW)
 *
 * Selects between the fast or slow internal reference clock source.
 *
 * Values:
 * - 0b0 - Slow internal reference clock selected.
 * - 0b1 - Fast internal reference clock selected.
 */
/*@{*/
/*! @brief Read current value of the MCG_C2_IRCS field. */
#define MCG_RD_C2_IRCS(base) ((MCG_C2_REG(base) & MCG_C2_IRCS_MASK) >> MCG_C2_IRCS_SHIFT)
#define MCG_BRD_C2_IRCS(base) (BME_UBFX8(&MCG_C2_REG(base), MCG_C2_IRCS_SHIFT, MCG_C2_IRCS_WIDTH))

/*! @brief Set the IRCS field to a new value. */
#define MCG_WR_C2_IRCS(base, value) (MCG_RMW_C2(base, MCG_C2_IRCS_MASK, MCG_C2_IRCS(value)))
#define MCG_BWR_C2_IRCS(base, value) (BME_BFI8(&MCG_C2_REG(base), ((uint8_t)(value) << MCG_C2_IRCS_SHIFT), MCG_C2_IRCS_SHIFT, MCG_C2_IRCS_WIDTH))
/*@}*/

/*!
 * @name Register MCG_C2, field LP[1] (RW)
 *
 * Controls whether the FLL or PLL is disabled in BLPI and BLPE modes. In FBE or
 * PBE modes, setting this bit to 1 will transition the MCG into BLPE mode; in
 * FBI mode, setting this bit to 1 will transition the MCG into BLPI mode. In any
 * other MCG mode, LP bit has no affect.
 *
 * Values:
 * - 0b0 - FLL or PLL is not disabled in bypass modes.
 * - 0b1 - FLL or PLL is disabled in bypass modes (lower power)
 */
/*@{*/
/*! @brief Read current value of the MCG_C2_LP field. */
#define MCG_RD_C2_LP(base)   ((MCG_C2_REG(base) & MCG_C2_LP_MASK) >> MCG_C2_LP_SHIFT)
#define MCG_BRD_C2_LP(base)  (BME_UBFX8(&MCG_C2_REG(base), MCG_C2_LP_SHIFT, MCG_C2_LP_WIDTH))

/*! @brief Set the LP field to a new value. */
#define MCG_WR_C2_LP(base, value) (MCG_RMW_C2(base, MCG_C2_LP_MASK, MCG_C2_LP(value)))
#define MCG_BWR_C2_LP(base, value) (BME_BFI8(&MCG_C2_REG(base), ((uint8_t)(value) << MCG_C2_LP_SHIFT), MCG_C2_LP_SHIFT, MCG_C2_LP_WIDTH))
/*@}*/

/*!
 * @name Register MCG_C2, field EREFS0[2] (RW)
 *
 * Selects the source for the external reference clock. See the Oscillator (OSC)
 * chapter for more details.
 *
 * Values:
 * - 0b0 - External reference clock requested.
 * - 0b1 - Oscillator requested.
 */
/*@{*/
/*! @brief Read current value of the MCG_C2_EREFS0 field. */
#define MCG_RD_C2_EREFS0(base) ((MCG_C2_REG(base) & MCG_C2_EREFS0_MASK) >> MCG_C2_EREFS0_SHIFT)
#define MCG_BRD_C2_EREFS0(base) (BME_UBFX8(&MCG_C2_REG(base), MCG_C2_EREFS0_SHIFT, MCG_C2_EREFS0_WIDTH))

/*! @brief Set the EREFS0 field to a new value. */
#define MCG_WR_C2_EREFS0(base, value) (MCG_RMW_C2(base, MCG_C2_EREFS0_MASK, MCG_C2_EREFS0(value)))
#define MCG_BWR_C2_EREFS0(base, value) (BME_BFI8(&MCG_C2_REG(base), ((uint8_t)(value) << MCG_C2_EREFS0_SHIFT), MCG_C2_EREFS0_SHIFT, MCG_C2_EREFS0_WIDTH))
/*@}*/

/*!
 * @name Register MCG_C2, field HGO0[3] (RW)
 *
 * Controls the crystal oscillator mode of operation. See the Oscillator (OSC)
 * chapter for more details.
 *
 * Values:
 * - 0b0 - Configure crystal oscillator for low-power operation.
 * - 0b1 - Configure crystal oscillator for high-gain operation.
 */
/*@{*/
/*! @brief Read current value of the MCG_C2_HGO0 field. */
#define MCG_RD_C2_HGO0(base) ((MCG_C2_REG(base) & MCG_C2_HGO0_MASK) >> MCG_C2_HGO0_SHIFT)
#define MCG_BRD_C2_HGO0(base) (BME_UBFX8(&MCG_C2_REG(base), MCG_C2_HGO0_SHIFT, MCG_C2_HGO0_WIDTH))

/*! @brief Set the HGO0 field to a new value. */
#define MCG_WR_C2_HGO0(base, value) (MCG_RMW_C2(base, MCG_C2_HGO0_MASK, MCG_C2_HGO0(value)))
#define MCG_BWR_C2_HGO0(base, value) (BME_BFI8(&MCG_C2_REG(base), ((uint8_t)(value) << MCG_C2_HGO0_SHIFT), MCG_C2_HGO0_SHIFT, MCG_C2_HGO0_WIDTH))
/*@}*/

/*!
 * @name Register MCG_C2, field RANGE0[5:4] (RW)
 *
 * Selects the frequency range for the crystal oscillator or external clock
 * source. See the Oscillator (OSC) chapter for more details and the device data
 * sheet for the frequency ranges used.
 *
 * Values:
 * - 0b00 - Encoding 0 - Low frequency range selected for the crystal oscillator
 *     .
 * - 0b01 - Encoding 1 - High frequency range selected for the crystal
 *     oscillator .
 */
/*@{*/
/*! @brief Read current value of the MCG_C2_RANGE0 field. */
#define MCG_RD_C2_RANGE0(base) ((MCG_C2_REG(base) & MCG_C2_RANGE0_MASK) >> MCG_C2_RANGE0_SHIFT)
#define MCG_BRD_C2_RANGE0(base) (BME_UBFX8(&MCG_C2_REG(base), MCG_C2_RANGE0_SHIFT, MCG_C2_RANGE0_WIDTH))

/*! @brief Set the RANGE0 field to a new value. */
#define MCG_WR_C2_RANGE0(base, value) (MCG_RMW_C2(base, MCG_C2_RANGE0_MASK, MCG_C2_RANGE0(value)))
#define MCG_BWR_C2_RANGE0(base, value) (BME_BFI8(&MCG_C2_REG(base), ((uint8_t)(value) << MCG_C2_RANGE0_SHIFT), MCG_C2_RANGE0_SHIFT, MCG_C2_RANGE0_WIDTH))
/*@}*/

/*!
 * @name Register MCG_C2, field LOCRE0[7] (RW)
 *
 * Determines whether an interrupt or a reset request is made following a loss
 * of OSC0 external reference clock. The LOCRE0 only has an affect when CME0 is
 * set.
 *
 * Values:
 * - 0b0 - Interrupt request is generated on a loss of OSC0 external reference
 *     clock.
 * - 0b1 - Generate a reset request on a loss of OSC0 external reference clock.
 */
/*@{*/
/*! @brief Read current value of the MCG_C2_LOCRE0 field. */
#define MCG_RD_C2_LOCRE0(base) ((MCG_C2_REG(base) & MCG_C2_LOCRE0_MASK) >> MCG_C2_LOCRE0_SHIFT)
#define MCG_BRD_C2_LOCRE0(base) (BME_UBFX8(&MCG_C2_REG(base), MCG_C2_LOCRE0_SHIFT, MCG_C2_LOCRE0_WIDTH))

/*! @brief Set the LOCRE0 field to a new value. */
#define MCG_WR_C2_LOCRE0(base, value) (MCG_RMW_C2(base, MCG_C2_LOCRE0_MASK, MCG_C2_LOCRE0(value)))
#define MCG_BWR_C2_LOCRE0(base, value) (BME_BFI8(&MCG_C2_REG(base), ((uint8_t)(value) << MCG_C2_LOCRE0_SHIFT), MCG_C2_LOCRE0_SHIFT, MCG_C2_LOCRE0_WIDTH))
/*@}*/

/*******************************************************************************
 * MCG_C3 - MCG Control 3 Register
 ******************************************************************************/

/*!
 * @brief MCG_C3 - MCG Control 3 Register (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire MCG_C3 register
 */
/*@{*/
#define MCG_RD_C3(base)          (MCG_C3_REG(base))
#define MCG_WR_C3(base, value)   (MCG_C3_REG(base) = (value))
#define MCG_RMW_C3(base, mask, value) (MCG_WR_C3(base, (MCG_RD_C3(base) & ~(mask)) | (value)))
#define MCG_SET_C3(base, value)  (BME_OR8(&MCG_C3_REG(base), (uint8_t)(value)))
#define MCG_CLR_C3(base, value)  (BME_AND8(&MCG_C3_REG(base), (uint8_t)(~(value))))
#define MCG_TOG_C3(base, value)  (BME_XOR8(&MCG_C3_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * MCG_C4 - MCG Control 4 Register
 ******************************************************************************/

/*!
 * @brief MCG_C4 - MCG Control 4 Register (RW)
 *
 * Reset value: 0x00U
 *
 * Reset values for DRST and DMX32 bits are 0.
 */
/*!
 * @name Constants and macros for entire MCG_C4 register
 */
/*@{*/
#define MCG_RD_C4(base)          (MCG_C4_REG(base))
#define MCG_WR_C4(base, value)   (MCG_C4_REG(base) = (value))
#define MCG_RMW_C4(base, mask, value) (MCG_WR_C4(base, (MCG_RD_C4(base) & ~(mask)) | (value)))
#define MCG_SET_C4(base, value)  (BME_OR8(&MCG_C4_REG(base), (uint8_t)(value)))
#define MCG_CLR_C4(base, value)  (BME_AND8(&MCG_C4_REG(base), (uint8_t)(~(value))))
#define MCG_TOG_C4(base, value)  (BME_XOR8(&MCG_C4_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual MCG_C4 bitfields
 */

/*!
 * @name Register MCG_C4, field SCFTRIM[0] (RW)
 *
 * SCFTRIM A value for SCFTRIM is loaded during reset from a factory programmed
 * location . controls the smallest adjustment of the slow internal reference
 * clock frequency. Setting SCFTRIM increases the period and clearing SCFTRIM
 * decreases the period by the smallest amount possible. If an SCFTRIM value stored in
 * nonvolatile memory is to be used, it is your responsibility to copy that value
 * from the nonvolatile memory location to this bit.
 */
/*@{*/
/*! @brief Read current value of the MCG_C4_SCFTRIM field. */
#define MCG_RD_C4_SCFTRIM(base) ((MCG_C4_REG(base) & MCG_C4_SCFTRIM_MASK) >> MCG_C4_SCFTRIM_SHIFT)
#define MCG_BRD_C4_SCFTRIM(base) (BME_UBFX8(&MCG_C4_REG(base), MCG_C4_SCFTRIM_SHIFT, MCG_C4_SCFTRIM_WIDTH))

/*! @brief Set the SCFTRIM field to a new value. */
#define MCG_WR_C4_SCFTRIM(base, value) (MCG_RMW_C4(base, MCG_C4_SCFTRIM_MASK, MCG_C4_SCFTRIM(value)))
#define MCG_BWR_C4_SCFTRIM(base, value) (BME_BFI8(&MCG_C4_REG(base), ((uint8_t)(value) << MCG_C4_SCFTRIM_SHIFT), MCG_C4_SCFTRIM_SHIFT, MCG_C4_SCFTRIM_WIDTH))
/*@}*/

/*!
 * @name Register MCG_C4, field FCTRIM[4:1] (RW)
 *
 * FCTRIM A value for FCTRIM is loaded during reset from a factory programmed
 * location. controls the fast internal reference clock frequency by controlling
 * the fast internal reference clock period. The FCTRIM bits are binary weighted,
 * that is, bit 1 adjusts twice as much as bit 0. Increasing the binary value
 * increases the period, and decreasing the value decreases the period. If an
 * FCTRIM[3:0] value stored in nonvolatile memory is to be used, it is your
 * responsibility to copy that value from the nonvolatile memory location to this register.
 */
/*@{*/
/*! @brief Read current value of the MCG_C4_FCTRIM field. */
#define MCG_RD_C4_FCTRIM(base) ((MCG_C4_REG(base) & MCG_C4_FCTRIM_MASK) >> MCG_C4_FCTRIM_SHIFT)
#define MCG_BRD_C4_FCTRIM(base) (BME_UBFX8(&MCG_C4_REG(base), MCG_C4_FCTRIM_SHIFT, MCG_C4_FCTRIM_WIDTH))

/*! @brief Set the FCTRIM field to a new value. */
#define MCG_WR_C4_FCTRIM(base, value) (MCG_RMW_C4(base, MCG_C4_FCTRIM_MASK, MCG_C4_FCTRIM(value)))
#define MCG_BWR_C4_FCTRIM(base, value) (BME_BFI8(&MCG_C4_REG(base), ((uint8_t)(value) << MCG_C4_FCTRIM_SHIFT), MCG_C4_FCTRIM_SHIFT, MCG_C4_FCTRIM_WIDTH))
/*@}*/

/*!
 * @name Register MCG_C4, field DRST_DRS[6:5] (RW)
 *
 * The DRS bits select the frequency range for the FLL output, DCOOUT. When the
 * LP bit is set, writes to the DRS bits are ignored. The DRST read field
 * indicates the current frequency range for DCOOUT. The DRST field does not update
 * immediately after a write to the DRS field due to internal synchronization between
 * clock domains. See the DCO Frequency Range table for more details.
 *
 * Values:
 * - 0b00 - Encoding 0 - Low range (reset default).
 * - 0b01 - Encoding 1 - Mid range.
 * - 0b10 - Encoding 2 - Mid-high range.
 * - 0b11 - Encoding 3 - High range.
 */
/*@{*/
/*! @brief Read current value of the MCG_C4_DRST_DRS field. */
#define MCG_RD_C4_DRST_DRS(base) ((MCG_C4_REG(base) & MCG_C4_DRST_DRS_MASK) >> MCG_C4_DRST_DRS_SHIFT)
#define MCG_BRD_C4_DRST_DRS(base) (BME_UBFX8(&MCG_C4_REG(base), MCG_C4_DRST_DRS_SHIFT, MCG_C4_DRST_DRS_WIDTH))

/*! @brief Set the DRST_DRS field to a new value. */
#define MCG_WR_C4_DRST_DRS(base, value) (MCG_RMW_C4(base, MCG_C4_DRST_DRS_MASK, MCG_C4_DRST_DRS(value)))
#define MCG_BWR_C4_DRST_DRS(base, value) (BME_BFI8(&MCG_C4_REG(base), ((uint8_t)(value) << MCG_C4_DRST_DRS_SHIFT), MCG_C4_DRST_DRS_SHIFT, MCG_C4_DRST_DRS_WIDTH))
/*@}*/

/*!
 * @name Register MCG_C4, field DMX32[7] (RW)
 *
 * The DMX32 bit controls whether the DCO frequency range is narrowed to its
 * maximum frequency with a 32.768 kHz reference. The following table identifies
 * settings for the DCO frequency range. The system clocks derived from this source
 * should not exceed their specified maximums. DRST_DRS DMX32 Reference Range FLL
 * Factor DCO Range 00 0 31.25-39.0625 kHz 640 20-25 MHz 1 32.768 kHz 732 24 MHz
 * 01 0 31.25-39.0625 kHz 1280 40-50 MHz 1 32.768 kHz 1464 48 MHz 10 0
 * 31.25-39.0625 kHz 1920 60-75 MHz 1 32.768 kHz 2197 72 MHz 11 0 31.25-39.0625 kHz 2560
 * 80-100 MHz 1 32.768 kHz 2929 96 MHz
 *
 * Values:
 * - 0b0 - DCO has a default range of 25%.
 * - 0b1 - DCO is fine-tuned for maximum frequency with 32.768 kHz reference.
 */
/*@{*/
/*! @brief Read current value of the MCG_C4_DMX32 field. */
#define MCG_RD_C4_DMX32(base) ((MCG_C4_REG(base) & MCG_C4_DMX32_MASK) >> MCG_C4_DMX32_SHIFT)
#define MCG_BRD_C4_DMX32(base) (BME_UBFX8(&MCG_C4_REG(base), MCG_C4_DMX32_SHIFT, MCG_C4_DMX32_WIDTH))

/*! @brief Set the DMX32 field to a new value. */
#define MCG_WR_C4_DMX32(base, value) (MCG_RMW_C4(base, MCG_C4_DMX32_MASK, MCG_C4_DMX32(value)))
#define MCG_BWR_C4_DMX32(base, value) (BME_BFI8(&MCG_C4_REG(base), ((uint8_t)(value) << MCG_C4_DMX32_SHIFT), MCG_C4_DMX32_SHIFT, MCG_C4_DMX32_WIDTH))
/*@}*/

/*******************************************************************************
 * MCG_C5 - MCG Control 5 Register
 ******************************************************************************/

/*!
 * @brief MCG_C5 - MCG Control 5 Register (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire MCG_C5 register
 */
/*@{*/
#define MCG_RD_C5(base)          (MCG_C5_REG(base))
#define MCG_WR_C5(base, value)   (MCG_C5_REG(base) = (value))
#define MCG_RMW_C5(base, mask, value) (MCG_WR_C5(base, (MCG_RD_C5(base) & ~(mask)) | (value)))
#define MCG_SET_C5(base, value)  (BME_OR8(&MCG_C5_REG(base), (uint8_t)(value)))
#define MCG_CLR_C5(base, value)  (BME_AND8(&MCG_C5_REG(base), (uint8_t)(~(value))))
#define MCG_TOG_C5(base, value)  (BME_XOR8(&MCG_C5_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual MCG_C5 bitfields
 */

/*!
 * @name Register MCG_C5, field PLLSTEN0[5] (RW)
 *
 * Enables the PLL Clock during Normal Stop. In Low Power Stop mode, the PLL
 * clock gets disabled even if PLLSTEN 0 =1. All other power modes, PLLSTEN 0 bit
 * has no affect and does not enable the PLL Clock to run if it is written to 1.
 *
 * Values:
 * - 0b0 - MCGPLLCLK is disabled in any of the Stop modes.
 * - 0b1 - MCGPLLCLK is enabled if system is in Normal Stop mode.
 */
/*@{*/
/*! @brief Read current value of the MCG_C5_PLLSTEN0 field. */
#define MCG_RD_C5_PLLSTEN0(base) ((MCG_C5_REG(base) & MCG_C5_PLLSTEN0_MASK) >> MCG_C5_PLLSTEN0_SHIFT)
#define MCG_BRD_C5_PLLSTEN0(base) (BME_UBFX8(&MCG_C5_REG(base), MCG_C5_PLLSTEN0_SHIFT, MCG_C5_PLLSTEN0_WIDTH))

/*! @brief Set the PLLSTEN0 field to a new value. */
#define MCG_WR_C5_PLLSTEN0(base, value) (MCG_RMW_C5(base, MCG_C5_PLLSTEN0_MASK, MCG_C5_PLLSTEN0(value)))
#define MCG_BWR_C5_PLLSTEN0(base, value) (BME_BFI8(&MCG_C5_REG(base), ((uint8_t)(value) << MCG_C5_PLLSTEN0_SHIFT), MCG_C5_PLLSTEN0_SHIFT, MCG_C5_PLLSTEN0_WIDTH))
/*@}*/

/*!
 * @name Register MCG_C5, field PLLCLKEN0[6] (RW)
 *
 * Enables the PLL independent of PLLS and enables the PLL clock for use as
 * MCGPLLCLK. Setting PLLCLKEN 0 will enable the external oscillator if not already
 * enabled. Whenever the PLL is being enabled by means of the PLLCLKEN 0 bit, and
 * the external oscillator is being used as the reference clock, the OSCINIT 0
 * bit should be checked to make sure it is set.
 *
 * Values:
 * - 0b0 - MCGPLLCLK is inactive.
 * - 0b1 - MCGPLLCLK is active.
 */
/*@{*/
/*! @brief Read current value of the MCG_C5_PLLCLKEN0 field. */
#define MCG_RD_C5_PLLCLKEN0(base) ((MCG_C5_REG(base) & MCG_C5_PLLCLKEN0_MASK) >> MCG_C5_PLLCLKEN0_SHIFT)
#define MCG_BRD_C5_PLLCLKEN0(base) (BME_UBFX8(&MCG_C5_REG(base), MCG_C5_PLLCLKEN0_SHIFT, MCG_C5_PLLCLKEN0_WIDTH))

/*! @brief Set the PLLCLKEN0 field to a new value. */
#define MCG_WR_C5_PLLCLKEN0(base, value) (MCG_RMW_C5(base, MCG_C5_PLLCLKEN0_MASK, MCG_C5_PLLCLKEN0(value)))
#define MCG_BWR_C5_PLLCLKEN0(base, value) (BME_BFI8(&MCG_C5_REG(base), ((uint8_t)(value) << MCG_C5_PLLCLKEN0_SHIFT), MCG_C5_PLLCLKEN0_SHIFT, MCG_C5_PLLCLKEN0_WIDTH))
/*@}*/

/*******************************************************************************
 * MCG_C6 - MCG Control 6 Register
 ******************************************************************************/

/*!
 * @brief MCG_C6 - MCG Control 6 Register (RW)
 *
 * Reset value: 0x08U
 */
/*!
 * @name Constants and macros for entire MCG_C6 register
 */
/*@{*/
#define MCG_RD_C6(base)          (MCG_C6_REG(base))
#define MCG_WR_C6(base, value)   (MCG_C6_REG(base) = (value))
#define MCG_RMW_C6(base, mask, value) (MCG_WR_C6(base, (MCG_RD_C6(base) & ~(mask)) | (value)))
#define MCG_SET_C6(base, value)  (BME_OR8(&MCG_C6_REG(base), (uint8_t)(value)))
#define MCG_CLR_C6(base, value)  (BME_AND8(&MCG_C6_REG(base), (uint8_t)(~(value))))
#define MCG_TOG_C6(base, value)  (BME_XOR8(&MCG_C6_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual MCG_C6 bitfields
 */

/*!
 * @name Register MCG_C6, field CHGPMP_BIAS[4:0] (RW)
 */
/*@{*/
/*! @brief Read current value of the MCG_C6_CHGPMP_BIAS field. */
#define MCG_RD_C6_CHGPMP_BIAS(base) ((MCG_C6_REG(base) & MCG_C6_CHGPMP_BIAS_MASK) >> MCG_C6_CHGPMP_BIAS_SHIFT)
#define MCG_BRD_C6_CHGPMP_BIAS(base) (BME_UBFX8(&MCG_C6_REG(base), MCG_C6_CHGPMP_BIAS_SHIFT, MCG_C6_CHGPMP_BIAS_WIDTH))

/*! @brief Set the CHGPMP_BIAS field to a new value. */
#define MCG_WR_C6_CHGPMP_BIAS(base, value) (MCG_RMW_C6(base, MCG_C6_CHGPMP_BIAS_MASK, MCG_C6_CHGPMP_BIAS(value)))
#define MCG_BWR_C6_CHGPMP_BIAS(base, value) (BME_BFI8(&MCG_C6_REG(base), ((uint8_t)(value) << MCG_C6_CHGPMP_BIAS_SHIFT), MCG_C6_CHGPMP_BIAS_SHIFT, MCG_C6_CHGPMP_BIAS_WIDTH))
/*@}*/

/*!
 * @name Register MCG_C6, field CME0[5] (RW)
 *
 * Enables the loss of clock monitoring circuit for the OSC0 external reference
 * mux select. The LOCRE0 bit will determine if a interrupt or a reset request is
 * generated following a loss of OSC0 indication. The CME0 bit must only be set
 * to a logic 1 when the MCG is in an operational mode that uses the external
 * clock (FEE, FBE, PEE, PBE, or BLPE) . Whenever the CME0 bit is set to a logic 1,
 * the value of the RANGE0 bits in the C2 register should not be changed. CME0
 * bit should be set to a logic 0 before the MCG enters any Stop mode. Otherwise, a
 * reset request may occur while in Stop mode. CME0 should also be set to a
 * logic 0 before entering VLPR or VLPW power modes if the MCG is in BLPE mode.
 *
 * Values:
 * - 0b0 - External clock monitor is disabled for OSC0.
 * - 0b1 - External clock monitor is enabled for OSC0.
 */
/*@{*/
/*! @brief Read current value of the MCG_C6_CME0 field. */
#define MCG_RD_C6_CME0(base) ((MCG_C6_REG(base) & MCG_C6_CME0_MASK) >> MCG_C6_CME0_SHIFT)
#define MCG_BRD_C6_CME0(base) (BME_UBFX8(&MCG_C6_REG(base), MCG_C6_CME0_SHIFT, MCG_C6_CME0_WIDTH))

/*! @brief Set the CME0 field to a new value. */
#define MCG_WR_C6_CME0(base, value) (MCG_RMW_C6(base, MCG_C6_CME0_MASK, MCG_C6_CME0(value)))
#define MCG_BWR_C6_CME0(base, value) (BME_BFI8(&MCG_C6_REG(base), ((uint8_t)(value) << MCG_C6_CME0_SHIFT), MCG_C6_CME0_SHIFT, MCG_C6_CME0_WIDTH))
/*@}*/

/*!
 * @name Register MCG_C6, field PLLS[6] (RW)
 *
 * Controls whether the PLL or FLL output is selected as the MCG source when
 * CLKS[1:0]=00. If the PLLS bit is cleared and PLLCLKEN 0 is not set, the PLL is
 * disabled in all modes. If the PLLS is set, the FLL is disabled in all modes.
 *
 * Values:
 * - 0b0 - FLL is selected.
 * - 0b1 - PLL is selected (PLL reference clock must be in the range of
 *     31.25-39.0625 KHz prior to setting the PLLS bit).
 */
/*@{*/
/*! @brief Read current value of the MCG_C6_PLLS field. */
#define MCG_RD_C6_PLLS(base) ((MCG_C6_REG(base) & MCG_C6_PLLS_MASK) >> MCG_C6_PLLS_SHIFT)
#define MCG_BRD_C6_PLLS(base) (BME_UBFX8(&MCG_C6_REG(base), MCG_C6_PLLS_SHIFT, MCG_C6_PLLS_WIDTH))

/*! @brief Set the PLLS field to a new value. */
#define MCG_WR_C6_PLLS(base, value) (MCG_RMW_C6(base, MCG_C6_PLLS_MASK, MCG_C6_PLLS(value)))
#define MCG_BWR_C6_PLLS(base, value) (BME_BFI8(&MCG_C6_REG(base), ((uint8_t)(value) << MCG_C6_PLLS_SHIFT), MCG_C6_PLLS_SHIFT, MCG_C6_PLLS_WIDTH))
/*@}*/

/*!
 * @name Register MCG_C6, field LOLIE0[7] (RW)
 *
 * Determines if an interrupt request is made following a loss of lock
 * indication. This bit only has an effect when LOLS 0 is set.
 *
 * Values:
 * - 0b0 - No interrupt request is generated on loss of lock.
 * - 0b1 - Generate an interrupt request on loss of lock.
 */
/*@{*/
/*! @brief Read current value of the MCG_C6_LOLIE0 field. */
#define MCG_RD_C6_LOLIE0(base) ((MCG_C6_REG(base) & MCG_C6_LOLIE0_MASK) >> MCG_C6_LOLIE0_SHIFT)
#define MCG_BRD_C6_LOLIE0(base) (BME_UBFX8(&MCG_C6_REG(base), MCG_C6_LOLIE0_SHIFT, MCG_C6_LOLIE0_WIDTH))

/*! @brief Set the LOLIE0 field to a new value. */
#define MCG_WR_C6_LOLIE0(base, value) (MCG_RMW_C6(base, MCG_C6_LOLIE0_MASK, MCG_C6_LOLIE0(value)))
#define MCG_BWR_C6_LOLIE0(base, value) (BME_BFI8(&MCG_C6_REG(base), ((uint8_t)(value) << MCG_C6_LOLIE0_SHIFT), MCG_C6_LOLIE0_SHIFT, MCG_C6_LOLIE0_WIDTH))
/*@}*/

/*******************************************************************************
 * MCG_S - MCG Status Register
 ******************************************************************************/

/*!
 * @brief MCG_S - MCG Status Register (RW)
 *
 * Reset value: 0x15U
 */
/*!
 * @name Constants and macros for entire MCG_S register
 */
/*@{*/
#define MCG_RD_S(base)           (MCG_S_REG(base))
#define MCG_WR_S(base, value)    (MCG_S_REG(base) = (value))
#define MCG_RMW_S(base, mask, value) (MCG_WR_S(base, (MCG_RD_S(base) & ~(mask)) | (value)))
#define MCG_SET_S(base, value)   (BME_OR8(&MCG_S_REG(base), (uint8_t)(value)))
#define MCG_CLR_S(base, value)   (BME_AND8(&MCG_S_REG(base), (uint8_t)(~(value))))
#define MCG_TOG_S(base, value)   (BME_XOR8(&MCG_S_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual MCG_S bitfields
 */

/*!
 * @name Register MCG_S, field IRCST[0] (RO)
 *
 * The IRCST bit indicates the current source for the internal reference clock
 * select clock (IRCSCLK). The IRCST bit does not update immediately after a write
 * to the IRCS bit due to internal synchronization between clock domains. The
 * IRCST bit will only be updated if the internal reference clock is enabled,
 * either by the MCG being in a mode that uses the IRC or by setting the C1[IRCLKEN]
 * bit .
 *
 * Values:
 * - 0b0 - Source of internal reference clock is the slow clock (32 kHz IRC).
 * - 0b1 - Source of internal reference clock is the fast clock (4 MHz IRC).
 */
/*@{*/
/*! @brief Read current value of the MCG_S_IRCST field. */
#define MCG_RD_S_IRCST(base) ((MCG_S_REG(base) & MCG_S_IRCST_MASK) >> MCG_S_IRCST_SHIFT)
#define MCG_BRD_S_IRCST(base) (BME_UBFX8(&MCG_S_REG(base), MCG_S_IRCST_SHIFT, MCG_S_IRCST_WIDTH))
/*@}*/

/*!
 * @name Register MCG_S, field OSCINIT0[1] (RO)
 *
 * This bit, which resets to 0, is set to 1 after the initialization cycles of
 * the crystal oscillator clock have completed. After being set, the bit is
 * cleared to 0 if the OSC is subsequently disabled. See the OSC module's detailed
 * description for more information.
 */
/*@{*/
/*! @brief Read current value of the MCG_S_OSCINIT0 field. */
#define MCG_RD_S_OSCINIT0(base) ((MCG_S_REG(base) & MCG_S_OSCINIT0_MASK) >> MCG_S_OSCINIT0_SHIFT)
#define MCG_BRD_S_OSCINIT0(base) (BME_UBFX8(&MCG_S_REG(base), MCG_S_OSCINIT0_SHIFT, MCG_S_OSCINIT0_WIDTH))
/*@}*/

/*!
 * @name Register MCG_S, field CLKST[3:2] (RO)
 *
 * These bits indicate the current clock mode. The CLKST bits do not update
 * immediately after a write to the CLKS bits due to internal synchronization between
 * clock domains.
 *
 * Values:
 * - 0b00 - Encoding 0 - Output of the FLL is selected (reset default).
 * - 0b01 - Encoding 1 - Internal reference clock is selected.
 * - 0b10 - Encoding 2 - External reference clock is selected.
 * - 0b11 - Encoding 3 - Output of the PLL is selected.
 */
/*@{*/
/*! @brief Read current value of the MCG_S_CLKST field. */
#define MCG_RD_S_CLKST(base) ((MCG_S_REG(base) & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT)
#define MCG_BRD_S_CLKST(base) (BME_UBFX8(&MCG_S_REG(base), MCG_S_CLKST_SHIFT, MCG_S_CLKST_WIDTH))
/*@}*/

/*!
 * @name Register MCG_S, field IREFST[4] (RO)
 *
 * This bit indicates the clock source for the FLL reference clock. The IREFST
 * bit does not update immediately after a write to the IREFS bit due to internal
 * synchronization between clock domains.
 *
 * Values:
 * - 0b0 - Source of FLL reference clock is the external reference clock.
 * - 0b1 - Source of FLL reference clock is the internal reference clock.
 */
/*@{*/
/*! @brief Read current value of the MCG_S_IREFST field. */
#define MCG_RD_S_IREFST(base) ((MCG_S_REG(base) & MCG_S_IREFST_MASK) >> MCG_S_IREFST_SHIFT)
#define MCG_BRD_S_IREFST(base) (BME_UBFX8(&MCG_S_REG(base), MCG_S_IREFST_SHIFT, MCG_S_IREFST_WIDTH))
/*@}*/

/*!
 * @name Register MCG_S, field PLLST[5] (RO)
 *
 * This bit indicates the clock source selected by PLLS . The PLLST bit does not
 * update immediately after a write to the PLLS bit due to internal
 * synchronization between clock domains.
 *
 * Values:
 * - 0b0 - Source of PLLS clock is FLL clock.
 * - 0b1 - Source of PLLS clock is PLL output clock.
 */
/*@{*/
/*! @brief Read current value of the MCG_S_PLLST field. */
#define MCG_RD_S_PLLST(base) ((MCG_S_REG(base) & MCG_S_PLLST_MASK) >> MCG_S_PLLST_SHIFT)
#define MCG_BRD_S_PLLST(base) (BME_UBFX8(&MCG_S_REG(base), MCG_S_PLLST_SHIFT, MCG_S_PLLST_WIDTH))
/*@}*/

/*!
 * @name Register MCG_S, field LOCK0[6] (RO)
 *
 * This bit indicates whether the PLL has acquired lock. Lock detection is only
 * enabled when the PLL is enabled (either through clock mode selection or
 * PLLCLKEN0=1 setting). While the PLL clock is locking to the desired frequency, the
 * MCG PLL clock (MCGPLLCLK) will be gated off until the LOCK bit gets asserted.
 * Loss of PLL reference clock will also cause the LOCK0 bit to clear until the
 * PLL has reacquired lock. Entry into VLPS, or regular Stop with PLLSTEN=0 also
 * causes the lock status bit to clear and stay cleared until the Stop mode is
 * exited and the PLL has reacquired lock. Any time the PLL is enabled and the LOCK0
 * bit is cleared, the MCGPLLCLK will be gated off until the LOCK0 bit is
 * asserted again.
 *
 * Values:
 * - 0b0 - PLL is currently unlocked.
 * - 0b1 - PLL is currently locked.
 */
/*@{*/
/*! @brief Read current value of the MCG_S_LOCK0 field. */
#define MCG_RD_S_LOCK0(base) ((MCG_S_REG(base) & MCG_S_LOCK0_MASK) >> MCG_S_LOCK0_SHIFT)
#define MCG_BRD_S_LOCK0(base) (BME_UBFX8(&MCG_S_REG(base), MCG_S_LOCK0_SHIFT, MCG_S_LOCK0_WIDTH))
/*@}*/

/*!
 * @name Register MCG_S, field LOLS0[7] (W1C)
 *
 * This bit is a sticky bit indicating the lock status for the PLL. LOLS is set
 * if after acquiring lock, the PLL output frequency has fallen outside the lock
 * exit frequency tolerance, D unl . LOLIE determines whether an interrupt
 * request is made when LOLS is set. LOLRE determines whether a reset request is made
 * when LOLS is set. This bit is cleared by reset or by writing a logic 1 to it
 * when set. Writing a logic 0 to this bit has no effect.
 *
 * Values:
 * - 0b0 - PLL has not lost lock since LOLS 0 was last cleared.
 * - 0b1 - PLL has lost lock since LOLS 0 was last cleared.
 */
/*@{*/
/*! @brief Read current value of the MCG_S_LOLS0 field. */
#define MCG_RD_S_LOLS0(base) ((MCG_S_REG(base) & MCG_S_LOLS0_MASK) >> MCG_S_LOLS0_SHIFT)
#define MCG_BRD_S_LOLS0(base) (BME_UBFX8(&MCG_S_REG(base), MCG_S_LOLS0_SHIFT, MCG_S_LOLS0_WIDTH))

/*! @brief Set the LOLS0 field to a new value. */
#define MCG_WR_S_LOLS0(base, value) (MCG_RMW_S(base, MCG_S_LOLS0_MASK, MCG_S_LOLS0(value)))
#define MCG_BWR_S_LOLS0(base, value) (BME_BFI8(&MCG_S_REG(base), ((uint8_t)(value) << MCG_S_LOLS0_SHIFT), MCG_S_LOLS0_SHIFT, MCG_S_LOLS0_WIDTH))
/*@}*/

/*******************************************************************************
 * MCG_SC - MCG Status and Control Register
 ******************************************************************************/

/*!
 * @brief MCG_SC - MCG Status and Control Register (RW)
 *
 * Reset value: 0x02U
 */
/*!
 * @name Constants and macros for entire MCG_SC register
 */
/*@{*/
#define MCG_RD_SC(base)          (MCG_SC_REG(base))
#define MCG_WR_SC(base, value)   (MCG_SC_REG(base) = (value))
#define MCG_RMW_SC(base, mask, value) (MCG_WR_SC(base, (MCG_RD_SC(base) & ~(mask)) | (value)))
#define MCG_SET_SC(base, value)  (BME_OR8(&MCG_SC_REG(base), (uint8_t)(value)))
#define MCG_CLR_SC(base, value)  (BME_AND8(&MCG_SC_REG(base), (uint8_t)(~(value))))
#define MCG_TOG_SC(base, value)  (BME_XOR8(&MCG_SC_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual MCG_SC bitfields
 */

/*!
 * @name Register MCG_SC, field LOCS0[0] (W1C)
 *
 * The LOCS0 indicates when a loss of OSC0 reference clock has occurred. The
 * LOCS0 bit only has an effect when CME0 is set. This bit is cleared by writing a
 * logic 1 to it when set.
 *
 * Values:
 * - 0b0 - Loss of OSC0 has not occurred.
 * - 0b1 - Loss of OSC0 has occurred.
 */
/*@{*/
/*! @brief Read current value of the MCG_SC_LOCS0 field. */
#define MCG_RD_SC_LOCS0(base) ((MCG_SC_REG(base) & MCG_SC_LOCS0_MASK) >> MCG_SC_LOCS0_SHIFT)
#define MCG_BRD_SC_LOCS0(base) (BME_UBFX8(&MCG_SC_REG(base), MCG_SC_LOCS0_SHIFT, MCG_SC_LOCS0_WIDTH))

/*! @brief Set the LOCS0 field to a new value. */
#define MCG_WR_SC_LOCS0(base, value) (MCG_RMW_SC(base, (MCG_SC_LOCS0_MASK | MCG_SC_ATMF_MASK), MCG_SC_LOCS0(value)))
#define MCG_BWR_SC_LOCS0(base, value) (BME_BFI8(&MCG_SC_REG(base), ((uint8_t)(value) << MCG_SC_LOCS0_SHIFT), MCG_SC_LOCS0_SHIFT, MCG_SC_LOCS0_WIDTH))
/*@}*/

/*!
 * @name Register MCG_SC, field FCRDIV[3:1] (RW)
 *
 * Selects the amount to divide down the fast internal reference clock. The
 * resulting frequency will be in the range 31.25 kHz to 4 MHz (Note: Changing the
 * divider when the Fast IRC is enabled is not supported).
 *
 * Values:
 * - 0b000 - Divide Factor is 1
 * - 0b001 - Divide Factor is 2.
 * - 0b010 - Divide Factor is 4.
 * - 0b011 - Divide Factor is 8.
 * - 0b100 - Divide Factor is 16
 * - 0b101 - Divide Factor is 32
 * - 0b110 - Divide Factor is 64
 * - 0b111 - Divide Factor is 128.
 */
/*@{*/
/*! @brief Read current value of the MCG_SC_FCRDIV field. */
#define MCG_RD_SC_FCRDIV(base) ((MCG_SC_REG(base) & MCG_SC_FCRDIV_MASK) >> MCG_SC_FCRDIV_SHIFT)
#define MCG_BRD_SC_FCRDIV(base) (BME_UBFX8(&MCG_SC_REG(base), MCG_SC_FCRDIV_SHIFT, MCG_SC_FCRDIV_WIDTH))

/*! @brief Set the FCRDIV field to a new value. */
#define MCG_WR_SC_FCRDIV(base, value) (MCG_RMW_SC(base, (MCG_SC_FCRDIV_MASK | MCG_SC_LOCS0_MASK | MCG_SC_ATMF_MASK), MCG_SC_FCRDIV(value)))
#define MCG_BWR_SC_FCRDIV(base, value) (BME_BFI8(&MCG_SC_REG(base), ((uint8_t)(value) << MCG_SC_FCRDIV_SHIFT), MCG_SC_FCRDIV_SHIFT, MCG_SC_FCRDIV_WIDTH))
/*@}*/

/*!
 * @name Register MCG_SC, field FLTPRSRV[4] (RW)
 *
 * This bit will prevent the FLL filter values from resetting allowing the FLL
 * output frequency to remain the same during clock mode changes where the FLL/DCO
 * output is still valid. (Note: This requires that the FLL reference frequency
 * to remain the same as what it was prior to the new clock mode switch.
 * Otherwise FLL filter and frequency values will change.)
 *
 * Values:
 * - 0b0 - FLL filter and FLL frequency will reset on changes to currect clock
 *     mode.
 * - 0b1 - Fll filter and FLL frequency retain their previous values during new
 *     clock mode change.
 */
/*@{*/
/*! @brief Read current value of the MCG_SC_FLTPRSRV field. */
#define MCG_RD_SC_FLTPRSRV(base) ((MCG_SC_REG(base) & MCG_SC_FLTPRSRV_MASK) >> MCG_SC_FLTPRSRV_SHIFT)
#define MCG_BRD_SC_FLTPRSRV(base) (BME_UBFX8(&MCG_SC_REG(base), MCG_SC_FLTPRSRV_SHIFT, MCG_SC_FLTPRSRV_WIDTH))

/*! @brief Set the FLTPRSRV field to a new value. */
#define MCG_WR_SC_FLTPRSRV(base, value) (MCG_RMW_SC(base, (MCG_SC_FLTPRSRV_MASK | MCG_SC_LOCS0_MASK | MCG_SC_ATMF_MASK), MCG_SC_FLTPRSRV(value)))
#define MCG_BWR_SC_FLTPRSRV(base, value) (BME_BFI8(&MCG_SC_REG(base), ((uint8_t)(value) << MCG_SC_FLTPRSRV_SHIFT), MCG_SC_FLTPRSRV_SHIFT, MCG_SC_FLTPRSRV_WIDTH))
/*@}*/

/*!
 * @name Register MCG_SC, field ATMF[5] (W1C)
 *
 * Fail flag for the Automatic Trim Machine (ATM). This bit asserts when the
 * Automatic Trim Machine is enabled, ATME=1, and a write to the C1, C3, C4, and SC
 * registers is detected or the MCG enters into any Stop mode. A write to ATMF
 * clears the flag.
 *
 * Values:
 * - 0b0 - Automatic Trim Machine completed normally.
 * - 0b1 - Automatic Trim Machine failed.
 */
/*@{*/
/*! @brief Read current value of the MCG_SC_ATMF field. */
#define MCG_RD_SC_ATMF(base) ((MCG_SC_REG(base) & MCG_SC_ATMF_MASK) >> MCG_SC_ATMF_SHIFT)
#define MCG_BRD_SC_ATMF(base) (BME_UBFX8(&MCG_SC_REG(base), MCG_SC_ATMF_SHIFT, MCG_SC_ATMF_WIDTH))

/*! @brief Set the ATMF field to a new value. */
#define MCG_WR_SC_ATMF(base, value) (MCG_RMW_SC(base, (MCG_SC_ATMF_MASK | MCG_SC_LOCS0_MASK), MCG_SC_ATMF(value)))
#define MCG_BWR_SC_ATMF(base, value) (BME_BFI8(&MCG_SC_REG(base), ((uint8_t)(value) << MCG_SC_ATMF_SHIFT), MCG_SC_ATMF_SHIFT, MCG_SC_ATMF_WIDTH))
/*@}*/

/*!
 * @name Register MCG_SC, field ATMS[6] (RW)
 *
 * Selects the IRCS clock for Auto Trim Test.
 *
 * Values:
 * - 0b0 - 32 kHz Internal Reference Clock selected.
 * - 0b1 - 4 MHz Internal Reference Clock selected.
 */
/*@{*/
/*! @brief Read current value of the MCG_SC_ATMS field. */
#define MCG_RD_SC_ATMS(base) ((MCG_SC_REG(base) & MCG_SC_ATMS_MASK) >> MCG_SC_ATMS_SHIFT)
#define MCG_BRD_SC_ATMS(base) (BME_UBFX8(&MCG_SC_REG(base), MCG_SC_ATMS_SHIFT, MCG_SC_ATMS_WIDTH))

/*! @brief Set the ATMS field to a new value. */
#define MCG_WR_SC_ATMS(base, value) (MCG_RMW_SC(base, (MCG_SC_ATMS_MASK | MCG_SC_LOCS0_MASK | MCG_SC_ATMF_MASK), MCG_SC_ATMS(value)))
#define MCG_BWR_SC_ATMS(base, value) (BME_BFI8(&MCG_SC_REG(base), ((uint8_t)(value) << MCG_SC_ATMS_SHIFT), MCG_SC_ATMS_SHIFT, MCG_SC_ATMS_WIDTH))
/*@}*/

/*!
 * @name Register MCG_SC, field ATME[7] (RW)
 *
 * Enables the Auto Trim Machine to start automatically trimming the selected
 * Internal Reference Clock. ATME deasserts after the Auto Trim Machine has
 * completed trimming all trim bits of the IRCS clock selected by the ATMS bit. Writing
 * to C1, C3, C4, and SC registers or entering Stop mode aborts the auto trim
 * operation and clears this bit.
 *
 * Values:
 * - 0b0 - Auto Trim Machine disabled.
 * - 0b1 - Auto Trim Machine enabled.
 */
/*@{*/
/*! @brief Read current value of the MCG_SC_ATME field. */
#define MCG_RD_SC_ATME(base) ((MCG_SC_REG(base) & MCG_SC_ATME_MASK) >> MCG_SC_ATME_SHIFT)
#define MCG_BRD_SC_ATME(base) (BME_UBFX8(&MCG_SC_REG(base), MCG_SC_ATME_SHIFT, MCG_SC_ATME_WIDTH))

/*! @brief Set the ATME field to a new value. */
#define MCG_WR_SC_ATME(base, value) (MCG_RMW_SC(base, (MCG_SC_ATME_MASK | MCG_SC_LOCS0_MASK | MCG_SC_ATMF_MASK), MCG_SC_ATME(value)))
#define MCG_BWR_SC_ATME(base, value) (BME_BFI8(&MCG_SC_REG(base), ((uint8_t)(value) << MCG_SC_ATME_SHIFT), MCG_SC_ATME_SHIFT, MCG_SC_ATME_WIDTH))
/*@}*/

/*******************************************************************************
 * MCG_ATCVH - MCG Auto Trim Compare Value High Register
 ******************************************************************************/

/*!
 * @brief MCG_ATCVH - MCG Auto Trim Compare Value High Register (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire MCG_ATCVH register
 */
/*@{*/
#define MCG_RD_ATCVH(base)       (MCG_ATCVH_REG(base))
#define MCG_WR_ATCVH(base, value) (MCG_ATCVH_REG(base) = (value))
#define MCG_RMW_ATCVH(base, mask, value) (MCG_WR_ATCVH(base, (MCG_RD_ATCVH(base) & ~(mask)) | (value)))
#define MCG_SET_ATCVH(base, value) (BME_OR8(&MCG_ATCVH_REG(base), (uint8_t)(value)))
#define MCG_CLR_ATCVH(base, value) (BME_AND8(&MCG_ATCVH_REG(base), (uint8_t)(~(value))))
#define MCG_TOG_ATCVH(base, value) (BME_XOR8(&MCG_ATCVH_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * MCG_ATCVL - MCG Auto Trim Compare Value Low Register
 ******************************************************************************/

/*!
 * @brief MCG_ATCVL - MCG Auto Trim Compare Value Low Register (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire MCG_ATCVL register
 */
/*@{*/
#define MCG_RD_ATCVL(base)       (MCG_ATCVL_REG(base))
#define MCG_WR_ATCVL(base, value) (MCG_ATCVL_REG(base) = (value))
#define MCG_RMW_ATCVL(base, mask, value) (MCG_WR_ATCVL(base, (MCG_RD_ATCVL(base) & ~(mask)) | (value)))
#define MCG_SET_ATCVL(base, value) (BME_OR8(&MCG_ATCVL_REG(base), (uint8_t)(value)))
#define MCG_CLR_ATCVL(base, value) (BME_AND8(&MCG_ATCVL_REG(base), (uint8_t)(~(value))))
#define MCG_TOG_ATCVL(base, value) (BME_XOR8(&MCG_ATCVL_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * MCG_C7 - MCG Control 7 Register
 ******************************************************************************/

/*!
 * @brief MCG_C7 - MCG Control 7 Register (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire MCG_C7 register
 */
/*@{*/
#define MCG_RD_C7(base)          (MCG_C7_REG(base))
#define MCG_WR_C7(base, value)   (MCG_C7_REG(base) = (value))
#define MCG_RMW_C7(base, mask, value) (MCG_WR_C7(base, (MCG_RD_C7(base) & ~(mask)) | (value)))
#define MCG_SET_C7(base, value)  (BME_OR8(&MCG_C7_REG(base), (uint8_t)(value)))
#define MCG_CLR_C7(base, value)  (BME_AND8(&MCG_C7_REG(base), (uint8_t)(~(value))))
#define MCG_TOG_C7(base, value)  (BME_XOR8(&MCG_C7_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual MCG_C7 bitfields
 */

/*!
 * @name Register MCG_C7, field OSCSEL[0] (RW)
 *
 * Selects the MCG FLL external reference clock
 *
 * Values:
 * - 0b0 - Selects Oscillator (OSCCLK).
 * - 0b1 - Selects 32 kHz RTC Oscillator.
 */
/*@{*/
/*! @brief Read current value of the MCG_C7_OSCSEL field. */
#define MCG_RD_C7_OSCSEL(base) ((MCG_C7_REG(base) & MCG_C7_OSCSEL_MASK) >> MCG_C7_OSCSEL_SHIFT)
#define MCG_BRD_C7_OSCSEL(base) (BME_UBFX8(&MCG_C7_REG(base), MCG_C7_OSCSEL_SHIFT, MCG_C7_OSCSEL_WIDTH))

/*! @brief Set the OSCSEL field to a new value. */
#define MCG_WR_C7_OSCSEL(base, value) (MCG_RMW_C7(base, MCG_C7_OSCSEL_MASK, MCG_C7_OSCSEL(value)))
#define MCG_BWR_C7_OSCSEL(base, value) (BME_BFI8(&MCG_C7_REG(base), ((uint8_t)(value) << MCG_C7_OSCSEL_SHIFT), MCG_C7_OSCSEL_SHIFT, MCG_C7_OSCSEL_WIDTH))
/*@}*/

/*!
 * @name Register MCG_C7, field PLL32KREFSEL[7:6] (RW)
 *
 * Selects the 32kHz PLL reference clock.
 *
 * Values:
 * - 0b00 - Selects 32 kHz RTC Oscillator.
 * - 0b01 - Selects 32 kHz IRC.
 * - 0b10 - Selects FLL FRDIV clock.
 * - 0b11 - Reserved.
 */
/*@{*/
/*! @brief Read current value of the MCG_C7_PLL32KREFSEL field. */
#define MCG_RD_C7_PLL32KREFSEL(base) ((MCG_C7_REG(base) & MCG_C7_PLL32KREFSEL_MASK) >> MCG_C7_PLL32KREFSEL_SHIFT)
#define MCG_BRD_C7_PLL32KREFSEL(base) (BME_UBFX8(&MCG_C7_REG(base), MCG_C7_PLL32KREFSEL_SHIFT, MCG_C7_PLL32KREFSEL_WIDTH))

/*! @brief Set the PLL32KREFSEL field to a new value. */
#define MCG_WR_C7_PLL32KREFSEL(base, value) (MCG_RMW_C7(base, MCG_C7_PLL32KREFSEL_MASK, MCG_C7_PLL32KREFSEL(value)))
#define MCG_BWR_C7_PLL32KREFSEL(base, value) (BME_BFI8(&MCG_C7_REG(base), ((uint8_t)(value) << MCG_C7_PLL32KREFSEL_SHIFT), MCG_C7_PLL32KREFSEL_SHIFT, MCG_C7_PLL32KREFSEL_WIDTH))
/*@}*/

/*******************************************************************************
 * MCG_C8 - MCG Control 8 Register
 ******************************************************************************/

/*!
 * @brief MCG_C8 - MCG Control 8 Register (RW)
 *
 * Reset value: 0x80U
 */
/*!
 * @name Constants and macros for entire MCG_C8 register
 */
/*@{*/
#define MCG_RD_C8(base)          (MCG_C8_REG(base))
#define MCG_WR_C8(base, value)   (MCG_C8_REG(base) = (value))
#define MCG_RMW_C8(base, mask, value) (MCG_WR_C8(base, (MCG_RD_C8(base) & ~(mask)) | (value)))
#define MCG_SET_C8(base, value)  (BME_OR8(&MCG_C8_REG(base), (uint8_t)(value)))
#define MCG_CLR_C8(base, value)  (BME_AND8(&MCG_C8_REG(base), (uint8_t)(~(value))))
#define MCG_TOG_C8(base, value)  (BME_XOR8(&MCG_C8_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual MCG_C8 bitfields
 */

/*!
 * @name Register MCG_C8, field LOCS1[0] (W1C)
 *
 * This bit indicates when a loss of clock has occurred. This bit is cleared by
 * writing a logic 1 to it when set.
 *
 * Values:
 * - 0b0 - Loss of RTC has not occur.
 * - 0b1 - Loss of RTC has occur
 */
/*@{*/
/*! @brief Read current value of the MCG_C8_LOCS1 field. */
#define MCG_RD_C8_LOCS1(base) ((MCG_C8_REG(base) & MCG_C8_LOCS1_MASK) >> MCG_C8_LOCS1_SHIFT)
#define MCG_BRD_C8_LOCS1(base) (BME_UBFX8(&MCG_C8_REG(base), MCG_C8_LOCS1_SHIFT, MCG_C8_LOCS1_WIDTH))

/*! @brief Set the LOCS1 field to a new value. */
#define MCG_WR_C8_LOCS1(base, value) (MCG_RMW_C8(base, MCG_C8_LOCS1_MASK, MCG_C8_LOCS1(value)))
#define MCG_BWR_C8_LOCS1(base, value) (BME_BFI8(&MCG_C8_REG(base), ((uint8_t)(value) << MCG_C8_LOCS1_SHIFT), MCG_C8_LOCS1_SHIFT, MCG_C8_LOCS1_WIDTH))
/*@}*/

/*!
 * @name Register MCG_C8, field COARSE_LOLIE[4] (RW)
 *
 * Determines if an interrupt request is made following a coarse loss of lock
 * indication. This bit only has an effect when COARSE_LOLS is set.
 *
 * Values:
 * - 0b0 - No interrupt request is generated on coarse loss of lock.
 * - 0b1 - Generate an interrupt request on coarse loss of lock.
 */
/*@{*/
/*! @brief Read current value of the MCG_C8_COARSE_LOLIE field. */
#define MCG_RD_C8_COARSE_LOLIE(base) ((MCG_C8_REG(base) & MCG_C8_COARSE_LOLIE_MASK) >> MCG_C8_COARSE_LOLIE_SHIFT)
#define MCG_BRD_C8_COARSE_LOLIE(base) (BME_UBFX8(&MCG_C8_REG(base), MCG_C8_COARSE_LOLIE_SHIFT, MCG_C8_COARSE_LOLIE_WIDTH))

/*! @brief Set the COARSE_LOLIE field to a new value. */
#define MCG_WR_C8_COARSE_LOLIE(base, value) (MCG_RMW_C8(base, (MCG_C8_COARSE_LOLIE_MASK | MCG_C8_LOCS1_MASK), MCG_C8_COARSE_LOLIE(value)))
#define MCG_BWR_C8_COARSE_LOLIE(base, value) (BME_BFI8(&MCG_C8_REG(base), ((uint8_t)(value) << MCG_C8_COARSE_LOLIE_SHIFT), MCG_C8_COARSE_LOLIE_SHIFT, MCG_C8_COARSE_LOLIE_WIDTH))
/*@}*/

/*!
 * @name Register MCG_C8, field CME1[5] (RW)
 *
 * Enables the loss of clock monitoring circuit for the output of the RTC
 * external reference clock. The LOCRE1 bit will determine whether an interrupt or a
 * reset request is generated following a loss of RTC clock indication. The CME1
 * bit should be set to a logic 1 when the MCG is in an operational mode that uses
 * the RTC as its external reference clock or if the RTC is operational. CME1 bit
 * must be set to a logic 0 before the MCG enters any Stop mode. Otherwise, a
 * reset request may occur when in Stop mode. CME1 should also be set to a logic 0
 * before entering VLPR or VLPW power modes.
 *
 * Values:
 * - 0b0 - External clock monitor is disabled for RTC clock.
 * - 0b1 - External clock monitor is enabled for RTC clock.
 */
/*@{*/
/*! @brief Read current value of the MCG_C8_CME1 field. */
#define MCG_RD_C8_CME1(base) ((MCG_C8_REG(base) & MCG_C8_CME1_MASK) >> MCG_C8_CME1_SHIFT)
#define MCG_BRD_C8_CME1(base) (BME_UBFX8(&MCG_C8_REG(base), MCG_C8_CME1_SHIFT, MCG_C8_CME1_WIDTH))

/*! @brief Set the CME1 field to a new value. */
#define MCG_WR_C8_CME1(base, value) (MCG_RMW_C8(base, (MCG_C8_CME1_MASK | MCG_C8_LOCS1_MASK), MCG_C8_CME1(value)))
#define MCG_BWR_C8_CME1(base, value) (BME_BFI8(&MCG_C8_REG(base), ((uint8_t)(value) << MCG_C8_CME1_SHIFT), MCG_C8_CME1_SHIFT, MCG_C8_CME1_WIDTH))
/*@}*/

/*!
 * @name Register MCG_C8, field LOLRE[6] (RW)
 *
 * Determines if an interrupt or a reset request is made following a PLL loss of
 * lock.
 *
 * Values:
 * - 0b0 - Interrupt request is generated on a PLL loss of lock indication. The
 *     PLL loss of lock interrupt enable bit must also be set to generate the
 *     interrupt request.
 * - 0b1 - Generate a reset request on a PLL loss of lock indication.
 */
/*@{*/
/*! @brief Read current value of the MCG_C8_LOLRE field. */
#define MCG_RD_C8_LOLRE(base) ((MCG_C8_REG(base) & MCG_C8_LOLRE_MASK) >> MCG_C8_LOLRE_SHIFT)
#define MCG_BRD_C8_LOLRE(base) (BME_UBFX8(&MCG_C8_REG(base), MCG_C8_LOLRE_SHIFT, MCG_C8_LOLRE_WIDTH))

/*! @brief Set the LOLRE field to a new value. */
#define MCG_WR_C8_LOLRE(base, value) (MCG_RMW_C8(base, (MCG_C8_LOLRE_MASK | MCG_C8_LOCS1_MASK), MCG_C8_LOLRE(value)))
#define MCG_BWR_C8_LOLRE(base, value) (BME_BFI8(&MCG_C8_REG(base), ((uint8_t)(value) << MCG_C8_LOLRE_SHIFT), MCG_C8_LOLRE_SHIFT, MCG_C8_LOLRE_WIDTH))
/*@}*/

/*!
 * @name Register MCG_C8, field LOCRE1[7] (RW)
 *
 * Determines if a interrupt or a reset request is made following a loss of RTC
 * external reference clock. The LOCRE1 only has an affect when CME1 is set.
 *
 * Values:
 * - 0b0 - Interrupt request is generated on a loss of RTC external reference
 *     clock.
 * - 0b1 - Generate a reset request on a loss of RTC external reference clock
 */
/*@{*/
/*! @brief Read current value of the MCG_C8_LOCRE1 field. */
#define MCG_RD_C8_LOCRE1(base) ((MCG_C8_REG(base) & MCG_C8_LOCRE1_MASK) >> MCG_C8_LOCRE1_SHIFT)
#define MCG_BRD_C8_LOCRE1(base) (BME_UBFX8(&MCG_C8_REG(base), MCG_C8_LOCRE1_SHIFT, MCG_C8_LOCRE1_WIDTH))

/*! @brief Set the LOCRE1 field to a new value. */
#define MCG_WR_C8_LOCRE1(base, value) (MCG_RMW_C8(base, (MCG_C8_LOCRE1_MASK | MCG_C8_LOCS1_MASK), MCG_C8_LOCRE1(value)))
#define MCG_BWR_C8_LOCRE1(base, value) (BME_BFI8(&MCG_C8_REG(base), ((uint8_t)(value) << MCG_C8_LOCRE1_SHIFT), MCG_C8_LOCRE1_SHIFT, MCG_C8_LOCRE1_WIDTH))
/*@}*/

/*******************************************************************************
 * MCG_C9 - MCG Control 9 Register
 ******************************************************************************/

/*!
 * @brief MCG_C9 - MCG Control 9 Register (RO)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire MCG_C9 register
 */
/*@{*/
#define MCG_RD_C9(base)          (MCG_C9_REG(base))
/*@}*/

/*
 * Constants & macros for individual MCG_C9 bitfields
 */

/*!
 * @name Register MCG_C9, field COARSE_LOCK[6] (RO)
 *
 * This bit indicates whether the PLL has acquired coarse lock after the first
 * lock sample (Note: LOCK bit asserts after three lock samples and CRS_LOCK will
 * assert after first lock sample). Lock detection is disabled when not operating
 * in either PEI, PBI, PBE or PEE mode unless PLLCLKEN0 =1 and the MCG is not
 * configured in BLPI or BLPE mode. Loss of PLL reference clock will also cause the
 * COARSE LOCK PLL has reacquired lock. Entry into LLS, VLPS, or regular Stop
 * with PLLSTEN0=0 also causes the coarse lock status bit to clear and stay cleared
 * until the Stop mode is exited and the PLL has reacquired lock after the first
 * sample.
 *
 * Values:
 * - 0b0 - PLL is currently unlocked.
 * - 0b1 - PLL is currently locked after first sample.
 */
/*@{*/
/*! @brief Read current value of the MCG_C9_COARSE_LOCK field. */
#define MCG_RD_C9_COARSE_LOCK(base) ((MCG_C9_REG(base) & MCG_C9_COARSE_LOCK_MASK) >> MCG_C9_COARSE_LOCK_SHIFT)
#define MCG_BRD_C9_COARSE_LOCK(base) (BME_UBFX8(&MCG_C9_REG(base), MCG_C9_COARSE_LOCK_SHIFT, MCG_C9_COARSE_LOCK_WIDTH))
/*@}*/

/*!
 * @name Register MCG_C9, field COARSE_LOLS[7] (RO)
 *
 * This bit is a sticky bit indicating the coarse lock status for the PLL.
 * COARSE_LOLS is set if after acquiring a coarse lock, the PLL output frequency has
 * fallen outside the lock exit frequency tolerance, D unl . COARSE_LOLIE
 * determines whether an interrupt request is made when COARSE_LOLS is set. This bit is
 * cleared by reset or by writing a logic 1 to it when set. Writing a logic 0 to
 * this bit has no effect.
 *
 * Values:
 * - 0b0 - PLL has not lost lock since COARSE_LOLS was last cleared.
 * - 0b1 - PLL has lost lock since COARSE_LOLS was last cleared.
 */
/*@{*/
/*! @brief Read current value of the MCG_C9_COARSE_LOLS field. */
#define MCG_RD_C9_COARSE_LOLS(base) ((MCG_C9_REG(base) & MCG_C9_COARSE_LOLS_MASK) >> MCG_C9_COARSE_LOLS_SHIFT)
#define MCG_BRD_C9_COARSE_LOLS(base) (BME_UBFX8(&MCG_C9_REG(base), MCG_C9_COARSE_LOLS_SHIFT, MCG_C9_COARSE_LOLS_WIDTH))
/*@}*/

/* MCG C2[EREFS] backward compatibility */
#define MCG_RD_C2_EREFS(base)         (MCG_RD_C2_EREFS0(base))
#define MCG_BRD_C2_EREFS(base)        (MCG_BRD_C2_EREFS0(base))
#define MCG_WR_C2_EREFS(base, value)  (MCG_WR_C2_EREFS0((base), (value)))
#define MCG_BWR_C2_EREFS(base, value) (MCG_BWR_C2_EREFS0((base), (value)))
/* MCG C2[HGO] backward compatibility */
#define MCG_RD_C2_HGO(base)         (MCG_RD_C2_HGO0(base))
#define MCG_BRD_C2_HGO(base)        (MCG_BRD_C2_HGO0(base))
#define MCG_WR_C2_HGO(base, value)  (MCG_WR_C2_HGO0((base), (value)))
#define MCG_BWR_C2_HGO(base, value) (MCG_BWR_C2_HGO0((base), (value)))
/* MCG C2[RANGE] backward compatibility */
#define MCG_RD_C2_RANGE(base)         (MCG_RD_C2_RANGE0(base))
#define MCG_BRD_C2_RANGE(base)        (MCG_BRD_C2_RANGE0(base))
#define MCG_WR_C2_RANGE(base, value)  (MCG_WR_C2_RANGE0((base), (value)))
#define MCG_BWR_C2_RANGE(base, value) (MCG_BWR_C2_RANGE0((base), (value)))

/*
 * MKM34Z7 MCM
 *
 * Core Platform Miscellaneous Control Module
 *
 * Registers defined in this header file:
 * - MCM_PLASC - Crossbar Switch (AXBS) Slave Configuration
 * - MCM_PLAMC - Crossbar Switch (AXBS) Master Configuration
 * - MCM_PLACR - Platform Control Register
 * - MCM_PID - Process ID register
 * - MCM_CPO - Compute Operation Control Register
 * - MCM_MATCR - Master Attribute Configuration Register
 */

#define MCM_INSTANCE_COUNT (1U) /*!< Number of instances of the MCM module. */
#define MCM_IDX (0U) /*!< Instance number for MCM. */

/*******************************************************************************
 * MCM_PLASC - Crossbar Switch (AXBS) Slave Configuration
 ******************************************************************************/

/*!
 * @brief MCM_PLASC - Crossbar Switch (AXBS) Slave Configuration (RO)
 *
 * Reset value: 0x0007U
 *
 * PLASC is a 16-bit read-only register identifying the presence/absence of bus
 * slave connections to the device's crossbar switch.
 */
/*!
 * @name Constants and macros for entire MCM_PLASC register
 */
/*@{*/
#define MCM_RD_PLASC(base)       (MCM_PLASC_REG(base))
/*@}*/

/*
 * Constants & macros for individual MCM_PLASC bitfields
 */

/*!
 * @name Register MCM_PLASC, field ASC[7:0] (RO)
 *
 * Values:
 * - 0b00000000 - A bus slave connection to AXBS input port n is absent.
 * - 0b00000001 - A bus slave connection to AXBS input port n is present.
 */
/*@{*/
/*! @brief Read current value of the MCM_PLASC_ASC field. */
#define MCM_RD_PLASC_ASC(base) ((MCM_PLASC_REG(base) & MCM_PLASC_ASC_MASK) >> MCM_PLASC_ASC_SHIFT)
#define MCM_BRD_PLASC_ASC(base) (MCM_RD_PLASC_ASC(base))
/*@}*/

/*******************************************************************************
 * MCM_PLAMC - Crossbar Switch (AXBS) Master Configuration
 ******************************************************************************/

/*!
 * @brief MCM_PLAMC - Crossbar Switch (AXBS) Master Configuration (RO)
 *
 * Reset value: 0x0005U
 *
 * PLAMC is a 16-bit read-only register identifying the presence/absence of bus
 * master connections to the device's crossbar switch.
 */
/*!
 * @name Constants and macros for entire MCM_PLAMC register
 */
/*@{*/
#define MCM_RD_PLAMC(base)       (MCM_PLAMC_REG(base))
/*@}*/

/*
 * Constants & macros for individual MCM_PLAMC bitfields
 */

/*!
 * @name Register MCM_PLAMC, field AMC[7:0] (RO)
 *
 * Values:
 * - 0b00000000 - A bus master connection to AXBS input port n is absent
 * - 0b00000001 - A bus master connection to AXBS input port n is present
 */
/*@{*/
/*! @brief Read current value of the MCM_PLAMC_AMC field. */
#define MCM_RD_PLAMC_AMC(base) ((MCM_PLAMC_REG(base) & MCM_PLAMC_AMC_MASK) >> MCM_PLAMC_AMC_SHIFT)
#define MCM_BRD_PLAMC_AMC(base) (MCM_RD_PLAMC_AMC(base))
/*@}*/

/*******************************************************************************
 * MCM_PLACR - Platform Control Register
 ******************************************************************************/

/*!
 * @brief MCM_PLACR - Platform Control Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The PLACR register selects the arbitration policy for the crossbar masters
 * and configures the flash memory controller. The speculation buffer and cache in
 * the flash memory controller is configurable via PLACR[15:10 ]. The speculation
 * buffer is enabled only for instructions after reset. It is possible to have
 * these states for the speculation buffer: DFCS EFDS Description 0 0 Speculation
 * buffer is on for instruction and off for data. 0 1 Speculation buffer is on
 * for instruction and on for data. 1 X Speculation buffer is off. The cache in
 * flash controller is enabled and caching both instruction and data type fetches
 * after reset. It is possible to have these states for the cache: DFCC DFCIC DFCDA
 * Description 0 0 0 Cache is on for both instruction and data. 0 0 1 Cache is
 * on for instruction and off for data. 0 1 0 Cache is off for instruction and on
 * for data. 0 1 1 Cache is off for both instruction and data. 1 X X Cache is off.
 */
/*!
 * @name Constants and macros for entire MCM_PLACR register
 */
/*@{*/
#define MCM_RD_PLACR(base)       (MCM_PLACR_REG(base))
#define MCM_WR_PLACR(base, value) (MCM_PLACR_REG(base) = (value))
#define MCM_RMW_PLACR(base, mask, value) (MCM_WR_PLACR(base, (MCM_RD_PLACR(base) & ~(mask)) | (value)))
#define MCM_SET_PLACR(base, value) (MCM_WR_PLACR(base, MCM_RD_PLACR(base) |  (value)))
#define MCM_CLR_PLACR(base, value) (MCM_WR_PLACR(base, MCM_RD_PLACR(base) & ~(value)))
#define MCM_TOG_PLACR(base, value) (MCM_WR_PLACR(base, MCM_RD_PLACR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual MCM_PLACR bitfields
 */

/*!
 * @name Register MCM_PLACR, field ARB[9] (RW)
 *
 * Values:
 * - 0b0 - Fixed-priority arbitration for the crossbar masters
 * - 0b1 - Round-robin arbitration for the crossbar masters
 */
/*@{*/
/*! @brief Read current value of the MCM_PLACR_ARB field. */
#define MCM_RD_PLACR_ARB(base) ((MCM_PLACR_REG(base) & MCM_PLACR_ARB_MASK) >> MCM_PLACR_ARB_SHIFT)
#define MCM_BRD_PLACR_ARB(base) (MCM_RD_PLACR_ARB(base))

/*! @brief Set the ARB field to a new value. */
#define MCM_WR_PLACR_ARB(base, value) (MCM_RMW_PLACR(base, MCM_PLACR_ARB_MASK, MCM_PLACR_ARB(value)))
#define MCM_BWR_PLACR_ARB(base, value) (MCM_WR_PLACR_ARB(base, value))
/*@}*/

/*!
 * @name Register MCM_PLACR, field CFCC[10] (WORZ)
 *
 * Writing a 1 to this field clears the cache. Writing a 0 to this field is
 * ignored. This field always reads as 0.
 */
/*@{*/
/*! @brief Set the CFCC field to a new value. */
#define MCM_WR_PLACR_CFCC(base, value) (MCM_RMW_PLACR(base, MCM_PLACR_CFCC_MASK, MCM_PLACR_CFCC(value)))
#define MCM_BWR_PLACR_CFCC(base, value) (MCM_WR_PLACR_CFCC(base, value))
/*@}*/

/*!
 * @name Register MCM_PLACR, field DFCDA[11] (RW)
 *
 * Disables flash controller data caching.
 *
 * Values:
 * - 0b0 - Enable flash controller data caching
 * - 0b1 - Disable flash controller data caching.
 */
/*@{*/
/*! @brief Read current value of the MCM_PLACR_DFCDA field. */
#define MCM_RD_PLACR_DFCDA(base) ((MCM_PLACR_REG(base) & MCM_PLACR_DFCDA_MASK) >> MCM_PLACR_DFCDA_SHIFT)
#define MCM_BRD_PLACR_DFCDA(base) (MCM_RD_PLACR_DFCDA(base))

/*! @brief Set the DFCDA field to a new value. */
#define MCM_WR_PLACR_DFCDA(base, value) (MCM_RMW_PLACR(base, MCM_PLACR_DFCDA_MASK, MCM_PLACR_DFCDA(value)))
#define MCM_BWR_PLACR_DFCDA(base, value) (MCM_WR_PLACR_DFCDA(base, value))
/*@}*/

/*!
 * @name Register MCM_PLACR, field DFCIC[12] (RW)
 *
 * Disables flash controller instruction caching.
 *
 * Values:
 * - 0b0 - Enable flash controller instruction caching.
 * - 0b1 - Disable flash controller instruction caching.
 */
/*@{*/
/*! @brief Read current value of the MCM_PLACR_DFCIC field. */
#define MCM_RD_PLACR_DFCIC(base) ((MCM_PLACR_REG(base) & MCM_PLACR_DFCIC_MASK) >> MCM_PLACR_DFCIC_SHIFT)
#define MCM_BRD_PLACR_DFCIC(base) (MCM_RD_PLACR_DFCIC(base))

/*! @brief Set the DFCIC field to a new value. */
#define MCM_WR_PLACR_DFCIC(base, value) (MCM_RMW_PLACR(base, MCM_PLACR_DFCIC_MASK, MCM_PLACR_DFCIC(value)))
#define MCM_BWR_PLACR_DFCIC(base, value) (MCM_WR_PLACR_DFCIC(base, value))
/*@}*/

/*!
 * @name Register MCM_PLACR, field DFCC[13] (RW)
 *
 * Disables flash controller cache.
 *
 * Values:
 * - 0b0 - Enable flash controller cache.
 * - 0b1 - Disable flash controller cache.
 */
/*@{*/
/*! @brief Read current value of the MCM_PLACR_DFCC field. */
#define MCM_RD_PLACR_DFCC(base) ((MCM_PLACR_REG(base) & MCM_PLACR_DFCC_MASK) >> MCM_PLACR_DFCC_SHIFT)
#define MCM_BRD_PLACR_DFCC(base) (MCM_RD_PLACR_DFCC(base))

/*! @brief Set the DFCC field to a new value. */
#define MCM_WR_PLACR_DFCC(base, value) (MCM_RMW_PLACR(base, MCM_PLACR_DFCC_MASK, MCM_PLACR_DFCC(value)))
#define MCM_BWR_PLACR_DFCC(base, value) (MCM_WR_PLACR_DFCC(base, value))
/*@}*/

/*!
 * @name Register MCM_PLACR, field EFDS[14] (RW)
 *
 * Enables flash data speculation.
 *
 * Values:
 * - 0b0 - Disable flash data speculation.
 * - 0b1 - Enable flash data speculation.
 */
/*@{*/
/*! @brief Read current value of the MCM_PLACR_EFDS field. */
#define MCM_RD_PLACR_EFDS(base) ((MCM_PLACR_REG(base) & MCM_PLACR_EFDS_MASK) >> MCM_PLACR_EFDS_SHIFT)
#define MCM_BRD_PLACR_EFDS(base) (MCM_RD_PLACR_EFDS(base))

/*! @brief Set the EFDS field to a new value. */
#define MCM_WR_PLACR_EFDS(base, value) (MCM_RMW_PLACR(base, MCM_PLACR_EFDS_MASK, MCM_PLACR_EFDS(value)))
#define MCM_BWR_PLACR_EFDS(base, value) (MCM_WR_PLACR_EFDS(base, value))
/*@}*/

/*!
 * @name Register MCM_PLACR, field DFCS[15] (RW)
 *
 * Disables flash controller speculation.
 *
 * Values:
 * - 0b0 - Enable flash controller speculation.
 * - 0b1 - Disable flash controller speculation.
 */
/*@{*/
/*! @brief Read current value of the MCM_PLACR_DFCS field. */
#define MCM_RD_PLACR_DFCS(base) ((MCM_PLACR_REG(base) & MCM_PLACR_DFCS_MASK) >> MCM_PLACR_DFCS_SHIFT)
#define MCM_BRD_PLACR_DFCS(base) (MCM_RD_PLACR_DFCS(base))

/*! @brief Set the DFCS field to a new value. */
#define MCM_WR_PLACR_DFCS(base, value) (MCM_RMW_PLACR(base, MCM_PLACR_DFCS_MASK, MCM_PLACR_DFCS(value)))
#define MCM_BWR_PLACR_DFCS(base, value) (MCM_WR_PLACR_DFCS(base, value))
/*@}*/

/*!
 * @name Register MCM_PLACR, field ESFC[16] (RW)
 *
 * Enables stalling flash controller when flash is busy. When software needs to
 * access the flash memory while a flash memory resource is being manipulated by
 * a flash command, software can enable a stall mechanism to avoid a read
 * collision. The stall mechanism allows software to execute code from the same block on
 * which flash operations are being performed. However, software must ensure the
 * sector the flash operations are being performed on is not the same sector
 * from which the code is executing. ESFC enables the stall mechanism. This bit must
 * be set only just before the flash operation is executed and must be cleared
 * when the operation completes.
 *
 * Values:
 * - 0b0 - Disable stalling flash controller when flash is busy.
 * - 0b1 - Enable stalling flash controller when flash is busy.
 */
/*@{*/
/*! @brief Read current value of the MCM_PLACR_ESFC field. */
#define MCM_RD_PLACR_ESFC(base) ((MCM_PLACR_REG(base) & MCM_PLACR_ESFC_MASK) >> MCM_PLACR_ESFC_SHIFT)
#define MCM_BRD_PLACR_ESFC(base) (MCM_RD_PLACR_ESFC(base))

/*! @brief Set the ESFC field to a new value. */
#define MCM_WR_PLACR_ESFC(base, value) (MCM_RMW_PLACR(base, MCM_PLACR_ESFC_MASK, MCM_PLACR_ESFC(value)))
#define MCM_BWR_PLACR_ESFC(base, value) (MCM_WR_PLACR_ESFC(base, value))
/*@}*/

/*******************************************************************************
 * MCM_PID - Process ID register
 ******************************************************************************/

/*!
 * @brief MCM_PID - Process ID register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register drives the M0_PID value in the Memory Protection Unit (MPU).
 * System software loads this register before passing control to a given user mode
 * process. If the PID of the process does not match the value in this register,
 * a bus error occurs. See the MPU chapter for more details.
 */
/*!
 * @name Constants and macros for entire MCM_PID register
 */
/*@{*/
#define MCM_RD_PID(base)         (MCM_PID_REG(base))
#define MCM_WR_PID(base, value)  (MCM_PID_REG(base) = (value))
#define MCM_RMW_PID(base, mask, value) (MCM_WR_PID(base, (MCM_RD_PID(base) & ~(mask)) | (value)))
#define MCM_SET_PID(base, value) (MCM_WR_PID(base, MCM_RD_PID(base) |  (value)))
#define MCM_CLR_PID(base, value) (MCM_WR_PID(base, MCM_RD_PID(base) & ~(value)))
#define MCM_TOG_PID(base, value) (MCM_WR_PID(base, MCM_RD_PID(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual MCM_PID bitfields
 */

/*!
 * @name Register MCM_PID, field PID[7:0] (RW)
 *
 * Drives the M0_PID value in the MPU.
 *
 * Values:
 * - 0b00000000 - Reserved for privileged secure tasks
 */
/*@{*/
/*! @brief Read current value of the MCM_PID_PID field. */
#define MCM_RD_PID_PID(base) ((MCM_PID_REG(base) & MCM_PID_PID_MASK) >> MCM_PID_PID_SHIFT)
#define MCM_BRD_PID_PID(base) (MCM_RD_PID_PID(base))

/*! @brief Set the PID field to a new value. */
#define MCM_WR_PID_PID(base, value) (MCM_RMW_PID(base, MCM_PID_PID_MASK, MCM_PID_PID(value)))
#define MCM_BWR_PID_PID(base, value) (MCM_WR_PID_PID(base, value))
/*@}*/

/*******************************************************************************
 * MCM_CPO - Compute Operation Control Register
 ******************************************************************************/

/*!
 * @brief MCM_CPO - Compute Operation Control Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register controls the Compute Operation.
 */
/*!
 * @name Constants and macros for entire MCM_CPO register
 */
/*@{*/
#define MCM_RD_CPO(base)         (MCM_CPO_REG(base))
#define MCM_WR_CPO(base, value)  (MCM_CPO_REG(base) = (value))
#define MCM_RMW_CPO(base, mask, value) (MCM_WR_CPO(base, (MCM_RD_CPO(base) & ~(mask)) | (value)))
#define MCM_SET_CPO(base, value) (MCM_WR_CPO(base, MCM_RD_CPO(base) |  (value)))
#define MCM_CLR_CPO(base, value) (MCM_WR_CPO(base, MCM_RD_CPO(base) & ~(value)))
#define MCM_TOG_CPO(base, value) (MCM_WR_CPO(base, MCM_RD_CPO(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual MCM_CPO bitfields
 */

/*!
 * @name Register MCM_CPO, field CPOREQ[0] (RW)
 *
 * This bit is auto-cleared by vector fetching if CPOWOI = 1.
 *
 * Values:
 * - 0b0 - Request is cleared.
 * - 0b1 - Request Compute Operation.
 */
/*@{*/
/*! @brief Read current value of the MCM_CPO_CPOREQ field. */
#define MCM_RD_CPO_CPOREQ(base) ((MCM_CPO_REG(base) & MCM_CPO_CPOREQ_MASK) >> MCM_CPO_CPOREQ_SHIFT)
#define MCM_BRD_CPO_CPOREQ(base) (MCM_RD_CPO_CPOREQ(base))

/*! @brief Set the CPOREQ field to a new value. */
#define MCM_WR_CPO_CPOREQ(base, value) (MCM_RMW_CPO(base, MCM_CPO_CPOREQ_MASK, MCM_CPO_CPOREQ(value)))
#define MCM_BWR_CPO_CPOREQ(base, value) (MCM_WR_CPO_CPOREQ(base, value))
/*@}*/

/*!
 * @name Register MCM_CPO, field CPOACK[1] (RO)
 *
 * Values:
 * - 0b0 - Compute operation entry has not completed or compute operation exit
 *     has completed.
 * - 0b1 - Compute operation entry has completed or compute operation exit has
 *     not completed.
 */
/*@{*/
/*! @brief Read current value of the MCM_CPO_CPOACK field. */
#define MCM_RD_CPO_CPOACK(base) ((MCM_CPO_REG(base) & MCM_CPO_CPOACK_MASK) >> MCM_CPO_CPOACK_SHIFT)
#define MCM_BRD_CPO_CPOACK(base) (MCM_RD_CPO_CPOACK(base))
/*@}*/

/*!
 * @name Register MCM_CPO, field CPOWOI[2] (RW)
 *
 * Values:
 * - 0b0 - No effect.
 * - 0b1 - When set, the CPOREQ is cleared on any interrupt or exception vector
 *     fetch.
 */
/*@{*/
/*! @brief Read current value of the MCM_CPO_CPOWOI field. */
#define MCM_RD_CPO_CPOWOI(base) ((MCM_CPO_REG(base) & MCM_CPO_CPOWOI_MASK) >> MCM_CPO_CPOWOI_SHIFT)
#define MCM_BRD_CPO_CPOWOI(base) (MCM_RD_CPO_CPOWOI(base))

/*! @brief Set the CPOWOI field to a new value. */
#define MCM_WR_CPO_CPOWOI(base, value) (MCM_RMW_CPO(base, MCM_CPO_CPOWOI_MASK, MCM_CPO_CPOWOI(value)))
#define MCM_BWR_CPO_CPOWOI(base, value) (MCM_WR_CPO_CPOWOI(base, value))
/*@}*/

/*******************************************************************************
 * MCM_MATCR - Master Attribute Configuration Register
 ******************************************************************************/

/*!
 * @brief MCM_MATCR - Master Attribute Configuration Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This 32-bit register consists of four 8-bit attribute configuration register
 * fields for each system bus master. Each MATCRn register field allows the
 * corresponding bus master's secure/nonsecure and privileged/user attributes to be
 * forced to a static state, or simply enable the attributes generated by the
 * master module. This information is then used on a per bus transaction basis to
 * control access. See the MPU chapter for more details. For all ATCn values, if the
 * state indicates privileged (either statically or via the master module's
 * attribute), then the other state indicator is forced to secure. Writes to ATC0
 * configure the processor's master attributes, and software must take special care
 * with this value. Typically, the processor would use an ATC0 value of {0b11- or
 * 0b00-} because the other values can create a configuration where access to
 * system level resources is not allowed. Each MATCRn register field also contains a
 * lock bit (RO) that may be set to disable writes to the register, preserving
 * the configured state until the next system reset.
 */
/*!
 * @name Constants and macros for entire MCM_MATCR register
 */
/*@{*/
#define MCM_RD_MATCR(base, index) (MCM_MATCR_REG(base, index))
#define MCM_WR_MATCR(base, index, value) (MCM_MATCR_REG(base, index) = (value))
#define MCM_RMW_MATCR(base, index, mask, value) (MCM_WR_MATCR(base, index, (MCM_RD_MATCR(base, index) & ~(mask)) | (value)))
#define MCM_SET_MATCR(base, index, value) (MCM_WR_MATCR(base, index, MCM_RD_MATCR(base, index) |  (value)))
#define MCM_CLR_MATCR(base, index, value) (MCM_WR_MATCR(base, index, MCM_RD_MATCR(base, index) & ~(value)))
#define MCM_TOG_MATCR(base, index, value) (MCM_WR_MATCR(base, index, MCM_RD_MATCR(base, index) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual MCM_MATCR bitfields
 */

/*!
 * @name Register MCM_MATCR, field ATC0[2:0] (RW)
 *
 * This 3-bit field defines the privileged/user and secure/nonsecure attribute
 * configurations.
 *
 * Values:
 * - 0b00x - Master attributes are statically forced to {privileged, secure}.
 * - 0b010 - Master attributes are statically forced to {user, secure}.
 * - 0b011 - Master attributes are statically forced to {user, nonsecure}.
 * - 0b100 - Enable master attribute {privileged or user} and statically force
 *     {secure}.
 * - 0b101 - Enable master attribute {privileged or user} and statically force
 *     {nonsecure}.
 * - 0b11x - Enable master attribute {privileged or user, secure or nonsecure}
 */
/*@{*/
/*! @brief Read current value of the MCM_MATCR_ATC0 field. */
#define MCM_RD_MATCR_ATC0(base, index) ((MCM_MATCR_REG(base, index) & MCM_MATCR_ATC0_MASK) >> MCM_MATCR_ATC0_SHIFT)
#define MCM_BRD_MATCR_ATC0(base, index) (MCM_RD_MATCR_ATC0(base, index))

/*! @brief Set the ATC0 field to a new value. */
#define MCM_WR_MATCR_ATC0(base, index, value) (MCM_RMW_MATCR(base, index, MCM_MATCR_ATC0_MASK, MCM_MATCR_ATC0(value)))
#define MCM_BWR_MATCR_ATC0(base, index, value) (MCM_WR_MATCR_ATC0(base, index, value))
/*@}*/

/*!
 * @name Register MCM_MATCR, field RO0[7] (RW)
 *
 * This register bit provides a mechanism to lock the configuration state
 * defined by ATCn. Once asserted, this bit remains set and attempted writes to the
 * ATCn register are ignored until the next system reset clears the flag.
 *
 * Values:
 * - 0b0 - Writes to the ATCn are allowed.
 * - 0b1 - Writes to the ATCn are ignored.
 */
/*@{*/
/*! @brief Read current value of the MCM_MATCR_RO0 field. */
#define MCM_RD_MATCR_RO0(base, index) ((MCM_MATCR_REG(base, index) & MCM_MATCR_RO0_MASK) >> MCM_MATCR_RO0_SHIFT)
#define MCM_BRD_MATCR_RO0(base, index) (MCM_RD_MATCR_RO0(base, index))

/*! @brief Set the RO0 field to a new value. */
#define MCM_WR_MATCR_RO0(base, index, value) (MCM_RMW_MATCR(base, index, MCM_MATCR_RO0_MASK, MCM_MATCR_RO0(value)))
#define MCM_BWR_MATCR_RO0(base, index, value) (MCM_WR_MATCR_RO0(base, index, value))
/*@}*/

/*!
 * @name Register MCM_MATCR, field ATC2[18:16] (RW)
 *
 * This 3-bit field defines the privileged/user and secure/nonsecure attribute
 * configurations.
 *
 * Values:
 * - 0b00x - Master attributes are statically forced to {privileged, secure}.
 * - 0b010 - Master attributes are statically forced to {user, secure}.
 * - 0b011 - Master attributes are statically forced to {user, nonsecure}.
 * - 0b100 - Enable master attribute {privileged or user} and statically force
 *     {secure}.
 * - 0b101 - Enable master attribute {privileged or user} and statically force
 *     {nonsecure}.
 * - 0b11x - Enable master attribute {privileged or user, secure or nonsecure}
 */
/*@{*/
/*! @brief Read current value of the MCM_MATCR_ATC2 field. */
#define MCM_RD_MATCR_ATC2(base, index) ((MCM_MATCR_REG(base, index) & MCM_MATCR_ATC2_MASK) >> MCM_MATCR_ATC2_SHIFT)
#define MCM_BRD_MATCR_ATC2(base, index) (MCM_RD_MATCR_ATC2(base, index))

/*! @brief Set the ATC2 field to a new value. */
#define MCM_WR_MATCR_ATC2(base, index, value) (MCM_RMW_MATCR(base, index, MCM_MATCR_ATC2_MASK, MCM_MATCR_ATC2(value)))
#define MCM_BWR_MATCR_ATC2(base, index, value) (MCM_WR_MATCR_ATC2(base, index, value))
/*@}*/

/*!
 * @name Register MCM_MATCR, field RO2[23] (RW)
 *
 * This register bit provides a mechanism to lock the configuration state
 * defined by ATCn. Once asserted, this bit remains set and attempted writes to the
 * ATCn are ignored until the next system reset clears the flag.
 *
 * Values:
 * - 0b0 - Writes to the ATCn are allowed.
 * - 0b1 - Writes to the ATCn are ignored.
 */
/*@{*/
/*! @brief Read current value of the MCM_MATCR_RO2 field. */
#define MCM_RD_MATCR_RO2(base, index) ((MCM_MATCR_REG(base, index) & MCM_MATCR_RO2_MASK) >> MCM_MATCR_RO2_SHIFT)
#define MCM_BRD_MATCR_RO2(base, index) (MCM_RD_MATCR_RO2(base, index))

/*! @brief Set the RO2 field to a new value. */
#define MCM_WR_MATCR_RO2(base, index, value) (MCM_RMW_MATCR(base, index, MCM_MATCR_RO2_MASK, MCM_MATCR_RO2(value)))
#define MCM_BWR_MATCR_RO2(base, index, value) (MCM_WR_MATCR_RO2(base, index, value))
/*@}*/

/*
 * MKM34Z7 MMAU
 *
 * Memory-Mapped Arithmetic Unit
 *
 * Registers defined in this header file:
 * - MMAU_X0 - Operand Register X0
 * - MMAU_X1 - Operand Register X1
 * - MMAU_X2 - Operand Register X2
 * - MMAU_X3 - Operand Register X3
 * - MMAU_A0 - Accumulator Register A0
 * - MMAU_A1 - Accumulator Register A1
 * - MMAU_CSR - Control/Status Register
 */

#define MMAU_INSTANCE_COUNT (1U) /*!< Number of instances of the MMAU module. */
#define MMAU_IDX (0U) /*!< Instance number for MMAU. */

/*******************************************************************************
 * MMAU_X0 - Operand Register X0
 ******************************************************************************/

/*!
 * @brief MMAU_X0 - Operand Register X0 (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register is loaded with the input X0 operand before a calculation
 * operation is initiated. This register can be accessed (read/write) even when MMAU is
 * busy with the current instruction execution. This is to allow pipeline in
 * setting up next calculation operand. When access to this register, the MMAU
 * address[4:0] need to be 0x00 and the MMAU decoration code bits (address bit[11:5])
 * are ignored.
 */
/*!
 * @name Constants and macros for entire MMAU_X0 register
 */
/*@{*/
#define MMAU_RD_X0(base)         (MMAU_X0_REG(base))
#define MMAU_WR_X0(base, value)  (MMAU_X0_REG(base) = (value))
#define MMAU_RMW_X0(base, mask, value) (MMAU_WR_X0(base, (MMAU_RD_X0(base) & ~(mask)) | (value)))
#define MMAU_SET_X0(base, value) (MMAU_WR_X0(base, MMAU_RD_X0(base) |  (value)))
#define MMAU_CLR_X0(base, value) (MMAU_WR_X0(base, MMAU_RD_X0(base) & ~(value)))
#define MMAU_TOG_X0(base, value) (MMAU_WR_X0(base, MMAU_RD_X0(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * MMAU_X1 - Operand Register X1
 ******************************************************************************/

/*!
 * @brief MMAU_X1 - Operand Register X1 (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register is loaded with the input X1 operand before a calculation
 * operation is initiated. This register can be accessed (read/write) even when MMAU is
 * busy with the current instruction execution. This is to allow pipeline in
 * setting up next calculation operand. When access to this register, the MMAU
 * address[4:0] need to be 0x04 and the MMAU decoration code bits(address bit[11:5])
 * are ignored.
 */
/*!
 * @name Constants and macros for entire MMAU_X1 register
 */
/*@{*/
#define MMAU_RD_X1(base)         (MMAU_X1_REG(base))
#define MMAU_WR_X1(base, value)  (MMAU_X1_REG(base) = (value))
#define MMAU_RMW_X1(base, mask, value) (MMAU_WR_X1(base, (MMAU_RD_X1(base) & ~(mask)) | (value)))
#define MMAU_SET_X1(base, value) (MMAU_WR_X1(base, MMAU_RD_X1(base) |  (value)))
#define MMAU_CLR_X1(base, value) (MMAU_WR_X1(base, MMAU_RD_X1(base) & ~(value)))
#define MMAU_TOG_X1(base, value) (MMAU_WR_X1(base, MMAU_RD_X1(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * MMAU_X2 - Operand Register X2
 ******************************************************************************/

/*!
 * @brief MMAU_X2 - Operand Register X2 (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register is loaded with the input X2 operand before a calculation
 * operation is initiated. This register can be accessed (read/write) even when MMAU is
 * busy with the current instruction execution. This is to allow pipeline in
 * setting up next calculation operand. When access to this register, the MMAU
 * address[4:0] need to be 0x08 and the MMAU decoration code bits (address bit[11:5])
 * are ignored.
 */
/*!
 * @name Constants and macros for entire MMAU_X2 register
 */
/*@{*/
#define MMAU_RD_X2(base)         (MMAU_X2_REG(base))
#define MMAU_WR_X2(base, value)  (MMAU_X2_REG(base) = (value))
#define MMAU_RMW_X2(base, mask, value) (MMAU_WR_X2(base, (MMAU_RD_X2(base) & ~(mask)) | (value)))
#define MMAU_SET_X2(base, value) (MMAU_WR_X2(base, MMAU_RD_X2(base) |  (value)))
#define MMAU_CLR_X2(base, value) (MMAU_WR_X2(base, MMAU_RD_X2(base) & ~(value)))
#define MMAU_TOG_X2(base, value) (MMAU_WR_X2(base, MMAU_RD_X2(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * MMAU_X3 - Operand Register X3
 ******************************************************************************/

/*!
 * @brief MMAU_X3 - Operand Register X3 (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register is loaded with the input X3 operand together with the
 * instruction to be activated. When write access to X3, the MMAU Address[11:5] defines
 * the decoration code, which is instruction type and the saturation configuration,
 * and address[4:0] need to be 0x0C. Writing to Operand Register X3 will start
 * the execution of the operation defined by the decoration code immediately. For
 * multiply, the calculation completes in single clock cycle, and for divide and
 * square root, the MMAU will be busy until the calculation completes. Any memory
 * write access of the X3 register while the module is busy causes the access to
 * be stalled (using wait states) until the calculation completes. Read access
 * of this register returns the value immediately.
 */
/*!
 * @name Constants and macros for entire MMAU_X3 register
 */
/*@{*/
#define MMAU_RD_X3(base)         (MMAU_X3_REG(base))
#define MMAU_WR_X3(base, value)  (MMAU_X3_REG(base) = (value))
#define MMAU_RMW_X3(base, mask, value) (MMAU_WR_X3(base, (MMAU_RD_X3(base) & ~(mask)) | (value)))
#define MMAU_SET_X3(base, value) (MMAU_WR_X3(base, MMAU_RD_X3(base) |  (value)))
#define MMAU_CLR_X3(base, value) (MMAU_WR_X3(base, MMAU_RD_X3(base) & ~(value)))
#define MMAU_TOG_X3(base, value) (MMAU_WR_X3(base, MMAU_RD_X3(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * MMAU_A0 - Accumulator Register A0
 ******************************************************************************/

/*!
 * @brief MMAU_A0 - Accumulator Register A0 (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register is loaded with the lower 32-bit result of a calculation
 * operation from divide, square root or multiply, or multiply with accumulation. It
 * also serve as the lower 32-bit of the 64-bit operand for certain type of
 * instruction. Any access (read or write) of this register while the module is busy
 * during a calculation causes the access to be stalled (using wait states) until the
 * calculation completes. Together with A1, it provides a 64-bit result or
 * operand. When access to this register, the MMAU address[4:0] need to be 0x10 and
 * the MMAU decoration code bits (address bit[11:5]) are ignored if they are not
 * matching QSQRDA. For unsigned square root calculation on A10 where there is no
 * need input operands from X0-3, reading to A0 with decoration code Address[11:5]
 * to be USQRDA will launching the calculation immediately and the read will be
 * pending until the computation completes with the result returned.
 */
/*!
 * @name Constants and macros for entire MMAU_A0 register
 */
/*@{*/
#define MMAU_RD_A0(base)         (MMAU_A0_REG(base))
#define MMAU_WR_A0(base, value)  (MMAU_A0_REG(base) = (value))
#define MMAU_RMW_A0(base, mask, value) (MMAU_WR_A0(base, (MMAU_RD_A0(base) & ~(mask)) | (value)))
#define MMAU_SET_A0(base, value) (MMAU_WR_A0(base, MMAU_RD_A0(base) |  (value)))
#define MMAU_CLR_A0(base, value) (MMAU_WR_A0(base, MMAU_RD_A0(base) & ~(value)))
#define MMAU_TOG_A0(base, value) (MMAU_WR_A0(base, MMAU_RD_A0(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * MMAU_A1 - Accumulator Register A1
 ******************************************************************************/

/*!
 * @brief MMAU_A1 - Accumulator Register A1 (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register is loaded with the higher 32-bit result of a calculation
 * operation from divide, square root or multiply, or multiply with accumulation. It
 * also serve as the higher 32-bit of the 64-bit operand for certain type of
 * instruction. Any access (read or write) of this register while the module is busy
 * during a calculation causes the access to be stalled (using wait states) until
 * the calculation completes. Together with A0, it provides a 64-bit result or
 * operand in the operation involved 64-bit. When access to this register, the MMAU
 * address[4:0] need to be 0x14 and the MMAU decoration code bits (address
 * bit[11:5]) are ignored if they are not matching to QSQRDA. For fractional numeric
 * square root calculation on A10 where there is no need input operands from X0-3,
 * reading to A1 with decoration code Address[11:5] to be QSQRDA will launching
 * the calculation immediately and the read will be pending until the computation
 * completes with the result returned.
 */
/*!
 * @name Constants and macros for entire MMAU_A1 register
 */
/*@{*/
#define MMAU_RD_A1(base)         (MMAU_A1_REG(base))
#define MMAU_WR_A1(base, value)  (MMAU_A1_REG(base) = (value))
#define MMAU_RMW_A1(base, mask, value) (MMAU_WR_A1(base, (MMAU_RD_A1(base) & ~(mask)) | (value)))
#define MMAU_SET_A1(base, value) (MMAU_WR_A1(base, MMAU_RD_A1(base) |  (value)))
#define MMAU_CLR_A1(base, value) (MMAU_WR_A1(base, MMAU_RD_A1(base) & ~(value)))
#define MMAU_TOG_A1(base, value) (MMAU_WR_A1(base, MMAU_RD_A1(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * MMAU_CSR - Control/Status Register
 ******************************************************************************/

/*!
 * @brief MMAU_CSR - Control/Status Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register defines the operating configuration and the computation result
 * status of MMAU. It includes the busy status indicators, computation result
 * status on overflow for multiply, divide and accumulation, error status flag for
 * divide by zero. It has the Interrupt Flag bits of the overflow, divide by zero
 * bits too. It also include supervisor lock bit, the MMAU can only be access in
 * Supervisor mode when set. It has DMA enable, interrupt enable control bits
 * too. A memory write access of the CSR register while the MMAU is busy during a
 * calculation causes the access to be stalled (using wait states) until the
 * calculation completes, read to CSR return the register value immediately even when
 * MMAU is in busy. When access to this register, the MMAU address[4:0] need to be
 * 0x8C and the MMAU decoration code bits (address bit[11:5]) are ignored. The
 * Interrupt Flag bits are read-only from the address offset of 0x18, MMAU
 * provides another register entry (CSR_IF_CLR) of address[4:0]=0x1C for clearing CSR
 * status and the Interrupt flag bits, where the interrupt flag bits can be cleared
 * by W1C (write one to clear).
 */
/*!
 * @name Constants and macros for entire MMAU_CSR register
 */
/*@{*/
#define MMAU_RD_CSR(base)        (MMAU_CSR_REG(base))
#define MMAU_WR_CSR(base, value) (MMAU_CSR_REG(base) = (value))
#define MMAU_RMW_CSR(base, mask, value) (MMAU_WR_CSR(base, (MMAU_RD_CSR(base) & ~(mask)) | (value)))
#define MMAU_SET_CSR(base, value) (MMAU_WR_CSR(base, MMAU_RD_CSR(base) |  (value)))
#define MMAU_CLR_CSR(base, value) (MMAU_WR_CSR(base, MMAU_RD_CSR(base) & ~(value)))
#define MMAU_TOG_CSR(base, value) (MMAU_WR_CSR(base, MMAU_RD_CSR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual MMAU_CSR bitfields
 */

/*!
 * @name Register MMAU_CSR, field Q[0] (RW)
 *
 * For computation of multiply with accumulation, this bit is set when the
 * accumulation computation results overflow. It is updated on each calculation. It
 * can be set/cleared by user software code too.
 *
 * Values:
 * - 0b0 - No accumulation operation or accumulation operation does not overflow
 * - 0b1 - Accumulation overflows during a MAC instruction
 */
/*@{*/
/*! @brief Read current value of the MMAU_CSR_Q field. */
#define MMAU_RD_CSR_Q(base)  ((MMAU_CSR_REG(base) & MMAU_CSR_Q_MASK) >> MMAU_CSR_Q_SHIFT)
#define MMAU_BRD_CSR_Q(base) (MMAU_RD_CSR_Q(base))

/*! @brief Set the Q field to a new value. */
#define MMAU_WR_CSR_Q(base, value) (MMAU_RMW_CSR(base, MMAU_CSR_Q_MASK, MMAU_CSR_Q(value)))
#define MMAU_BWR_CSR_Q(base, value) (MMAU_WR_CSR_Q(base, value))
/*@}*/

/*!
 * @name Register MMAU_CSR, field V[1] (RW)
 *
 * For divide or multiply operation, if the divide quotient or multiply product
 * computation overflows, this V flag bit will be set. It is updated on each
 * calculation. It can be set/cleared by user software code too.
 *
 * Values:
 * - 0b0 - Calculation is not include divider or multiply, or the
 *     product/quotient does not overflow
 * - 0b1 - Product in multiply or multiply with accumulation, or quotient of a
 *     divide overflows
 */
/*@{*/
/*! @brief Read current value of the MMAU_CSR_V field. */
#define MMAU_RD_CSR_V(base)  ((MMAU_CSR_REG(base) & MMAU_CSR_V_MASK) >> MMAU_CSR_V_SHIFT)
#define MMAU_BRD_CSR_V(base) (MMAU_RD_CSR_V(base))

/*! @brief Set the V field to a new value. */
#define MMAU_WR_CSR_V(base, value) (MMAU_RMW_CSR(base, MMAU_CSR_V_MASK, MMAU_CSR_V(value)))
#define MMAU_BWR_CSR_V(base, value) (MMAU_WR_CSR_V(base, value))
/*@}*/

/*!
 * @name Register MMAU_CSR, field DZ[2] (RW)
 *
 * This DZ flag indicates that the divisor is zero for a divide operation when
 * set. It is updated on each calculation. It can be set/cleared by user software
 * code too.
 *
 * Values:
 * - 0b0 - For divide, the divisor is not zero, or the calculation is not divide
 * - 0b1 - For divide, the divisor is zero, which is a divide-by-zero error
 */
/*@{*/
/*! @brief Read current value of the MMAU_CSR_DZ field. */
#define MMAU_RD_CSR_DZ(base) ((MMAU_CSR_REG(base) & MMAU_CSR_DZ_MASK) >> MMAU_CSR_DZ_SHIFT)
#define MMAU_BRD_CSR_DZ(base) (MMAU_RD_CSR_DZ(base))

/*! @brief Set the DZ field to a new value. */
#define MMAU_WR_CSR_DZ(base, value) (MMAU_RMW_CSR(base, MMAU_CSR_DZ_MASK, MMAU_CSR_DZ(value)))
#define MMAU_BWR_CSR_DZ(base, value) (MMAU_WR_CSR_DZ(base, value))
/*@}*/

/*!
 * @name Register MMAU_CSR, field N[3] (RW)
 *
 * For signed arithmetic calculation, if the raw computation result is negative
 * (before overflows or saturation), this N flag bit will be set. It is updated
 * on each calculation. It can be set/cleared by software code too.
 *
 * Values:
 * - 0b0 - Calculation raw result is zero or positive, or unsigned number
 * - 0b1 - Calculation raw result is negative
 */
/*@{*/
/*! @brief Read current value of the MMAU_CSR_N field. */
#define MMAU_RD_CSR_N(base)  ((MMAU_CSR_REG(base) & MMAU_CSR_N_MASK) >> MMAU_CSR_N_SHIFT)
#define MMAU_BRD_CSR_N(base) (MMAU_RD_CSR_N(base))

/*! @brief Set the N field to a new value. */
#define MMAU_WR_CSR_N(base, value) (MMAU_RMW_CSR(base, MMAU_CSR_N_MASK, MMAU_CSR_N(value)))
#define MMAU_BWR_CSR_N(base, value) (MMAU_WR_CSR_N(base, value))
/*@}*/

/*!
 * @name Register MMAU_CSR, field QIF[4] (RO)
 *
 * The QIF is the Accumulation Overflow Interrupt Flag bit, and it is the sticky
 * version of CSR[Q]. It can only be set by MMAU execution of instruction. Once
 * it is set, it can only be cleared by user software through writing "1" to this
 * bit from register entry of CSR_IF_CLR at address offset 0x1C. When this bit
 * is set, and if the accumulation interrupt is enable by setting CSR[QIE], MMAU
 * will issue interrupt to CPU.
 *
 * Values:
 * - 0b0 - No accumulation operation or accumulation operation does not overflow
 * - 0b1 - Accumulation overflows during a MAC instruction
 */
/*@{*/
/*! @brief Read current value of the MMAU_CSR_QIF field. */
#define MMAU_RD_CSR_QIF(base) ((MMAU_CSR_REG(base) & MMAU_CSR_QIF_MASK) >> MMAU_CSR_QIF_SHIFT)
#define MMAU_BRD_CSR_QIF(base) (MMAU_RD_CSR_QIF(base))
/*@}*/

/*!
 * @name Register MMAU_CSR, field VIF[5] (RO)
 *
 * The VIF is the Multiply or Divide Overflow Interrupt Flag bit, and it is the
 * sticky version of CSR[V]. It can only be set by MMAU execution of instruction.
 * Once it is set, it can only be cleared by user software code through writing
 * "1" to this bit from register entry of CSR_IF_CLR at address offset 0x1C. When
 * this bit is set, and if the Multiply or Divide Overflow Interrupt is enable
 * by setting CSR[VIE], MMAU will issue interrupt to CPU.
 *
 * Values:
 * - 0b0 - Calculation is not include divider or multiply, or the
 *     product/quotient does not overflow
 * - 0b1 - Product in multiply or multiply with accumulation, or quotient of a
 *     divide overflows
 */
/*@{*/
/*! @brief Read current value of the MMAU_CSR_VIF field. */
#define MMAU_RD_CSR_VIF(base) ((MMAU_CSR_REG(base) & MMAU_CSR_VIF_MASK) >> MMAU_CSR_VIF_SHIFT)
#define MMAU_BRD_CSR_VIF(base) (MMAU_RD_CSR_VIF(base))
/*@}*/

/*!
 * @name Register MMAU_CSR, field DZIF[6] (RO)
 *
 * The DZIF is the Divide by Zero Interrupt Flag bit, and it is the sticky
 * version of CSR[DZ]. It can only be set by MMAU execution of instruction. Once it is
 * set, it can only be cleared by user software code through writing "1" to this
 * bit from register entry of CSR_IF_CLR at address offset 0x1C. When this bit
 * is set, and if the Divide by Zero Interrupt is enable by setting CSR[DZIE],
 * MMAU will issue interrupt to CPU.
 *
 * Values:
 * - 0b0 - For divide, the divisor is not zero, or the calculation is not divide
 * - 0b1 - For divide, the divisor is zero, which is a divide-by-zero error
 */
/*@{*/
/*! @brief Read current value of the MMAU_CSR_DZIF field. */
#define MMAU_RD_CSR_DZIF(base) ((MMAU_CSR_REG(base) & MMAU_CSR_DZIF_MASK) >> MMAU_CSR_DZIF_SHIFT)
#define MMAU_BRD_CSR_DZIF(base) (MMAU_RD_CSR_DZIF(base))
/*@}*/

/*!
 * @name Register MMAU_CSR, field QIE[12] (RW)
 *
 * This control bit is used to enable/disable QIF flag interrupt.
 *
 * Values:
 * - 0b0 - Q flag (CSR[QIF]) set will not generate interrupt.
 * - 0b1 - Q flag (CSR[QIF]) set will generate interrupt to inform an
 *     accumulation overflow
 */
/*@{*/
/*! @brief Read current value of the MMAU_CSR_QIE field. */
#define MMAU_RD_CSR_QIE(base) ((MMAU_CSR_REG(base) & MMAU_CSR_QIE_MASK) >> MMAU_CSR_QIE_SHIFT)
#define MMAU_BRD_CSR_QIE(base) (MMAU_RD_CSR_QIE(base))

/*! @brief Set the QIE field to a new value. */
#define MMAU_WR_CSR_QIE(base, value) (MMAU_RMW_CSR(base, MMAU_CSR_QIE_MASK, MMAU_CSR_QIE(value)))
#define MMAU_BWR_CSR_QIE(base, value) (MMAU_WR_CSR_QIE(base, value))
/*@}*/

/*!
 * @name Register MMAU_CSR, field VIE[13] (RW)
 *
 * This control bit is used to enable/disable VIF flag interrupt.
 *
 * Values:
 * - 0b0 - V flag (CSR[VIF]) set will not generate interrupt.
 * - 0b1 - V flag (CSR[VIF]) set will generate interrupt to inform a divide or
 *     multiply overflow
 */
/*@{*/
/*! @brief Read current value of the MMAU_CSR_VIE field. */
#define MMAU_RD_CSR_VIE(base) ((MMAU_CSR_REG(base) & MMAU_CSR_VIE_MASK) >> MMAU_CSR_VIE_SHIFT)
#define MMAU_BRD_CSR_VIE(base) (MMAU_RD_CSR_VIE(base))

/*! @brief Set the VIE field to a new value. */
#define MMAU_WR_CSR_VIE(base, value) (MMAU_RMW_CSR(base, MMAU_CSR_VIE_MASK, MMAU_CSR_VIE(value)))
#define MMAU_BWR_CSR_VIE(base, value) (MMAU_WR_CSR_VIE(base, value))
/*@}*/

/*!
 * @name Register MMAU_CSR, field DZIE[14] (RW)
 *
 * This indicator configures the MMAU's interrupt when a divide-by-zero
 * calculations is detected. If both CSR[DZIF] and CSR[DZE] are set, MMAU will generate
 * an interrupt to CPU.
 *
 * Values:
 * - 0b0 - MMAU will not generate interrupt even CSR[DZIF]=1
 * - 0b1 - If CSR[DZIF] = 1, MMAU will generate an interrupt to signal a
 *     divide-by-zero.
 */
/*@{*/
/*! @brief Read current value of the MMAU_CSR_DZIE field. */
#define MMAU_RD_CSR_DZIE(base) ((MMAU_CSR_REG(base) & MMAU_CSR_DZIE_MASK) >> MMAU_CSR_DZIE_SHIFT)
#define MMAU_BRD_CSR_DZIE(base) (MMAU_RD_CSR_DZIE(base))

/*! @brief Set the DZIE field to a new value. */
#define MMAU_WR_CSR_DZIE(base, value) (MMAU_RMW_CSR(base, MMAU_CSR_DZIE_MASK, MMAU_CSR_DZIE(value)))
#define MMAU_BWR_CSR_DZIE(base, value) (MMAU_WR_CSR_DZIE(base, value))
/*@}*/

/*!
 * @name Register MMAU_CSR, field DRE[16] (RW)
 *
 * MMAU provide interface for DMA to configure the MMAU and launch the
 * calculation. When MMAU completes the execution of instruction, it will be in IDLE state
 * (not busy). It can be configured optional to generate the DMA request so that
 * user can use DMA to fetch the result and program the new computation
 * instruction.
 *
 * Values:
 * - 0b0 - MMAU will not generate DMA request when in IDLE (not busy) state
 * - 0b1 - MMAU will generate DMA request when in IDLE (not busy) state
 */
/*@{*/
/*! @brief Read current value of the MMAU_CSR_DRE field. */
#define MMAU_RD_CSR_DRE(base) ((MMAU_CSR_REG(base) & MMAU_CSR_DRE_MASK) >> MMAU_CSR_DRE_SHIFT)
#define MMAU_BRD_CSR_DRE(base) (MMAU_RD_CSR_DRE(base))

/*! @brief Set the DRE field to a new value. */
#define MMAU_WR_CSR_DRE(base, value) (MMAU_RMW_CSR(base, MMAU_CSR_DRE_MASK, MMAU_CSR_DRE(value)))
#define MMAU_BWR_CSR_DRE(base, value) (MMAU_WR_CSR_DRE(base, value))
/*@}*/

/*!
 * @name Register MMAU_CSR, field SO[17] (RW)
 *
 * This is the Supervisor Only bit. When this bit is set, CPU/DMA can only
 * access MMAU in supervisor mode; when it is access through user mode, MMAU will
 * terminate the access with an bus error. This bit can only be changed by CPU in
 * supervisor mode, write access in User Mode will be ignored by MMAU.
 *
 * Values:
 * - 0b0 - MMAU registers can be access in both User Mode or Supervisor Mode
 * - 0b1 - MMAU registers can only be access in Supervisor Mode
 */
/*@{*/
/*! @brief Read current value of the MMAU_CSR_SO field. */
#define MMAU_RD_CSR_SO(base) ((MMAU_CSR_REG(base) & MMAU_CSR_SO_MASK) >> MMAU_CSR_SO_SHIFT)
#define MMAU_BRD_CSR_SO(base) (MMAU_RD_CSR_SO(base))

/*! @brief Set the SO field to a new value. */
#define MMAU_WR_CSR_SO(base, value) (MMAU_RMW_CSR(base, MMAU_CSR_SO_MASK, MMAU_CSR_SO(value)))
#define MMAU_BWR_CSR_SO(base, value) (MMAU_WR_CSR_SO(base, value))
/*@}*/

/*!
 * @name Register MMAU_CSR, field HDR[23:20] (RO)
 *
 * This HDR field is read-only and tells the Hardware Revision Level of MMAU, it
 * will changes with different version of MMAU.
 *
 * Values:
 * - 0b0000 - Current Hardware Revision Level is 0000
 */
/*@{*/
/*! @brief Read current value of the MMAU_CSR_HDR field. */
#define MMAU_RD_CSR_HDR(base) ((MMAU_CSR_REG(base) & MMAU_CSR_HDR_MASK) >> MMAU_CSR_HDR_SHIFT)
#define MMAU_BRD_CSR_HDR(base) (MMAU_RD_CSR_HDR(base))
/*@}*/

/*!
 * @name Register MMAU_CSR, field BUSY[31] (RO)
 *
 * This read-only bit is asserted when the MMAU is performing a divide or square
 * root. Multiply operation completes in single cycle. When an operation is
 * initiated, the hardware sets this flag. It remains asserted until the operation
 * completes and the hardware automatically clears the indicator. This bit can be
 * used to poll the MMAU's execution status.
 *
 * Values:
 * - 0b0 - MMAU is idle
 * - 0b1 - MMAU is busy performing a divide or square root calculation
 */
/*@{*/
/*! @brief Read current value of the MMAU_CSR_BUSY field. */
#define MMAU_RD_CSR_BUSY(base) ((MMAU_CSR_REG(base) & MMAU_CSR_BUSY_MASK) >> MMAU_CSR_BUSY_SHIFT)
#define MMAU_BRD_CSR_BUSY(base) (MMAU_RD_CSR_BUSY(base))
/*@}*/

/* Constants and macros for entire MMAU_CSR registers */
#define MMAU_WR_CSR_IF_CLR(base, value) (MMAU_CSR_IF_CLR_REG(base) = (value))

/*
 * MKM34Z7 MPU
 *
 * Memory protection unit
 *
 * Registers defined in this header file:
 * - MPU_CESR - Control/Error Status Register
 * - MPU_EAR - Error Address Register, slave port n
 * - MPU_EDR - Error Detail Register, slave port n
 * - MPU_WORD - Region Descriptor n, Word 0
 * - MPU_RGDAAC - Region Descriptor Alternate Access Control n
 */

#define MPU_INSTANCE_COUNT (1U) /*!< Number of instances of the MPU module. */
#define MPU_IDX (0U) /*!< Instance number for MPU. */

/*******************************************************************************
 * MPU_CESR - Control/Error Status Register
 ******************************************************************************/

/*!
 * @brief MPU_CESR - Control/Error Status Register (RW)
 *
 * Reset value: 0x00812001U
 */
/*!
 * @name Constants and macros for entire MPU_CESR register
 */
/*@{*/
#define MPU_RD_CESR(base)        (MPU_CESR_REG(base))
#define MPU_WR_CESR(base, value) (MPU_CESR_REG(base) = (value))
#define MPU_RMW_CESR(base, mask, value) (MPU_WR_CESR(base, (MPU_RD_CESR(base) & ~(mask)) | (value)))
#define MPU_SET_CESR(base, value) (BME_OR32(&MPU_CESR_REG(base), (uint32_t)(value)))
#define MPU_CLR_CESR(base, value) (BME_AND32(&MPU_CESR_REG(base), (uint32_t)(~(value))))
#define MPU_TOG_CESR(base, value) (BME_XOR32(&MPU_CESR_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual MPU_CESR bitfields
 */

/*!
 * @name Register MPU_CESR, field VLD[0] (RW)
 *
 * Global enable/disable for the MPU.
 *
 * Values:
 * - 0b0 - MPU is disabled. All accesses from all bus masters are allowed.
 * - 0b1 - MPU is enabled
 */
/*@{*/
/*! @brief Read current value of the MPU_CESR_VLD field. */
#define MPU_RD_CESR_VLD(base) ((MPU_CESR_REG(base) & MPU_CESR_VLD_MASK) >> MPU_CESR_VLD_SHIFT)
#define MPU_BRD_CESR_VLD(base) (BME_UBFX32(&MPU_CESR_REG(base), MPU_CESR_VLD_SHIFT, MPU_CESR_VLD_WIDTH))

/*! @brief Set the VLD field to a new value. */
#define MPU_WR_CESR_VLD(base, value) (MPU_RMW_CESR(base, (MPU_CESR_VLD_MASK | MPU_CESR_SPERR_MASK), MPU_CESR_VLD(value)))
#define MPU_BWR_CESR_VLD(base, value) (BME_BFI32(&MPU_CESR_REG(base), ((uint32_t)(value) << MPU_CESR_VLD_SHIFT), MPU_CESR_VLD_SHIFT, MPU_CESR_VLD_WIDTH))
/*@}*/

/*!
 * @name Register MPU_CESR, field NRGD[11:8] (RO)
 *
 * Indicates the number of region descriptors implemented in the MPU.
 *
 * Values:
 * - 0b0000 - 8 region descriptors
 * - 0b0001 - 12 region descriptors
 * - 0b0010 - 16 region descriptors
 */
/*@{*/
/*! @brief Read current value of the MPU_CESR_NRGD field. */
#define MPU_RD_CESR_NRGD(base) ((MPU_CESR_REG(base) & MPU_CESR_NRGD_MASK) >> MPU_CESR_NRGD_SHIFT)
#define MPU_BRD_CESR_NRGD(base) (BME_UBFX32(&MPU_CESR_REG(base), MPU_CESR_NRGD_SHIFT, MPU_CESR_NRGD_WIDTH))
/*@}*/

/*!
 * @name Register MPU_CESR, field NSP[15:12] (RO)
 *
 * Specifies the number of slave ports connected to the MPU.
 */
/*@{*/
/*! @brief Read current value of the MPU_CESR_NSP field. */
#define MPU_RD_CESR_NSP(base) ((MPU_CESR_REG(base) & MPU_CESR_NSP_MASK) >> MPU_CESR_NSP_SHIFT)
#define MPU_BRD_CESR_NSP(base) (BME_UBFX32(&MPU_CESR_REG(base), MPU_CESR_NSP_SHIFT, MPU_CESR_NSP_WIDTH))
/*@}*/

/*!
 * @name Register MPU_CESR, field HRL[19:16] (RO)
 *
 * Specifies the MPU's hardware and definition revision level. It can be read by
 * software to determine the functional definition of the module.
 */
/*@{*/
/*! @brief Read current value of the MPU_CESR_HRL field. */
#define MPU_RD_CESR_HRL(base) ((MPU_CESR_REG(base) & MPU_CESR_HRL_MASK) >> MPU_CESR_HRL_SHIFT)
#define MPU_BRD_CESR_HRL(base) (BME_UBFX32(&MPU_CESR_REG(base), MPU_CESR_HRL_SHIFT, MPU_CESR_HRL_WIDTH))
/*@}*/

/*!
 * @name Register MPU_CESR, field SPERR[31:30] (W1C)
 *
 * Indicates a captured error in EARn and EDRn. This bit is set when the
 * hardware detects an error and records the faulting address and attributes. It is
 * cleared by writing one to it. If another error is captured at the exact same cycle
 * as the write, the flag remains set. A find-first-one instruction or
 * equivalent can detect the presence of a captured error. The following shows the
 * correspondence between the bit number and slave port number: Bit 31 corresponds to
 * slave port 0. Bit 30 corresponds to slave port 1.
 *
 * Values:
 * - 0b00 - No error has occurred for slave port n.
 * - 0b01 - An error has occurred for slave port n.
 */
/*@{*/
/*! @brief Read current value of the MPU_CESR_SPERR field. */
#define MPU_RD_CESR_SPERR(base) ((MPU_CESR_REG(base) & MPU_CESR_SPERR_MASK) >> MPU_CESR_SPERR_SHIFT)
#define MPU_BRD_CESR_SPERR(base) (BME_UBFX32(&MPU_CESR_REG(base), MPU_CESR_SPERR_SHIFT, MPU_CESR_SPERR_WIDTH))

/*! @brief Set the SPERR field to a new value. */
#define MPU_WR_CESR_SPERR(base, value) (MPU_RMW_CESR(base, MPU_CESR_SPERR_MASK, MPU_CESR_SPERR(value)))
#define MPU_BWR_CESR_SPERR(base, value) (BME_BFI32(&MPU_CESR_REG(base), ((uint32_t)(value) << MPU_CESR_SPERR_SHIFT), MPU_CESR_SPERR_SHIFT, MPU_CESR_SPERR_WIDTH))
/*@}*/

/*******************************************************************************
 * MPU_EAR - Error Address Register, slave port n
 ******************************************************************************/

/*!
 * @brief MPU_EAR - Error Address Register, slave port n (RO)
 *
 * Reset value: 0x00000000U
 *
 * When the MPU detects an access error on slave port n, the 32-bit reference
 * address is captured in this read-only register and the corresponding bit in
 * CESR[SPERR] set. Additional information about the faulting access is captured in
 * the corresponding EDRn at the same time. This register and the corresponding
 * EDRn contain the most recent access error; there are no hardware interlocks with
 * CESR[SPERR], as the error registers are always loaded upon the occurrence of
 * each protection violation.
 */
/*!
 * @name Constants and macros for entire MPU_EAR register
 */
/*@{*/
#define MPU_RD_EAR(base, index)  (MPU_EAR_REG(base, index))
/*@}*/

/*******************************************************************************
 * MPU_EDR - Error Detail Register, slave port n
 ******************************************************************************/

/*!
 * @brief MPU_EDR - Error Detail Register, slave port n (RO)
 *
 * Reset value: 0x00000000U
 *
 * When the MPU detects an access error on slave port n, 32 bits of error detail
 * are captured in this read-only register and the corresponding bit in
 * CESR[SPERR] is set. Information on the faulting address is captured in the
 * corresponding EARn register at the same time. This register and the corresponding EARn
 * register contain the most recent access error; there are no hardware interlocks
 * with CESR[SPERR] as the error registers are always loaded upon the occurrence
 * of each protection violation.
 */
/*!
 * @name Constants and macros for entire MPU_EDR register
 */
/*@{*/
#define MPU_RD_EDR(base, index)  (MPU_EDR_REG(base, index))
/*@}*/

/*
 * Constants & macros for individual MPU_EDR bitfields
 */

/*!
 * @name Register MPU_EDR, field ERW[0] (RO)
 *
 * Indicates the access type of the faulting reference.
 *
 * Values:
 * - 0b0 - Read
 * - 0b1 - Write
 */
/*@{*/
/*! @brief Read current value of the MPU_EDR_ERW field. */
#define MPU_RD_EDR_ERW(base, index) ((MPU_EDR_REG(base, index) & MPU_EDR_ERW_MASK) >> MPU_EDR_ERW_SHIFT)
#define MPU_BRD_EDR_ERW(base, index) (BME_UBFX32(&MPU_EDR_REG(base, index), MPU_EDR_ERW_SHIFT, MPU_EDR_ERW_WIDTH))
/*@}*/

/*!
 * @name Register MPU_EDR, field EATTR[3:1] (RO)
 *
 * Indicates attribute information about the faulting reference. All other
 * encodings are reserved.
 *
 * Values:
 * - 0b000 - User mode, instruction access
 * - 0b001 - User mode, data access
 * - 0b010 - Supervisor mode, instruction access
 * - 0b011 - Supervisor mode, data access
 */
/*@{*/
/*! @brief Read current value of the MPU_EDR_EATTR field. */
#define MPU_RD_EDR_EATTR(base, index) ((MPU_EDR_REG(base, index) & MPU_EDR_EATTR_MASK) >> MPU_EDR_EATTR_SHIFT)
#define MPU_BRD_EDR_EATTR(base, index) (BME_UBFX32(&MPU_EDR_REG(base, index), MPU_EDR_EATTR_SHIFT, MPU_EDR_EATTR_WIDTH))
/*@}*/

/*!
 * @name Register MPU_EDR, field EMN[7:4] (RO)
 *
 * Indicates the bus master that generated the access error.
 */
/*@{*/
/*! @brief Read current value of the MPU_EDR_EMN field. */
#define MPU_RD_EDR_EMN(base, index) ((MPU_EDR_REG(base, index) & MPU_EDR_EMN_MASK) >> MPU_EDR_EMN_SHIFT)
#define MPU_BRD_EDR_EMN(base, index) (BME_UBFX32(&MPU_EDR_REG(base, index), MPU_EDR_EMN_SHIFT, MPU_EDR_EMN_WIDTH))
/*@}*/

/*!
 * @name Register MPU_EDR, field EPID[15:8] (RO)
 *
 * Records the process identifier of the faulting reference. The process
 * identifier is typically driven only by processor cores; for other bus masters, this
 * field is cleared.
 */
/*@{*/
/*! @brief Read current value of the MPU_EDR_EPID field. */
#define MPU_RD_EDR_EPID(base, index) ((MPU_EDR_REG(base, index) & MPU_EDR_EPID_MASK) >> MPU_EDR_EPID_SHIFT)
#define MPU_BRD_EDR_EPID(base, index) (BME_UBFX32(&MPU_EDR_REG(base, index), MPU_EDR_EPID_SHIFT, MPU_EDR_EPID_WIDTH))
/*@}*/

/*!
 * @name Register MPU_EDR, field EACD[31:16] (RO)
 *
 * Indicates the region descriptor with the access error. If EDRn contains a
 * captured error and EACD is cleared, an access did not hit in any region
 * descriptor. If only a single EACD bit is set, the protection error was caused by a
 * single non-overlapping region descriptor. If two or more EACD bits are set, the
 * protection error was caused by an overlapping set of region descriptors.
 */
/*@{*/
/*! @brief Read current value of the MPU_EDR_EACD field. */
#define MPU_RD_EDR_EACD(base, index) ((MPU_EDR_REG(base, index) & MPU_EDR_EACD_MASK) >> MPU_EDR_EACD_SHIFT)
#define MPU_BRD_EDR_EACD(base, index) (BME_UBFX32(&MPU_EDR_REG(base, index), MPU_EDR_EACD_SHIFT, MPU_EDR_EACD_WIDTH))
/*@}*/

/*******************************************************************************
 * MPU_WORD - Region Descriptor n, Word 0
 ******************************************************************************/

/*!
 * @brief MPU_WORD - Region Descriptor n, Word 0 (RW)
 *
 * Reset value: 0x00000000U
 *
 * The first word of the region descriptor defines the 0-modulo-32 byte start
 * address of the memory region. Writes to this register clear the region
 * descriptor's valid bit (RGDn_WORD3[VLD]). RGD0_WORD0 register is read-only. Write
 * access to RGD0_WORD0 generates error.
 */
/*!
 * @name Constants and macros for entire MPU_WORD register
 */
/*@{*/
#define MPU_RD_WORD(base, index, index2) (MPU_WORD_REG(base, index, index2))
#define MPU_WR_WORD(base, index, index2, value) (MPU_WORD_REG(base, index, index2) = (value))
#define MPU_RMW_WORD(base, index, index2, mask, value) (MPU_WR_WORD(base, index, index2, (MPU_RD_WORD(base, index, index2) & ~(mask)) | (value)))
#define MPU_SET_WORD(base, index, index2, value) (BME_OR32(&MPU_WORD_REG(base, index, index2), (uint32_t)(value)))
#define MPU_CLR_WORD(base, index, index2, value) (BME_AND32(&MPU_WORD_REG(base, index, index2), (uint32_t)(~(value))))
#define MPU_TOG_WORD(base, index, index2, value) (BME_XOR32(&MPU_WORD_REG(base, index, index2), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual MPU_WORD bitfields
 */

/*!
 * @name Register MPU_WORD, field VLD[0] (RW)
 *
 * Signals the region descriptor is valid. Any write to RGDn_WORD0-2 clears this
 * bit.
 *
 * Values:
 * - 0b0 - Region descriptor is invalid
 * - 0b1 - Region descriptor is valid
 */
/*@{*/
/*! @brief Read current value of the MPU_WORD_VLD field. */
#define MPU_RD_WORD_VLD(base, index, index2) ((MPU_WORD_REG(base, index, index2) & MPU_WORD_VLD_MASK) >> MPU_WORD_VLD_SHIFT)
#define MPU_BRD_WORD_VLD(base, index, index2) (BME_UBFX32(&MPU_WORD_REG(base, index, index2), MPU_WORD_VLD_SHIFT, MPU_WORD_VLD_WIDTH))

/*! @brief Set the VLD field to a new value. */
#define MPU_WR_WORD_VLD(base, index, index2, value) (MPU_RMW_WORD(base, index, index2, MPU_WORD_VLD_MASK, MPU_WORD_VLD(value)))
#define MPU_BWR_WORD_VLD(base, index, index2, value) (BME_BFI32(&MPU_WORD_REG(base, index, index2), ((uint32_t)(value) << MPU_WORD_VLD_SHIFT), MPU_WORD_VLD_SHIFT, MPU_WORD_VLD_WIDTH))
/*@}*/

/*!
 * @name Register MPU_WORD, field M0UM[2:0] (RW)
 *
 * See M3UM description.
 */
/*@{*/
/*! @brief Read current value of the MPU_WORD_M0UM field. */
#define MPU_RD_WORD_M0UM(base, index, index2) ((MPU_WORD_REG(base, index, index2) & MPU_WORD_M0UM_MASK) >> MPU_WORD_M0UM_SHIFT)
#define MPU_BRD_WORD_M0UM(base, index, index2) (BME_UBFX32(&MPU_WORD_REG(base, index, index2), MPU_WORD_M0UM_SHIFT, MPU_WORD_M0UM_WIDTH))

/*! @brief Set the M0UM field to a new value. */
#define MPU_WR_WORD_M0UM(base, index, index2, value) (MPU_RMW_WORD(base, index, index2, MPU_WORD_M0UM_MASK, MPU_WORD_M0UM(value)))
#define MPU_BWR_WORD_M0UM(base, index, index2, value) (BME_BFI32(&MPU_WORD_REG(base, index, index2), ((uint32_t)(value) << MPU_WORD_M0UM_SHIFT), MPU_WORD_M0UM_SHIFT, MPU_WORD_M0UM_WIDTH))
/*@}*/

/*!
 * @name Register MPU_WORD, field M0SM[4:3] (RW)
 *
 * See M3SM description.
 */
/*@{*/
/*! @brief Read current value of the MPU_WORD_M0SM field. */
#define MPU_RD_WORD_M0SM(base, index, index2) ((MPU_WORD_REG(base, index, index2) & MPU_WORD_M0SM_MASK) >> MPU_WORD_M0SM_SHIFT)
#define MPU_BRD_WORD_M0SM(base, index, index2) (BME_UBFX32(&MPU_WORD_REG(base, index, index2), MPU_WORD_M0SM_SHIFT, MPU_WORD_M0SM_WIDTH))

/*! @brief Set the M0SM field to a new value. */
#define MPU_WR_WORD_M0SM(base, index, index2, value) (MPU_RMW_WORD(base, index, index2, MPU_WORD_M0SM_MASK, MPU_WORD_M0SM(value)))
#define MPU_BWR_WORD_M0SM(base, index, index2, value) (BME_BFI32(&MPU_WORD_REG(base, index, index2), ((uint32_t)(value) << MPU_WORD_M0SM_SHIFT), MPU_WORD_M0SM_SHIFT, MPU_WORD_M0SM_WIDTH))
/*@}*/

/*!
 * @name Register MPU_WORD, field M0PE[5] (RW)
 *
 * See M0PE description.
 */
/*@{*/
/*! @brief Read current value of the MPU_WORD_M0PE field. */
#define MPU_RD_WORD_M0PE(base, index, index2) ((MPU_WORD_REG(base, index, index2) & MPU_WORD_M0PE_MASK) >> MPU_WORD_M0PE_SHIFT)
#define MPU_BRD_WORD_M0PE(base, index, index2) (BME_UBFX32(&MPU_WORD_REG(base, index, index2), MPU_WORD_M0PE_SHIFT, MPU_WORD_M0PE_WIDTH))

/*! @brief Set the M0PE field to a new value. */
#define MPU_WR_WORD_M0PE(base, index, index2, value) (MPU_RMW_WORD(base, index, index2, MPU_WORD_M0PE_MASK, MPU_WORD_M0PE(value)))
#define MPU_BWR_WORD_M0PE(base, index, index2, value) (BME_BFI32(&MPU_WORD_REG(base, index, index2), ((uint32_t)(value) << MPU_WORD_M0PE_SHIFT), MPU_WORD_M0PE_SHIFT, MPU_WORD_M0PE_WIDTH))
/*@}*/

/*!
 * @name Register MPU_WORD, field ENDADDR[31:5] (RW)
 *
 * Defines the most significant bits of the 31-modulo-32 byte end address of the
 * memory region. The MPU does not verify that ENDADDR >= SRTADDR.
 */
/*@{*/
/*! @brief Read current value of the MPU_WORD_ENDADDR field. */
#define MPU_RD_WORD_ENDADDR(base, index, index2) ((MPU_WORD_REG(base, index, index2) & MPU_WORD_ENDADDR_MASK) >> MPU_WORD_ENDADDR_SHIFT)
#define MPU_BRD_WORD_ENDADDR(base, index, index2) (MPU_RD_WORD_ENDADDR(base, index, index2))

/*! @brief Set the ENDADDR field to a new value. */
#define MPU_WR_WORD_ENDADDR(base, index, index2, value) (MPU_RMW_WORD(base, index, index2, MPU_WORD_ENDADDR_MASK, MPU_WORD_ENDADDR(value)))
#define MPU_BWR_WORD_ENDADDR(base, index, index2, value) (MPU_WR_WORD_ENDADDR(base, index, index2, value))
/*@}*/

/*!
 * @name Register MPU_WORD, field SRTADDR[31:5] (RW)
 *
 * Defines the most significant bits of the 0-modulo-32 byte start address of
 * the memory region.
 */
/*@{*/
/*! @brief Read current value of the MPU_WORD_SRTADDR field. */
#define MPU_RD_WORD_SRTADDR(base, index, index2) ((MPU_WORD_REG(base, index, index2) & MPU_WORD_SRTADDR_MASK) >> MPU_WORD_SRTADDR_SHIFT)
#define MPU_BRD_WORD_SRTADDR(base, index, index2) (MPU_RD_WORD_SRTADDR(base, index, index2))

/*! @brief Set the SRTADDR field to a new value. */
#define MPU_WR_WORD_SRTADDR(base, index, index2, value) (MPU_RMW_WORD(base, index, index2, MPU_WORD_SRTADDR_MASK, MPU_WORD_SRTADDR(value)))
#define MPU_BWR_WORD_SRTADDR(base, index, index2, value) (MPU_WR_WORD_SRTADDR(base, index, index2, value))
/*@}*/

/*!
 * @name Register MPU_WORD, field M1UM[8:6] (RW)
 *
 * See M3UM description.
 */
/*@{*/
/*! @brief Read current value of the MPU_WORD_M1UM field. */
#define MPU_RD_WORD_M1UM(base, index, index2) ((MPU_WORD_REG(base, index, index2) & MPU_WORD_M1UM_MASK) >> MPU_WORD_M1UM_SHIFT)
#define MPU_BRD_WORD_M1UM(base, index, index2) (BME_UBFX32(&MPU_WORD_REG(base, index, index2), MPU_WORD_M1UM_SHIFT, MPU_WORD_M1UM_WIDTH))

/*! @brief Set the M1UM field to a new value. */
#define MPU_WR_WORD_M1UM(base, index, index2, value) (MPU_RMW_WORD(base, index, index2, MPU_WORD_M1UM_MASK, MPU_WORD_M1UM(value)))
#define MPU_BWR_WORD_M1UM(base, index, index2, value) (BME_BFI32(&MPU_WORD_REG(base, index, index2), ((uint32_t)(value) << MPU_WORD_M1UM_SHIFT), MPU_WORD_M1UM_SHIFT, MPU_WORD_M1UM_WIDTH))
/*@}*/

/*!
 * @name Register MPU_WORD, field M1SM[10:9] (RW)
 *
 * See M3SM description.
 */
/*@{*/
/*! @brief Read current value of the MPU_WORD_M1SM field. */
#define MPU_RD_WORD_M1SM(base, index, index2) ((MPU_WORD_REG(base, index, index2) & MPU_WORD_M1SM_MASK) >> MPU_WORD_M1SM_SHIFT)
#define MPU_BRD_WORD_M1SM(base, index, index2) (BME_UBFX32(&MPU_WORD_REG(base, index, index2), MPU_WORD_M1SM_SHIFT, MPU_WORD_M1SM_WIDTH))

/*! @brief Set the M1SM field to a new value. */
#define MPU_WR_WORD_M1SM(base, index, index2, value) (MPU_RMW_WORD(base, index, index2, MPU_WORD_M1SM_MASK, MPU_WORD_M1SM(value)))
#define MPU_BWR_WORD_M1SM(base, index, index2, value) (BME_BFI32(&MPU_WORD_REG(base, index, index2), ((uint32_t)(value) << MPU_WORD_M1SM_SHIFT), MPU_WORD_M1SM_SHIFT, MPU_WORD_M1SM_WIDTH))
/*@}*/

/*!
 * @name Register MPU_WORD, field M1PE[11] (RW)
 *
 * See M3PE description.
 */
/*@{*/
/*! @brief Read current value of the MPU_WORD_M1PE field. */
#define MPU_RD_WORD_M1PE(base, index, index2) ((MPU_WORD_REG(base, index, index2) & MPU_WORD_M1PE_MASK) >> MPU_WORD_M1PE_SHIFT)
#define MPU_BRD_WORD_M1PE(base, index, index2) (BME_UBFX32(&MPU_WORD_REG(base, index, index2), MPU_WORD_M1PE_SHIFT, MPU_WORD_M1PE_WIDTH))

/*! @brief Set the M1PE field to a new value. */
#define MPU_WR_WORD_M1PE(base, index, index2, value) (MPU_RMW_WORD(base, index, index2, MPU_WORD_M1PE_MASK, MPU_WORD_M1PE(value)))
#define MPU_BWR_WORD_M1PE(base, index, index2, value) (BME_BFI32(&MPU_WORD_REG(base, index, index2), ((uint32_t)(value) << MPU_WORD_M1PE_SHIFT), MPU_WORD_M1PE_SHIFT, MPU_WORD_M1PE_WIDTH))
/*@}*/

/*!
 * @name Register MPU_WORD, field M2UM[14:12] (RW)
 *
 * See M3UM description.
 */
/*@{*/
/*! @brief Read current value of the MPU_WORD_M2UM field. */
#define MPU_RD_WORD_M2UM(base, index, index2) ((MPU_WORD_REG(base, index, index2) & MPU_WORD_M2UM_MASK) >> MPU_WORD_M2UM_SHIFT)
#define MPU_BRD_WORD_M2UM(base, index, index2) (BME_UBFX32(&MPU_WORD_REG(base, index, index2), MPU_WORD_M2UM_SHIFT, MPU_WORD_M2UM_WIDTH))

/*! @brief Set the M2UM field to a new value. */
#define MPU_WR_WORD_M2UM(base, index, index2, value) (MPU_RMW_WORD(base, index, index2, MPU_WORD_M2UM_MASK, MPU_WORD_M2UM(value)))
#define MPU_BWR_WORD_M2UM(base, index, index2, value) (BME_BFI32(&MPU_WORD_REG(base, index, index2), ((uint32_t)(value) << MPU_WORD_M2UM_SHIFT), MPU_WORD_M2UM_SHIFT, MPU_WORD_M2UM_WIDTH))
/*@}*/

/*!
 * @name Register MPU_WORD, field M2SM[16:15] (RW)
 *
 * See M3SM description.
 */
/*@{*/
/*! @brief Read current value of the MPU_WORD_M2SM field. */
#define MPU_RD_WORD_M2SM(base, index, index2) ((MPU_WORD_REG(base, index, index2) & MPU_WORD_M2SM_MASK) >> MPU_WORD_M2SM_SHIFT)
#define MPU_BRD_WORD_M2SM(base, index, index2) (BME_UBFX32(&MPU_WORD_REG(base, index, index2), MPU_WORD_M2SM_SHIFT, MPU_WORD_M2SM_WIDTH))

/*! @brief Set the M2SM field to a new value. */
#define MPU_WR_WORD_M2SM(base, index, index2, value) (MPU_RMW_WORD(base, index, index2, MPU_WORD_M2SM_MASK, MPU_WORD_M2SM(value)))
#define MPU_BWR_WORD_M2SM(base, index, index2, value) (BME_BFI32(&MPU_WORD_REG(base, index, index2), ((uint32_t)(value) << MPU_WORD_M2SM_SHIFT), MPU_WORD_M2SM_SHIFT, MPU_WORD_M2SM_WIDTH))
/*@}*/

/*!
 * @name Register MPU_WORD, field PIDMASK[23:16] (RW)
 *
 * Provides a masking capability so that multiple process identifiers can be
 * included as part of the region hit determination. If a bit in PIDMASK is set,
 * then the corresponding PID bit is ignored in the comparison. This field and PID
 * are included in the region hit determination if RGDn_WORD2[MxPE] is set. For
 * more information on the handling of the PID and PIDMASK, see "Access Evaluation
 * - Hit Determination."
 */
/*@{*/
/*! @brief Read current value of the MPU_WORD_PIDMASK field. */
#define MPU_RD_WORD_PIDMASK(base, index, index2) ((MPU_WORD_REG(base, index, index2) & MPU_WORD_PIDMASK_MASK) >> MPU_WORD_PIDMASK_SHIFT)
#define MPU_BRD_WORD_PIDMASK(base, index, index2) (BME_UBFX32(&MPU_WORD_REG(base, index, index2), MPU_WORD_PIDMASK_SHIFT, MPU_WORD_PIDMASK_WIDTH))

/*! @brief Set the PIDMASK field to a new value. */
#define MPU_WR_WORD_PIDMASK(base, index, index2, value) (MPU_RMW_WORD(base, index, index2, MPU_WORD_PIDMASK_MASK, MPU_WORD_PIDMASK(value)))
#define MPU_BWR_WORD_PIDMASK(base, index, index2, value) (BME_BFI32(&MPU_WORD_REG(base, index, index2), ((uint32_t)(value) << MPU_WORD_PIDMASK_SHIFT), MPU_WORD_PIDMASK_SHIFT, MPU_WORD_PIDMASK_WIDTH))
/*@}*/

/*!
 * @name Register MPU_WORD, field M2PE[17] (RW)
 *
 * See M3PE description.
 */
/*@{*/
/*! @brief Read current value of the MPU_WORD_M2PE field. */
#define MPU_RD_WORD_M2PE(base, index, index2) ((MPU_WORD_REG(base, index, index2) & MPU_WORD_M2PE_MASK) >> MPU_WORD_M2PE_SHIFT)
#define MPU_BRD_WORD_M2PE(base, index, index2) (BME_UBFX32(&MPU_WORD_REG(base, index, index2), MPU_WORD_M2PE_SHIFT, MPU_WORD_M2PE_WIDTH))

/*! @brief Set the M2PE field to a new value. */
#define MPU_WR_WORD_M2PE(base, index, index2, value) (MPU_RMW_WORD(base, index, index2, MPU_WORD_M2PE_MASK, MPU_WORD_M2PE(value)))
#define MPU_BWR_WORD_M2PE(base, index, index2, value) (BME_BFI32(&MPU_WORD_REG(base, index, index2), ((uint32_t)(value) << MPU_WORD_M2PE_SHIFT), MPU_WORD_M2PE_SHIFT, MPU_WORD_M2PE_WIDTH))
/*@}*/

/*!
 * @name Register MPU_WORD, field M3UM[20:18] (RW)
 *
 * Defines the access controls for bus master 3 in User mode. M3UM consists of
 * three independent bits, enabling read (r), write (w), and execute (x)
 * permissions.
 *
 * Values:
 * - 0b000 - An attempted access of that mode may be terminated with an access
 *     error (if not allowed by another descriptor) and the access not performed.
 * - 0b001 - Allows the given access type to occur
 */
/*@{*/
/*! @brief Read current value of the MPU_WORD_M3UM field. */
#define MPU_RD_WORD_M3UM(base, index, index2) ((MPU_WORD_REG(base, index, index2) & MPU_WORD_M3UM_MASK) >> MPU_WORD_M3UM_SHIFT)
#define MPU_BRD_WORD_M3UM(base, index, index2) (BME_UBFX32(&MPU_WORD_REG(base, index, index2), MPU_WORD_M3UM_SHIFT, MPU_WORD_M3UM_WIDTH))

/*! @brief Set the M3UM field to a new value. */
#define MPU_WR_WORD_M3UM(base, index, index2, value) (MPU_RMW_WORD(base, index, index2, MPU_WORD_M3UM_MASK, MPU_WORD_M3UM(value)))
#define MPU_BWR_WORD_M3UM(base, index, index2, value) (BME_BFI32(&MPU_WORD_REG(base, index, index2), ((uint32_t)(value) << MPU_WORD_M3UM_SHIFT), MPU_WORD_M3UM_SHIFT, MPU_WORD_M3UM_WIDTH))
/*@}*/

/*!
 * @name Register MPU_WORD, field M3SM[22:21] (RW)
 *
 * Defines the access controls for bus master 3 in Supervisor mode.
 *
 * Values:
 * - 0b00 - r/w/x; read, write and execute allowed
 * - 0b01 - r/x; read and execute allowed, but no write
 * - 0b10 - r/w; read and write allowed, but no execute
 * - 0b11 - Same as User mode defined in M3UM
 */
/*@{*/
/*! @brief Read current value of the MPU_WORD_M3SM field. */
#define MPU_RD_WORD_M3SM(base, index, index2) ((MPU_WORD_REG(base, index, index2) & MPU_WORD_M3SM_MASK) >> MPU_WORD_M3SM_SHIFT)
#define MPU_BRD_WORD_M3SM(base, index, index2) (BME_UBFX32(&MPU_WORD_REG(base, index, index2), MPU_WORD_M3SM_SHIFT, MPU_WORD_M3SM_WIDTH))

/*! @brief Set the M3SM field to a new value. */
#define MPU_WR_WORD_M3SM(base, index, index2, value) (MPU_RMW_WORD(base, index, index2, MPU_WORD_M3SM_MASK, MPU_WORD_M3SM(value)))
#define MPU_BWR_WORD_M3SM(base, index, index2, value) (BME_BFI32(&MPU_WORD_REG(base, index, index2), ((uint32_t)(value) << MPU_WORD_M3SM_SHIFT), MPU_WORD_M3SM_SHIFT, MPU_WORD_M3SM_WIDTH))
/*@}*/

/*!
 * @name Register MPU_WORD, field M3PE[23] (RW)
 *
 * Values:
 * - 0b0 - Do not include the process identifier in the evaluation
 * - 0b1 - Include the process identifier and mask (RGDn_WORD3) in the region
 *     hit evaluation
 */
/*@{*/
/*! @brief Read current value of the MPU_WORD_M3PE field. */
#define MPU_RD_WORD_M3PE(base, index, index2) ((MPU_WORD_REG(base, index, index2) & MPU_WORD_M3PE_MASK) >> MPU_WORD_M3PE_SHIFT)
#define MPU_BRD_WORD_M3PE(base, index, index2) (BME_UBFX32(&MPU_WORD_REG(base, index, index2), MPU_WORD_M3PE_SHIFT, MPU_WORD_M3PE_WIDTH))

/*! @brief Set the M3PE field to a new value. */
#define MPU_WR_WORD_M3PE(base, index, index2, value) (MPU_RMW_WORD(base, index, index2, MPU_WORD_M3PE_MASK, MPU_WORD_M3PE(value)))
#define MPU_BWR_WORD_M3PE(base, index, index2, value) (BME_BFI32(&MPU_WORD_REG(base, index, index2), ((uint32_t)(value) << MPU_WORD_M3PE_SHIFT), MPU_WORD_M3PE_SHIFT, MPU_WORD_M3PE_WIDTH))
/*@}*/

/*!
 * @name Register MPU_WORD, field PID[31:24] (RW)
 *
 * Specifies the process identifier that is included in the region hit
 * determination if RGDn_WORD2[MxPE] is set. PIDMASK can mask individual bits in this
 * field.
 */
/*@{*/
/*! @brief Read current value of the MPU_WORD_PID field. */
#define MPU_RD_WORD_PID(base, index, index2) ((MPU_WORD_REG(base, index, index2) & MPU_WORD_PID_MASK) >> MPU_WORD_PID_SHIFT)
#define MPU_BRD_WORD_PID(base, index, index2) (BME_UBFX32(&MPU_WORD_REG(base, index, index2), MPU_WORD_PID_SHIFT, MPU_WORD_PID_WIDTH))

/*! @brief Set the PID field to a new value. */
#define MPU_WR_WORD_PID(base, index, index2, value) (MPU_RMW_WORD(base, index, index2, MPU_WORD_PID_MASK, MPU_WORD_PID(value)))
#define MPU_BWR_WORD_PID(base, index, index2, value) (BME_BFI32(&MPU_WORD_REG(base, index, index2), ((uint32_t)(value) << MPU_WORD_PID_SHIFT), MPU_WORD_PID_SHIFT, MPU_WORD_PID_WIDTH))
/*@}*/

/*!
 * @name Register MPU_WORD, field M4WE[24] (RW)
 *
 * Values:
 * - 0b0 - Bus master 4 writes terminate with an access error and the write is
 *     not performed
 * - 0b1 - Bus master 4 writes allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_WORD_M4WE field. */
#define MPU_RD_WORD_M4WE(base, index, index2) ((MPU_WORD_REG(base, index, index2) & MPU_WORD_M4WE_MASK) >> MPU_WORD_M4WE_SHIFT)
#define MPU_BRD_WORD_M4WE(base, index, index2) (BME_UBFX32(&MPU_WORD_REG(base, index, index2), MPU_WORD_M4WE_SHIFT, MPU_WORD_M4WE_WIDTH))

/*! @brief Set the M4WE field to a new value. */
#define MPU_WR_WORD_M4WE(base, index, index2, value) (MPU_RMW_WORD(base, index, index2, MPU_WORD_M4WE_MASK, MPU_WORD_M4WE(value)))
#define MPU_BWR_WORD_M4WE(base, index, index2, value) (BME_BFI32(&MPU_WORD_REG(base, index, index2), ((uint32_t)(value) << MPU_WORD_M4WE_SHIFT), MPU_WORD_M4WE_SHIFT, MPU_WORD_M4WE_WIDTH))
/*@}*/

/*!
 * @name Register MPU_WORD, field M4RE[25] (RW)
 *
 * Values:
 * - 0b0 - Bus master 4 reads terminate with an access error and the read is not
 *     performed
 * - 0b1 - Bus master 4 reads allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_WORD_M4RE field. */
#define MPU_RD_WORD_M4RE(base, index, index2) ((MPU_WORD_REG(base, index, index2) & MPU_WORD_M4RE_MASK) >> MPU_WORD_M4RE_SHIFT)
#define MPU_BRD_WORD_M4RE(base, index, index2) (BME_UBFX32(&MPU_WORD_REG(base, index, index2), MPU_WORD_M4RE_SHIFT, MPU_WORD_M4RE_WIDTH))

/*! @brief Set the M4RE field to a new value. */
#define MPU_WR_WORD_M4RE(base, index, index2, value) (MPU_RMW_WORD(base, index, index2, MPU_WORD_M4RE_MASK, MPU_WORD_M4RE(value)))
#define MPU_BWR_WORD_M4RE(base, index, index2, value) (BME_BFI32(&MPU_WORD_REG(base, index, index2), ((uint32_t)(value) << MPU_WORD_M4RE_SHIFT), MPU_WORD_M4RE_SHIFT, MPU_WORD_M4RE_WIDTH))
/*@}*/

/*!
 * @name Register MPU_WORD, field M5WE[26] (RW)
 *
 * Values:
 * - 0b0 - Bus master 5 writes terminate with an access error and the write is
 *     not performed
 * - 0b1 - Bus master 5 writes allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_WORD_M5WE field. */
#define MPU_RD_WORD_M5WE(base, index, index2) ((MPU_WORD_REG(base, index, index2) & MPU_WORD_M5WE_MASK) >> MPU_WORD_M5WE_SHIFT)
#define MPU_BRD_WORD_M5WE(base, index, index2) (BME_UBFX32(&MPU_WORD_REG(base, index, index2), MPU_WORD_M5WE_SHIFT, MPU_WORD_M5WE_WIDTH))

/*! @brief Set the M5WE field to a new value. */
#define MPU_WR_WORD_M5WE(base, index, index2, value) (MPU_RMW_WORD(base, index, index2, MPU_WORD_M5WE_MASK, MPU_WORD_M5WE(value)))
#define MPU_BWR_WORD_M5WE(base, index, index2, value) (BME_BFI32(&MPU_WORD_REG(base, index, index2), ((uint32_t)(value) << MPU_WORD_M5WE_SHIFT), MPU_WORD_M5WE_SHIFT, MPU_WORD_M5WE_WIDTH))
/*@}*/

/*!
 * @name Register MPU_WORD, field M5RE[27] (RW)
 *
 * Values:
 * - 0b0 - Bus master 5 reads terminate with an access error and the read is not
 *     performed
 * - 0b1 - Bus master 5 reads allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_WORD_M5RE field. */
#define MPU_RD_WORD_M5RE(base, index, index2) ((MPU_WORD_REG(base, index, index2) & MPU_WORD_M5RE_MASK) >> MPU_WORD_M5RE_SHIFT)
#define MPU_BRD_WORD_M5RE(base, index, index2) (BME_UBFX32(&MPU_WORD_REG(base, index, index2), MPU_WORD_M5RE_SHIFT, MPU_WORD_M5RE_WIDTH))

/*! @brief Set the M5RE field to a new value. */
#define MPU_WR_WORD_M5RE(base, index, index2, value) (MPU_RMW_WORD(base, index, index2, MPU_WORD_M5RE_MASK, MPU_WORD_M5RE(value)))
#define MPU_BWR_WORD_M5RE(base, index, index2, value) (BME_BFI32(&MPU_WORD_REG(base, index, index2), ((uint32_t)(value) << MPU_WORD_M5RE_SHIFT), MPU_WORD_M5RE_SHIFT, MPU_WORD_M5RE_WIDTH))
/*@}*/

/*!
 * @name Register MPU_WORD, field M6WE[28] (RW)
 *
 * Values:
 * - 0b0 - Bus master 6 writes terminate with an access error and the write is
 *     not performed
 * - 0b1 - Bus master 6 writes allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_WORD_M6WE field. */
#define MPU_RD_WORD_M6WE(base, index, index2) ((MPU_WORD_REG(base, index, index2) & MPU_WORD_M6WE_MASK) >> MPU_WORD_M6WE_SHIFT)
#define MPU_BRD_WORD_M6WE(base, index, index2) (BME_UBFX32(&MPU_WORD_REG(base, index, index2), MPU_WORD_M6WE_SHIFT, MPU_WORD_M6WE_WIDTH))

/*! @brief Set the M6WE field to a new value. */
#define MPU_WR_WORD_M6WE(base, index, index2, value) (MPU_RMW_WORD(base, index, index2, MPU_WORD_M6WE_MASK, MPU_WORD_M6WE(value)))
#define MPU_BWR_WORD_M6WE(base, index, index2, value) (BME_BFI32(&MPU_WORD_REG(base, index, index2), ((uint32_t)(value) << MPU_WORD_M6WE_SHIFT), MPU_WORD_M6WE_SHIFT, MPU_WORD_M6WE_WIDTH))
/*@}*/

/*!
 * @name Register MPU_WORD, field M6RE[29] (RW)
 *
 * Values:
 * - 0b0 - Bus master 6 reads terminate with an access error and the read is not
 *     performed
 * - 0b1 - Bus master 6 reads allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_WORD_M6RE field. */
#define MPU_RD_WORD_M6RE(base, index, index2) ((MPU_WORD_REG(base, index, index2) & MPU_WORD_M6RE_MASK) >> MPU_WORD_M6RE_SHIFT)
#define MPU_BRD_WORD_M6RE(base, index, index2) (BME_UBFX32(&MPU_WORD_REG(base, index, index2), MPU_WORD_M6RE_SHIFT, MPU_WORD_M6RE_WIDTH))

/*! @brief Set the M6RE field to a new value. */
#define MPU_WR_WORD_M6RE(base, index, index2, value) (MPU_RMW_WORD(base, index, index2, MPU_WORD_M6RE_MASK, MPU_WORD_M6RE(value)))
#define MPU_BWR_WORD_M6RE(base, index, index2, value) (BME_BFI32(&MPU_WORD_REG(base, index, index2), ((uint32_t)(value) << MPU_WORD_M6RE_SHIFT), MPU_WORD_M6RE_SHIFT, MPU_WORD_M6RE_WIDTH))
/*@}*/

/*!
 * @name Register MPU_WORD, field M7WE[30] (RW)
 *
 * Values:
 * - 0b0 - Bus master 7 writes terminate with an access error and the write is
 *     not performed
 * - 0b1 - Bus master 7 writes allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_WORD_M7WE field. */
#define MPU_RD_WORD_M7WE(base, index, index2) ((MPU_WORD_REG(base, index, index2) & MPU_WORD_M7WE_MASK) >> MPU_WORD_M7WE_SHIFT)
#define MPU_BRD_WORD_M7WE(base, index, index2) (BME_UBFX32(&MPU_WORD_REG(base, index, index2), MPU_WORD_M7WE_SHIFT, MPU_WORD_M7WE_WIDTH))

/*! @brief Set the M7WE field to a new value. */
#define MPU_WR_WORD_M7WE(base, index, index2, value) (MPU_RMW_WORD(base, index, index2, MPU_WORD_M7WE_MASK, MPU_WORD_M7WE(value)))
#define MPU_BWR_WORD_M7WE(base, index, index2, value) (BME_BFI32(&MPU_WORD_REG(base, index, index2), ((uint32_t)(value) << MPU_WORD_M7WE_SHIFT), MPU_WORD_M7WE_SHIFT, MPU_WORD_M7WE_WIDTH))
/*@}*/

/*!
 * @name Register MPU_WORD, field M7RE[31] (RW)
 *
 * Values:
 * - 0b0 - Bus master 7 reads terminate with an access error and the read is not
 *     performed
 * - 0b1 - Bus master 7 reads allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_WORD_M7RE field. */
#define MPU_RD_WORD_M7RE(base, index, index2) ((MPU_WORD_REG(base, index, index2) & MPU_WORD_M7RE_MASK) >> MPU_WORD_M7RE_SHIFT)
#define MPU_BRD_WORD_M7RE(base, index, index2) (BME_UBFX32(&MPU_WORD_REG(base, index, index2), MPU_WORD_M7RE_SHIFT, MPU_WORD_M7RE_WIDTH))

/*! @brief Set the M7RE field to a new value. */
#define MPU_WR_WORD_M7RE(base, index, index2, value) (MPU_RMW_WORD(base, index, index2, MPU_WORD_M7RE_MASK, MPU_WORD_M7RE(value)))
#define MPU_BWR_WORD_M7RE(base, index, index2, value) (BME_BFI32(&MPU_WORD_REG(base, index, index2), ((uint32_t)(value) << MPU_WORD_M7RE_SHIFT), MPU_WORD_M7RE_SHIFT, MPU_WORD_M7RE_WIDTH))
/*@}*/

/*******************************************************************************
 * MPU_RGDAAC - Region Descriptor Alternate Access Control n
 ******************************************************************************/

/*!
 * @brief MPU_RGDAAC - Region Descriptor Alternate Access Control n (RW)
 *
 * Reset value: 0x0061F7DFU
 *
 * Because software may adjust only the access controls within a region
 * descriptor (RGDn_WORD2) as different tasks execute, an alternate programming view of
 * this 32-bit entity is available. Writing to this register does not affect the
 * descriptor's valid bit.
 */
/*!
 * @name Constants and macros for entire MPU_RGDAAC register
 */
/*@{*/
#define MPU_RD_RGDAAC(base, index) (MPU_RGDAAC_REG(base, index))
#define MPU_WR_RGDAAC(base, index, value) (MPU_RGDAAC_REG(base, index) = (value))
#define MPU_RMW_RGDAAC(base, index, mask, value) (MPU_WR_RGDAAC(base, index, (MPU_RD_RGDAAC(base, index) & ~(mask)) | (value)))
#define MPU_SET_RGDAAC(base, index, value) (BME_OR32(&MPU_RGDAAC_REG(base, index), (uint32_t)(value)))
#define MPU_CLR_RGDAAC(base, index, value) (BME_AND32(&MPU_RGDAAC_REG(base, index), (uint32_t)(~(value))))
#define MPU_TOG_RGDAAC(base, index, value) (BME_XOR32(&MPU_RGDAAC_REG(base, index), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual MPU_RGDAAC bitfields
 */

/*!
 * @name Register MPU_RGDAAC, field M0UM[2:0] (RW)
 *
 * See M3UM description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC_M0UM field. */
#define MPU_RD_RGDAAC_M0UM(base, index) ((MPU_RGDAAC_REG(base, index) & MPU_RGDAAC_M0UM_MASK) >> MPU_RGDAAC_M0UM_SHIFT)
#define MPU_BRD_RGDAAC_M0UM(base, index) (BME_UBFX32(&MPU_RGDAAC_REG(base, index), MPU_RGDAAC_M0UM_SHIFT, MPU_RGDAAC_M0UM_WIDTH))

/*! @brief Set the M0UM field to a new value. */
#define MPU_WR_RGDAAC_M0UM(base, index, value) (MPU_RMW_RGDAAC(base, index, MPU_RGDAAC_M0UM_MASK, MPU_RGDAAC_M0UM(value)))
#define MPU_BWR_RGDAAC_M0UM(base, index, value) (BME_BFI32(&MPU_RGDAAC_REG(base, index), ((uint32_t)(value) << MPU_RGDAAC_M0UM_SHIFT), MPU_RGDAAC_M0UM_SHIFT, MPU_RGDAAC_M0UM_WIDTH))
/*@}*/

/*!
 * @name Register MPU_RGDAAC, field M0SM[4:3] (RW)
 *
 * See M3SM description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC_M0SM field. */
#define MPU_RD_RGDAAC_M0SM(base, index) ((MPU_RGDAAC_REG(base, index) & MPU_RGDAAC_M0SM_MASK) >> MPU_RGDAAC_M0SM_SHIFT)
#define MPU_BRD_RGDAAC_M0SM(base, index) (BME_UBFX32(&MPU_RGDAAC_REG(base, index), MPU_RGDAAC_M0SM_SHIFT, MPU_RGDAAC_M0SM_WIDTH))

/*! @brief Set the M0SM field to a new value. */
#define MPU_WR_RGDAAC_M0SM(base, index, value) (MPU_RMW_RGDAAC(base, index, MPU_RGDAAC_M0SM_MASK, MPU_RGDAAC_M0SM(value)))
#define MPU_BWR_RGDAAC_M0SM(base, index, value) (BME_BFI32(&MPU_RGDAAC_REG(base, index), ((uint32_t)(value) << MPU_RGDAAC_M0SM_SHIFT), MPU_RGDAAC_M0SM_SHIFT, MPU_RGDAAC_M0SM_WIDTH))
/*@}*/

/*!
 * @name Register MPU_RGDAAC, field M0PE[5] (RW)
 *
 * See M3PE description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC_M0PE field. */
#define MPU_RD_RGDAAC_M0PE(base, index) ((MPU_RGDAAC_REG(base, index) & MPU_RGDAAC_M0PE_MASK) >> MPU_RGDAAC_M0PE_SHIFT)
#define MPU_BRD_RGDAAC_M0PE(base, index) (BME_UBFX32(&MPU_RGDAAC_REG(base, index), MPU_RGDAAC_M0PE_SHIFT, MPU_RGDAAC_M0PE_WIDTH))

/*! @brief Set the M0PE field to a new value. */
#define MPU_WR_RGDAAC_M0PE(base, index, value) (MPU_RMW_RGDAAC(base, index, MPU_RGDAAC_M0PE_MASK, MPU_RGDAAC_M0PE(value)))
#define MPU_BWR_RGDAAC_M0PE(base, index, value) (BME_BFI32(&MPU_RGDAAC_REG(base, index), ((uint32_t)(value) << MPU_RGDAAC_M0PE_SHIFT), MPU_RGDAAC_M0PE_SHIFT, MPU_RGDAAC_M0PE_WIDTH))
/*@}*/

/*!
 * @name Register MPU_RGDAAC, field M1UM[8:6] (RW)
 *
 * See M3UM description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC_M1UM field. */
#define MPU_RD_RGDAAC_M1UM(base, index) ((MPU_RGDAAC_REG(base, index) & MPU_RGDAAC_M1UM_MASK) >> MPU_RGDAAC_M1UM_SHIFT)
#define MPU_BRD_RGDAAC_M1UM(base, index) (BME_UBFX32(&MPU_RGDAAC_REG(base, index), MPU_RGDAAC_M1UM_SHIFT, MPU_RGDAAC_M1UM_WIDTH))

/*! @brief Set the M1UM field to a new value. */
#define MPU_WR_RGDAAC_M1UM(base, index, value) (MPU_RMW_RGDAAC(base, index, MPU_RGDAAC_M1UM_MASK, MPU_RGDAAC_M1UM(value)))
#define MPU_BWR_RGDAAC_M1UM(base, index, value) (BME_BFI32(&MPU_RGDAAC_REG(base, index), ((uint32_t)(value) << MPU_RGDAAC_M1UM_SHIFT), MPU_RGDAAC_M1UM_SHIFT, MPU_RGDAAC_M1UM_WIDTH))
/*@}*/

/*!
 * @name Register MPU_RGDAAC, field M1SM[10:9] (RW)
 *
 * See M3SM description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC_M1SM field. */
#define MPU_RD_RGDAAC_M1SM(base, index) ((MPU_RGDAAC_REG(base, index) & MPU_RGDAAC_M1SM_MASK) >> MPU_RGDAAC_M1SM_SHIFT)
#define MPU_BRD_RGDAAC_M1SM(base, index) (BME_UBFX32(&MPU_RGDAAC_REG(base, index), MPU_RGDAAC_M1SM_SHIFT, MPU_RGDAAC_M1SM_WIDTH))

/*! @brief Set the M1SM field to a new value. */
#define MPU_WR_RGDAAC_M1SM(base, index, value) (MPU_RMW_RGDAAC(base, index, MPU_RGDAAC_M1SM_MASK, MPU_RGDAAC_M1SM(value)))
#define MPU_BWR_RGDAAC_M1SM(base, index, value) (BME_BFI32(&MPU_RGDAAC_REG(base, index), ((uint32_t)(value) << MPU_RGDAAC_M1SM_SHIFT), MPU_RGDAAC_M1SM_SHIFT, MPU_RGDAAC_M1SM_WIDTH))
/*@}*/

/*!
 * @name Register MPU_RGDAAC, field M1PE[11] (RW)
 *
 * See M3PE description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC_M1PE field. */
#define MPU_RD_RGDAAC_M1PE(base, index) ((MPU_RGDAAC_REG(base, index) & MPU_RGDAAC_M1PE_MASK) >> MPU_RGDAAC_M1PE_SHIFT)
#define MPU_BRD_RGDAAC_M1PE(base, index) (BME_UBFX32(&MPU_RGDAAC_REG(base, index), MPU_RGDAAC_M1PE_SHIFT, MPU_RGDAAC_M1PE_WIDTH))

/*! @brief Set the M1PE field to a new value. */
#define MPU_WR_RGDAAC_M1PE(base, index, value) (MPU_RMW_RGDAAC(base, index, MPU_RGDAAC_M1PE_MASK, MPU_RGDAAC_M1PE(value)))
#define MPU_BWR_RGDAAC_M1PE(base, index, value) (BME_BFI32(&MPU_RGDAAC_REG(base, index), ((uint32_t)(value) << MPU_RGDAAC_M1PE_SHIFT), MPU_RGDAAC_M1PE_SHIFT, MPU_RGDAAC_M1PE_WIDTH))
/*@}*/

/*!
 * @name Register MPU_RGDAAC, field M2UM[14:12] (RW)
 *
 * See M3UM description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC_M2UM field. */
#define MPU_RD_RGDAAC_M2UM(base, index) ((MPU_RGDAAC_REG(base, index) & MPU_RGDAAC_M2UM_MASK) >> MPU_RGDAAC_M2UM_SHIFT)
#define MPU_BRD_RGDAAC_M2UM(base, index) (BME_UBFX32(&MPU_RGDAAC_REG(base, index), MPU_RGDAAC_M2UM_SHIFT, MPU_RGDAAC_M2UM_WIDTH))

/*! @brief Set the M2UM field to a new value. */
#define MPU_WR_RGDAAC_M2UM(base, index, value) (MPU_RMW_RGDAAC(base, index, MPU_RGDAAC_M2UM_MASK, MPU_RGDAAC_M2UM(value)))
#define MPU_BWR_RGDAAC_M2UM(base, index, value) (BME_BFI32(&MPU_RGDAAC_REG(base, index), ((uint32_t)(value) << MPU_RGDAAC_M2UM_SHIFT), MPU_RGDAAC_M2UM_SHIFT, MPU_RGDAAC_M2UM_WIDTH))
/*@}*/

/*!
 * @name Register MPU_RGDAAC, field M2SM[16:15] (RW)
 *
 * See M3SM description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC_M2SM field. */
#define MPU_RD_RGDAAC_M2SM(base, index) ((MPU_RGDAAC_REG(base, index) & MPU_RGDAAC_M2SM_MASK) >> MPU_RGDAAC_M2SM_SHIFT)
#define MPU_BRD_RGDAAC_M2SM(base, index) (BME_UBFX32(&MPU_RGDAAC_REG(base, index), MPU_RGDAAC_M2SM_SHIFT, MPU_RGDAAC_M2SM_WIDTH))

/*! @brief Set the M2SM field to a new value. */
#define MPU_WR_RGDAAC_M2SM(base, index, value) (MPU_RMW_RGDAAC(base, index, MPU_RGDAAC_M2SM_MASK, MPU_RGDAAC_M2SM(value)))
#define MPU_BWR_RGDAAC_M2SM(base, index, value) (BME_BFI32(&MPU_RGDAAC_REG(base, index), ((uint32_t)(value) << MPU_RGDAAC_M2SM_SHIFT), MPU_RGDAAC_M2SM_SHIFT, MPU_RGDAAC_M2SM_WIDTH))
/*@}*/

/*!
 * @name Register MPU_RGDAAC, field M2PE[17] (RW)
 *
 * See M3PE description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC_M2PE field. */
#define MPU_RD_RGDAAC_M2PE(base, index) ((MPU_RGDAAC_REG(base, index) & MPU_RGDAAC_M2PE_MASK) >> MPU_RGDAAC_M2PE_SHIFT)
#define MPU_BRD_RGDAAC_M2PE(base, index) (BME_UBFX32(&MPU_RGDAAC_REG(base, index), MPU_RGDAAC_M2PE_SHIFT, MPU_RGDAAC_M2PE_WIDTH))

/*! @brief Set the M2PE field to a new value. */
#define MPU_WR_RGDAAC_M2PE(base, index, value) (MPU_RMW_RGDAAC(base, index, MPU_RGDAAC_M2PE_MASK, MPU_RGDAAC_M2PE(value)))
#define MPU_BWR_RGDAAC_M2PE(base, index, value) (BME_BFI32(&MPU_RGDAAC_REG(base, index), ((uint32_t)(value) << MPU_RGDAAC_M2PE_SHIFT), MPU_RGDAAC_M2PE_SHIFT, MPU_RGDAAC_M2PE_WIDTH))
/*@}*/

/*!
 * @name Register MPU_RGDAAC, field M3UM[20:18] (RW)
 *
 * Defines the access controls for bus master 3 in user mode. M3UM consists of
 * three independent bits, enabling read (r), write (w), and execute (x)
 * permissions.
 *
 * Values:
 * - 0b000 - An attempted access of that mode may be terminated with an access
 *     error (if not allowed by another descriptor) and the access not performed.
 * - 0b001 - Allows the given access type to occur
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC_M3UM field. */
#define MPU_RD_RGDAAC_M3UM(base, index) ((MPU_RGDAAC_REG(base, index) & MPU_RGDAAC_M3UM_MASK) >> MPU_RGDAAC_M3UM_SHIFT)
#define MPU_BRD_RGDAAC_M3UM(base, index) (BME_UBFX32(&MPU_RGDAAC_REG(base, index), MPU_RGDAAC_M3UM_SHIFT, MPU_RGDAAC_M3UM_WIDTH))

/*! @brief Set the M3UM field to a new value. */
#define MPU_WR_RGDAAC_M3UM(base, index, value) (MPU_RMW_RGDAAC(base, index, MPU_RGDAAC_M3UM_MASK, MPU_RGDAAC_M3UM(value)))
#define MPU_BWR_RGDAAC_M3UM(base, index, value) (BME_BFI32(&MPU_RGDAAC_REG(base, index), ((uint32_t)(value) << MPU_RGDAAC_M3UM_SHIFT), MPU_RGDAAC_M3UM_SHIFT, MPU_RGDAAC_M3UM_WIDTH))
/*@}*/

/*!
 * @name Register MPU_RGDAAC, field M3SM[22:21] (RW)
 *
 * Defines the access controls for bus master 3 in Supervisor mode.
 *
 * Values:
 * - 0b00 - r/w/x; read, write and execute allowed
 * - 0b01 - r/x; read and execute allowed, but no write
 * - 0b10 - r/w; read and write allowed, but no execute
 * - 0b11 - Same as User mode defined in M3UM
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC_M3SM field. */
#define MPU_RD_RGDAAC_M3SM(base, index) ((MPU_RGDAAC_REG(base, index) & MPU_RGDAAC_M3SM_MASK) >> MPU_RGDAAC_M3SM_SHIFT)
#define MPU_BRD_RGDAAC_M3SM(base, index) (BME_UBFX32(&MPU_RGDAAC_REG(base, index), MPU_RGDAAC_M3SM_SHIFT, MPU_RGDAAC_M3SM_WIDTH))

/*! @brief Set the M3SM field to a new value. */
#define MPU_WR_RGDAAC_M3SM(base, index, value) (MPU_RMW_RGDAAC(base, index, MPU_RGDAAC_M3SM_MASK, MPU_RGDAAC_M3SM(value)))
#define MPU_BWR_RGDAAC_M3SM(base, index, value) (BME_BFI32(&MPU_RGDAAC_REG(base, index), ((uint32_t)(value) << MPU_RGDAAC_M3SM_SHIFT), MPU_RGDAAC_M3SM_SHIFT, MPU_RGDAAC_M3SM_WIDTH))
/*@}*/

/*!
 * @name Register MPU_RGDAAC, field M3PE[23] (RW)
 *
 * Values:
 * - 0b0 - Do not include the process identifier in the evaluation
 * - 0b1 - Include the process identifier and mask (RGDn.RGDAAC) in the region
 *     hit evaluation
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC_M3PE field. */
#define MPU_RD_RGDAAC_M3PE(base, index) ((MPU_RGDAAC_REG(base, index) & MPU_RGDAAC_M3PE_MASK) >> MPU_RGDAAC_M3PE_SHIFT)
#define MPU_BRD_RGDAAC_M3PE(base, index) (BME_UBFX32(&MPU_RGDAAC_REG(base, index), MPU_RGDAAC_M3PE_SHIFT, MPU_RGDAAC_M3PE_WIDTH))

/*! @brief Set the M3PE field to a new value. */
#define MPU_WR_RGDAAC_M3PE(base, index, value) (MPU_RMW_RGDAAC(base, index, MPU_RGDAAC_M3PE_MASK, MPU_RGDAAC_M3PE(value)))
#define MPU_BWR_RGDAAC_M3PE(base, index, value) (BME_BFI32(&MPU_RGDAAC_REG(base, index), ((uint32_t)(value) << MPU_RGDAAC_M3PE_SHIFT), MPU_RGDAAC_M3PE_SHIFT, MPU_RGDAAC_M3PE_WIDTH))
/*@}*/

/*!
 * @name Register MPU_RGDAAC, field M4WE[24] (RW)
 *
 * Values:
 * - 0b0 - Bus master 4 writes terminate with an access error and the write is
 *     not performed
 * - 0b1 - Bus master 4 writes allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC_M4WE field. */
#define MPU_RD_RGDAAC_M4WE(base, index) ((MPU_RGDAAC_REG(base, index) & MPU_RGDAAC_M4WE_MASK) >> MPU_RGDAAC_M4WE_SHIFT)
#define MPU_BRD_RGDAAC_M4WE(base, index) (BME_UBFX32(&MPU_RGDAAC_REG(base, index), MPU_RGDAAC_M4WE_SHIFT, MPU_RGDAAC_M4WE_WIDTH))

/*! @brief Set the M4WE field to a new value. */
#define MPU_WR_RGDAAC_M4WE(base, index, value) (MPU_RMW_RGDAAC(base, index, MPU_RGDAAC_M4WE_MASK, MPU_RGDAAC_M4WE(value)))
#define MPU_BWR_RGDAAC_M4WE(base, index, value) (BME_BFI32(&MPU_RGDAAC_REG(base, index), ((uint32_t)(value) << MPU_RGDAAC_M4WE_SHIFT), MPU_RGDAAC_M4WE_SHIFT, MPU_RGDAAC_M4WE_WIDTH))
/*@}*/

/*!
 * @name Register MPU_RGDAAC, field M4RE[25] (RW)
 *
 * Values:
 * - 0b0 - Bus master 4 reads terminate with an access error and the read is not
 *     performed
 * - 0b1 - Bus master 4 reads allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC_M4RE field. */
#define MPU_RD_RGDAAC_M4RE(base, index) ((MPU_RGDAAC_REG(base, index) & MPU_RGDAAC_M4RE_MASK) >> MPU_RGDAAC_M4RE_SHIFT)
#define MPU_BRD_RGDAAC_M4RE(base, index) (BME_UBFX32(&MPU_RGDAAC_REG(base, index), MPU_RGDAAC_M4RE_SHIFT, MPU_RGDAAC_M4RE_WIDTH))

/*! @brief Set the M4RE field to a new value. */
#define MPU_WR_RGDAAC_M4RE(base, index, value) (MPU_RMW_RGDAAC(base, index, MPU_RGDAAC_M4RE_MASK, MPU_RGDAAC_M4RE(value)))
#define MPU_BWR_RGDAAC_M4RE(base, index, value) (BME_BFI32(&MPU_RGDAAC_REG(base, index), ((uint32_t)(value) << MPU_RGDAAC_M4RE_SHIFT), MPU_RGDAAC_M4RE_SHIFT, MPU_RGDAAC_M4RE_WIDTH))
/*@}*/

/*!
 * @name Register MPU_RGDAAC, field M5WE[26] (RW)
 *
 * Values:
 * - 0b0 - Bus master 5 writes terminate with an access error and the write is
 *     not performed
 * - 0b1 - Bus master 5 writes allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC_M5WE field. */
#define MPU_RD_RGDAAC_M5WE(base, index) ((MPU_RGDAAC_REG(base, index) & MPU_RGDAAC_M5WE_MASK) >> MPU_RGDAAC_M5WE_SHIFT)
#define MPU_BRD_RGDAAC_M5WE(base, index) (BME_UBFX32(&MPU_RGDAAC_REG(base, index), MPU_RGDAAC_M5WE_SHIFT, MPU_RGDAAC_M5WE_WIDTH))

/*! @brief Set the M5WE field to a new value. */
#define MPU_WR_RGDAAC_M5WE(base, index, value) (MPU_RMW_RGDAAC(base, index, MPU_RGDAAC_M5WE_MASK, MPU_RGDAAC_M5WE(value)))
#define MPU_BWR_RGDAAC_M5WE(base, index, value) (BME_BFI32(&MPU_RGDAAC_REG(base, index), ((uint32_t)(value) << MPU_RGDAAC_M5WE_SHIFT), MPU_RGDAAC_M5WE_SHIFT, MPU_RGDAAC_M5WE_WIDTH))
/*@}*/

/*!
 * @name Register MPU_RGDAAC, field M5RE[27] (RW)
 *
 * Values:
 * - 0b0 - Bus master 5 reads terminate with an access error and the read is not
 *     performed
 * - 0b1 - Bus master 5 reads allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC_M5RE field. */
#define MPU_RD_RGDAAC_M5RE(base, index) ((MPU_RGDAAC_REG(base, index) & MPU_RGDAAC_M5RE_MASK) >> MPU_RGDAAC_M5RE_SHIFT)
#define MPU_BRD_RGDAAC_M5RE(base, index) (BME_UBFX32(&MPU_RGDAAC_REG(base, index), MPU_RGDAAC_M5RE_SHIFT, MPU_RGDAAC_M5RE_WIDTH))

/*! @brief Set the M5RE field to a new value. */
#define MPU_WR_RGDAAC_M5RE(base, index, value) (MPU_RMW_RGDAAC(base, index, MPU_RGDAAC_M5RE_MASK, MPU_RGDAAC_M5RE(value)))
#define MPU_BWR_RGDAAC_M5RE(base, index, value) (BME_BFI32(&MPU_RGDAAC_REG(base, index), ((uint32_t)(value) << MPU_RGDAAC_M5RE_SHIFT), MPU_RGDAAC_M5RE_SHIFT, MPU_RGDAAC_M5RE_WIDTH))
/*@}*/

/*!
 * @name Register MPU_RGDAAC, field M6WE[28] (RW)
 *
 * Values:
 * - 0b0 - Bus master 6 writes terminate with an access error and the write is
 *     not performed
 * - 0b1 - Bus master 6 writes allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC_M6WE field. */
#define MPU_RD_RGDAAC_M6WE(base, index) ((MPU_RGDAAC_REG(base, index) & MPU_RGDAAC_M6WE_MASK) >> MPU_RGDAAC_M6WE_SHIFT)
#define MPU_BRD_RGDAAC_M6WE(base, index) (BME_UBFX32(&MPU_RGDAAC_REG(base, index), MPU_RGDAAC_M6WE_SHIFT, MPU_RGDAAC_M6WE_WIDTH))

/*! @brief Set the M6WE field to a new value. */
#define MPU_WR_RGDAAC_M6WE(base, index, value) (MPU_RMW_RGDAAC(base, index, MPU_RGDAAC_M6WE_MASK, MPU_RGDAAC_M6WE(value)))
#define MPU_BWR_RGDAAC_M6WE(base, index, value) (BME_BFI32(&MPU_RGDAAC_REG(base, index), ((uint32_t)(value) << MPU_RGDAAC_M6WE_SHIFT), MPU_RGDAAC_M6WE_SHIFT, MPU_RGDAAC_M6WE_WIDTH))
/*@}*/

/*!
 * @name Register MPU_RGDAAC, field M6RE[29] (RW)
 *
 * Values:
 * - 0b0 - Bus master 6 reads terminate with an access error and the read is not
 *     performed
 * - 0b1 - Bus master 6 reads allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC_M6RE field. */
#define MPU_RD_RGDAAC_M6RE(base, index) ((MPU_RGDAAC_REG(base, index) & MPU_RGDAAC_M6RE_MASK) >> MPU_RGDAAC_M6RE_SHIFT)
#define MPU_BRD_RGDAAC_M6RE(base, index) (BME_UBFX32(&MPU_RGDAAC_REG(base, index), MPU_RGDAAC_M6RE_SHIFT, MPU_RGDAAC_M6RE_WIDTH))

/*! @brief Set the M6RE field to a new value. */
#define MPU_WR_RGDAAC_M6RE(base, index, value) (MPU_RMW_RGDAAC(base, index, MPU_RGDAAC_M6RE_MASK, MPU_RGDAAC_M6RE(value)))
#define MPU_BWR_RGDAAC_M6RE(base, index, value) (BME_BFI32(&MPU_RGDAAC_REG(base, index), ((uint32_t)(value) << MPU_RGDAAC_M6RE_SHIFT), MPU_RGDAAC_M6RE_SHIFT, MPU_RGDAAC_M6RE_WIDTH))
/*@}*/

/*!
 * @name Register MPU_RGDAAC, field M7WE[30] (RW)
 *
 * Values:
 * - 0b0 - Bus master 7 writes terminate with an access error and the write is
 *     not performed
 * - 0b1 - Bus master 7 writes allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC_M7WE field. */
#define MPU_RD_RGDAAC_M7WE(base, index) ((MPU_RGDAAC_REG(base, index) & MPU_RGDAAC_M7WE_MASK) >> MPU_RGDAAC_M7WE_SHIFT)
#define MPU_BRD_RGDAAC_M7WE(base, index) (BME_UBFX32(&MPU_RGDAAC_REG(base, index), MPU_RGDAAC_M7WE_SHIFT, MPU_RGDAAC_M7WE_WIDTH))

/*! @brief Set the M7WE field to a new value. */
#define MPU_WR_RGDAAC_M7WE(base, index, value) (MPU_RMW_RGDAAC(base, index, MPU_RGDAAC_M7WE_MASK, MPU_RGDAAC_M7WE(value)))
#define MPU_BWR_RGDAAC_M7WE(base, index, value) (BME_BFI32(&MPU_RGDAAC_REG(base, index), ((uint32_t)(value) << MPU_RGDAAC_M7WE_SHIFT), MPU_RGDAAC_M7WE_SHIFT, MPU_RGDAAC_M7WE_WIDTH))
/*@}*/

/*!
 * @name Register MPU_RGDAAC, field M7RE[31] (RW)
 *
 * Values:
 * - 0b0 - Bus master 7 reads terminate with an access error and the read is not
 *     performed
 * - 0b1 - Bus master 7 reads allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC_M7RE field. */
#define MPU_RD_RGDAAC_M7RE(base, index) ((MPU_RGDAAC_REG(base, index) & MPU_RGDAAC_M7RE_MASK) >> MPU_RGDAAC_M7RE_SHIFT)
#define MPU_BRD_RGDAAC_M7RE(base, index) (BME_UBFX32(&MPU_RGDAAC_REG(base, index), MPU_RGDAAC_M7RE_SHIFT, MPU_RGDAAC_M7RE_WIDTH))

/*! @brief Set the M7RE field to a new value. */
#define MPU_WR_RGDAAC_M7RE(base, index, value) (MPU_RMW_RGDAAC(base, index, MPU_RGDAAC_M7RE_MASK, MPU_RGDAAC_M7RE(value)))
#define MPU_BWR_RGDAAC_M7RE(base, index, value) (BME_BFI32(&MPU_RGDAAC_REG(base, index), ((uint32_t)(value) << MPU_RGDAAC_M7RE_SHIFT), MPU_RGDAAC_M7RE_SHIFT, MPU_RGDAAC_M7RE_WIDTH))
/*@}*/

/*
 * MKM34Z7 MTB
 *
 * Micro Trace Buffer
 *
 * Registers defined in this header file:
 * - MTB_POSITION - MTB Position Register
 * - MTB_MASTER - MTB Master Register
 * - MTB_FLOW - MTB Flow Register
 * - MTB_BASE - MTB Base Register
 * - MTB_MODECTRL - Integration Mode Control Register
 * - MTB_TAGSET - Claim TAG Set Register
 * - MTB_TAGCLEAR - Claim TAG Clear Register
 * - MTB_LOCKACCESS - Lock Access Register
 * - MTB_LOCKSTAT - Lock Status Register
 * - MTB_AUTHSTAT - Authentication Status Register
 * - MTB_DEVICEARCH - Device Architecture Register
 * - MTB_DEVICECFG - Device Configuration Register
 * - MTB_DEVICETYPID - Device Type Identifier Register
 * - MTB_PERIPHID - Peripheral ID Register
 * - MTB_COMPID - Component ID Register
 */

#define MTB_INSTANCE_COUNT (1U) /*!< Number of instances of the MTB module. */
#define MTB_IDX (0U) /*!< Instance number for MTB. */

/*******************************************************************************
 * MTB_POSITION - MTB Position Register
 ******************************************************************************/

/*!
 * @brief MTB_POSITION - MTB Position Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The MTB_POSITION register contains the Trace Write Address Pointer and Wrap
 * fields. This register can be modified by the explicit programming model writes.
 * It is also automatically updated by the MTB hardware when trace packets are
 * being recorded. The base address of the system RAM in the memory map dictates
 * special consideration for the placement of the MTB. Consider the following
 * guidelines: For the standard configuration where the size of the MTB is <= 25% of
 * the total RAM capacity, it is recommended the MTB be based at the address
 * defined by the MTB_BASE register. The read-only MTB_BASE register is defined by
 * the expression (0x2000_0000 - (RAM_Size/4)). For this configuration, the
 * MTB_POSITION register is initialized to MTB_BASE & 0x0000_7FF8. If the size of the
 * MTB is more than 25% but less than or equal to 50% of the total RAM capacity, it
 * is recommended the MTB be based at address 0x2000_0000. In this
 * configuration, the MTB_POSITION register is initialized to (0x2000_0000 & 0x0000_7FF8) =
 * 0x0000_00000. Following these two suggested placements provides a full-featured
 * circular memory buffer containing program trace packets. In the unlikely event
 * an even larger trace buffer is required, a write-once capacity of 75% of the
 * total RAM capacity can be based at address 0x2000_0000. The MTB_POSITION
 * register is initialized to (0x2000_0000 & 0x0000_7FF8) = 0x0000_0000. However, this
 * configuration cannot support operation as a circular queue and instead
 * requires the use of the MTB_FLOW[WATERMARK] capability to automatically disable
 * tracing or halting the processor as the number of packet writes approach the
 * buffer capacity. See the MTB_FLOW register description for more details.
 */
/*!
 * @name Constants and macros for entire MTB_POSITION register
 */
/*@{*/
#define MTB_RD_POSITION(base)    (MTB_POSITION_REG(base))
#define MTB_WR_POSITION(base, value) (MTB_POSITION_REG(base) = (value))
#define MTB_RMW_POSITION(base, mask, value) (MTB_WR_POSITION(base, (MTB_RD_POSITION(base) & ~(mask)) | (value)))
#define MTB_SET_POSITION(base, value) (MTB_WR_POSITION(base, MTB_RD_POSITION(base) |  (value)))
#define MTB_CLR_POSITION(base, value) (MTB_WR_POSITION(base, MTB_RD_POSITION(base) & ~(value)))
#define MTB_TOG_POSITION(base, value) (MTB_WR_POSITION(base, MTB_RD_POSITION(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual MTB_POSITION bitfields
 */

/*!
 * @name Register MTB_POSITION, field WRAP[2] (RW)
 *
 * This field is set to 1 automatically when the POINTER value wraps as
 * determined by the MTB_MASTER[MASK] field in the MASTER Trace Control Register. A debug
 * agent might use the WRAP field to determine whether the trace information
 * above and below the pointer address is valid.
 */
/*@{*/
/*! @brief Read current value of the MTB_POSITION_WRAP field. */
#define MTB_RD_POSITION_WRAP(base) ((MTB_POSITION_REG(base) & MTB_POSITION_WRAP_MASK) >> MTB_POSITION_WRAP_SHIFT)
#define MTB_BRD_POSITION_WRAP(base) (MTB_RD_POSITION_WRAP(base))

/*! @brief Set the WRAP field to a new value. */
#define MTB_WR_POSITION_WRAP(base, value) (MTB_RMW_POSITION(base, MTB_POSITION_WRAP_MASK, MTB_POSITION_WRAP(value)))
#define MTB_BWR_POSITION_WRAP(base, value) (MTB_WR_POSITION_WRAP(base, value))
/*@}*/

/*!
 * @name Register MTB_POSITION, field POINTER[31:3] (RW)
 *
 * Because a packet consists of two words, the POINTER field is the address of
 * the first word of a packet. This field contains bits[31:3] of the RAM address
 * where the next trace packet is written. Therefore, it points to an unused
 * location and is automatically incremented. A debug agent can calculate the system
 * memory map address for the current location in the MTB using the following
 * "generic" equation: Given mtb_size = 1 << (MTB_MASTER[MASK] + 4), systemAddress =
 * MTB_BASE + (((MTB_POSITION & 0xFFFF_FFF8) + (mtb_size - (MTB_BASE &
 * (mtb_size-1)))) & 0x0000_7FF8); For this device, a simpler expression also applies. See
 * the following pseudo-code: if ((MTB_POSITION >> 13) == 0x3) systemAddress =
 * (0x1FFF << 16) + (0x1 << 15) + (MTB_POSITION & 0x7FF8); else systemAddress =
 * (0x2000 << 16) + (0x0 << 15) + (MTB_POSITION & 0x7FF8); The size of the RAM is
 * parameterized and the most significant bits of the POINTER field are RAZ/WI. For
 * these devices, POSITION[31:15] == POSITION[POINTER[28:12]] are RAZ/WI.
 * Therefore, the active bits in this field are POSITION[14:3] ==
 * POSITION[POINTER[11:0]].
 */
/*@{*/
/*! @brief Read current value of the MTB_POSITION_POINTER field. */
#define MTB_RD_POSITION_POINTER(base) ((MTB_POSITION_REG(base) & MTB_POSITION_POINTER_MASK) >> MTB_POSITION_POINTER_SHIFT)
#define MTB_BRD_POSITION_POINTER(base) (MTB_RD_POSITION_POINTER(base))

/*! @brief Set the POINTER field to a new value. */
#define MTB_WR_POSITION_POINTER(base, value) (MTB_RMW_POSITION(base, MTB_POSITION_POINTER_MASK, MTB_POSITION_POINTER(value)))
#define MTB_BWR_POSITION_POINTER(base, value) (MTB_WR_POSITION_POINTER(base, value))
/*@}*/

/*******************************************************************************
 * MTB_MASTER - MTB Master Register
 ******************************************************************************/

/*!
 * @brief MTB_MASTER - MTB Master Register (RW)
 *
 * Reset value: 0x00000080U
 *
 * The MTB_MASTER register contains the main program trace enable plus other
 * trace controls. This register can be modified by the explicit programming model
 * writes. MTB_MASTER[EN] and MTB_MASTER[HALTREQ] fields are also automatically
 * updated by the MTB hardware. Before MTB_MASTER[EN] or MTB_MASTER[TSTARTEN] are
 * set to 1, the software must initialize the MTB_POSITION and MTB_FLOW registers.
 * If MTB_FLOW[WATERMARK] is used to stop tracing or to halt the processor,
 * MTB_MASTER[MASK] must still be set to a value that prevents MTB_POSITION[POINTER]
 * from wrapping before it reaches the MTB_FLOW[WATERMARK] value. The format of
 * this mask field is different than MTBDWT_MASKn[MASK].
 */
/*!
 * @name Constants and macros for entire MTB_MASTER register
 */
/*@{*/
#define MTB_RD_MASTER(base)      (MTB_MASTER_REG(base))
#define MTB_WR_MASTER(base, value) (MTB_MASTER_REG(base) = (value))
#define MTB_RMW_MASTER(base, mask, value) (MTB_WR_MASTER(base, (MTB_RD_MASTER(base) & ~(mask)) | (value)))
#define MTB_SET_MASTER(base, value) (MTB_WR_MASTER(base, MTB_RD_MASTER(base) |  (value)))
#define MTB_CLR_MASTER(base, value) (MTB_WR_MASTER(base, MTB_RD_MASTER(base) & ~(value)))
#define MTB_TOG_MASTER(base, value) (MTB_WR_MASTER(base, MTB_RD_MASTER(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual MTB_MASTER bitfields
 */

/*!
 * @name Register MTB_MASTER, field MASK[4:0] (RW)
 *
 * This value determines the maximum size of the trace buffer in RAM. It
 * specifies the most-significant bit of the MTB_POSITION[POINTER] field that can be
 * updated by automatic increment. If the trace tries to advance past this power of
 * 2, the MTB_POSITION[WRAP] bit is set to 1, the MTB_POSITION[MASK+3:3] ==
 * MTB_POSITION[POINTER[MASK:0]] bits are set to 0, and the MTB_POSITION[14:MASK+3] ==
 * MTB_POSITION[POINTER[11:MASK+1]] bits remain unchanged. This field causes the
 * trace packet information to be stored in a circular buffer of size 2^[MASK+4]
 * bytes, that can be positioned in memory at multiples of this size. As
 * detailed in the MTB_POSITION description, typical "upper limits" for the MTB size are
 * RAM_Size/4 or RAM_Size/2. Values greater than the maximum have the same
 * effect as the maximum.
 */
/*@{*/
/*! @brief Read current value of the MTB_MASTER_MASK field. */
#define MTB_RD_MASTER_MASK(base) ((MTB_MASTER_REG(base) & MTB_MASTER_MASK_MASK) >> MTB_MASTER_MASK_SHIFT)
#define MTB_BRD_MASTER_MASK(base) (MTB_RD_MASTER_MASK(base))

/*! @brief Set the MASK field to a new value. */
#define MTB_WR_MASTER_MASK(base, value) (MTB_RMW_MASTER(base, MTB_MASTER_MASK_MASK, MTB_MASTER_MASK(value)))
#define MTB_BWR_MASTER_MASK(base, value) (MTB_WR_MASTER_MASK(base, value))
/*@}*/

/*!
 * @name Register MTB_MASTER, field TSTARTEN[5] (RW)
 *
 * If this field is 1 and the TSTART signal is HIGH, then EN is set to 1.
 * Tracing continues until a stop condition occurs.
 */
/*@{*/
/*! @brief Read current value of the MTB_MASTER_TSTARTEN field. */
#define MTB_RD_MASTER_TSTARTEN(base) ((MTB_MASTER_REG(base) & MTB_MASTER_TSTARTEN_MASK) >> MTB_MASTER_TSTARTEN_SHIFT)
#define MTB_BRD_MASTER_TSTARTEN(base) (MTB_RD_MASTER_TSTARTEN(base))

/*! @brief Set the TSTARTEN field to a new value. */
#define MTB_WR_MASTER_TSTARTEN(base, value) (MTB_RMW_MASTER(base, MTB_MASTER_TSTARTEN_MASK, MTB_MASTER_TSTARTEN(value)))
#define MTB_BWR_MASTER_TSTARTEN(base, value) (MTB_WR_MASTER_TSTARTEN(base, value))
/*@}*/

/*!
 * @name Register MTB_MASTER, field TSTOPEN[6] (RW)
 *
 * If this field is 1 and the TSTOP signal is HIGH, then EN is set to 0. If a
 * trace packet is being written to memory, the write is completed before tracing
 * is stopped.
 */
/*@{*/
/*! @brief Read current value of the MTB_MASTER_TSTOPEN field. */
#define MTB_RD_MASTER_TSTOPEN(base) ((MTB_MASTER_REG(base) & MTB_MASTER_TSTOPEN_MASK) >> MTB_MASTER_TSTOPEN_SHIFT)
#define MTB_BRD_MASTER_TSTOPEN(base) (MTB_RD_MASTER_TSTOPEN(base))

/*! @brief Set the TSTOPEN field to a new value. */
#define MTB_WR_MASTER_TSTOPEN(base, value) (MTB_RMW_MASTER(base, MTB_MASTER_TSTOPEN_MASK, MTB_MASTER_TSTOPEN(value)))
#define MTB_BWR_MASTER_TSTOPEN(base, value) (MTB_WR_MASTER_TSTOPEN(base, value))
/*@}*/

/*!
 * @name Register MTB_MASTER, field SFRWPRIV[7] (RW)
 *
 * If this field is 0, then user or privileged AHB read and write accesses to
 * the MTB_RAM Special Function Registers (programming model) are permitted. If
 * this field is 1, then only privileged write accesses are permitted; user write
 * accesses are ignored. The HPROT[1] signal determines if an access is user or
 * privileged. Note MTB_RAM SFR read access are not controlled by this bit and are
 * always permitted.
 */
/*@{*/
/*! @brief Read current value of the MTB_MASTER_SFRWPRIV field. */
#define MTB_RD_MASTER_SFRWPRIV(base) ((MTB_MASTER_REG(base) & MTB_MASTER_SFRWPRIV_MASK) >> MTB_MASTER_SFRWPRIV_SHIFT)
#define MTB_BRD_MASTER_SFRWPRIV(base) (MTB_RD_MASTER_SFRWPRIV(base))

/*! @brief Set the SFRWPRIV field to a new value. */
#define MTB_WR_MASTER_SFRWPRIV(base, value) (MTB_RMW_MASTER(base, MTB_MASTER_SFRWPRIV_MASK, MTB_MASTER_SFRWPRIV(value)))
#define MTB_BWR_MASTER_SFRWPRIV(base, value) (MTB_WR_MASTER_SFRWPRIV(base, value))
/*@}*/

/*!
 * @name Register MTB_MASTER, field RAMPRIV[8] (RW)
 *
 * If this field is 0, then user or privileged AHB read and write accesses to
 * the RAM are permitted. If this field is 1, then only privileged AHB read and
 * write accesses to the RAM are permitted and user accesses are RAZ/WI. The
 * HPROT[1] signal determines if an access is a user or privileged mode reference.
 */
/*@{*/
/*! @brief Read current value of the MTB_MASTER_RAMPRIV field. */
#define MTB_RD_MASTER_RAMPRIV(base) ((MTB_MASTER_REG(base) & MTB_MASTER_RAMPRIV_MASK) >> MTB_MASTER_RAMPRIV_SHIFT)
#define MTB_BRD_MASTER_RAMPRIV(base) (MTB_RD_MASTER_RAMPRIV(base))

/*! @brief Set the RAMPRIV field to a new value. */
#define MTB_WR_MASTER_RAMPRIV(base, value) (MTB_RMW_MASTER(base, MTB_MASTER_RAMPRIV_MASK, MTB_MASTER_RAMPRIV(value)))
#define MTB_BWR_MASTER_RAMPRIV(base, value) (MTB_WR_MASTER_RAMPRIV(base, value))
/*@}*/

/*!
 * @name Register MTB_MASTER, field HALTREQ[9] (RW)
 *
 * This field is connected to the halt request signal of the trace logic,
 * EDBGRQ. When HALTREQ is set to 1, the EDBFGRQ is asserted if DBGEN (invasive debug
 * enable, one of the debug authentication interface signals) is also HIGH.
 * HALTREQ can be automatically set to 1 using MTB_FLOW[WATERMARK].
 */
/*@{*/
/*! @brief Read current value of the MTB_MASTER_HALTREQ field. */
#define MTB_RD_MASTER_HALTREQ(base) ((MTB_MASTER_REG(base) & MTB_MASTER_HALTREQ_MASK) >> MTB_MASTER_HALTREQ_SHIFT)
#define MTB_BRD_MASTER_HALTREQ(base) (MTB_RD_MASTER_HALTREQ(base))

/*! @brief Set the HALTREQ field to a new value. */
#define MTB_WR_MASTER_HALTREQ(base, value) (MTB_RMW_MASTER(base, MTB_MASTER_HALTREQ_MASK, MTB_MASTER_HALTREQ(value)))
#define MTB_BWR_MASTER_HALTREQ(base, value) (MTB_WR_MASTER_HALTREQ(base, value))
/*@}*/

/*!
 * @name Register MTB_MASTER, field EN[31] (RW)
 *
 * When this field is 1, trace data is written into the RAM memory location
 * addressed by MTB_POSITION[POINTER]. The MTB_POSITION[POINTER] value auto
 * increments after the trace data packet is written. EN can be automatically set to 0
 * using the MTB_FLOW[WATERMARK] field and the MTB_FLOW[AUTOSTOP] bit. EN is
 * automatically set to 1 if TSTARTEN is 1 and the TSTART signal is HIGH. EN is
 * automatically set to 0 if TSTOPEN is 1 and the TSTOP signal is HIGH. If EN is set to 0
 * because MTB_FLOW[WATERMARK] is set, then it is not automatically set to 1 if
 * TSTARTEN is 1 and the TSTART input is HIGH. In this case, tracing can only be
 * restarted if MTB_FLOW[WATERMARK] or MTB_POSITION[POINTER] value is changed by
 * software.
 */
/*@{*/
/*! @brief Read current value of the MTB_MASTER_EN field. */
#define MTB_RD_MASTER_EN(base) ((MTB_MASTER_REG(base) & MTB_MASTER_EN_MASK) >> MTB_MASTER_EN_SHIFT)
#define MTB_BRD_MASTER_EN(base) (MTB_RD_MASTER_EN(base))

/*! @brief Set the EN field to a new value. */
#define MTB_WR_MASTER_EN(base, value) (MTB_RMW_MASTER(base, MTB_MASTER_EN_MASK, MTB_MASTER_EN(value)))
#define MTB_BWR_MASTER_EN(base, value) (MTB_WR_MASTER_EN(base, value))
/*@}*/

/*******************************************************************************
 * MTB_FLOW - MTB Flow Register
 ******************************************************************************/

/*!
 * @brief MTB_FLOW - MTB Flow Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The MTB_FLOW register contains the watermark address and the
 * autostop/autohalt control bits. If tracing is stopped using the watermark autostop feature, it
 * cannot be restarted until software clears the watermark autostop. This can be
 * achieved in one of the following ways: Changing the MTB_POSITION[POINTER]
 * field value to point to the beginning of the trace buffer, or Setting
 * MTB_FLOW[AUTOSTOP] = 0. A debug agent can use MTB_FLOW[AUTOSTOP] to fill the trace buffer
 * once only without halting the processor. A debug agent can use
 * MTB_FLOW[AUTOHALT] to fill the trace buffer once before causing the Cortex-M0+ processor to
 * enter the Debug state. To enter Debug state, the Cortex-M0+ processor might
 * have to perform additional branch type operations. Therefore, the
 * MTB_FLOW[WATERMARK] field must be set below the final entry in the trace buffer region.
 */
/*!
 * @name Constants and macros for entire MTB_FLOW register
 */
/*@{*/
#define MTB_RD_FLOW(base)        (MTB_FLOW_REG(base))
#define MTB_WR_FLOW(base, value) (MTB_FLOW_REG(base) = (value))
#define MTB_RMW_FLOW(base, mask, value) (MTB_WR_FLOW(base, (MTB_RD_FLOW(base) & ~(mask)) | (value)))
#define MTB_SET_FLOW(base, value) (MTB_WR_FLOW(base, MTB_RD_FLOW(base) |  (value)))
#define MTB_CLR_FLOW(base, value) (MTB_WR_FLOW(base, MTB_RD_FLOW(base) & ~(value)))
#define MTB_TOG_FLOW(base, value) (MTB_WR_FLOW(base, MTB_RD_FLOW(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual MTB_FLOW bitfields
 */

/*!
 * @name Register MTB_FLOW, field AUTOSTOP[0] (RW)
 *
 * If this field is 1 and WATERMARK is equal to MTB_POSITION[POINTER], then
 * MTB_MASTER[EN] is automatically set to 0. This stops tracing.
 */
/*@{*/
/*! @brief Read current value of the MTB_FLOW_AUTOSTOP field. */
#define MTB_RD_FLOW_AUTOSTOP(base) ((MTB_FLOW_REG(base) & MTB_FLOW_AUTOSTOP_MASK) >> MTB_FLOW_AUTOSTOP_SHIFT)
#define MTB_BRD_FLOW_AUTOSTOP(base) (MTB_RD_FLOW_AUTOSTOP(base))

/*! @brief Set the AUTOSTOP field to a new value. */
#define MTB_WR_FLOW_AUTOSTOP(base, value) (MTB_RMW_FLOW(base, MTB_FLOW_AUTOSTOP_MASK, MTB_FLOW_AUTOSTOP(value)))
#define MTB_BWR_FLOW_AUTOSTOP(base, value) (MTB_WR_FLOW_AUTOSTOP(base, value))
/*@}*/

/*!
 * @name Register MTB_FLOW, field AUTOHALT[1] (RW)
 *
 * If this field is 1 and WATERMARK is equal to MTB_POSITION[POINTER], then
 * MTB_MASTER[HALTREQ] is automatically set to 1. If the DBGEN signal is HIGH, the
 * MTB asserts this halt request to the Cortex-M0+ processor by asserting the
 * EDBGRQ signal.
 */
/*@{*/
/*! @brief Read current value of the MTB_FLOW_AUTOHALT field. */
#define MTB_RD_FLOW_AUTOHALT(base) ((MTB_FLOW_REG(base) & MTB_FLOW_AUTOHALT_MASK) >> MTB_FLOW_AUTOHALT_SHIFT)
#define MTB_BRD_FLOW_AUTOHALT(base) (MTB_RD_FLOW_AUTOHALT(base))

/*! @brief Set the AUTOHALT field to a new value. */
#define MTB_WR_FLOW_AUTOHALT(base, value) (MTB_RMW_FLOW(base, MTB_FLOW_AUTOHALT_MASK, MTB_FLOW_AUTOHALT(value)))
#define MTB_BWR_FLOW_AUTOHALT(base, value) (MTB_WR_FLOW_AUTOHALT(base, value))
/*@}*/

/*!
 * @name Register MTB_FLOW, field WATERMARK[31:3] (RW)
 *
 * This field contains an address in the same format as the
 * MTB_POSITION[POINTER] field. When MTB_POSITION[POINTER] matches the WATERMARK field value, actions
 * defined by the AUTOHALT and AUTOSTOP bits are performed.
 */
/*@{*/
/*! @brief Read current value of the MTB_FLOW_WATERMARK field. */
#define MTB_RD_FLOW_WATERMARK(base) ((MTB_FLOW_REG(base) & MTB_FLOW_WATERMARK_MASK) >> MTB_FLOW_WATERMARK_SHIFT)
#define MTB_BRD_FLOW_WATERMARK(base) (MTB_RD_FLOW_WATERMARK(base))

/*! @brief Set the WATERMARK field to a new value. */
#define MTB_WR_FLOW_WATERMARK(base, value) (MTB_RMW_FLOW(base, MTB_FLOW_WATERMARK_MASK, MTB_FLOW_WATERMARK(value)))
#define MTB_BWR_FLOW_WATERMARK(base, value) (MTB_WR_FLOW_WATERMARK(base, value))
/*@}*/

/*******************************************************************************
 * MTB_BASE - MTB Base Register
 ******************************************************************************/

/*!
 * @brief MTB_BASE - MTB Base Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The read-only MTB_BASE Register indicates where the RAM is located in the
 * system memory map. This register is provided to enable auto discovery of the MTB
 * RAM location, by a debug agent and is defined by a hardware design parameter.
 * For this device, the base address is defined by the expression:
 * MTB_BASE[BASEADDR] = 0x2000_0000 - (RAM_Size/4)
 */
/*!
 * @name Constants and macros for entire MTB_BASE register
 */
/*@{*/
#define MTB_RD_BASE(base)        (MTB_BASE_REG(base))
/*@}*/

/*******************************************************************************
 * MTB_MODECTRL - Integration Mode Control Register
 ******************************************************************************/

/*!
 * @brief MTB_MODECTRL - Integration Mode Control Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * This register enables the device to switch from a functional mode, or default
 * behavior, into integration mode. It is hardwired to specific values used
 * during the auto-discovery process by an external debug agent.
 */
/*!
 * @name Constants and macros for entire MTB_MODECTRL register
 */
/*@{*/
#define MTB_RD_MODECTRL(base)    (MTB_MODECTRL_REG(base))
/*@}*/

/*******************************************************************************
 * MTB_TAGSET - Claim TAG Set Register
 ******************************************************************************/

/*!
 * @brief MTB_TAGSET - Claim TAG Set Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The Claim Tag Set Register returns the number of bits that can be set on a
 * read, and enables individual bits to be set on a write. It is hardwired to
 * specific values used during the auto-discovery process by an external debug agent.
 */
/*!
 * @name Constants and macros for entire MTB_TAGSET register
 */
/*@{*/
#define MTB_RD_TAGSET(base)      (MTB_TAGSET_REG(base))
/*@}*/

/*******************************************************************************
 * MTB_TAGCLEAR - Claim TAG Clear Register
 ******************************************************************************/

/*!
 * @brief MTB_TAGCLEAR - Claim TAG Clear Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The read/write Claim Tag Clear Register is used to read the claim status on
 * debug resources. A read indicates the claim tag status. Writing 1 to a specific
 * bit clears the corresponding claim tag to 0. It is hardwired to specific
 * values used during the auto-discovery process by an external debug agent.
 */
/*!
 * @name Constants and macros for entire MTB_TAGCLEAR register
 */
/*@{*/
#define MTB_RD_TAGCLEAR(base)    (MTB_TAGCLEAR_REG(base))
/*@}*/

/*******************************************************************************
 * MTB_LOCKACCESS - Lock Access Register
 ******************************************************************************/

/*!
 * @brief MTB_LOCKACCESS - Lock Access Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The Lock Access Register enables a write access to component registers. It is
 * hardwired to specific values used during the auto-discovery process by an
 * external debug agent.
 */
/*!
 * @name Constants and macros for entire MTB_LOCKACCESS register
 */
/*@{*/
#define MTB_RD_LOCKACCESS(base)  (MTB_LOCKACCESS_REG(base))
/*@}*/

/*******************************************************************************
 * MTB_LOCKSTAT - Lock Status Register
 ******************************************************************************/

/*!
 * @brief MTB_LOCKSTAT - Lock Status Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The Lock Status Register indicates the status of the lock control mechanism.
 * This register is used in conjunction with the Lock Access Register. It is
 * hardwired to specific values used during the auto-discovery process by an external
 * debug agent.
 */
/*!
 * @name Constants and macros for entire MTB_LOCKSTAT register
 */
/*@{*/
#define MTB_RD_LOCKSTAT(base)    (MTB_LOCKSTAT_REG(base))
/*@}*/

/*******************************************************************************
 * MTB_AUTHSTAT - Authentication Status Register
 ******************************************************************************/

/*!
 * @brief MTB_AUTHSTAT - Authentication Status Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The Authentication Status Register reports the required security level and
 * current status of the security enable bit pairs. Where functionality changes on
 * a given security level, this change must be reported in this register. It is
 * connected to specific signals used during the auto-discovery process by an
 * external debug agent. MTB_AUTHSTAT[3:2] indicates if nonsecure, noninvasive debug
 * is enabled or disabled, while MTB_AUTHSTAT[1:0] indicates the enabled/disabled
 * state of nonsecure, invasive debug. For both 2-bit fields, 0b10 indicates the
 * functionality is disabled and 0b11 indicates it is enabled.
 */
/*!
 * @name Constants and macros for entire MTB_AUTHSTAT register
 */
/*@{*/
#define MTB_RD_AUTHSTAT(base)    (MTB_AUTHSTAT_REG(base))
/*@}*/

/*
 * Constants & macros for individual MTB_AUTHSTAT bitfields
 */

/*!
 * @name Register MTB_AUTHSTAT, field BIT0[0] (RO)
 *
 * Connected to DBGEN.
 */
/*@{*/
/*! @brief Read current value of the MTB_AUTHSTAT_BIT0 field. */
#define MTB_RD_AUTHSTAT_BIT0(base) ((MTB_AUTHSTAT_REG(base) & MTB_AUTHSTAT_BIT0_MASK) >> MTB_AUTHSTAT_BIT0_SHIFT)
#define MTB_BRD_AUTHSTAT_BIT0(base) (MTB_RD_AUTHSTAT_BIT0(base))
/*@}*/

/*!
 * @name Register MTB_AUTHSTAT, field BIT1[1] (ROO)
 *
 * Hardwired to 1.
 */
/*@{*/
/*! @brief Read current value of the MTB_AUTHSTAT_BIT1 field. */
#define MTB_RD_AUTHSTAT_BIT1(base) ((MTB_AUTHSTAT_REG(base) & MTB_AUTHSTAT_BIT1_MASK) >> MTB_AUTHSTAT_BIT1_SHIFT)
#define MTB_BRD_AUTHSTAT_BIT1(base) (MTB_RD_AUTHSTAT_BIT1(base))
/*@}*/

/*!
 * @name Register MTB_AUTHSTAT, field BIT2[2] (RO)
 *
 * Connected to NIDEN or DBGEN signal.
 */
/*@{*/
/*! @brief Read current value of the MTB_AUTHSTAT_BIT2 field. */
#define MTB_RD_AUTHSTAT_BIT2(base) ((MTB_AUTHSTAT_REG(base) & MTB_AUTHSTAT_BIT2_MASK) >> MTB_AUTHSTAT_BIT2_SHIFT)
#define MTB_BRD_AUTHSTAT_BIT2(base) (MTB_RD_AUTHSTAT_BIT2(base))
/*@}*/

/*!
 * @name Register MTB_AUTHSTAT, field BIT3[3] (ROO)
 *
 * Hardwired to 1.
 */
/*@{*/
/*! @brief Read current value of the MTB_AUTHSTAT_BIT3 field. */
#define MTB_RD_AUTHSTAT_BIT3(base) ((MTB_AUTHSTAT_REG(base) & MTB_AUTHSTAT_BIT3_MASK) >> MTB_AUTHSTAT_BIT3_SHIFT)
#define MTB_BRD_AUTHSTAT_BIT3(base) (MTB_RD_AUTHSTAT_BIT3(base))
/*@}*/

/*******************************************************************************
 * MTB_DEVICEARCH - Device Architecture Register
 ******************************************************************************/

/*!
 * @brief MTB_DEVICEARCH - Device Architecture Register (RO)
 *
 * Reset value: 0x47700A31U
 *
 * This register indicates the device architecture. It is hardwired to specific
 * values used during the auto-discovery process by an external debug agent.
 */
/*!
 * @name Constants and macros for entire MTB_DEVICEARCH register
 */
/*@{*/
#define MTB_RD_DEVICEARCH(base)  (MTB_DEVICEARCH_REG(base))
/*@}*/

/*******************************************************************************
 * MTB_DEVICECFG - Device Configuration Register
 ******************************************************************************/

/*!
 * @brief MTB_DEVICECFG - Device Configuration Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * This register indicates the device configuration. It is hardwired to specific
 * values used during the auto-discovery process by an external debug agent.
 */
/*!
 * @name Constants and macros for entire MTB_DEVICECFG register
 */
/*@{*/
#define MTB_RD_DEVICECFG(base)   (MTB_DEVICECFG_REG(base))
/*@}*/

/*******************************************************************************
 * MTB_DEVICETYPID - Device Type Identifier Register
 ******************************************************************************/

/*!
 * @brief MTB_DEVICETYPID - Device Type Identifier Register (RO)
 *
 * Reset value: 0x00000031U
 *
 * This register indicates the device type ID. It is hardwired to specific
 * values used during the auto-discovery process by an external debug agent.
 */
/*!
 * @name Constants and macros for entire MTB_DEVICETYPID register
 */
/*@{*/
#define MTB_RD_DEVICETYPID(base) (MTB_DEVICETYPID_REG(base))
/*@}*/

/*******************************************************************************
 * MTB_PERIPHID - Peripheral ID Register
 ******************************************************************************/

/*!
 * @brief MTB_PERIPHID - Peripheral ID Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * These registers indicate the peripheral IDs. They are hardwired to specific
 * values used during the auto-discovery process by an external debug agent.
 */
/*!
 * @name Constants and macros for entire MTB_PERIPHID register
 */
/*@{*/
#define MTB_RD_PERIPHID(base, index) (MTB_PERIPHID_REG(base, index))
/*@}*/

/*******************************************************************************
 * MTB_COMPID - Component ID Register
 ******************************************************************************/

/*!
 * @brief MTB_COMPID - Component ID Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * These registers indicate the component IDs. They are hardwired to specific
 * values used during the auto-discovery process by an external debug agent.
 */
/*!
 * @name Constants and macros for entire MTB_COMPID register
 */
/*@{*/
#define MTB_RD_COMPID(base, index) (MTB_COMPID_REG(base, index))
/*@}*/

/*
 * MKM34Z7 MTBDWT
 *
 * MTB data watchpoint and trace
 *
 * Registers defined in this header file:
 * - MTBDWT_CTRL - MTB DWT Control Register
 * - MTBDWT_COMP - MTB_DWT Comparator Register
 * - MTBDWT_MASK - MTB_DWT Comparator Mask Register
 * - MTBDWT_FCT - MTB_DWT Comparator Function Register 0
 * - MTBDWT_TBCTRL - MTB_DWT Trace Buffer Control Register
 * - MTBDWT_DEVICECFG - Device Configuration Register
 * - MTBDWT_DEVICETYPID - Device Type Identifier Register
 * - MTBDWT_PERIPHID - Peripheral ID Register
 * - MTBDWT_COMPID - Component ID Register
 */

#define MTBDWT_INSTANCE_COUNT (1U) /*!< Number of instances of the MTBDWT module. */
#define MTBDWT_IDX (0U) /*!< Instance number for MTBDWT. */

/*******************************************************************************
 * MTBDWT_CTRL - MTB DWT Control Register
 ******************************************************************************/

/*!
 * @brief MTBDWT_CTRL - MTB DWT Control Register (RO)
 *
 * Reset value: 0x2F000000U
 *
 * The MTBDWT_CTRL register provides read-only information on the watchpoint
 * configuration for the MTB_DWT.
 */
/*!
 * @name Constants and macros for entire MTBDWT_CTRL register
 */
/*@{*/
#define MTBDWT_RD_CTRL(base)     (MTBDWT_CTRL_REG(base))
/*@}*/

/*
 * Constants & macros for individual MTBDWT_CTRL bitfields
 */

/*!
 * @name Register MTBDWT_CTRL, field DWTCFGCTRL[27:0] (RO)
 *
 * This field is hardwired to 0xF00_0000, disabling all the remaining DWT
 * functionality. The specific fields and their state are: MTBDWT_CTRL[27] = NOTRCPKT =
 * 1, trace sample and exception trace is not supported MTBDWT_CTRL[26] =
 * NOEXTTRIG = 1, external match signals are not supported MTBDWT_CTRL[25] = NOCYCCNT =
 * 1, cycle counter is not supported MTBDWT_CTRL[24] = NOPRFCNT = 1, profiling
 * counters are not supported MTBDWT_CTRL[22] = CYCEBTENA = 0, no POSTCNT
 * underflow packets generated MTBDWT_CTRL[21] = FOLDEVTENA = 0, no folded instruction
 * counter overflow events MTBDWT_CTRL[20] = LSUEVTENA = 0, no LSU counter overflow
 * events MTBDWT_CTRL[19] = SLEEPEVTENA = 0, no sleep counter overflow events
 * MTBDWT_CTRL[18] = EXCEVTENA = 0, no exception overhead counter events
 * MTBDWT_CTRL[17] = CPIEVTENA = 0, no CPI counter overflow events MTBDWT_CTRL[16] =
 * EXCTRCENA = 0, generation of exception trace disabled MTBDWT_CTRL[12] = PCSAMPLENA =
 * 0, no periodic PC sample packets generated MTBDWT_CTRL[11:10] = SYNCTAP = 0,
 * no synchronization packets MTBDWT_CTRL[9] = CYCTAP = 0, cycle counter is not
 * supported MTBDWT_CTRL[8:5] = POSTINIT = 0, cycle counter is not supported
 * MTBDWT_CTRL[4:1] = POSTPRESET = 0, cycle counter is not supported MTBDWT_CTRL[0] =
 * CYCCNTENA = 0, cycle counter is not supported
 */
/*@{*/
/*! @brief Read current value of the MTBDWT_CTRL_DWTCFGCTRL field. */
#define MTBDWT_RD_CTRL_DWTCFGCTRL(base) ((MTBDWT_CTRL_REG(base) & MTBDWT_CTRL_DWTCFGCTRL_MASK) >> MTBDWT_CTRL_DWTCFGCTRL_SHIFT)
#define MTBDWT_BRD_CTRL_DWTCFGCTRL(base) (MTBDWT_RD_CTRL_DWTCFGCTRL(base))
/*@}*/

/*!
 * @name Register MTBDWT_CTRL, field NUMCMP[31:28] (RO)
 *
 * The MTB_DWT implements two comparators.
 */
/*@{*/
/*! @brief Read current value of the MTBDWT_CTRL_NUMCMP field. */
#define MTBDWT_RD_CTRL_NUMCMP(base) ((MTBDWT_CTRL_REG(base) & MTBDWT_CTRL_NUMCMP_MASK) >> MTBDWT_CTRL_NUMCMP_SHIFT)
#define MTBDWT_BRD_CTRL_NUMCMP(base) (MTBDWT_RD_CTRL_NUMCMP(base))
/*@}*/

/*******************************************************************************
 * MTBDWT_COMP - MTB_DWT Comparator Register
 ******************************************************************************/

/*!
 * @brief MTBDWT_COMP - MTB_DWT Comparator Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The MTBDWT_COMPn registers provide the reference value for comparator n.
 */
/*!
 * @name Constants and macros for entire MTBDWT_COMP register
 */
/*@{*/
#define MTBDWT_RD_COMP(base, index) (MTBDWT_COMP_REG(base, index))
#define MTBDWT_WR_COMP(base, index, value) (MTBDWT_COMP_REG(base, index) = (value))
#define MTBDWT_RMW_COMP(base, index, mask, value) (MTBDWT_WR_COMP(base, index, (MTBDWT_RD_COMP(base, index) & ~(mask)) | (value)))
#define MTBDWT_SET_COMP(base, index, value) (MTBDWT_WR_COMP(base, index, MTBDWT_RD_COMP(base, index) |  (value)))
#define MTBDWT_CLR_COMP(base, index, value) (MTBDWT_WR_COMP(base, index, MTBDWT_RD_COMP(base, index) & ~(value)))
#define MTBDWT_TOG_COMP(base, index, value) (MTBDWT_WR_COMP(base, index, MTBDWT_RD_COMP(base, index) ^  (value)))
/*@}*/

/*******************************************************************************
 * MTBDWT_MASK - MTB_DWT Comparator Mask Register
 ******************************************************************************/

/*!
 * @brief MTBDWT_MASK - MTB_DWT Comparator Mask Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The MTBDWT_MASKn registers define the size of the ignore mask applied to the
 * reference address for address range matching by comparator n. Note the format
 * of this mask field is different than the MTB_MASTER[MASK].
 */
/*!
 * @name Constants and macros for entire MTBDWT_MASK register
 */
/*@{*/
#define MTBDWT_RD_MASK(base, index) (MTBDWT_MASK_REG(base, index))
#define MTBDWT_WR_MASK(base, index, value) (MTBDWT_MASK_REG(base, index) = (value))
#define MTBDWT_RMW_MASK(base, index, mask, value) (MTBDWT_WR_MASK(base, index, (MTBDWT_RD_MASK(base, index) & ~(mask)) | (value)))
#define MTBDWT_SET_MASK(base, index, value) (MTBDWT_WR_MASK(base, index, MTBDWT_RD_MASK(base, index) |  (value)))
#define MTBDWT_CLR_MASK(base, index, value) (MTBDWT_WR_MASK(base, index, MTBDWT_RD_MASK(base, index) & ~(value)))
#define MTBDWT_TOG_MASK(base, index, value) (MTBDWT_WR_MASK(base, index, MTBDWT_RD_MASK(base, index) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual MTBDWT_MASK bitfields
 */

/*!
 * @name Register MTBDWT_MASK, field MASK[4:0] (RW)
 *
 * The value of the ignore mask, 0-31 bits, is applied to address range
 * matching. MASK = 0 is used to include all bits of the address in the comparison,
 * except if MASK = 0 and the comparator is configured to watch instruction fetch
 * addresses, address bit [0] is ignored by the hardware since all fetches must be at
 * least halfword aligned. For MASK != 0 and regardless of watch type, address
 * bits [x-1:0] are ignored in the address comparison. Using a mask means the
 * comparator matches on a range of addresses, defined by the unmasked most
 * significant bits of the address, bits [31:x]. The maximum MASK value is 24, producing a
 * 16 Mbyte mask. An attempted write of a MASK value > 24 is limited by the
 * MTBDWT hardware to 24. If MTBDWT_COMP0 is used as a data value comparator, then
 * MTBDWT_MASK0 should be programmed to zero.
 */
/*@{*/
/*! @brief Read current value of the MTBDWT_MASK_MASK field. */
#define MTBDWT_RD_MASK_MASK(base, index) ((MTBDWT_MASK_REG(base, index) & MTBDWT_MASK_MASK_MASK) >> MTBDWT_MASK_MASK_SHIFT)
#define MTBDWT_BRD_MASK_MASK(base, index) (MTBDWT_RD_MASK_MASK(base, index))

/*! @brief Set the MASK field to a new value. */
#define MTBDWT_WR_MASK_MASK(base, index, value) (MTBDWT_RMW_MASK(base, index, MTBDWT_MASK_MASK_MASK, MTBDWT_MASK_MASK(value)))
#define MTBDWT_BWR_MASK_MASK(base, index, value) (MTBDWT_WR_MASK_MASK(base, index, value))
/*@}*/

/*******************************************************************************
 * MTBDWT_FCT - MTB_DWT Comparator Function Register 0
 ******************************************************************************/

/*!
 * @brief MTBDWT_FCT - MTB_DWT Comparator Function Register 0 (RW)
 *
 * Reset value: 0x00000000U
 *
 * The MTBDWT_FCTn registers control the operation of comparator n.
 */
/*!
 * @name Constants and macros for entire MTBDWT_FCT register
 */
/*@{*/
#define MTBDWT_RD_FCT(base, index) (MTBDWT_FCT_REG(base, index))
#define MTBDWT_WR_FCT(base, index, value) (MTBDWT_FCT_REG(base, index) = (value))
#define MTBDWT_RMW_FCT(base, index, mask, value) (MTBDWT_WR_FCT(base, index, (MTBDWT_RD_FCT(base, index) & ~(mask)) | (value)))
#define MTBDWT_SET_FCT(base, index, value) (MTBDWT_WR_FCT(base, index, MTBDWT_RD_FCT(base, index) |  (value)))
#define MTBDWT_CLR_FCT(base, index, value) (MTBDWT_WR_FCT(base, index, MTBDWT_RD_FCT(base, index) & ~(value)))
#define MTBDWT_TOG_FCT(base, index, value) (MTBDWT_WR_FCT(base, index, MTBDWT_RD_FCT(base, index) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual MTBDWT_FCT bitfields
 */

/*!
 * @name Register MTBDWT_FCT, field FUNCTION[3:0] (RW)
 *
 * Selects the action taken on a comparator match. If MTBDWT_COMP0 is used for a
 * data value and MTBDWT_COMP1 for an address value, then MTBDWT_FCT1[FUNCTION]
 * must be set to zero. For this configuration, MTBDWT_MASK1 can be set to a
 * non-zero value, so the combined comparators match on a range of addresses.
 *
 * Values:
 * - 0b0000 - Disabled.
 * - 0b0100 - Instruction fetch.
 * - 0b0101 - Data operand read.
 * - 0b0110 - Data operand write.
 * - 0b0111 - Data operand (read + write).
 */
/*@{*/
/*! @brief Read current value of the MTBDWT_FCT_FUNCTION field. */
#define MTBDWT_RD_FCT_FUNCTION(base, index) ((MTBDWT_FCT_REG(base, index) & MTBDWT_FCT_FUNCTION_MASK) >> MTBDWT_FCT_FUNCTION_SHIFT)
#define MTBDWT_BRD_FCT_FUNCTION(base, index) (MTBDWT_RD_FCT_FUNCTION(base, index))

/*! @brief Set the FUNCTION field to a new value. */
#define MTBDWT_WR_FCT_FUNCTION(base, index, value) (MTBDWT_RMW_FCT(base, index, MTBDWT_FCT_FUNCTION_MASK, MTBDWT_FCT_FUNCTION(value)))
#define MTBDWT_BWR_FCT_FUNCTION(base, index, value) (MTBDWT_WR_FCT_FUNCTION(base, index, value))
/*@}*/

/*!
 * @name Register MTBDWT_FCT, field DATAVMATCH[8] (RW)
 *
 * When this field is 1, it enables data value comparison. For this
 * implementation, MTBDWT_COMP0 supports address or data value comparisons; MTBDWT_COMP1 only
 * supports address comparisons.
 *
 * Values:
 * - 0b0 - Perform address comparison.
 * - 0b1 - Perform data value comparison.
 */
/*@{*/
/*! @brief Read current value of the MTBDWT_FCT_DATAVMATCH field. */
#define MTBDWT_RD_FCT_DATAVMATCH(base, index) ((MTBDWT_FCT_REG(base, index) & MTBDWT_FCT_DATAVMATCH_MASK) >> MTBDWT_FCT_DATAVMATCH_SHIFT)
#define MTBDWT_BRD_FCT_DATAVMATCH(base, index) (MTBDWT_RD_FCT_DATAVMATCH(base, index))

/*! @brief Set the DATAVMATCH field to a new value. */
#define MTBDWT_WR_FCT_DATAVMATCH(base, index, value) (MTBDWT_RMW_FCT(base, index, MTBDWT_FCT_DATAVMATCH_MASK, MTBDWT_FCT_DATAVMATCH(value)))
#define MTBDWT_BWR_FCT_DATAVMATCH(base, index, value) (MTBDWT_WR_FCT_DATAVMATCH(base, index, value))
/*@}*/

/*!
 * @name Register MTBDWT_FCT, field DATAVSIZE[11:10] (RW)
 *
 * For data value matching, this field defines the size of the required data
 * comparison.
 *
 * Values:
 * - 0b00 - Byte.
 * - 0b01 - Halfword.
 * - 0b10 - Word.
 * - 0b11 - Reserved. Any attempts to use this value results in UNPREDICTABLE
 *     behavior.
 */
/*@{*/
/*! @brief Read current value of the MTBDWT_FCT_DATAVSIZE field. */
#define MTBDWT_RD_FCT_DATAVSIZE(base, index) ((MTBDWT_FCT_REG(base, index) & MTBDWT_FCT_DATAVSIZE_MASK) >> MTBDWT_FCT_DATAVSIZE_SHIFT)
#define MTBDWT_BRD_FCT_DATAVSIZE(base, index) (MTBDWT_RD_FCT_DATAVSIZE(base, index))

/*! @brief Set the DATAVSIZE field to a new value. */
#define MTBDWT_WR_FCT_DATAVSIZE(base, index, value) (MTBDWT_RMW_FCT(base, index, MTBDWT_FCT_DATAVSIZE_MASK, MTBDWT_FCT_DATAVSIZE(value)))
#define MTBDWT_BWR_FCT_DATAVSIZE(base, index, value) (MTBDWT_WR_FCT_DATAVSIZE(base, index, value))
/*@}*/

/*!
 * @name Register MTBDWT_FCT, field DATAVADDR0[15:12] (RW)
 *
 * Since the MTB_DWT implements two comparators, the DATAVADDR0 field is
 * restricted to values {0,1}. When the DATAVMATCH bit is asserted, this field defines
 * the comparator number to use for linked address comparison. If MTBDWT_COMP0 is
 * used as a data watchpoint and MTBDWT_COMP1 as an address watchpoint,
 * DATAVADDR0 must be set.
 */
/*@{*/
/*! @brief Read current value of the MTBDWT_FCT_DATAVADDR0 field. */
#define MTBDWT_RD_FCT_DATAVADDR0(base, index) ((MTBDWT_FCT_REG(base, index) & MTBDWT_FCT_DATAVADDR0_MASK) >> MTBDWT_FCT_DATAVADDR0_SHIFT)
#define MTBDWT_BRD_FCT_DATAVADDR0(base, index) (MTBDWT_RD_FCT_DATAVADDR0(base, index))

/*! @brief Set the DATAVADDR0 field to a new value. */
#define MTBDWT_WR_FCT_DATAVADDR0(base, index, value) (MTBDWT_RMW_FCT(base, index, MTBDWT_FCT_DATAVADDR0_MASK, MTBDWT_FCT_DATAVADDR0(value)))
#define MTBDWT_BWR_FCT_DATAVADDR0(base, index, value) (MTBDWT_WR_FCT_DATAVADDR0(base, index, value))
/*@}*/

/*!
 * @name Register MTBDWT_FCT, field MATCHED[24] (RO)
 *
 * If this read-only flag is asserted, it indicates the operation defined by the
 * FUNCTION field occurred since the last read of the register. Reading the
 * register clears this bit.
 *
 * Values:
 * - 0b0 - No match.
 * - 0b1 - Match occurred.
 */
/*@{*/
/*! @brief Read current value of the MTBDWT_FCT_MATCHED field. */
#define MTBDWT_RD_FCT_MATCHED(base, index) ((MTBDWT_FCT_REG(base, index) & MTBDWT_FCT_MATCHED_MASK) >> MTBDWT_FCT_MATCHED_SHIFT)
#define MTBDWT_BRD_FCT_MATCHED(base, index) (MTBDWT_RD_FCT_MATCHED(base, index))
/*@}*/

/*******************************************************************************
 * MTBDWT_TBCTRL - MTB_DWT Trace Buffer Control Register
 ******************************************************************************/

/*!
 * @brief MTBDWT_TBCTRL - MTB_DWT Trace Buffer Control Register (RW)
 *
 * Reset value: 0x20000000U
 *
 * The MTBDWT_TBCTRL register defines how the watchpoint comparisons control the
 * actual trace buffer operation. Recall the MTB supports starting and stopping
 * the program trace based on the watchpoint comparisons signaled via TSTART and
 * TSTOP. The watchpoint comparison signals are enabled in the MTB's control
 * logic by setting the appropriate enable bits, MTB_MASTER[TSTARTEN, TSTOPEN]. In
 * the event of simultaneous assertion of both TSTART and TSTOP, TSTART takes
 * priority.
 */
/*!
 * @name Constants and macros for entire MTBDWT_TBCTRL register
 */
/*@{*/
#define MTBDWT_RD_TBCTRL(base)   (MTBDWT_TBCTRL_REG(base))
#define MTBDWT_WR_TBCTRL(base, value) (MTBDWT_TBCTRL_REG(base) = (value))
#define MTBDWT_RMW_TBCTRL(base, mask, value) (MTBDWT_WR_TBCTRL(base, (MTBDWT_RD_TBCTRL(base) & ~(mask)) | (value)))
#define MTBDWT_SET_TBCTRL(base, value) (MTBDWT_WR_TBCTRL(base, MTBDWT_RD_TBCTRL(base) |  (value)))
#define MTBDWT_CLR_TBCTRL(base, value) (MTBDWT_WR_TBCTRL(base, MTBDWT_RD_TBCTRL(base) & ~(value)))
#define MTBDWT_TOG_TBCTRL(base, value) (MTBDWT_WR_TBCTRL(base, MTBDWT_RD_TBCTRL(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual MTBDWT_TBCTRL bitfields
 */

/*!
 * @name Register MTBDWT_TBCTRL, field ACOMP0[0] (RW)
 *
 * When the MTBDWT_FCT0[MATCHED] is set, it indicates MTBDWT_COMP0 address
 * compare has triggered and the trace buffer's recording state is changed. The
 * assertion of MTBDWT_FCT0[MATCHED] is caused by the following conditions: Address
 * match in MTBDWT_COMP0 when MTBDWT_FCT0[DATAVMATCH] = 0 Data match in MTBDWT_COMP0
 * when MTBDWT_FCT0[DATAVMATCH, DATAVADDR0] = {1,0} Data match in MTBDWT_COMP0
 * and address match in MTBDWT_COMP1 when MTBDWT_FCT0[DATAVMATCH, DATAVADDR0] =
 * {1,1}
 *
 * Values:
 * - 0b0 - Trigger TSTOP based on the assertion of MTBDWT_FCT0[MATCHED].
 * - 0b1 - Trigger TSTART based on the assertion of MTBDWT_FCT0[MATCHED].
 */
/*@{*/
/*! @brief Read current value of the MTBDWT_TBCTRL_ACOMP0 field. */
#define MTBDWT_RD_TBCTRL_ACOMP0(base) ((MTBDWT_TBCTRL_REG(base) & MTBDWT_TBCTRL_ACOMP0_MASK) >> MTBDWT_TBCTRL_ACOMP0_SHIFT)
#define MTBDWT_BRD_TBCTRL_ACOMP0(base) (MTBDWT_RD_TBCTRL_ACOMP0(base))

/*! @brief Set the ACOMP0 field to a new value. */
#define MTBDWT_WR_TBCTRL_ACOMP0(base, value) (MTBDWT_RMW_TBCTRL(base, MTBDWT_TBCTRL_ACOMP0_MASK, MTBDWT_TBCTRL_ACOMP0(value)))
#define MTBDWT_BWR_TBCTRL_ACOMP0(base, value) (MTBDWT_WR_TBCTRL_ACOMP0(base, value))
/*@}*/

/*!
 * @name Register MTBDWT_TBCTRL, field ACOMP1[1] (RW)
 *
 * When the MTBDWT_FCT1[MATCHED] is set, it indicates MTBDWT_COMP1 address
 * compare has triggered and the trace buffer's recording state is changed.
 *
 * Values:
 * - 0b0 - Trigger TSTOP based on the assertion of MTBDWT_FCT1[MATCHED].
 * - 0b1 - Trigger TSTART based on the assertion of MTBDWT_FCT1[MATCHED].
 */
/*@{*/
/*! @brief Read current value of the MTBDWT_TBCTRL_ACOMP1 field. */
#define MTBDWT_RD_TBCTRL_ACOMP1(base) ((MTBDWT_TBCTRL_REG(base) & MTBDWT_TBCTRL_ACOMP1_MASK) >> MTBDWT_TBCTRL_ACOMP1_SHIFT)
#define MTBDWT_BRD_TBCTRL_ACOMP1(base) (MTBDWT_RD_TBCTRL_ACOMP1(base))

/*! @brief Set the ACOMP1 field to a new value. */
#define MTBDWT_WR_TBCTRL_ACOMP1(base, value) (MTBDWT_RMW_TBCTRL(base, MTBDWT_TBCTRL_ACOMP1_MASK, MTBDWT_TBCTRL_ACOMP1(value)))
#define MTBDWT_BWR_TBCTRL_ACOMP1(base, value) (MTBDWT_WR_TBCTRL_ACOMP1(base, value))
/*@}*/

/*!
 * @name Register MTBDWT_TBCTRL, field NUMCOMP[31:28] (RO)
 *
 * This read-only field specifies the number of comparators in the MTB_DWT. This
 * implementation includes two registers.
 */
/*@{*/
/*! @brief Read current value of the MTBDWT_TBCTRL_NUMCOMP field. */
#define MTBDWT_RD_TBCTRL_NUMCOMP(base) ((MTBDWT_TBCTRL_REG(base) & MTBDWT_TBCTRL_NUMCOMP_MASK) >> MTBDWT_TBCTRL_NUMCOMP_SHIFT)
#define MTBDWT_BRD_TBCTRL_NUMCOMP(base) (MTBDWT_RD_TBCTRL_NUMCOMP(base))
/*@}*/

/*******************************************************************************
 * MTBDWT_DEVICECFG - Device Configuration Register
 ******************************************************************************/

/*!
 * @brief MTBDWT_DEVICECFG - Device Configuration Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * This register indicates the device configuration. It is hardwired to specific
 * values used during the auto-discovery process by an external debug agent.
 */
/*!
 * @name Constants and macros for entire MTBDWT_DEVICECFG register
 */
/*@{*/
#define MTBDWT_RD_DEVICECFG(base) (MTBDWT_DEVICECFG_REG(base))
/*@}*/

/*******************************************************************************
 * MTBDWT_DEVICETYPID - Device Type Identifier Register
 ******************************************************************************/

/*!
 * @brief MTBDWT_DEVICETYPID - Device Type Identifier Register (RO)
 *
 * Reset value: 0x00000004U
 *
 * This register indicates the device type ID. It is hardwired to specific
 * values used during the auto-discovery process by an external debug agent.
 */
/*!
 * @name Constants and macros for entire MTBDWT_DEVICETYPID register
 */
/*@{*/
#define MTBDWT_RD_DEVICETYPID(base) (MTBDWT_DEVICETYPID_REG(base))
/*@}*/

/*******************************************************************************
 * MTBDWT_PERIPHID - Peripheral ID Register
 ******************************************************************************/

/*!
 * @brief MTBDWT_PERIPHID - Peripheral ID Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * These registers indicate the peripheral IDs. They are hardwired to specific
 * values used during the auto-discovery process by an external debug agent.
 */
/*!
 * @name Constants and macros for entire MTBDWT_PERIPHID register
 */
/*@{*/
#define MTBDWT_RD_PERIPHID(base, index) (MTBDWT_PERIPHID_REG(base, index))
/*@}*/

/*******************************************************************************
 * MTBDWT_COMPID - Component ID Register
 ******************************************************************************/

/*!
 * @brief MTBDWT_COMPID - Component ID Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * These registers indicate the component IDs. They are hardwired to specific
 * values used during the auto-discovery process by an external debug agent.
 */
/*!
 * @name Constants and macros for entire MTBDWT_COMPID register
 */
/*@{*/
#define MTBDWT_RD_COMPID(base, index) (MTBDWT_COMPID_REG(base, index))
/*@}*/

/*
 * MKM34Z7 NV
 *
 * Flash configuration field
 *
 * Registers defined in this header file:
 * - NV_BACKKEY3 - Backdoor Comparison Key 3.
 * - NV_BACKKEY2 - Backdoor Comparison Key 2.
 * - NV_BACKKEY1 - Backdoor Comparison Key 1.
 * - NV_BACKKEY0 - Backdoor Comparison Key 0.
 * - NV_BACKKEY7 - Backdoor Comparison Key 7.
 * - NV_BACKKEY6 - Backdoor Comparison Key 6.
 * - NV_BACKKEY5 - Backdoor Comparison Key 5.
 * - NV_BACKKEY4 - Backdoor Comparison Key 4.
 * - NV_FPROT3 - Non-volatile P-Flash Protection 1 - Low Register
 * - NV_FPROT2 - Non-volatile P-Flash Protection 1 - High Register
 * - NV_FPROT1 - Non-volatile P-Flash Protection 0 - Low Register
 * - NV_FPROT0 - Non-volatile P-Flash Protection 0 - High Register
 * - NV_FSEC - Non-volatile Flash Security Register
 * - NV_FOPT - Non-volatile Flash Option Register
 */

#define NV_INSTANCE_COUNT (1U) /*!< Number of instances of the NV module. */
#define FTFA_FlashConfig_IDX (0U) /*!< Instance number for FTFA_FlashConfig. */

/*******************************************************************************
 * NV_BACKKEY3 - Backdoor Comparison Key 3.
 ******************************************************************************/

/*!
 * @brief NV_BACKKEY3 - Backdoor Comparison Key 3. (RO)
 *
 * Reset value: 0xFFU
 */
/*!
 * @name Constants and macros for entire NV_BACKKEY3 register
 */
/*@{*/
#define NV_RD_BACKKEY3(base)     (NV_BACKKEY3_REG(base))
/*@}*/

/*******************************************************************************
 * NV_BACKKEY2 - Backdoor Comparison Key 2.
 ******************************************************************************/

/*!
 * @brief NV_BACKKEY2 - Backdoor Comparison Key 2. (RO)
 *
 * Reset value: 0xFFU
 */
/*!
 * @name Constants and macros for entire NV_BACKKEY2 register
 */
/*@{*/
#define NV_RD_BACKKEY2(base)     (NV_BACKKEY2_REG(base))
/*@}*/

/*******************************************************************************
 * NV_BACKKEY1 - Backdoor Comparison Key 1.
 ******************************************************************************/

/*!
 * @brief NV_BACKKEY1 - Backdoor Comparison Key 1. (RO)
 *
 * Reset value: 0xFFU
 */
/*!
 * @name Constants and macros for entire NV_BACKKEY1 register
 */
/*@{*/
#define NV_RD_BACKKEY1(base)     (NV_BACKKEY1_REG(base))
/*@}*/

/*******************************************************************************
 * NV_BACKKEY0 - Backdoor Comparison Key 0.
 ******************************************************************************/

/*!
 * @brief NV_BACKKEY0 - Backdoor Comparison Key 0. (RO)
 *
 * Reset value: 0xFFU
 */
/*!
 * @name Constants and macros for entire NV_BACKKEY0 register
 */
/*@{*/
#define NV_RD_BACKKEY0(base)     (NV_BACKKEY0_REG(base))
/*@}*/

/*******************************************************************************
 * NV_BACKKEY7 - Backdoor Comparison Key 7.
 ******************************************************************************/

/*!
 * @brief NV_BACKKEY7 - Backdoor Comparison Key 7. (RO)
 *
 * Reset value: 0xFFU
 */
/*!
 * @name Constants and macros for entire NV_BACKKEY7 register
 */
/*@{*/
#define NV_RD_BACKKEY7(base)     (NV_BACKKEY7_REG(base))
/*@}*/

/*******************************************************************************
 * NV_BACKKEY6 - Backdoor Comparison Key 6.
 ******************************************************************************/

/*!
 * @brief NV_BACKKEY6 - Backdoor Comparison Key 6. (RO)
 *
 * Reset value: 0xFFU
 */
/*!
 * @name Constants and macros for entire NV_BACKKEY6 register
 */
/*@{*/
#define NV_RD_BACKKEY6(base)     (NV_BACKKEY6_REG(base))
/*@}*/

/*******************************************************************************
 * NV_BACKKEY5 - Backdoor Comparison Key 5.
 ******************************************************************************/

/*!
 * @brief NV_BACKKEY5 - Backdoor Comparison Key 5. (RO)
 *
 * Reset value: 0xFFU
 */
/*!
 * @name Constants and macros for entire NV_BACKKEY5 register
 */
/*@{*/
#define NV_RD_BACKKEY5(base)     (NV_BACKKEY5_REG(base))
/*@}*/

/*******************************************************************************
 * NV_BACKKEY4 - Backdoor Comparison Key 4.
 ******************************************************************************/

/*!
 * @brief NV_BACKKEY4 - Backdoor Comparison Key 4. (RO)
 *
 * Reset value: 0xFFU
 */
/*!
 * @name Constants and macros for entire NV_BACKKEY4 register
 */
/*@{*/
#define NV_RD_BACKKEY4(base)     (NV_BACKKEY4_REG(base))
/*@}*/

/*******************************************************************************
 * NV_FPROT3 - Non-volatile P-Flash Protection 1 - Low Register
 ******************************************************************************/

/*!
 * @brief NV_FPROT3 - Non-volatile P-Flash Protection 1 - Low Register (RO)
 *
 * Reset value: 0xFFU
 */
/*!
 * @name Constants and macros for entire NV_FPROT3 register
 */
/*@{*/
#define NV_RD_FPROT3(base)       (NV_FPROT3_REG(base))
/*@}*/

/*******************************************************************************
 * NV_FPROT2 - Non-volatile P-Flash Protection 1 - High Register
 ******************************************************************************/

/*!
 * @brief NV_FPROT2 - Non-volatile P-Flash Protection 1 - High Register (RO)
 *
 * Reset value: 0xFFU
 */
/*!
 * @name Constants and macros for entire NV_FPROT2 register
 */
/*@{*/
#define NV_RD_FPROT2(base)       (NV_FPROT2_REG(base))
/*@}*/

/*******************************************************************************
 * NV_FPROT1 - Non-volatile P-Flash Protection 0 - Low Register
 ******************************************************************************/

/*!
 * @brief NV_FPROT1 - Non-volatile P-Flash Protection 0 - Low Register (RO)
 *
 * Reset value: 0xFFU
 */
/*!
 * @name Constants and macros for entire NV_FPROT1 register
 */
/*@{*/
#define NV_RD_FPROT1(base)       (NV_FPROT1_REG(base))
/*@}*/

/*******************************************************************************
 * NV_FPROT0 - Non-volatile P-Flash Protection 0 - High Register
 ******************************************************************************/

/*!
 * @brief NV_FPROT0 - Non-volatile P-Flash Protection 0 - High Register (RO)
 *
 * Reset value: 0xFFU
 */
/*!
 * @name Constants and macros for entire NV_FPROT0 register
 */
/*@{*/
#define NV_RD_FPROT0(base)       (NV_FPROT0_REG(base))
/*@}*/

/*******************************************************************************
 * NV_FSEC - Non-volatile Flash Security Register
 ******************************************************************************/

/*!
 * @brief NV_FSEC - Non-volatile Flash Security Register (RO)
 *
 * Reset value: 0xFFU
 *
 * Allows the user to customize the operation of the MCU at boot time
 */
/*!
 * @name Constants and macros for entire NV_FSEC register
 */
/*@{*/
#define NV_RD_FSEC(base)         (NV_FSEC_REG(base))
/*@}*/

/*
 * Constants & macros for individual NV_FSEC bitfields
 */

/*!
 * @name Register NV_FSEC, field SEC[1:0] (RO)
 *
 * Values:
 * - 0b10 - MCU security status is unsecure
 * - 0b11 - MCU security status is secure
 */
/*@{*/
/*! @brief Read current value of the NV_FSEC_SEC field. */
#define NV_RD_FSEC_SEC(base) ((NV_FSEC_REG(base) & NV_FSEC_SEC_MASK) >> NV_FSEC_SEC_SHIFT)
#define NV_BRD_FSEC_SEC(base) (NV_RD_FSEC_SEC(base))
/*@}*/

/*!
 * @name Register NV_FSEC, field FSLACC[3:2] (RO)
 *
 * Values:
 * - 0b10 - Freescale factory access denied
 * - 0b11 - Freescale factory access granted
 */
/*@{*/
/*! @brief Read current value of the NV_FSEC_FSLACC field. */
#define NV_RD_FSEC_FSLACC(base) ((NV_FSEC_REG(base) & NV_FSEC_FSLACC_MASK) >> NV_FSEC_FSLACC_SHIFT)
#define NV_BRD_FSEC_FSLACC(base) (NV_RD_FSEC_FSLACC(base))
/*@}*/

/*!
 * @name Register NV_FSEC, field MEEN[5:4] (RO)
 *
 * Values:
 * - 0b10 - Mass erase is disabled
 * - 0b11 - Mass erase is enabled
 */
/*@{*/
/*! @brief Read current value of the NV_FSEC_MEEN field. */
#define NV_RD_FSEC_MEEN(base) ((NV_FSEC_REG(base) & NV_FSEC_MEEN_MASK) >> NV_FSEC_MEEN_SHIFT)
#define NV_BRD_FSEC_MEEN(base) (NV_RD_FSEC_MEEN(base))
/*@}*/

/*!
 * @name Register NV_FSEC, field KEYEN[7:6] (RO)
 *
 * Values:
 * - 0b10 - Backdoor key access enabled
 * - 0b11 - Backdoor key access disabled
 */
/*@{*/
/*! @brief Read current value of the NV_FSEC_KEYEN field. */
#define NV_RD_FSEC_KEYEN(base) ((NV_FSEC_REG(base) & NV_FSEC_KEYEN_MASK) >> NV_FSEC_KEYEN_SHIFT)
#define NV_BRD_FSEC_KEYEN(base) (NV_RD_FSEC_KEYEN(base))
/*@}*/

/*******************************************************************************
 * NV_FOPT - Non-volatile Flash Option Register
 ******************************************************************************/

/*!
 * @brief NV_FOPT - Non-volatile Flash Option Register (RO)
 *
 * Reset value: 0x3FU
 */
/*!
 * @name Constants and macros for entire NV_FOPT register
 */
/*@{*/
#define NV_RD_FOPT(base)         (NV_FOPT_REG(base))
/*@}*/

/*
 * Constants & macros for individual NV_FOPT bitfields
 */

/*!
 * @name Register NV_FOPT, field LPBOOT[0] (RO)
 *
 * Values:
 * - 0b0 - Low-power boot
 * - 0b1 - Normal boot
 */
/*@{*/
/*! @brief Read current value of the NV_FOPT_LPBOOT field. */
#define NV_RD_FOPT_LPBOOT(base) ((NV_FOPT_REG(base) & NV_FOPT_LPBOOT_MASK) >> NV_FOPT_LPBOOT_SHIFT)
#define NV_BRD_FOPT_LPBOOT(base) (NV_RD_FOPT_LPBOOT(base))
/*@}*/

/*!
 * @name Register NV_FOPT, field NMI_EN[2] (RO)
 *
 * Values:
 * - 0b0 - NMI interrupts are always blocked
 * - 0b1 - NMI_b pin/interrupts reset default to enabled
 */
/*@{*/
/*! @brief Read current value of the NV_FOPT_NMI_EN field. */
#define NV_RD_FOPT_NMI_EN(base) ((NV_FOPT_REG(base) & NV_FOPT_NMI_EN_MASK) >> NV_FOPT_NMI_EN_SHIFT)
#define NV_BRD_FOPT_NMI_EN(base) (NV_RD_FOPT_NMI_EN(base))
/*@}*/

/*!
 * @name Register NV_FOPT, field EXE_MODE[3] (RO)
 *
 * Values:
 * - 0b0 - Execution Mode is RUN Mode
 * - 0b1 - Execution Mode is VLPR Mode
 */
/*@{*/
/*! @brief Read current value of the NV_FOPT_EXE_MODE field. */
#define NV_RD_FOPT_EXE_MODE(base) ((NV_FOPT_REG(base) & NV_FOPT_EXE_MODE_MASK) >> NV_FOPT_EXE_MODE_SHIFT)
#define NV_BRD_FOPT_EXE_MODE(base) (NV_RD_FOPT_EXE_MODE(base))
/*@}*/

/*!
 * @name Register NV_FOPT, field CLK_SRC[5] (RO)
 *
 * Values:
 * - 0b0 - Externally supplied clock used by Flash
 * - 0b1 - Internal clock source used by Flash
 */
/*@{*/
/*! @brief Read current value of the NV_FOPT_CLK_SRC field. */
#define NV_RD_FOPT_CLK_SRC(base) ((NV_FOPT_REG(base) & NV_FOPT_CLK_SRC_MASK) >> NV_FOPT_CLK_SRC_SHIFT)
#define NV_BRD_FOPT_CLK_SRC(base) (NV_RD_FOPT_CLK_SRC(base))
/*@}*/

/*
 * MKM34Z7 OSC
 *
 * Oscillator
 *
 * Registers defined in this header file:
 * - OSC_CR - OSC Control Register
 */

#define OSC_INSTANCE_COUNT (1U) /*!< Number of instances of the OSC module. */
#define OSC_IDX (0U) /*!< Instance number for OSC. */

/*******************************************************************************
 * OSC_CR - OSC Control Register
 ******************************************************************************/

/*!
 * @brief OSC_CR - OSC Control Register (RW)
 *
 * Reset value: 0x00U
 *
 * After OSC is enabled and starts generating the clocks, the configurations
 * such as low power and frequency range, must not be changed.
 */
/*!
 * @name Constants and macros for entire OSC_CR register
 */
/*@{*/
#define OSC_RD_CR(base)          (OSC_CR_REG(base))
#define OSC_WR_CR(base, value)   (OSC_CR_REG(base) = (value))
#define OSC_RMW_CR(base, mask, value) (OSC_WR_CR(base, (OSC_RD_CR(base) & ~(mask)) | (value)))
#define OSC_SET_CR(base, value)  (BME_OR8(&OSC_CR_REG(base), (uint8_t)(value)))
#define OSC_CLR_CR(base, value)  (BME_AND8(&OSC_CR_REG(base), (uint8_t)(~(value))))
#define OSC_TOG_CR(base, value)  (BME_XOR8(&OSC_CR_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual OSC_CR bitfields
 */

/*!
 * @name Register OSC_CR, field SC16P[0] (RW)
 *
 * Configures the oscillator load.
 *
 * Values:
 * - 0b0 - Disable the selection.
 * - 0b1 - Add 16 pF capacitor to the oscillator load.
 */
/*@{*/
/*! @brief Read current value of the OSC_CR_SC16P field. */
#define OSC_RD_CR_SC16P(base) ((OSC_CR_REG(base) & OSC_CR_SC16P_MASK) >> OSC_CR_SC16P_SHIFT)
#define OSC_BRD_CR_SC16P(base) (BME_UBFX8(&OSC_CR_REG(base), OSC_CR_SC16P_SHIFT, OSC_CR_SC16P_WIDTH))

/*! @brief Set the SC16P field to a new value. */
#define OSC_WR_CR_SC16P(base, value) (OSC_RMW_CR(base, OSC_CR_SC16P_MASK, OSC_CR_SC16P(value)))
#define OSC_BWR_CR_SC16P(base, value) (BME_BFI8(&OSC_CR_REG(base), ((uint8_t)(value) << OSC_CR_SC16P_SHIFT), OSC_CR_SC16P_SHIFT, OSC_CR_SC16P_WIDTH))
/*@}*/

/*!
 * @name Register OSC_CR, field SC8P[1] (RW)
 *
 * Configures the oscillator load.
 *
 * Values:
 * - 0b0 - Disable the selection.
 * - 0b1 - Add 8 pF capacitor to the oscillator load.
 */
/*@{*/
/*! @brief Read current value of the OSC_CR_SC8P field. */
#define OSC_RD_CR_SC8P(base) ((OSC_CR_REG(base) & OSC_CR_SC8P_MASK) >> OSC_CR_SC8P_SHIFT)
#define OSC_BRD_CR_SC8P(base) (BME_UBFX8(&OSC_CR_REG(base), OSC_CR_SC8P_SHIFT, OSC_CR_SC8P_WIDTH))

/*! @brief Set the SC8P field to a new value. */
#define OSC_WR_CR_SC8P(base, value) (OSC_RMW_CR(base, OSC_CR_SC8P_MASK, OSC_CR_SC8P(value)))
#define OSC_BWR_CR_SC8P(base, value) (BME_BFI8(&OSC_CR_REG(base), ((uint8_t)(value) << OSC_CR_SC8P_SHIFT), OSC_CR_SC8P_SHIFT, OSC_CR_SC8P_WIDTH))
/*@}*/

/*!
 * @name Register OSC_CR, field SC4P[2] (RW)
 *
 * Configures the oscillator load.
 *
 * Values:
 * - 0b0 - Disable the selection.
 * - 0b1 - Add 4 pF capacitor to the oscillator load.
 */
/*@{*/
/*! @brief Read current value of the OSC_CR_SC4P field. */
#define OSC_RD_CR_SC4P(base) ((OSC_CR_REG(base) & OSC_CR_SC4P_MASK) >> OSC_CR_SC4P_SHIFT)
#define OSC_BRD_CR_SC4P(base) (BME_UBFX8(&OSC_CR_REG(base), OSC_CR_SC4P_SHIFT, OSC_CR_SC4P_WIDTH))

/*! @brief Set the SC4P field to a new value. */
#define OSC_WR_CR_SC4P(base, value) (OSC_RMW_CR(base, OSC_CR_SC4P_MASK, OSC_CR_SC4P(value)))
#define OSC_BWR_CR_SC4P(base, value) (BME_BFI8(&OSC_CR_REG(base), ((uint8_t)(value) << OSC_CR_SC4P_SHIFT), OSC_CR_SC4P_SHIFT, OSC_CR_SC4P_WIDTH))
/*@}*/

/*!
 * @name Register OSC_CR, field SC2P[3] (RW)
 *
 * Configures the oscillator load.
 *
 * Values:
 * - 0b0 - Disable the selection.
 * - 0b1 - Add 2 pF capacitor to the oscillator load.
 */
/*@{*/
/*! @brief Read current value of the OSC_CR_SC2P field. */
#define OSC_RD_CR_SC2P(base) ((OSC_CR_REG(base) & OSC_CR_SC2P_MASK) >> OSC_CR_SC2P_SHIFT)
#define OSC_BRD_CR_SC2P(base) (BME_UBFX8(&OSC_CR_REG(base), OSC_CR_SC2P_SHIFT, OSC_CR_SC2P_WIDTH))

/*! @brief Set the SC2P field to a new value. */
#define OSC_WR_CR_SC2P(base, value) (OSC_RMW_CR(base, OSC_CR_SC2P_MASK, OSC_CR_SC2P(value)))
#define OSC_BWR_CR_SC2P(base, value) (BME_BFI8(&OSC_CR_REG(base), ((uint8_t)(value) << OSC_CR_SC2P_SHIFT), OSC_CR_SC2P_SHIFT, OSC_CR_SC2P_WIDTH))
/*@}*/

/*!
 * @name Register OSC_CR, field EREFSTEN[5] (RW)
 *
 * Controls whether or not the external reference clock (OSCERCLK) remains
 * enabled when MCU enters Stop mode.
 *
 * Values:
 * - 0b0 - External reference clock is disabled in Stop mode.
 * - 0b1 - External reference clock stays enabled in Stop mode if ERCLKEN is set
 *     before entering Stop mode.
 */
/*@{*/
/*! @brief Read current value of the OSC_CR_EREFSTEN field. */
#define OSC_RD_CR_EREFSTEN(base) ((OSC_CR_REG(base) & OSC_CR_EREFSTEN_MASK) >> OSC_CR_EREFSTEN_SHIFT)
#define OSC_BRD_CR_EREFSTEN(base) (BME_UBFX8(&OSC_CR_REG(base), OSC_CR_EREFSTEN_SHIFT, OSC_CR_EREFSTEN_WIDTH))

/*! @brief Set the EREFSTEN field to a new value. */
#define OSC_WR_CR_EREFSTEN(base, value) (OSC_RMW_CR(base, OSC_CR_EREFSTEN_MASK, OSC_CR_EREFSTEN(value)))
#define OSC_BWR_CR_EREFSTEN(base, value) (BME_BFI8(&OSC_CR_REG(base), ((uint8_t)(value) << OSC_CR_EREFSTEN_SHIFT), OSC_CR_EREFSTEN_SHIFT, OSC_CR_EREFSTEN_WIDTH))
/*@}*/

/*!
 * @name Register OSC_CR, field ERCLKEN[7] (RW)
 *
 * Enables external reference clock (OSCERCLK).
 *
 * Values:
 * - 0b0 - External reference clock is inactive.
 * - 0b1 - External reference clock is enabled.
 */
/*@{*/
/*! @brief Read current value of the OSC_CR_ERCLKEN field. */
#define OSC_RD_CR_ERCLKEN(base) ((OSC_CR_REG(base) & OSC_CR_ERCLKEN_MASK) >> OSC_CR_ERCLKEN_SHIFT)
#define OSC_BRD_CR_ERCLKEN(base) (BME_UBFX8(&OSC_CR_REG(base), OSC_CR_ERCLKEN_SHIFT, OSC_CR_ERCLKEN_WIDTH))

/*! @brief Set the ERCLKEN field to a new value. */
#define OSC_WR_CR_ERCLKEN(base, value) (OSC_RMW_CR(base, OSC_CR_ERCLKEN_MASK, OSC_CR_ERCLKEN(value)))
#define OSC_BWR_CR_ERCLKEN(base, value) (BME_BFI8(&OSC_CR_REG(base), ((uint8_t)(value) << OSC_CR_ERCLKEN_SHIFT), OSC_CR_ERCLKEN_SHIFT, OSC_CR_ERCLKEN_WIDTH))
/*@}*/

/*
 * MKM34Z7 PDB
 *
 * Programmable Delay Block
 *
 * Registers defined in this header file:
 * - PDB_SC - Status and Control register
 * - PDB_MOD - Modulus register
 * - PDB_CNT - Counter register
 * - PDB_IDLY - Interrupt Delay register
 * - PDB_C1 - Channel n Control register 1
 * - PDB_S - Channel n Status register
 * - PDB_DLY - Channel n Delay 0 register
 * - PDB_CHDLY2 - Channel n Delay 2 register
 * - PDB_CHDLY3 - Channel n Delay 3 register
 * - PDB_POEN - Pulse-Out n Enable register
 * - PDB_PODLY - Pulse-Out n Delay register
 */

#define PDB_INSTANCE_COUNT (1U) /*!< Number of instances of the PDB module. */
#define PDB0_IDX (0U) /*!< Instance number for PDB0. */

/*******************************************************************************
 * PDB_SC - Status and Control register
 ******************************************************************************/

/*!
 * @brief PDB_SC - Status and Control register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire PDB_SC register
 */
/*@{*/
#define PDB_RD_SC(base)          (PDB_SC_REG(base))
#define PDB_WR_SC(base, value)   (PDB_SC_REG(base) = (value))
#define PDB_RMW_SC(base, mask, value) (PDB_WR_SC(base, (PDB_RD_SC(base) & ~(mask)) | (value)))
#define PDB_SET_SC(base, value)  (BME_OR32(&PDB_SC_REG(base), (uint32_t)(value)))
#define PDB_CLR_SC(base, value)  (BME_AND32(&PDB_SC_REG(base), (uint32_t)(~(value))))
#define PDB_TOG_SC(base, value)  (BME_XOR32(&PDB_SC_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual PDB_SC bitfields
 */

/*!
 * @name Register PDB_SC, field LDOK[0] (RW)
 *
 * Writing 1 to this bit updates the internal registers of MOD, IDLY, CHnDLYm,
 * DACINTx,and POyDLY with the values written to their buffers. The MOD, IDLY,
 * CHnDLYm, DACINTx, and POyDLY will take effect according to the LDMOD. After 1 is
 * written to the LDOK field, the values in the buffers of above registers are
 * not effective and the buffers cannot be written until the values in buffers are
 * loaded into their internal registers. LDOK can be written only when PDBEN is
 * set or it can be written at the same time with PDBEN being written to 1. It is
 * automatically cleared when the values in buffers are loaded into the internal
 * registers or the PDBEN is cleared. Writing 0 to it has no effect.
 */
/*@{*/
/*! @brief Read current value of the PDB_SC_LDOK field. */
#define PDB_RD_SC_LDOK(base) ((PDB_SC_REG(base) & PDB_SC_LDOK_MASK) >> PDB_SC_LDOK_SHIFT)
#define PDB_BRD_SC_LDOK(base) (BME_UBFX32(&PDB_SC_REG(base), PDB_SC_LDOK_SHIFT, PDB_SC_LDOK_WIDTH))

/*! @brief Set the LDOK field to a new value. */
#define PDB_WR_SC_LDOK(base, value) (PDB_RMW_SC(base, PDB_SC_LDOK_MASK, PDB_SC_LDOK(value)))
#define PDB_BWR_SC_LDOK(base, value) (BME_BFI32(&PDB_SC_REG(base), ((uint32_t)(value) << PDB_SC_LDOK_SHIFT), PDB_SC_LDOK_SHIFT, PDB_SC_LDOK_WIDTH))
/*@}*/

/*!
 * @name Register PDB_SC, field CONT[1] (RW)
 *
 * Enables the PDB operation in Continuous mode.
 *
 * Values:
 * - 0b0 - PDB operation in One-Shot mode
 * - 0b1 - PDB operation in Continuous mode
 */
/*@{*/
/*! @brief Read current value of the PDB_SC_CONT field. */
#define PDB_RD_SC_CONT(base) ((PDB_SC_REG(base) & PDB_SC_CONT_MASK) >> PDB_SC_CONT_SHIFT)
#define PDB_BRD_SC_CONT(base) (BME_UBFX32(&PDB_SC_REG(base), PDB_SC_CONT_SHIFT, PDB_SC_CONT_WIDTH))

/*! @brief Set the CONT field to a new value. */
#define PDB_WR_SC_CONT(base, value) (PDB_RMW_SC(base, PDB_SC_CONT_MASK, PDB_SC_CONT(value)))
#define PDB_BWR_SC_CONT(base, value) (BME_BFI32(&PDB_SC_REG(base), ((uint32_t)(value) << PDB_SC_CONT_SHIFT), PDB_SC_CONT_SHIFT, PDB_SC_CONT_WIDTH))
/*@}*/

/*!
 * @name Register PDB_SC, field MULT[3:2] (RW)
 *
 * Selects the multiplication factor of the prescaler divider for the counter
 * clock.
 *
 * Values:
 * - 0b00 - Multiplication factor is 1.
 * - 0b01 - Multiplication factor is 10.
 * - 0b10 - Multiplication factor is 20.
 * - 0b11 - Multiplication factor is 40.
 */
/*@{*/
/*! @brief Read current value of the PDB_SC_MULT field. */
#define PDB_RD_SC_MULT(base) ((PDB_SC_REG(base) & PDB_SC_MULT_MASK) >> PDB_SC_MULT_SHIFT)
#define PDB_BRD_SC_MULT(base) (BME_UBFX32(&PDB_SC_REG(base), PDB_SC_MULT_SHIFT, PDB_SC_MULT_WIDTH))

/*! @brief Set the MULT field to a new value. */
#define PDB_WR_SC_MULT(base, value) (PDB_RMW_SC(base, PDB_SC_MULT_MASK, PDB_SC_MULT(value)))
#define PDB_BWR_SC_MULT(base, value) (BME_BFI32(&PDB_SC_REG(base), ((uint32_t)(value) << PDB_SC_MULT_SHIFT), PDB_SC_MULT_SHIFT, PDB_SC_MULT_WIDTH))
/*@}*/

/*!
 * @name Register PDB_SC, field PDBIE[5] (RW)
 *
 * Enables the PDB interrupt. When this field is set and DMAEN is cleared, PDBIF
 * generates a PDB interrupt.
 *
 * Values:
 * - 0b0 - PDB interrupt disabled.
 * - 0b1 - PDB interrupt enabled.
 */
/*@{*/
/*! @brief Read current value of the PDB_SC_PDBIE field. */
#define PDB_RD_SC_PDBIE(base) ((PDB_SC_REG(base) & PDB_SC_PDBIE_MASK) >> PDB_SC_PDBIE_SHIFT)
#define PDB_BRD_SC_PDBIE(base) (BME_UBFX32(&PDB_SC_REG(base), PDB_SC_PDBIE_SHIFT, PDB_SC_PDBIE_WIDTH))

/*! @brief Set the PDBIE field to a new value. */
#define PDB_WR_SC_PDBIE(base, value) (PDB_RMW_SC(base, PDB_SC_PDBIE_MASK, PDB_SC_PDBIE(value)))
#define PDB_BWR_SC_PDBIE(base, value) (BME_BFI32(&PDB_SC_REG(base), ((uint32_t)(value) << PDB_SC_PDBIE_SHIFT), PDB_SC_PDBIE_SHIFT, PDB_SC_PDBIE_WIDTH))
/*@}*/

/*!
 * @name Register PDB_SC, field PDBIF[6] (RW)
 *
 * This field is set when the counter value is equal to the IDLY register.
 * Writing zero clears this field.
 */
/*@{*/
/*! @brief Read current value of the PDB_SC_PDBIF field. */
#define PDB_RD_SC_PDBIF(base) ((PDB_SC_REG(base) & PDB_SC_PDBIF_MASK) >> PDB_SC_PDBIF_SHIFT)
#define PDB_BRD_SC_PDBIF(base) (BME_UBFX32(&PDB_SC_REG(base), PDB_SC_PDBIF_SHIFT, PDB_SC_PDBIF_WIDTH))

/*! @brief Set the PDBIF field to a new value. */
#define PDB_WR_SC_PDBIF(base, value) (PDB_RMW_SC(base, PDB_SC_PDBIF_MASK, PDB_SC_PDBIF(value)))
#define PDB_BWR_SC_PDBIF(base, value) (BME_BFI32(&PDB_SC_REG(base), ((uint32_t)(value) << PDB_SC_PDBIF_SHIFT), PDB_SC_PDBIF_SHIFT, PDB_SC_PDBIF_WIDTH))
/*@}*/

/*!
 * @name Register PDB_SC, field PDBEN[7] (RW)
 *
 * Values:
 * - 0b0 - PDB disabled. Counter is off.
 * - 0b1 - PDB enabled.
 */
/*@{*/
/*! @brief Read current value of the PDB_SC_PDBEN field. */
#define PDB_RD_SC_PDBEN(base) ((PDB_SC_REG(base) & PDB_SC_PDBEN_MASK) >> PDB_SC_PDBEN_SHIFT)
#define PDB_BRD_SC_PDBEN(base) (BME_UBFX32(&PDB_SC_REG(base), PDB_SC_PDBEN_SHIFT, PDB_SC_PDBEN_WIDTH))

/*! @brief Set the PDBEN field to a new value. */
#define PDB_WR_SC_PDBEN(base, value) (PDB_RMW_SC(base, PDB_SC_PDBEN_MASK, PDB_SC_PDBEN(value)))
#define PDB_BWR_SC_PDBEN(base, value) (BME_BFI32(&PDB_SC_REG(base), ((uint32_t)(value) << PDB_SC_PDBEN_SHIFT), PDB_SC_PDBEN_SHIFT, PDB_SC_PDBEN_WIDTH))
/*@}*/

/*!
 * @name Register PDB_SC, field TRGSEL[11:8] (RW)
 *
 * Selects the trigger input source for the PDB. The trigger input source can be
 * internal or external (EXTRG pin), or the software trigger. Refer to chip
 * configuration details for the actual PDB input trigger connections.
 *
 * Values:
 * - 0b0000 - Trigger-In 0 is selected.
 * - 0b0001 - Trigger-In 1 is selected.
 * - 0b0010 - Trigger-In 2 is selected.
 * - 0b0011 - Trigger-In 3 is selected.
 * - 0b0100 - Trigger-In 4 is selected.
 * - 0b0101 - Trigger-In 5 is selected.
 * - 0b0110 - Trigger-In 6 is selected.
 * - 0b0111 - Trigger-In 7 is selected.
 * - 0b1000 - Trigger-In 8 is selected.
 * - 0b1001 - Trigger-In 9 is selected.
 * - 0b1010 - Trigger-In 10 is selected.
 * - 0b1011 - Trigger-In 11 is selected.
 * - 0b1100 - Trigger-In 12 is selected.
 * - 0b1101 - Trigger-In 13 is selected.
 * - 0b1110 - Trigger-In 14 is selected.
 * - 0b1111 - Software trigger is selected.
 */
/*@{*/
/*! @brief Read current value of the PDB_SC_TRGSEL field. */
#define PDB_RD_SC_TRGSEL(base) ((PDB_SC_REG(base) & PDB_SC_TRGSEL_MASK) >> PDB_SC_TRGSEL_SHIFT)
#define PDB_BRD_SC_TRGSEL(base) (BME_UBFX32(&PDB_SC_REG(base), PDB_SC_TRGSEL_SHIFT, PDB_SC_TRGSEL_WIDTH))

/*! @brief Set the TRGSEL field to a new value. */
#define PDB_WR_SC_TRGSEL(base, value) (PDB_RMW_SC(base, PDB_SC_TRGSEL_MASK, PDB_SC_TRGSEL(value)))
#define PDB_BWR_SC_TRGSEL(base, value) (BME_BFI32(&PDB_SC_REG(base), ((uint32_t)(value) << PDB_SC_TRGSEL_SHIFT), PDB_SC_TRGSEL_SHIFT, PDB_SC_TRGSEL_WIDTH))
/*@}*/

/*!
 * @name Register PDB_SC, field PRESCALER[14:12] (RW)
 *
 * Values:
 * - 0b000 - Counting uses the peripheral clock divided by multiplication factor
 *     selected by MULT.
 * - 0b001 - Counting uses the peripheral clock divided by twice of the
 *     multiplication factor selected by MULT.
 * - 0b010 - Counting uses the peripheral clock divided by four times of the
 *     multiplication factor selected by MULT.
 * - 0b011 - Counting uses the peripheral clock divided by eight times of the
 *     multiplication factor selected by MULT.
 * - 0b100 - Counting uses the peripheral clock divided by 16 times of the
 *     multiplication factor selected by MULT.
 * - 0b101 - Counting uses the peripheral clock divided by 32 times of the
 *     multiplication factor selected by MULT.
 * - 0b110 - Counting uses the peripheral clock divided by 64 times of the
 *     multiplication factor selected by MULT.
 * - 0b111 - Counting uses the peripheral clock divided by 128 times of the
 *     multiplication factor selected by MULT.
 */
/*@{*/
/*! @brief Read current value of the PDB_SC_PRESCALER field. */
#define PDB_RD_SC_PRESCALER(base) ((PDB_SC_REG(base) & PDB_SC_PRESCALER_MASK) >> PDB_SC_PRESCALER_SHIFT)
#define PDB_BRD_SC_PRESCALER(base) (BME_UBFX32(&PDB_SC_REG(base), PDB_SC_PRESCALER_SHIFT, PDB_SC_PRESCALER_WIDTH))

/*! @brief Set the PRESCALER field to a new value. */
#define PDB_WR_SC_PRESCALER(base, value) (PDB_RMW_SC(base, PDB_SC_PRESCALER_MASK, PDB_SC_PRESCALER(value)))
#define PDB_BWR_SC_PRESCALER(base, value) (BME_BFI32(&PDB_SC_REG(base), ((uint32_t)(value) << PDB_SC_PRESCALER_SHIFT), PDB_SC_PRESCALER_SHIFT, PDB_SC_PRESCALER_WIDTH))
/*@}*/

/*!
 * @name Register PDB_SC, field DMAEN[15] (RW)
 *
 * When DMA is enabled, the PDBIF flag generates a DMA request instead of an
 * interrupt.
 *
 * Values:
 * - 0b0 - DMA disabled.
 * - 0b1 - DMA enabled.
 */
/*@{*/
/*! @brief Read current value of the PDB_SC_DMAEN field. */
#define PDB_RD_SC_DMAEN(base) ((PDB_SC_REG(base) & PDB_SC_DMAEN_MASK) >> PDB_SC_DMAEN_SHIFT)
#define PDB_BRD_SC_DMAEN(base) (BME_UBFX32(&PDB_SC_REG(base), PDB_SC_DMAEN_SHIFT, PDB_SC_DMAEN_WIDTH))

/*! @brief Set the DMAEN field to a new value. */
#define PDB_WR_SC_DMAEN(base, value) (PDB_RMW_SC(base, PDB_SC_DMAEN_MASK, PDB_SC_DMAEN(value)))
#define PDB_BWR_SC_DMAEN(base, value) (BME_BFI32(&PDB_SC_REG(base), ((uint32_t)(value) << PDB_SC_DMAEN_SHIFT), PDB_SC_DMAEN_SHIFT, PDB_SC_DMAEN_WIDTH))
/*@}*/

/*!
 * @name Register PDB_SC, field SWTRIG[16] (WORZ)
 *
 * When PDB is enabled and the software trigger is selected as the trigger input
 * source, writing 1 to this field resets and restarts the counter. Writing 0 to
 * this field has no effect. Reading this field results 0.
 */
/*@{*/
/*! @brief Set the SWTRIG field to a new value. */
#define PDB_WR_SC_SWTRIG(base, value) (PDB_RMW_SC(base, PDB_SC_SWTRIG_MASK, PDB_SC_SWTRIG(value)))
#define PDB_BWR_SC_SWTRIG(base, value) (BME_BFI32(&PDB_SC_REG(base), ((uint32_t)(value) << PDB_SC_SWTRIG_SHIFT), PDB_SC_SWTRIG_SHIFT, PDB_SC_SWTRIG_WIDTH))
/*@}*/

/*!
 * @name Register PDB_SC, field PDBEIE[17] (RW)
 *
 * Enables the PDB sequence error interrupt. When this field is set, any of the
 * PDB channel sequence error flags generates a PDB sequence error interrupt.
 *
 * Values:
 * - 0b0 - PDB sequence error interrupt disabled.
 * - 0b1 - PDB sequence error interrupt enabled.
 */
/*@{*/
/*! @brief Read current value of the PDB_SC_PDBEIE field. */
#define PDB_RD_SC_PDBEIE(base) ((PDB_SC_REG(base) & PDB_SC_PDBEIE_MASK) >> PDB_SC_PDBEIE_SHIFT)
#define PDB_BRD_SC_PDBEIE(base) (BME_UBFX32(&PDB_SC_REG(base), PDB_SC_PDBEIE_SHIFT, PDB_SC_PDBEIE_WIDTH))

/*! @brief Set the PDBEIE field to a new value. */
#define PDB_WR_SC_PDBEIE(base, value) (PDB_RMW_SC(base, PDB_SC_PDBEIE_MASK, PDB_SC_PDBEIE(value)))
#define PDB_BWR_SC_PDBEIE(base, value) (BME_BFI32(&PDB_SC_REG(base), ((uint32_t)(value) << PDB_SC_PDBEIE_SHIFT), PDB_SC_PDBEIE_SHIFT, PDB_SC_PDBEIE_WIDTH))
/*@}*/

/*!
 * @name Register PDB_SC, field LDMOD[19:18] (RW)
 *
 * Selects the mode to load the MOD, IDLY, CHnDLYm, INTx, and POyDLY registers,
 * after 1 is written to LDOK.
 *
 * Values:
 * - 0b00 - The internal registers are loaded with the values from their buffers
 *     immediately after 1 is written to LDOK.
 * - 0b01 - The internal registers are loaded with the values from their buffers
 *     when the PDB counter reaches the MOD register value after 1 is written to
 *     LDOK.
 * - 0b10 - The internal registers are loaded with the values from their buffers
 *     when a trigger input event is detected after 1 is written to LDOK.
 * - 0b11 - The internal registers are loaded with the values from their buffers
 *     when either the PDB counter reaches the MOD register value or a trigger
 *     input event is detected, after 1 is written to LDOK.
 */
/*@{*/
/*! @brief Read current value of the PDB_SC_LDMOD field. */
#define PDB_RD_SC_LDMOD(base) ((PDB_SC_REG(base) & PDB_SC_LDMOD_MASK) >> PDB_SC_LDMOD_SHIFT)
#define PDB_BRD_SC_LDMOD(base) (BME_UBFX32(&PDB_SC_REG(base), PDB_SC_LDMOD_SHIFT, PDB_SC_LDMOD_WIDTH))

/*! @brief Set the LDMOD field to a new value. */
#define PDB_WR_SC_LDMOD(base, value) (PDB_RMW_SC(base, PDB_SC_LDMOD_MASK, PDB_SC_LDMOD(value)))
#define PDB_BWR_SC_LDMOD(base, value) (BME_BFI32(&PDB_SC_REG(base), ((uint32_t)(value) << PDB_SC_LDMOD_SHIFT), PDB_SC_LDMOD_SHIFT, PDB_SC_LDMOD_WIDTH))
/*@}*/

/*******************************************************************************
 * PDB_MOD - Modulus register
 ******************************************************************************/

/*!
 * @brief PDB_MOD - Modulus register (RW)
 *
 * Reset value: 0x0000FFFFU
 */
/*!
 * @name Constants and macros for entire PDB_MOD register
 */
/*@{*/
#define PDB_RD_MOD(base)         (PDB_MOD_REG(base))
#define PDB_WR_MOD(base, value)  (PDB_MOD_REG(base) = (value))
#define PDB_RMW_MOD(base, mask, value) (PDB_WR_MOD(base, (PDB_RD_MOD(base) & ~(mask)) | (value)))
#define PDB_SET_MOD(base, value) (BME_OR32(&PDB_MOD_REG(base), (uint32_t)(value)))
#define PDB_CLR_MOD(base, value) (BME_AND32(&PDB_MOD_REG(base), (uint32_t)(~(value))))
#define PDB_TOG_MOD(base, value) (BME_XOR32(&PDB_MOD_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual PDB_MOD bitfields
 */

/*!
 * @name Register PDB_MOD, field MOD[15:0] (RW)
 *
 * Specifies the period of the counter. When the counter reaches this value, it
 * will be reset back to zero. If the PDB is in Continuous mode, the count begins
 * anew. Reading this field returns the value of the internal register that is
 * effective for the current cycle of PDB.
 */
/*@{*/
/*! @brief Read current value of the PDB_MOD_MOD field. */
#define PDB_RD_MOD_MOD(base) ((PDB_MOD_REG(base) & PDB_MOD_MOD_MASK) >> PDB_MOD_MOD_SHIFT)
#define PDB_BRD_MOD_MOD(base) (BME_UBFX32(&PDB_MOD_REG(base), PDB_MOD_MOD_SHIFT, PDB_MOD_MOD_WIDTH))

/*! @brief Set the MOD field to a new value. */
#define PDB_WR_MOD_MOD(base, value) (PDB_RMW_MOD(base, PDB_MOD_MOD_MASK, PDB_MOD_MOD(value)))
#define PDB_BWR_MOD_MOD(base, value) (BME_BFI32(&PDB_MOD_REG(base), ((uint32_t)(value) << PDB_MOD_MOD_SHIFT), PDB_MOD_MOD_SHIFT, PDB_MOD_MOD_WIDTH))
/*@}*/

/*******************************************************************************
 * PDB_CNT - Counter register
 ******************************************************************************/

/*!
 * @brief PDB_CNT - Counter register (RO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire PDB_CNT register
 */
/*@{*/
#define PDB_RD_CNT(base)         (PDB_CNT_REG(base))
/*@}*/

/*
 * Constants & macros for individual PDB_CNT bitfields
 */

/*!
 * @name Register PDB_CNT, field CNT[15:0] (RO)
 *
 * Contains the current value of the counter.
 */
/*@{*/
/*! @brief Read current value of the PDB_CNT_CNT field. */
#define PDB_RD_CNT_CNT(base) ((PDB_CNT_REG(base) & PDB_CNT_CNT_MASK) >> PDB_CNT_CNT_SHIFT)
#define PDB_BRD_CNT_CNT(base) (BME_UBFX32(&PDB_CNT_REG(base), PDB_CNT_CNT_SHIFT, PDB_CNT_CNT_WIDTH))
/*@}*/

/*******************************************************************************
 * PDB_IDLY - Interrupt Delay register
 ******************************************************************************/

/*!
 * @brief PDB_IDLY - Interrupt Delay register (RW)
 *
 * Reset value: 0x0000FFFFU
 */
/*!
 * @name Constants and macros for entire PDB_IDLY register
 */
/*@{*/
#define PDB_RD_IDLY(base)        (PDB_IDLY_REG(base))
#define PDB_WR_IDLY(base, value) (PDB_IDLY_REG(base) = (value))
#define PDB_RMW_IDLY(base, mask, value) (PDB_WR_IDLY(base, (PDB_RD_IDLY(base) & ~(mask)) | (value)))
#define PDB_SET_IDLY(base, value) (BME_OR32(&PDB_IDLY_REG(base), (uint32_t)(value)))
#define PDB_CLR_IDLY(base, value) (BME_AND32(&PDB_IDLY_REG(base), (uint32_t)(~(value))))
#define PDB_TOG_IDLY(base, value) (BME_XOR32(&PDB_IDLY_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual PDB_IDLY bitfields
 */

/*!
 * @name Register PDB_IDLY, field IDLY[15:0] (RW)
 *
 * Specifies the delay value to schedule the PDB interrupt. It can be used to
 * schedule an independent interrupt at some point in the PDB cycle. If enabled, a
 * PDB interrupt is generated, when the counter is equal to the IDLY. Reading
 * this field returns the value of internal register that is effective for the
 * current cycle of the PDB.
 */
/*@{*/
/*! @brief Read current value of the PDB_IDLY_IDLY field. */
#define PDB_RD_IDLY_IDLY(base) ((PDB_IDLY_REG(base) & PDB_IDLY_IDLY_MASK) >> PDB_IDLY_IDLY_SHIFT)
#define PDB_BRD_IDLY_IDLY(base) (BME_UBFX32(&PDB_IDLY_REG(base), PDB_IDLY_IDLY_SHIFT, PDB_IDLY_IDLY_WIDTH))

/*! @brief Set the IDLY field to a new value. */
#define PDB_WR_IDLY_IDLY(base, value) (PDB_RMW_IDLY(base, PDB_IDLY_IDLY_MASK, PDB_IDLY_IDLY(value)))
#define PDB_BWR_IDLY_IDLY(base, value) (BME_BFI32(&PDB_IDLY_REG(base), ((uint32_t)(value) << PDB_IDLY_IDLY_SHIFT), PDB_IDLY_IDLY_SHIFT, PDB_IDLY_IDLY_WIDTH))
/*@}*/

/*******************************************************************************
 * PDB_C1 - Channel n Control register 1
 ******************************************************************************/

/*!
 * @brief PDB_C1 - Channel n Control register 1 (RW)
 *
 * Reset value: 0x00000000U
 *
 * Each PDB channel has one control register, CHnC1. The fields in this register
 * control the functionality of each PDB channel operation.
 */
/*!
 * @name Constants and macros for entire PDB_C1 register
 */
/*@{*/
#define PDB_RD_C1(base, index)   (PDB_C1_REG(base, index))
#define PDB_WR_C1(base, index, value) (PDB_C1_REG(base, index) = (value))
#define PDB_RMW_C1(base, index, mask, value) (PDB_WR_C1(base, index, (PDB_RD_C1(base, index) & ~(mask)) | (value)))
#define PDB_SET_C1(base, index, value) (BME_OR32(&PDB_C1_REG(base, index), (uint32_t)(value)))
#define PDB_CLR_C1(base, index, value) (BME_AND32(&PDB_C1_REG(base, index), (uint32_t)(~(value))))
#define PDB_TOG_C1(base, index, value) (BME_XOR32(&PDB_C1_REG(base, index), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual PDB_C1 bitfields
 */

/*!
 * @name Register PDB_C1, field EN[7:0] (RW)
 *
 * Enables the PDB ADC pre-trigger outputs. Only lower M pre-trigger fields are
 * implemented in this MCU.
 *
 * Values:
 * - 0b00000000 - PDB channel's corresponding pre-trigger disabled.
 * - 0b00000001 - PDB channel's corresponding pre-trigger enabled.
 */
/*@{*/
/*! @brief Read current value of the PDB_C1_EN field. */
#define PDB_RD_C1_EN(base, index) ((PDB_C1_REG(base, index) & PDB_C1_EN_MASK) >> PDB_C1_EN_SHIFT)
#define PDB_BRD_C1_EN(base, index) (BME_UBFX32(&PDB_C1_REG(base, index), PDB_C1_EN_SHIFT, PDB_C1_EN_WIDTH))

/*! @brief Set the EN field to a new value. */
#define PDB_WR_C1_EN(base, index, value) (PDB_RMW_C1(base, index, PDB_C1_EN_MASK, PDB_C1_EN(value)))
#define PDB_BWR_C1_EN(base, index, value) (BME_BFI32(&PDB_C1_REG(base, index), ((uint32_t)(value) << PDB_C1_EN_SHIFT), PDB_C1_EN_SHIFT, PDB_C1_EN_WIDTH))
/*@}*/

/*!
 * @name Register PDB_C1, field TOS[15:8] (RW)
 *
 * These bits select the PDB ADC pre-trigger outputs. Only lower M pre-trigger
 * bits are implemented in this MCU.
 *
 * Values:
 * - 0b00000000 - PDB channel's corresponding pre-trigger is in bypassed mode.
 *     The pre-trigger asserts one peripheral clock cycle after a rising edge is
 *     detected on selected trigger input source or software trigger is selected
 *     and SWTRIG is written with 1.
 * - 0b00000001 - PDB channel's corresponding pre-trigger asserts when the
 *     counter reaches the channel delay register plus one peripheral clock cycle
 *     after a rising edge is detected on selected trigger input source or software
 *     trigger is selected and SETRIG is written with 1.
 */
/*@{*/
/*! @brief Read current value of the PDB_C1_TOS field. */
#define PDB_RD_C1_TOS(base, index) ((PDB_C1_REG(base, index) & PDB_C1_TOS_MASK) >> PDB_C1_TOS_SHIFT)
#define PDB_BRD_C1_TOS(base, index) (BME_UBFX32(&PDB_C1_REG(base, index), PDB_C1_TOS_SHIFT, PDB_C1_TOS_WIDTH))

/*! @brief Set the TOS field to a new value. */
#define PDB_WR_C1_TOS(base, index, value) (PDB_RMW_C1(base, index, PDB_C1_TOS_MASK, PDB_C1_TOS(value)))
#define PDB_BWR_C1_TOS(base, index, value) (BME_BFI32(&PDB_C1_REG(base, index), ((uint32_t)(value) << PDB_C1_TOS_SHIFT), PDB_C1_TOS_SHIFT, PDB_C1_TOS_WIDTH))
/*@}*/

/*!
 * @name Register PDB_C1, field BB[23:16] (RW)
 *
 * Enables the PDB ADC pre-trigger operation as back-to-back mode. Only lower M
 * pre-trigger bits are implemented in this MCU. Back-to-back operation enables
 * the ADC conversions complete to trigger the next PDB channel pre-trigger and
 * trigger output, so that the ADC conversions can be triggered on the next set of
 * configuration and results registers. Application code must enable only the
 * back-to-back operation of the PDB pre-triggers at the leading of the back-to-back
 * connection chain.
 *
 * Values:
 * - 0b00000000 - PDB channel's corresponding pre-trigger back-to-back operation
 *     disabled.
 * - 0b00000001 - PDB channel's corresponding pre-trigger back-to-back operation
 *     enabled.
 */
/*@{*/
/*! @brief Read current value of the PDB_C1_BB field. */
#define PDB_RD_C1_BB(base, index) ((PDB_C1_REG(base, index) & PDB_C1_BB_MASK) >> PDB_C1_BB_SHIFT)
#define PDB_BRD_C1_BB(base, index) (BME_UBFX32(&PDB_C1_REG(base, index), PDB_C1_BB_SHIFT, PDB_C1_BB_WIDTH))

/*! @brief Set the BB field to a new value. */
#define PDB_WR_C1_BB(base, index, value) (PDB_RMW_C1(base, index, PDB_C1_BB_MASK, PDB_C1_BB(value)))
#define PDB_BWR_C1_BB(base, index, value) (BME_BFI32(&PDB_C1_REG(base, index), ((uint32_t)(value) << PDB_C1_BB_SHIFT), PDB_C1_BB_SHIFT, PDB_C1_BB_WIDTH))
/*@}*/

/*******************************************************************************
 * PDB_S - Channel n Status register
 ******************************************************************************/

/*!
 * @brief PDB_S - Channel n Status register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire PDB_S register
 */
/*@{*/
#define PDB_RD_S(base, index)    (PDB_S_REG(base, index))
#define PDB_WR_S(base, index, value) (PDB_S_REG(base, index) = (value))
#define PDB_RMW_S(base, index, mask, value) (PDB_WR_S(base, index, (PDB_RD_S(base, index) & ~(mask)) | (value)))
#define PDB_SET_S(base, index, value) (BME_OR32(&PDB_S_REG(base, index), (uint32_t)(value)))
#define PDB_CLR_S(base, index, value) (BME_AND32(&PDB_S_REG(base, index), (uint32_t)(~(value))))
#define PDB_TOG_S(base, index, value) (BME_XOR32(&PDB_S_REG(base, index), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual PDB_S bitfields
 */

/*!
 * @name Register PDB_S, field ERR[7:0] (RW)
 *
 * Only the lower M bits are implemented in this MCU.
 *
 * Values:
 * - 0b00000000 - Sequence error not detected on PDB channel's corresponding
 *     pre-trigger.
 * - 0b00000001 - Sequence error detected on PDB channel's corresponding
 *     pre-trigger. ADCn block can be triggered for a conversion by one pre-trigger from
 *     PDB channel n. When one conversion, which is triggered by one of the
 *     pre-triggers from PDB channel n, is in progress, new trigger from PDB
 *     channel's corresponding pre-trigger m cannot be accepted by ADCn, and ERR[m] is
 *     set. Writing 0's to clear the sequence error flags.
 */
/*@{*/
/*! @brief Read current value of the PDB_S_ERR field. */
#define PDB_RD_S_ERR(base, index) ((PDB_S_REG(base, index) & PDB_S_ERR_MASK) >> PDB_S_ERR_SHIFT)
#define PDB_BRD_S_ERR(base, index) (BME_UBFX32(&PDB_S_REG(base, index), PDB_S_ERR_SHIFT, PDB_S_ERR_WIDTH))

/*! @brief Set the ERR field to a new value. */
#define PDB_WR_S_ERR(base, index, value) (PDB_RMW_S(base, index, PDB_S_ERR_MASK, PDB_S_ERR(value)))
#define PDB_BWR_S_ERR(base, index, value) (BME_BFI32(&PDB_S_REG(base, index), ((uint32_t)(value) << PDB_S_ERR_SHIFT), PDB_S_ERR_SHIFT, PDB_S_ERR_WIDTH))
/*@}*/

/*!
 * @name Register PDB_S, field CF[23:16] (RW)
 *
 * The CF[m] field is set when the PDB counter matches the CHnDLYm. Write 0 to
 * clear these bits.
 */
/*@{*/
/*! @brief Read current value of the PDB_S_CF field. */
#define PDB_RD_S_CF(base, index) ((PDB_S_REG(base, index) & PDB_S_CF_MASK) >> PDB_S_CF_SHIFT)
#define PDB_BRD_S_CF(base, index) (BME_UBFX32(&PDB_S_REG(base, index), PDB_S_CF_SHIFT, PDB_S_CF_WIDTH))

/*! @brief Set the CF field to a new value. */
#define PDB_WR_S_CF(base, index, value) (PDB_RMW_S(base, index, PDB_S_CF_MASK, PDB_S_CF(value)))
#define PDB_BWR_S_CF(base, index, value) (BME_BFI32(&PDB_S_REG(base, index), ((uint32_t)(value) << PDB_S_CF_SHIFT), PDB_S_CF_SHIFT, PDB_S_CF_WIDTH))
/*@}*/

/*******************************************************************************
 * PDB_DLY - Channel n Delay 0 register
 ******************************************************************************/

/*!
 * @brief PDB_DLY - Channel n Delay 0 register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire PDB_DLY register
 */
/*@{*/
#define PDB_RD_DLY(base, index, index2) (PDB_DLY_REG(base, index, index2))
#define PDB_WR_DLY(base, index, index2, value) (PDB_DLY_REG(base, index, index2) = (value))
#define PDB_RMW_DLY(base, index, index2, mask, value) (PDB_WR_DLY(base, index, index2, (PDB_RD_DLY(base, index, index2) & ~(mask)) | (value)))
#define PDB_SET_DLY(base, index, index2, value) (BME_OR32(&PDB_DLY_REG(base, index, index2), (uint32_t)(value)))
#define PDB_CLR_DLY(base, index, index2, value) (BME_AND32(&PDB_DLY_REG(base, index, index2), (uint32_t)(~(value))))
#define PDB_TOG_DLY(base, index, index2, value) (BME_XOR32(&PDB_DLY_REG(base, index, index2), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual PDB_DLY bitfields
 */

/*!
 * @name Register PDB_DLY, field DLY[15:0] (RW)
 *
 * Specifies the delay value for the channel's corresponding pre-trigger. The
 * pre-trigger asserts when the counter is equal to DLY. Reading this field returns
 * the value of internal register that is effective for the current PDB cycle.
 */
/*@{*/
/*! @brief Read current value of the PDB_DLY_DLY field. */
#define PDB_RD_DLY_DLY(base, index, index2) ((PDB_DLY_REG(base, index, index2) & PDB_DLY_DLY_MASK) >> PDB_DLY_DLY_SHIFT)
#define PDB_BRD_DLY_DLY(base, index, index2) (BME_UBFX32(&PDB_DLY_REG(base, index, index2), PDB_DLY_DLY_SHIFT, PDB_DLY_DLY_WIDTH))

/*! @brief Set the DLY field to a new value. */
#define PDB_WR_DLY_DLY(base, index, index2, value) (PDB_RMW_DLY(base, index, index2, PDB_DLY_DLY_MASK, PDB_DLY_DLY(value)))
#define PDB_BWR_DLY_DLY(base, index, index2, value) (BME_BFI32(&PDB_DLY_REG(base, index, index2), ((uint32_t)(value) << PDB_DLY_DLY_SHIFT), PDB_DLY_DLY_SHIFT, PDB_DLY_DLY_WIDTH))
/*@}*/

/*******************************************************************************
 * PDB_CHDLY2 - Channel n Delay 2 register
 ******************************************************************************/

/*!
 * @brief PDB_CHDLY2 - Channel n Delay 2 register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire PDB_CHDLY2 register
 */
/*@{*/
#define PDB_RD_CHDLY2(base, index) (PDB_CHDLY2_REG(base, index))
#define PDB_WR_CHDLY2(base, index, value) (PDB_CHDLY2_REG(base, index) = (value))
#define PDB_RMW_CHDLY2(base, index, mask, value) (PDB_WR_CHDLY2(base, index, (PDB_RD_CHDLY2(base, index) & ~(mask)) | (value)))
#define PDB_SET_CHDLY2(base, index, value) (BME_OR32(&PDB_CHDLY2_REG(base, index), (uint32_t)(value)))
#define PDB_CLR_CHDLY2(base, index, value) (BME_AND32(&PDB_CHDLY2_REG(base, index), (uint32_t)(~(value))))
#define PDB_TOG_CHDLY2(base, index, value) (BME_XOR32(&PDB_CHDLY2_REG(base, index), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual PDB_CHDLY2 bitfields
 */

/*!
 * @name Register PDB_CHDLY2, field DLY[15:0] (RW)
 *
 * These bits specify the delay value for the channel's corresponding
 * pre-trigger. The pre-trigger asserts when the counter is equal to DLY. Reading these
 * bits returns the value of internal register that is effective for the current PDB
 * cycle.
 */
/*@{*/
/*! @brief Read current value of the PDB_CHDLY2_DLY field. */
#define PDB_RD_CHDLY2_DLY(base, index) ((PDB_CHDLY2_REG(base, index) & PDB_CHDLY2_DLY_MASK) >> PDB_CHDLY2_DLY_SHIFT)
#define PDB_BRD_CHDLY2_DLY(base, index) (BME_UBFX32(&PDB_CHDLY2_REG(base, index), PDB_CHDLY2_DLY_SHIFT, PDB_CHDLY2_DLY_WIDTH))

/*! @brief Set the DLY field to a new value. */
#define PDB_WR_CHDLY2_DLY(base, index, value) (PDB_RMW_CHDLY2(base, index, PDB_CHDLY2_DLY_MASK, PDB_CHDLY2_DLY(value)))
#define PDB_BWR_CHDLY2_DLY(base, index, value) (BME_BFI32(&PDB_CHDLY2_REG(base, index), ((uint32_t)(value) << PDB_CHDLY2_DLY_SHIFT), PDB_CHDLY2_DLY_SHIFT, PDB_CHDLY2_DLY_WIDTH))
/*@}*/

/*******************************************************************************
 * PDB_CHDLY3 - Channel n Delay 3 register
 ******************************************************************************/

/*!
 * @brief PDB_CHDLY3 - Channel n Delay 3 register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire PDB_CHDLY3 register
 */
/*@{*/
#define PDB_RD_CHDLY3(base, index) (PDB_CHDLY3_REG(base, index))
#define PDB_WR_CHDLY3(base, index, value) (PDB_CHDLY3_REG(base, index) = (value))
#define PDB_RMW_CHDLY3(base, index, mask, value) (PDB_WR_CHDLY3(base, index, (PDB_RD_CHDLY3(base, index) & ~(mask)) | (value)))
#define PDB_SET_CHDLY3(base, index, value) (BME_OR32(&PDB_CHDLY3_REG(base, index), (uint32_t)(value)))
#define PDB_CLR_CHDLY3(base, index, value) (BME_AND32(&PDB_CHDLY3_REG(base, index), (uint32_t)(~(value))))
#define PDB_TOG_CHDLY3(base, index, value) (BME_XOR32(&PDB_CHDLY3_REG(base, index), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual PDB_CHDLY3 bitfields
 */

/*!
 * @name Register PDB_CHDLY3, field DLY[15:0] (RW)
 *
 * These bits specify the delay value for the channel's corresponding
 * pre-trigger. The pre-trigger asserts when the counter is equal to DLY. Reading these
 * bits returns the value of internal register that is effective for the current PDB
 * cycle.
 */
/*@{*/
/*! @brief Read current value of the PDB_CHDLY3_DLY field. */
#define PDB_RD_CHDLY3_DLY(base, index) ((PDB_CHDLY3_REG(base, index) & PDB_CHDLY3_DLY_MASK) >> PDB_CHDLY3_DLY_SHIFT)
#define PDB_BRD_CHDLY3_DLY(base, index) (BME_UBFX32(&PDB_CHDLY3_REG(base, index), PDB_CHDLY3_DLY_SHIFT, PDB_CHDLY3_DLY_WIDTH))

/*! @brief Set the DLY field to a new value. */
#define PDB_WR_CHDLY3_DLY(base, index, value) (PDB_RMW_CHDLY3(base, index, PDB_CHDLY3_DLY_MASK, PDB_CHDLY3_DLY(value)))
#define PDB_BWR_CHDLY3_DLY(base, index, value) (BME_BFI32(&PDB_CHDLY3_REG(base, index), ((uint32_t)(value) << PDB_CHDLY3_DLY_SHIFT), PDB_CHDLY3_DLY_SHIFT, PDB_CHDLY3_DLY_WIDTH))
/*@}*/

/*******************************************************************************
 * PDB_POEN - Pulse-Out n Enable register
 ******************************************************************************/

/*!
 * @brief PDB_POEN - Pulse-Out n Enable register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire PDB_POEN register
 */
/*@{*/
#define PDB_RD_POEN(base)        (PDB_POEN_REG(base))
#define PDB_WR_POEN(base, value) (PDB_POEN_REG(base) = (value))
#define PDB_RMW_POEN(base, mask, value) (PDB_WR_POEN(base, (PDB_RD_POEN(base) & ~(mask)) | (value)))
#define PDB_SET_POEN(base, value) (BME_OR32(&PDB_POEN_REG(base), (uint32_t)(value)))
#define PDB_CLR_POEN(base, value) (BME_AND32(&PDB_POEN_REG(base), (uint32_t)(~(value))))
#define PDB_TOG_POEN(base, value) (BME_XOR32(&PDB_POEN_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual PDB_POEN bitfields
 */

/*!
 * @name Register PDB_POEN, field POEN[7:0] (RW)
 *
 * Enables the pulse output. Only lower Y bits are implemented in this MCU.
 *
 * Values:
 * - 0b00000000 - PDB Pulse-Out disabled
 * - 0b00000001 - PDB Pulse-Out enabled
 */
/*@{*/
/*! @brief Read current value of the PDB_POEN_POEN field. */
#define PDB_RD_POEN_POEN(base) ((PDB_POEN_REG(base) & PDB_POEN_POEN_MASK) >> PDB_POEN_POEN_SHIFT)
#define PDB_BRD_POEN_POEN(base) (BME_UBFX32(&PDB_POEN_REG(base), PDB_POEN_POEN_SHIFT, PDB_POEN_POEN_WIDTH))

/*! @brief Set the POEN field to a new value. */
#define PDB_WR_POEN_POEN(base, value) (PDB_RMW_POEN(base, PDB_POEN_POEN_MASK, PDB_POEN_POEN(value)))
#define PDB_BWR_POEN_POEN(base, value) (BME_BFI32(&PDB_POEN_REG(base), ((uint32_t)(value) << PDB_POEN_POEN_SHIFT), PDB_POEN_POEN_SHIFT, PDB_POEN_POEN_WIDTH))
/*@}*/

/*******************************************************************************
 * PDB_PODLY - Pulse-Out n Delay register
 ******************************************************************************/

/*!
 * @brief PDB_PODLY - Pulse-Out n Delay register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire PDB_PODLY register
 */
/*@{*/
#define PDB_RD_PODLY(base, index) (PDB_PODLY_REG(base, index))
#define PDB_WR_PODLY(base, index, value) (PDB_PODLY_REG(base, index) = (value))
#define PDB_RMW_PODLY(base, index, mask, value) (PDB_WR_PODLY(base, index, (PDB_RD_PODLY(base, index) & ~(mask)) | (value)))
#define PDB_SET_PODLY(base, index, value) (BME_OR32(&PDB_PODLY_REG(base, index), (uint32_t)(value)))
#define PDB_CLR_PODLY(base, index, value) (BME_AND32(&PDB_PODLY_REG(base, index), (uint32_t)(~(value))))
#define PDB_TOG_PODLY(base, index, value) (BME_XOR32(&PDB_PODLY_REG(base, index), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual PDB_PODLY bitfields
 */

/*!
 * @name Register PDB_PODLY, field DLY2[15:0] (RW)
 *
 * These bits specify the delay 2 value for the PDB Pulse-Out. Pulse-Out goes
 * low when the PDB counter is equal to the DLY2. Reading these bits returns the
 * value of internal register that is effective for the current PDB cycle.
 */
/*@{*/
/*! @brief Read current value of the PDB_PODLY_DLY2 field. */
#define PDB_RD_PODLY_DLY2(base, index) ((PDB_PODLY_REG(base, index) & PDB_PODLY_DLY2_MASK) >> PDB_PODLY_DLY2_SHIFT)
#define PDB_BRD_PODLY_DLY2(base, index) (BME_UBFX32(&PDB_PODLY_REG(base, index), PDB_PODLY_DLY2_SHIFT, PDB_PODLY_DLY2_WIDTH))

/*! @brief Set the DLY2 field to a new value. */
#define PDB_WR_PODLY_DLY2(base, index, value) (PDB_RMW_PODLY(base, index, PDB_PODLY_DLY2_MASK, PDB_PODLY_DLY2(value)))
#define PDB_BWR_PODLY_DLY2(base, index, value) (BME_BFI32(&PDB_PODLY_REG(base, index), ((uint32_t)(value) << PDB_PODLY_DLY2_SHIFT), PDB_PODLY_DLY2_SHIFT, PDB_PODLY_DLY2_WIDTH))
/*@}*/

/*!
 * @name Register PDB_PODLY, field DLY1[31:16] (RW)
 *
 * These bits specify the delay 1 value for the PDB Pulse-Out. Pulse-Out goes
 * high when the PDB counter is equal to the DLY1. Reading these bits returns the
 * value of internal register that is effective for the current PDB cycle.
 */
/*@{*/
/*! @brief Read current value of the PDB_PODLY_DLY1 field. */
#define PDB_RD_PODLY_DLY1(base, index) ((PDB_PODLY_REG(base, index) & PDB_PODLY_DLY1_MASK) >> PDB_PODLY_DLY1_SHIFT)
#define PDB_BRD_PODLY_DLY1(base, index) (BME_UBFX32(&PDB_PODLY_REG(base, index), PDB_PODLY_DLY1_SHIFT, PDB_PODLY_DLY1_WIDTH))

/*! @brief Set the DLY1 field to a new value. */
#define PDB_WR_PODLY_DLY1(base, index, value) (PDB_RMW_PODLY(base, index, PDB_PODLY_DLY1_MASK, PDB_PODLY_DLY1(value)))
#define PDB_BWR_PODLY_DLY1(base, index, value) (BME_BFI32(&PDB_PODLY_REG(base, index), ((uint32_t)(value) << PDB_PODLY_DLY1_SHIFT), PDB_PODLY_DLY1_SHIFT, PDB_PODLY_DLY1_WIDTH))
/*@}*/

/*
 * MKM34Z7 PIT
 *
 * Periodic Interrupt Timer
 *
 * Registers defined in this header file:
 * - PIT_MCR - PIT Module Control Register
 * - PIT_LDVAL - Timer Load Value Register
 * - PIT_CVAL - Current Timer Value Register
 * - PIT_TCTRL - Timer Control Register
 * - PIT_TFLG - Timer Flag Register
 */

#define PIT_INSTANCE_COUNT (2U) /*!< Number of instances of the PIT module. */
#define PIT0_IDX (0U) /*!< Instance number for PIT0. */
#define PIT1_IDX (1U) /*!< Instance number for PIT1. */

/*******************************************************************************
 * PIT_MCR - PIT Module Control Register
 ******************************************************************************/

/*!
 * @brief PIT_MCR - PIT Module Control Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register enables or disables the PIT timer clocks and controls the
 * timers when the PIT enters the Debug mode. Access: User read/write
 */
/*!
 * @name Constants and macros for entire PIT_MCR register
 */
/*@{*/
#define PIT_RD_MCR(base)         (PIT_MCR_REG(base))
#define PIT_WR_MCR(base, value)  (PIT_MCR_REG(base) = (value))
#define PIT_RMW_MCR(base, mask, value) (PIT_WR_MCR(base, (PIT_RD_MCR(base) & ~(mask)) | (value)))
#define PIT_SET_MCR(base, value) (BME_OR32(&PIT_MCR_REG(base), (uint32_t)(value)))
#define PIT_CLR_MCR(base, value) (BME_AND32(&PIT_MCR_REG(base), (uint32_t)(~(value))))
#define PIT_TOG_MCR(base, value) (BME_XOR32(&PIT_MCR_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual PIT_MCR bitfields
 */

/*!
 * @name Register PIT_MCR, field FRZ[0] (RW)
 *
 * Allows the timers to be stopped when the device enters the Debug mode.
 *
 * Values:
 * - 0b0 - Timers continue to run in Debug mode.
 * - 0b1 - Timers are stopped in Debug mode.
 */
/*@{*/
/*! @brief Read current value of the PIT_MCR_FRZ field. */
#define PIT_RD_MCR_FRZ(base) ((PIT_MCR_REG(base) & PIT_MCR_FRZ_MASK) >> PIT_MCR_FRZ_SHIFT)
#define PIT_BRD_MCR_FRZ(base) (BME_UBFX32(&PIT_MCR_REG(base), PIT_MCR_FRZ_SHIFT, PIT_MCR_FRZ_WIDTH))

/*! @brief Set the FRZ field to a new value. */
#define PIT_WR_MCR_FRZ(base, value) (PIT_RMW_MCR(base, PIT_MCR_FRZ_MASK, PIT_MCR_FRZ(value)))
#define PIT_BWR_MCR_FRZ(base, value) (BME_BFI32(&PIT_MCR_REG(base), ((uint32_t)(value) << PIT_MCR_FRZ_SHIFT), PIT_MCR_FRZ_SHIFT, PIT_MCR_FRZ_WIDTH))
/*@}*/

/*!
 * @name Register PIT_MCR, field MDIS[1] (RW)
 *
 * Disables the standard timers. This field must be enabled before any other
 * setup is done.
 *
 * Values:
 * - 0b0 - Clock for standard PIT timers is enabled.
 * - 0b1 - Clock for standard PIT timers is disabled.
 */
/*@{*/
/*! @brief Read current value of the PIT_MCR_MDIS field. */
#define PIT_RD_MCR_MDIS(base) ((PIT_MCR_REG(base) & PIT_MCR_MDIS_MASK) >> PIT_MCR_MDIS_SHIFT)
#define PIT_BRD_MCR_MDIS(base) (BME_UBFX32(&PIT_MCR_REG(base), PIT_MCR_MDIS_SHIFT, PIT_MCR_MDIS_WIDTH))

/*! @brief Set the MDIS field to a new value. */
#define PIT_WR_MCR_MDIS(base, value) (PIT_RMW_MCR(base, PIT_MCR_MDIS_MASK, PIT_MCR_MDIS(value)))
#define PIT_BWR_MCR_MDIS(base, value) (BME_BFI32(&PIT_MCR_REG(base), ((uint32_t)(value) << PIT_MCR_MDIS_SHIFT), PIT_MCR_MDIS_SHIFT, PIT_MCR_MDIS_WIDTH))
/*@}*/

/*******************************************************************************
 * PIT_LDVAL - Timer Load Value Register
 ******************************************************************************/

/*!
 * @brief PIT_LDVAL - Timer Load Value Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * These registers select the timeout period for the timer interrupts. Access:
 * User read/write
 */
/*!
 * @name Constants and macros for entire PIT_LDVAL register
 */
/*@{*/
#define PIT_RD_LDVAL(base, index) (PIT_LDVAL_REG(base, index))
#define PIT_WR_LDVAL(base, index, value) (PIT_LDVAL_REG(base, index) = (value))
#define PIT_RMW_LDVAL(base, index, mask, value) (PIT_WR_LDVAL(base, index, (PIT_RD_LDVAL(base, index) & ~(mask)) | (value)))
#define PIT_SET_LDVAL(base, index, value) (BME_OR32(&PIT_LDVAL_REG(base, index), (uint32_t)(value)))
#define PIT_CLR_LDVAL(base, index, value) (BME_AND32(&PIT_LDVAL_REG(base, index), (uint32_t)(~(value))))
#define PIT_TOG_LDVAL(base, index, value) (BME_XOR32(&PIT_LDVAL_REG(base, index), (uint32_t)(value)))
/*@}*/

/*******************************************************************************
 * PIT_CVAL - Current Timer Value Register
 ******************************************************************************/

/*!
 * @brief PIT_CVAL - Current Timer Value Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * These registers indicate the current timer position. Access: User read only
 */
/*!
 * @name Constants and macros for entire PIT_CVAL register
 */
/*@{*/
#define PIT_RD_CVAL(base, index) (PIT_CVAL_REG(base, index))
/*@}*/

/*******************************************************************************
 * PIT_TCTRL - Timer Control Register
 ******************************************************************************/

/*!
 * @brief PIT_TCTRL - Timer Control Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * These registers contain the control bits for each timer. Access: User
 * read/write
 */
/*!
 * @name Constants and macros for entire PIT_TCTRL register
 */
/*@{*/
#define PIT_RD_TCTRL(base, index) (PIT_TCTRL_REG(base, index))
#define PIT_WR_TCTRL(base, index, value) (PIT_TCTRL_REG(base, index) = (value))
#define PIT_RMW_TCTRL(base, index, mask, value) (PIT_WR_TCTRL(base, index, (PIT_RD_TCTRL(base, index) & ~(mask)) | (value)))
#define PIT_SET_TCTRL(base, index, value) (BME_OR32(&PIT_TCTRL_REG(base, index), (uint32_t)(value)))
#define PIT_CLR_TCTRL(base, index, value) (BME_AND32(&PIT_TCTRL_REG(base, index), (uint32_t)(~(value))))
#define PIT_TOG_TCTRL(base, index, value) (BME_XOR32(&PIT_TCTRL_REG(base, index), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual PIT_TCTRL bitfields
 */

/*!
 * @name Register PIT_TCTRL, field TEN[0] (RW)
 *
 * Enables or disables the timer.
 *
 * Values:
 * - 0b0 - Timer n is disabled.
 * - 0b1 - Timer n is enabled.
 */
/*@{*/
/*! @brief Read current value of the PIT_TCTRL_TEN field. */
#define PIT_RD_TCTRL_TEN(base, index) ((PIT_TCTRL_REG(base, index) & PIT_TCTRL_TEN_MASK) >> PIT_TCTRL_TEN_SHIFT)
#define PIT_BRD_TCTRL_TEN(base, index) (BME_UBFX32(&PIT_TCTRL_REG(base, index), PIT_TCTRL_TEN_SHIFT, PIT_TCTRL_TEN_WIDTH))

/*! @brief Set the TEN field to a new value. */
#define PIT_WR_TCTRL_TEN(base, index, value) (PIT_RMW_TCTRL(base, index, PIT_TCTRL_TEN_MASK, PIT_TCTRL_TEN(value)))
#define PIT_BWR_TCTRL_TEN(base, index, value) (BME_BFI32(&PIT_TCTRL_REG(base, index), ((uint32_t)(value) << PIT_TCTRL_TEN_SHIFT), PIT_TCTRL_TEN_SHIFT, PIT_TCTRL_TEN_WIDTH))
/*@}*/

/*!
 * @name Register PIT_TCTRL, field TIE[1] (RW)
 *
 * When an interrupt is pending, or, TFLGn[TIF] is set, enabling the interrupt
 * will immediately cause an interrupt event. To avoid this, the associated
 * TFLGn[TIF] must be cleared first.
 *
 * Values:
 * - 0b0 - Interrupt requests from Timer n are disabled.
 * - 0b1 - Interrupt will be requested whenever TIF is set.
 */
/*@{*/
/*! @brief Read current value of the PIT_TCTRL_TIE field. */
#define PIT_RD_TCTRL_TIE(base, index) ((PIT_TCTRL_REG(base, index) & PIT_TCTRL_TIE_MASK) >> PIT_TCTRL_TIE_SHIFT)
#define PIT_BRD_TCTRL_TIE(base, index) (BME_UBFX32(&PIT_TCTRL_REG(base, index), PIT_TCTRL_TIE_SHIFT, PIT_TCTRL_TIE_WIDTH))

/*! @brief Set the TIE field to a new value. */
#define PIT_WR_TCTRL_TIE(base, index, value) (PIT_RMW_TCTRL(base, index, PIT_TCTRL_TIE_MASK, PIT_TCTRL_TIE(value)))
#define PIT_BWR_TCTRL_TIE(base, index, value) (BME_BFI32(&PIT_TCTRL_REG(base, index), ((uint32_t)(value) << PIT_TCTRL_TIE_SHIFT), PIT_TCTRL_TIE_SHIFT, PIT_TCTRL_TIE_WIDTH))
/*@}*/

/*!
 * @name Register PIT_TCTRL, field CHN[2] (RW)
 *
 * When activated, Timer n-1 needs to expire before timer n can decrement by 1.
 * Timer 0 cannot be chained.
 *
 * Values:
 * - 0b0 - Timer is not chained.
 * - 0b1 - Timer is chained to previous timer. For example, for Channel 2, if
 *     this field is set, Timer 2 is chained to Timer 1.
 */
/*@{*/
/*! @brief Read current value of the PIT_TCTRL_CHN field. */
#define PIT_RD_TCTRL_CHN(base, index) ((PIT_TCTRL_REG(base, index) & PIT_TCTRL_CHN_MASK) >> PIT_TCTRL_CHN_SHIFT)
#define PIT_BRD_TCTRL_CHN(base, index) (BME_UBFX32(&PIT_TCTRL_REG(base, index), PIT_TCTRL_CHN_SHIFT, PIT_TCTRL_CHN_WIDTH))

/*! @brief Set the CHN field to a new value. */
#define PIT_WR_TCTRL_CHN(base, index, value) (PIT_RMW_TCTRL(base, index, PIT_TCTRL_CHN_MASK, PIT_TCTRL_CHN(value)))
#define PIT_BWR_TCTRL_CHN(base, index, value) (BME_BFI32(&PIT_TCTRL_REG(base, index), ((uint32_t)(value) << PIT_TCTRL_CHN_SHIFT), PIT_TCTRL_CHN_SHIFT, PIT_TCTRL_CHN_WIDTH))
/*@}*/

/*******************************************************************************
 * PIT_TFLG - Timer Flag Register
 ******************************************************************************/

/*!
 * @brief PIT_TFLG - Timer Flag Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * These registers hold the PIT interrupt flags. Access: User read/write
 */
/*!
 * @name Constants and macros for entire PIT_TFLG register
 */
/*@{*/
#define PIT_RD_TFLG(base, index) (PIT_TFLG_REG(base, index))
#define PIT_WR_TFLG(base, index, value) (PIT_TFLG_REG(base, index) = (value))
#define PIT_RMW_TFLG(base, index, mask, value) (PIT_WR_TFLG(base, index, (PIT_RD_TFLG(base, index) & ~(mask)) | (value)))
#define PIT_SET_TFLG(base, index, value) (BME_OR32(&PIT_TFLG_REG(base, index), (uint32_t)(value)))
#define PIT_CLR_TFLG(base, index, value) (BME_AND32(&PIT_TFLG_REG(base, index), (uint32_t)(~(value))))
#define PIT_TOG_TFLG(base, index, value) (BME_XOR32(&PIT_TFLG_REG(base, index), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual PIT_TFLG bitfields
 */

/*!
 * @name Register PIT_TFLG, field TIF[0] (W1C)
 *
 * Sets to 1 at the end of the timer period. Writing 1 to this flag clears it.
 * Writing 0 has no effect. If enabled, or, when TCTRLn[TIE] = 1, TIF causes an
 * interrupt request.
 *
 * Values:
 * - 0b0 - Timeout has not yet occurred.
 * - 0b1 - Timeout has occurred.
 */
/*@{*/
/*! @brief Read current value of the PIT_TFLG_TIF field. */
#define PIT_RD_TFLG_TIF(base, index) ((PIT_TFLG_REG(base, index) & PIT_TFLG_TIF_MASK) >> PIT_TFLG_TIF_SHIFT)
#define PIT_BRD_TFLG_TIF(base, index) (BME_UBFX32(&PIT_TFLG_REG(base, index), PIT_TFLG_TIF_SHIFT, PIT_TFLG_TIF_WIDTH))

/*! @brief Set the TIF field to a new value. */
#define PIT_WR_TFLG_TIF(base, index, value) (PIT_RMW_TFLG(base, index, PIT_TFLG_TIF_MASK, PIT_TFLG_TIF(value)))
#define PIT_BWR_TFLG_TIF(base, index, value) (BME_BFI32(&PIT_TFLG_REG(base, index), ((uint32_t)(value) << PIT_TFLG_TIF_SHIFT), PIT_TFLG_TIF_SHIFT, PIT_TFLG_TIF_WIDTH))
/*@}*/

/*
 * MKM34Z7 PMC
 *
 * Power Management Controller
 *
 * Registers defined in this header file:
 * - PMC_LVDSC1 - Low Voltage Detect Status And Control 1 register
 * - PMC_LVDSC2 - Low Voltage Detect Status And Control 2 register
 * - PMC_REGSC - Regulator Status And Control register
 */

#define PMC_INSTANCE_COUNT (1U) /*!< Number of instances of the PMC module. */
#define PMC_IDX (0U) /*!< Instance number for PMC. */

/*******************************************************************************
 * PMC_LVDSC1 - Low Voltage Detect Status And Control 1 register
 ******************************************************************************/

/*!
 * @brief PMC_LVDSC1 - Low Voltage Detect Status And Control 1 register (RW)
 *
 * Reset value: 0x10U
 *
 * This register contains status and control bits to support the low voltage
 * detect function. This register should be written during the reset initialization
 * program to set the desired controls even if the desired settings are the same
 * as the reset settings. While the device is in the very low power or low
 * leakage modes, the LVD system is disabled regardless of LVDSC1 settings. To protect
 * systems that must have LVD always on, configure the Power Mode Protection
 * (PMPROT) register of the SMC module (SMC_PMPROT) to disallow any very low power or
 * low leakage modes from being enabled. See the device's data sheet for the
 * exact LVD trip voltages. The LVDV bits are reset solely on a POR Only event. The
 * register's other bits are reset on Chip Reset Not VLLS. For more information
 * about these reset types, refer to the Reset section details.
 */
/*!
 * @name Constants and macros for entire PMC_LVDSC1 register
 */
/*@{*/
#define PMC_RD_LVDSC1(base)      (PMC_LVDSC1_REG(base))
#define PMC_WR_LVDSC1(base, value) (PMC_LVDSC1_REG(base) = (value))
#define PMC_RMW_LVDSC1(base, mask, value) (PMC_WR_LVDSC1(base, (PMC_RD_LVDSC1(base) & ~(mask)) | (value)))
#define PMC_SET_LVDSC1(base, value) (BME_OR8(&PMC_LVDSC1_REG(base), (uint8_t)(value)))
#define PMC_CLR_LVDSC1(base, value) (BME_AND8(&PMC_LVDSC1_REG(base), (uint8_t)(~(value))))
#define PMC_TOG_LVDSC1(base, value) (BME_XOR8(&PMC_LVDSC1_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual PMC_LVDSC1 bitfields
 */

/*!
 * @name Register PMC_LVDSC1, field LVDV[1:0] (RW)
 *
 * Selects the LVD trip point voltage (V LVD ).
 *
 * Values:
 * - 0b00 - Low trip point selected (V LVD = V LVDL )
 * - 0b01 - High trip point selected (V LVD = V LVDH )
 * - 0b10 - Reserved
 * - 0b11 - Reserved
 */
/*@{*/
/*! @brief Read current value of the PMC_LVDSC1_LVDV field. */
#define PMC_RD_LVDSC1_LVDV(base) ((PMC_LVDSC1_REG(base) & PMC_LVDSC1_LVDV_MASK) >> PMC_LVDSC1_LVDV_SHIFT)
#define PMC_BRD_LVDSC1_LVDV(base) (BME_UBFX8(&PMC_LVDSC1_REG(base), PMC_LVDSC1_LVDV_SHIFT, PMC_LVDSC1_LVDV_WIDTH))

/*! @brief Set the LVDV field to a new value. */
#define PMC_WR_LVDSC1_LVDV(base, value) (PMC_RMW_LVDSC1(base, PMC_LVDSC1_LVDV_MASK, PMC_LVDSC1_LVDV(value)))
#define PMC_BWR_LVDSC1_LVDV(base, value) (BME_BFI8(&PMC_LVDSC1_REG(base), ((uint8_t)(value) << PMC_LVDSC1_LVDV_SHIFT), PMC_LVDSC1_LVDV_SHIFT, PMC_LVDSC1_LVDV_WIDTH))
/*@}*/

/*!
 * @name Register PMC_LVDSC1, field LVDRE[4] (RW)
 *
 * This write-once bit enables LVDF events to generate a hardware reset.
 * Additional writes are ignored.
 *
 * Values:
 * - 0b0 - LVDF does not generate hardware resets
 * - 0b1 - Force an MCU reset when LVDF = 1
 */
/*@{*/
/*! @brief Read current value of the PMC_LVDSC1_LVDRE field. */
#define PMC_RD_LVDSC1_LVDRE(base) ((PMC_LVDSC1_REG(base) & PMC_LVDSC1_LVDRE_MASK) >> PMC_LVDSC1_LVDRE_SHIFT)
#define PMC_BRD_LVDSC1_LVDRE(base) (BME_UBFX8(&PMC_LVDSC1_REG(base), PMC_LVDSC1_LVDRE_SHIFT, PMC_LVDSC1_LVDRE_WIDTH))

/*! @brief Set the LVDRE field to a new value. */
#define PMC_WR_LVDSC1_LVDRE(base, value) (PMC_RMW_LVDSC1(base, PMC_LVDSC1_LVDRE_MASK, PMC_LVDSC1_LVDRE(value)))
#define PMC_BWR_LVDSC1_LVDRE(base, value) (BME_BFI8(&PMC_LVDSC1_REG(base), ((uint8_t)(value) << PMC_LVDSC1_LVDRE_SHIFT), PMC_LVDSC1_LVDRE_SHIFT, PMC_LVDSC1_LVDRE_WIDTH))
/*@}*/

/*!
 * @name Register PMC_LVDSC1, field LVDIE[5] (RW)
 *
 * Enables hardware interrupt requests for LVDF.
 *
 * Values:
 * - 0b0 - Hardware interrupt disabled (use polling)
 * - 0b1 - Request a hardware interrupt when LVDF = 1
 */
/*@{*/
/*! @brief Read current value of the PMC_LVDSC1_LVDIE field. */
#define PMC_RD_LVDSC1_LVDIE(base) ((PMC_LVDSC1_REG(base) & PMC_LVDSC1_LVDIE_MASK) >> PMC_LVDSC1_LVDIE_SHIFT)
#define PMC_BRD_LVDSC1_LVDIE(base) (BME_UBFX8(&PMC_LVDSC1_REG(base), PMC_LVDSC1_LVDIE_SHIFT, PMC_LVDSC1_LVDIE_WIDTH))

/*! @brief Set the LVDIE field to a new value. */
#define PMC_WR_LVDSC1_LVDIE(base, value) (PMC_RMW_LVDSC1(base, PMC_LVDSC1_LVDIE_MASK, PMC_LVDSC1_LVDIE(value)))
#define PMC_BWR_LVDSC1_LVDIE(base, value) (BME_BFI8(&PMC_LVDSC1_REG(base), ((uint8_t)(value) << PMC_LVDSC1_LVDIE_SHIFT), PMC_LVDSC1_LVDIE_SHIFT, PMC_LVDSC1_LVDIE_WIDTH))
/*@}*/

/*!
 * @name Register PMC_LVDSC1, field LVDACK[6] (WORZ)
 *
 * This write-only field is used to acknowledge low voltage detection errors.
 * Write 1 to clear LVDF. Reads always return 0.
 */
/*@{*/
/*! @brief Set the LVDACK field to a new value. */
#define PMC_WR_LVDSC1_LVDACK(base, value) (PMC_RMW_LVDSC1(base, PMC_LVDSC1_LVDACK_MASK, PMC_LVDSC1_LVDACK(value)))
#define PMC_BWR_LVDSC1_LVDACK(base, value) (BME_BFI8(&PMC_LVDSC1_REG(base), ((uint8_t)(value) << PMC_LVDSC1_LVDACK_SHIFT), PMC_LVDSC1_LVDACK_SHIFT, PMC_LVDSC1_LVDACK_WIDTH))
/*@}*/

/*!
 * @name Register PMC_LVDSC1, field LVDF[7] (RO)
 *
 * This read-only status field indicates a low-voltage detect event.
 *
 * Values:
 * - 0b0 - Low-voltage event not detected
 * - 0b1 - Low-voltage event detected
 */
/*@{*/
/*! @brief Read current value of the PMC_LVDSC1_LVDF field. */
#define PMC_RD_LVDSC1_LVDF(base) ((PMC_LVDSC1_REG(base) & PMC_LVDSC1_LVDF_MASK) >> PMC_LVDSC1_LVDF_SHIFT)
#define PMC_BRD_LVDSC1_LVDF(base) (BME_UBFX8(&PMC_LVDSC1_REG(base), PMC_LVDSC1_LVDF_SHIFT, PMC_LVDSC1_LVDF_WIDTH))
/*@}*/

/*******************************************************************************
 * PMC_LVDSC2 - Low Voltage Detect Status And Control 2 register
 ******************************************************************************/

/*!
 * @brief PMC_LVDSC2 - Low Voltage Detect Status And Control 2 register (RW)
 *
 * Reset value: 0x00U
 *
 * This register contains status and control bits to support the low voltage
 * warning function. While the device is in the very low power or low leakage modes,
 * the LVD system is disabled regardless of LVDSC2 settings. See the device's
 * data sheet for the exact LVD trip voltages. The LVW trip voltages depend on LVWV
 * and LVDV. LVWV is reset solely on a POR Only event. The other fields of the
 * register are reset on Chip Reset Not VLLS. For more information about these
 * reset types, refer to the Reset section details.
 */
/*!
 * @name Constants and macros for entire PMC_LVDSC2 register
 */
/*@{*/
#define PMC_RD_LVDSC2(base)      (PMC_LVDSC2_REG(base))
#define PMC_WR_LVDSC2(base, value) (PMC_LVDSC2_REG(base) = (value))
#define PMC_RMW_LVDSC2(base, mask, value) (PMC_WR_LVDSC2(base, (PMC_RD_LVDSC2(base) & ~(mask)) | (value)))
#define PMC_SET_LVDSC2(base, value) (BME_OR8(&PMC_LVDSC2_REG(base), (uint8_t)(value)))
#define PMC_CLR_LVDSC2(base, value) (BME_AND8(&PMC_LVDSC2_REG(base), (uint8_t)(~(value))))
#define PMC_TOG_LVDSC2(base, value) (BME_XOR8(&PMC_LVDSC2_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual PMC_LVDSC2 bitfields
 */

/*!
 * @name Register PMC_LVDSC2, field LVWV[1:0] (RW)
 *
 * Selects the LVW trip point voltage (VLVW). The actual voltage for the warning
 * depends on LVDSC1[LVDV].
 *
 * Values:
 * - 0b00 - Low trip point selected (VLVW = VLVW1)
 * - 0b01 - Mid 1 trip point selected (VLVW = VLVW2)
 * - 0b10 - Mid 2 trip point selected (VLVW = VLVW3)
 * - 0b11 - High trip point selected (VLVW = VLVW4)
 */
/*@{*/
/*! @brief Read current value of the PMC_LVDSC2_LVWV field. */
#define PMC_RD_LVDSC2_LVWV(base) ((PMC_LVDSC2_REG(base) & PMC_LVDSC2_LVWV_MASK) >> PMC_LVDSC2_LVWV_SHIFT)
#define PMC_BRD_LVDSC2_LVWV(base) (BME_UBFX8(&PMC_LVDSC2_REG(base), PMC_LVDSC2_LVWV_SHIFT, PMC_LVDSC2_LVWV_WIDTH))

/*! @brief Set the LVWV field to a new value. */
#define PMC_WR_LVDSC2_LVWV(base, value) (PMC_RMW_LVDSC2(base, PMC_LVDSC2_LVWV_MASK, PMC_LVDSC2_LVWV(value)))
#define PMC_BWR_LVDSC2_LVWV(base, value) (BME_BFI8(&PMC_LVDSC2_REG(base), ((uint8_t)(value) << PMC_LVDSC2_LVWV_SHIFT), PMC_LVDSC2_LVWV_SHIFT, PMC_LVDSC2_LVWV_WIDTH))
/*@}*/

/*!
 * @name Register PMC_LVDSC2, field LVWIE[5] (RW)
 *
 * Enables hardware interrupt requests for LVWF.
 *
 * Values:
 * - 0b0 - Hardware interrupt disabled (use polling)
 * - 0b1 - Request a hardware interrupt when LVWF = 1
 */
/*@{*/
/*! @brief Read current value of the PMC_LVDSC2_LVWIE field. */
#define PMC_RD_LVDSC2_LVWIE(base) ((PMC_LVDSC2_REG(base) & PMC_LVDSC2_LVWIE_MASK) >> PMC_LVDSC2_LVWIE_SHIFT)
#define PMC_BRD_LVDSC2_LVWIE(base) (BME_UBFX8(&PMC_LVDSC2_REG(base), PMC_LVDSC2_LVWIE_SHIFT, PMC_LVDSC2_LVWIE_WIDTH))

/*! @brief Set the LVWIE field to a new value. */
#define PMC_WR_LVDSC2_LVWIE(base, value) (PMC_RMW_LVDSC2(base, PMC_LVDSC2_LVWIE_MASK, PMC_LVDSC2_LVWIE(value)))
#define PMC_BWR_LVDSC2_LVWIE(base, value) (BME_BFI8(&PMC_LVDSC2_REG(base), ((uint8_t)(value) << PMC_LVDSC2_LVWIE_SHIFT), PMC_LVDSC2_LVWIE_SHIFT, PMC_LVDSC2_LVWIE_WIDTH))
/*@}*/

/*!
 * @name Register PMC_LVDSC2, field LVWACK[6] (WORZ)
 *
 * This write-only field is used to acknowledge low voltage warning errors.
 * Write 1 to clear LVWF. Reads always return 0.
 */
/*@{*/
/*! @brief Set the LVWACK field to a new value. */
#define PMC_WR_LVDSC2_LVWACK(base, value) (PMC_RMW_LVDSC2(base, PMC_LVDSC2_LVWACK_MASK, PMC_LVDSC2_LVWACK(value)))
#define PMC_BWR_LVDSC2_LVWACK(base, value) (BME_BFI8(&PMC_LVDSC2_REG(base), ((uint8_t)(value) << PMC_LVDSC2_LVWACK_SHIFT), PMC_LVDSC2_LVWACK_SHIFT, PMC_LVDSC2_LVWACK_WIDTH))
/*@}*/

/*!
 * @name Register PMC_LVDSC2, field LVWF[7] (RO)
 *
 * This read-only status field indicates a low-voltage warning event. LVWF is
 * set when VSupply transitions below the trip point, or after reset and VSupply is
 * already below VLVW. LVWF may be 1 after power-on reset, therefore, to use LVW
 * interrupt function, before enabling LVWIE, LVWF must be cleared by writing
 * LVWACK first.
 *
 * Values:
 * - 0b0 - Low-voltage warning event not detected
 * - 0b1 - Low-voltage warning event detected
 */
/*@{*/
/*! @brief Read current value of the PMC_LVDSC2_LVWF field. */
#define PMC_RD_LVDSC2_LVWF(base) ((PMC_LVDSC2_REG(base) & PMC_LVDSC2_LVWF_MASK) >> PMC_LVDSC2_LVWF_SHIFT)
#define PMC_BRD_LVDSC2_LVWF(base) (BME_UBFX8(&PMC_LVDSC2_REG(base), PMC_LVDSC2_LVWF_SHIFT, PMC_LVDSC2_LVWF_WIDTH))
/*@}*/

/*******************************************************************************
 * PMC_REGSC - Regulator Status And Control register
 ******************************************************************************/

/*!
 * @brief PMC_REGSC - Regulator Status And Control register (RW)
 *
 * Reset value: 0x04U
 *
 * The PMC contains an internal voltage regulator. The voltage regulator design
 * uses a bandgap reference that is also available through a buffer as input to
 * certain internal peripherals, such as the CMP and ADC. The internal regulator
 * provides a status bit (REGONS) indicating the regulator is in run regulation.
 * This register is reset on Chip Reset Not VLLS and by reset types that trigger
 * Chip Reset not VLLS. See the Reset section details for more information.
 */
/*!
 * @name Constants and macros for entire PMC_REGSC register
 */
/*@{*/
#define PMC_RD_REGSC(base)       (PMC_REGSC_REG(base))
#define PMC_WR_REGSC(base, value) (PMC_REGSC_REG(base) = (value))
#define PMC_RMW_REGSC(base, mask, value) (PMC_WR_REGSC(base, (PMC_RD_REGSC(base) & ~(mask)) | (value)))
#define PMC_SET_REGSC(base, value) (BME_OR8(&PMC_REGSC_REG(base), (uint8_t)(value)))
#define PMC_CLR_REGSC(base, value) (BME_AND8(&PMC_REGSC_REG(base), (uint8_t)(~(value))))
#define PMC_TOG_REGSC(base, value) (BME_XOR8(&PMC_REGSC_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual PMC_REGSC bitfields
 */

/*!
 * @name Register PMC_REGSC, field BGBE[0] (RW)
 *
 * Enables the bandgap buffer.
 *
 * Values:
 * - 0b0 - Bandgap buffer not enabled
 * - 0b1 - Bandgap buffer enabled
 */
/*@{*/
/*! @brief Read current value of the PMC_REGSC_BGBE field. */
#define PMC_RD_REGSC_BGBE(base) ((PMC_REGSC_REG(base) & PMC_REGSC_BGBE_MASK) >> PMC_REGSC_BGBE_SHIFT)
#define PMC_BRD_REGSC_BGBE(base) (BME_UBFX8(&PMC_REGSC_REG(base), PMC_REGSC_BGBE_SHIFT, PMC_REGSC_BGBE_WIDTH))

/*! @brief Set the BGBE field to a new value. */
#define PMC_WR_REGSC_BGBE(base, value) (PMC_RMW_REGSC(base, (PMC_REGSC_BGBE_MASK | PMC_REGSC_ACKISO_MASK), PMC_REGSC_BGBE(value)))
#define PMC_BWR_REGSC_BGBE(base, value) (BME_BFI8(&PMC_REGSC_REG(base), ((uint8_t)(value) << PMC_REGSC_BGBE_SHIFT), PMC_REGSC_BGBE_SHIFT, PMC_REGSC_BGBE_WIDTH))
/*@}*/

/*!
 * @name Register PMC_REGSC, field REGONS[2] (RO)
 *
 * This read-only field provides the current status of the internal voltage
 * regulator.
 *
 * Values:
 * - 0b0 - Regulator is in stop regulation or in transition to/from it
 * - 0b1 - Regulator is in run regulation
 */
/*@{*/
/*! @brief Read current value of the PMC_REGSC_REGONS field. */
#define PMC_RD_REGSC_REGONS(base) ((PMC_REGSC_REG(base) & PMC_REGSC_REGONS_MASK) >> PMC_REGSC_REGONS_SHIFT)
#define PMC_BRD_REGSC_REGONS(base) (BME_UBFX8(&PMC_REGSC_REG(base), PMC_REGSC_REGONS_SHIFT, PMC_REGSC_REGONS_WIDTH))
/*@}*/

/*!
 * @name Register PMC_REGSC, field ACKISO[3] (W1C)
 *
 * Reading this field indicates whether certain peripherals and the I/O pads are
 * in a latched state as a result of having been in a VLLS mode. Writing 1 to
 * this field when it is set releases the I/O pads and certain peripherals to their
 * normal run mode state. After recovering from a VLLS mode, user should restore
 * chip configuration before clearing ACKISO.
 *
 * Values:
 * - 0b0 - Peripherals and I/O pads are in normal run state.
 * - 0b1 - Certain peripherals and I/O pads are in an isolated and latched state.
 */
/*@{*/
/*! @brief Read current value of the PMC_REGSC_ACKISO field. */
#define PMC_RD_REGSC_ACKISO(base) ((PMC_REGSC_REG(base) & PMC_REGSC_ACKISO_MASK) >> PMC_REGSC_ACKISO_SHIFT)
#define PMC_BRD_REGSC_ACKISO(base) (BME_UBFX8(&PMC_REGSC_REG(base), PMC_REGSC_ACKISO_SHIFT, PMC_REGSC_ACKISO_WIDTH))

/*! @brief Set the ACKISO field to a new value. */
#define PMC_WR_REGSC_ACKISO(base, value) (PMC_RMW_REGSC(base, PMC_REGSC_ACKISO_MASK, PMC_REGSC_ACKISO(value)))
#define PMC_BWR_REGSC_ACKISO(base, value) (BME_BFI8(&PMC_REGSC_REG(base), ((uint8_t)(value) << PMC_REGSC_ACKISO_SHIFT), PMC_REGSC_ACKISO_SHIFT, PMC_REGSC_ACKISO_WIDTH))
/*@}*/

/*!
 * @name Register PMC_REGSC, field BGEN[4] (RW)
 *
 * BGEN controls whether the bandgap is enabled in lower power modes of
 * operation (VLPx, and VLLSx). When on-chip peripherals require the bandgap voltage
 * reference in low power modes of operation, set BGEN to continue to enable the
 * bandgap operation. When the bandgap voltage reference is not needed in low power
 * modes, clear BGEN to avoid excess power consumption.
 *
 * Values:
 * - 0b0 - Bandgap voltage reference is disabled in VLPx , and VLLSx modes.
 * - 0b1 - Bandgap voltage reference is enabled in VLPx , and VLLSx modes.
 */
/*@{*/
/*! @brief Read current value of the PMC_REGSC_BGEN field. */
#define PMC_RD_REGSC_BGEN(base) ((PMC_REGSC_REG(base) & PMC_REGSC_BGEN_MASK) >> PMC_REGSC_BGEN_SHIFT)
#define PMC_BRD_REGSC_BGEN(base) (BME_UBFX8(&PMC_REGSC_REG(base), PMC_REGSC_BGEN_SHIFT, PMC_REGSC_BGEN_WIDTH))

/*! @brief Set the BGEN field to a new value. */
#define PMC_WR_REGSC_BGEN(base, value) (PMC_RMW_REGSC(base, (PMC_REGSC_BGEN_MASK | PMC_REGSC_ACKISO_MASK), PMC_REGSC_BGEN(value)))
#define PMC_BWR_REGSC_BGEN(base, value) (BME_BFI8(&PMC_REGSC_REG(base), ((uint8_t)(value) << PMC_REGSC_BGEN_SHIFT), PMC_REGSC_BGEN_SHIFT, PMC_REGSC_BGEN_WIDTH))
/*@}*/

/*
 * MKM34Z7 PORT
 *
 * Pin Control and Interrupts
 *
 * Registers defined in this header file:
 * - PORT_PCR - Pin Control Register n
 * - PORT_GPCLR - Global Pin Control Low Register
 * - PORT_GPCHR - Global Pin Control High Register
 * - PORT_ISFR - Interrupt Status Flag Register
 * - PORT_DFER - Digital Filter Enable Register
 * - PORT_DFCR - Digital Filter Clock Register
 * - PORT_DFWR - Digital Filter Width Register
 */

#define PORT_INSTANCE_COUNT (13U) /*!< Number of instances of the PORT module. */
#define PORTA_IDX (0U) /*!< Instance number for PORTA. */
#define PORTB_IDX (1U) /*!< Instance number for PORTB. */
#define PORTC_IDX (2U) /*!< Instance number for PORTC. */
#define PORTD_IDX (3U) /*!< Instance number for PORTD. */
#define PORTE_IDX (4U) /*!< Instance number for PORTE. */
#define PORTF_IDX (5U) /*!< Instance number for PORTF. */
#define PORTG_IDX (6U) /*!< Instance number for PORTG. */
#define PORTH_IDX (7U) /*!< Instance number for PORTH. */
#define PORTI_IDX (8U) /*!< Instance number for PORTI. */
#define PORTJ_IDX (9U) /*!< Instance number for PORTJ. */
#define PORTK_IDX (10U) /*!< Instance number for PORTK. */
#define PORTL_IDX (11U) /*!< Instance number for PORTL. */
#define PORTM_IDX (12U) /*!< Instance number for PORTM. */

/*******************************************************************************
 * PORT_PCR - Pin Control Register n
 ******************************************************************************/

/*!
 * @brief PORT_PCR - Pin Control Register n (RW)
 *
 * Reset value: 0x00000000U
 *
 * See the Signal Multiplexing and Pin Assignment chapter for the reset value of
 * this device. See the GPIO Configuration section for details on the available
 * functions for each pin. Do not modify pin configuration registers associated
 * with pins not available in your selected package. All unbonded pins not
 * available in your package will default to DISABLE state for lowest power consumption.
 */
/*!
 * @name Constants and macros for entire PORT_PCR register
 */
/*@{*/
#define PORT_RD_PCR(base, index) (PORT_PCR_REG(base, index))
#define PORT_WR_PCR(base, index, value) (PORT_PCR_REG(base, index) = (value))
#define PORT_RMW_PCR(base, index, mask, value) (PORT_WR_PCR(base, index, (PORT_RD_PCR(base, index) & ~(mask)) | (value)))
#define PORT_SET_PCR(base, index, value) (BME_OR32(&PORT_PCR_REG(base, index), (uint32_t)(value)))
#define PORT_CLR_PCR(base, index, value) (BME_AND32(&PORT_PCR_REG(base, index), (uint32_t)(~(value))))
#define PORT_TOG_PCR(base, index, value) (BME_XOR32(&PORT_PCR_REG(base, index), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual PORT_PCR bitfields
 */

/*!
 * @name Register PORT_PCR, field PS[0] (RW)
 *
 * This bit is read only for pins that do not support a configurable pull
 * resistor direction. Pull configuration is valid in all digital pin muxing modes.
 *
 * Values:
 * - 0b0 - Internal pulldown resistor is enabled on the corresponding pin, if
 *     the corresponding PE field is set.
 * - 0b1 - Internal pullup resistor is enabled on the corresponding pin, if the
 *     corresponding PE field is set.
 */
/*@{*/
/*! @brief Read current value of the PORT_PCR_PS field. */
#define PORT_RD_PCR_PS(base, index) ((PORT_PCR_REG(base, index) & PORT_PCR_PS_MASK) >> PORT_PCR_PS_SHIFT)
#define PORT_BRD_PCR_PS(base, index) (BME_UBFX32(&PORT_PCR_REG(base, index), PORT_PCR_PS_SHIFT, PORT_PCR_PS_WIDTH))

/*! @brief Set the PS field to a new value. */
#define PORT_WR_PCR_PS(base, index, value) (PORT_RMW_PCR(base, index, (PORT_PCR_PS_MASK | PORT_PCR_ISF_MASK), PORT_PCR_PS(value)))
#define PORT_BWR_PCR_PS(base, index, value) (BME_BFI32(&PORT_PCR_REG(base, index), ((uint32_t)(value) << PORT_PCR_PS_SHIFT), PORT_PCR_PS_SHIFT, PORT_PCR_PS_WIDTH))
/*@}*/

/*!
 * @name Register PORT_PCR, field PE[1] (RW)
 *
 * This field is read-only for pins that do not support a configurable pull
 * resistor. Refer to the Chapter of Signal Multiplexing and Signal Descriptions for
 * the pins that support a configurable pull resistor. Pull configuration is
 * valid in all digital pin muxing modes.
 *
 * Values:
 * - 0b0 - Internal pullup or pulldown resistor is not enabled on the
 *     corresponding pin.
 * - 0b1 - Internal pullup or pulldown resistor is enabled on the corresponding
 *     pin, if the pin is configured as a digital input.
 */
/*@{*/
/*! @brief Read current value of the PORT_PCR_PE field. */
#define PORT_RD_PCR_PE(base, index) ((PORT_PCR_REG(base, index) & PORT_PCR_PE_MASK) >> PORT_PCR_PE_SHIFT)
#define PORT_BRD_PCR_PE(base, index) (BME_UBFX32(&PORT_PCR_REG(base, index), PORT_PCR_PE_SHIFT, PORT_PCR_PE_WIDTH))

/*! @brief Set the PE field to a new value. */
#define PORT_WR_PCR_PE(base, index, value) (PORT_RMW_PCR(base, index, (PORT_PCR_PE_MASK | PORT_PCR_ISF_MASK), PORT_PCR_PE(value)))
#define PORT_BWR_PCR_PE(base, index, value) (BME_BFI32(&PORT_PCR_REG(base, index), ((uint32_t)(value) << PORT_PCR_PE_SHIFT), PORT_PCR_PE_SHIFT, PORT_PCR_PE_WIDTH))
/*@}*/

/*!
 * @name Register PORT_PCR, field SRE[2] (RW)
 *
 * This field is read-only for pins that do not support a configurable slew
 * rate. Slew rate configuration is valid in all digital pin muxing modes.
 *
 * Values:
 * - 0b0 - Fast slew rate is configured on the corresponding pin, if the pin is
 *     configured as a digital output.
 * - 0b1 - Slow slew rate is configured on the corresponding pin, if the pin is
 *     configured as a digital output.
 */
/*@{*/
/*! @brief Read current value of the PORT_PCR_SRE field. */
#define PORT_RD_PCR_SRE(base, index) ((PORT_PCR_REG(base, index) & PORT_PCR_SRE_MASK) >> PORT_PCR_SRE_SHIFT)
#define PORT_BRD_PCR_SRE(base, index) (BME_UBFX32(&PORT_PCR_REG(base, index), PORT_PCR_SRE_SHIFT, PORT_PCR_SRE_WIDTH))

/*! @brief Set the SRE field to a new value. */
#define PORT_WR_PCR_SRE(base, index, value) (PORT_RMW_PCR(base, index, (PORT_PCR_SRE_MASK | PORT_PCR_ISF_MASK), PORT_PCR_SRE(value)))
#define PORT_BWR_PCR_SRE(base, index, value) (BME_BFI32(&PORT_PCR_REG(base, index), ((uint32_t)(value) << PORT_PCR_SRE_SHIFT), PORT_PCR_SRE_SHIFT, PORT_PCR_SRE_WIDTH))
/*@}*/

/*!
 * @name Register PORT_PCR, field ODE[5] (RW)
 *
 * This field is read-only for pins that do not support a configurable open
 * drain output. Open drain configuration is valid in all digital pin muxing modes.
 *
 * Values:
 * - 0b0 - Open drain output is disabled on the corresponding pin.
 * - 0b1 - Open drain output is enabled on the corresponding pin, if the pin is
 *     configured as a digital output.
 */
/*@{*/
/*! @brief Read current value of the PORT_PCR_ODE field. */
#define PORT_RD_PCR_ODE(base, index) ((PORT_PCR_REG(base, index) & PORT_PCR_ODE_MASK) >> PORT_PCR_ODE_SHIFT)
#define PORT_BRD_PCR_ODE(base, index) (BME_UBFX32(&PORT_PCR_REG(base, index), PORT_PCR_ODE_SHIFT, PORT_PCR_ODE_WIDTH))

/*! @brief Set the ODE field to a new value. */
#define PORT_WR_PCR_ODE(base, index, value) (PORT_RMW_PCR(base, index, (PORT_PCR_ODE_MASK | PORT_PCR_ISF_MASK), PORT_PCR_ODE(value)))
#define PORT_BWR_PCR_ODE(base, index, value) (BME_BFI32(&PORT_PCR_REG(base, index), ((uint32_t)(value) << PORT_PCR_ODE_SHIFT), PORT_PCR_ODE_SHIFT, PORT_PCR_ODE_WIDTH))
/*@}*/

/*!
 * @name Register PORT_PCR, field MUX[10:8] (RW)
 *
 * Not all pins support all pin muxing slots. Unimplemented pin muxing slots are
 * reserved and may result in configuring the pin for a different pin muxing
 * slot. The corresponding pin is configured in the following pin muxing slot as
 * follows:
 *
 * Values:
 * - 0b000 - Pin disabled (analog).
 * - 0b001 - Alternative 1 (GPIO).
 * - 0b010 - Alternative 2 (chip-specific).
 * - 0b011 - Alternative 3 (chip-specific).
 * - 0b100 - Alternative 4 (chip-specific).
 * - 0b101 - Alternative 5 (chip-specific).
 * - 0b110 - Alternative 6 (chip-specific).
 * - 0b111 - Alternative 7 (chip-specific).
 */
/*@{*/
/*! @brief Read current value of the PORT_PCR_MUX field. */
#define PORT_RD_PCR_MUX(base, index) ((PORT_PCR_REG(base, index) & PORT_PCR_MUX_MASK) >> PORT_PCR_MUX_SHIFT)
#define PORT_BRD_PCR_MUX(base, index) (BME_UBFX32(&PORT_PCR_REG(base, index), PORT_PCR_MUX_SHIFT, PORT_PCR_MUX_WIDTH))

/*! @brief Set the MUX field to a new value. */
#define PORT_WR_PCR_MUX(base, index, value) (PORT_RMW_PCR(base, index, (PORT_PCR_MUX_MASK | PORT_PCR_ISF_MASK), PORT_PCR_MUX(value)))
#define PORT_BWR_PCR_MUX(base, index, value) (BME_BFI32(&PORT_PCR_REG(base, index), ((uint32_t)(value) << PORT_PCR_MUX_SHIFT), PORT_PCR_MUX_SHIFT, PORT_PCR_MUX_WIDTH))
/*@}*/

/*!
 * @name Register PORT_PCR, field LK[15] (RW)
 *
 * Values:
 * - 0b0 - Pin Control Register fields [15:0] are not locked.
 * - 0b1 - Pin Control Register fields [15:0] are locked and cannot be updated
 *     until the next system reset.
 */
/*@{*/
/*! @brief Read current value of the PORT_PCR_LK field. */
#define PORT_RD_PCR_LK(base, index) ((PORT_PCR_REG(base, index) & PORT_PCR_LK_MASK) >> PORT_PCR_LK_SHIFT)
#define PORT_BRD_PCR_LK(base, index) (BME_UBFX32(&PORT_PCR_REG(base, index), PORT_PCR_LK_SHIFT, PORT_PCR_LK_WIDTH))

/*! @brief Set the LK field to a new value. */
#define PORT_WR_PCR_LK(base, index, value) (PORT_RMW_PCR(base, index, (PORT_PCR_LK_MASK | PORT_PCR_ISF_MASK), PORT_PCR_LK(value)))
#define PORT_BWR_PCR_LK(base, index, value) (BME_BFI32(&PORT_PCR_REG(base, index), ((uint32_t)(value) << PORT_PCR_LK_SHIFT), PORT_PCR_LK_SHIFT, PORT_PCR_LK_WIDTH))
/*@}*/

/*!
 * @name Register PORT_PCR, field IRQC[19:16] (RW)
 *
 * This field is read-only for pins that do not support interrupt generation.
 * The pin interrupt configuration is valid in all digital pin muxing modes. The
 * corresponding pin is configured to generate interrupt/DMA request as follows:
 *
 * Values:
 * - 0b0000 - Interrupt Status Flag (ISF) is disabled.
 * - 0b0001 - ISF flag and DMA request on rising edge.
 * - 0b0010 - ISF flag and DMA request on falling edge.
 * - 0b0011 - ISF flag and DMA request on either edge.
 * - 0b0100 - Reserved.
 * - 0b0101 - Reserved.
 * - 0b0110 - Reserved.
 * - 0b0111 - Reserved.
 * - 0b1000 - ISF flag and Interrupt when logic 0.
 * - 0b1001 - ISF flag and Interrupt on rising-edge.
 * - 0b1010 - ISF flag and Interrupt on falling-edge.
 * - 0b1011 - ISF flag and Interrupt on either edge.
 * - 0b1100 - ISF flag and Interrupt when logic 1.
 * - 0b1101 - Reserved.
 * - 0b1110 - Reserved.
 * - 0b1111 - Reserved.
 */
/*@{*/
/*! @brief Read current value of the PORT_PCR_IRQC field. */
#define PORT_RD_PCR_IRQC(base, index) ((PORT_PCR_REG(base, index) & PORT_PCR_IRQC_MASK) >> PORT_PCR_IRQC_SHIFT)
#define PORT_BRD_PCR_IRQC(base, index) (BME_UBFX32(&PORT_PCR_REG(base, index), PORT_PCR_IRQC_SHIFT, PORT_PCR_IRQC_WIDTH))

/*! @brief Set the IRQC field to a new value. */
#define PORT_WR_PCR_IRQC(base, index, value) (PORT_RMW_PCR(base, index, (PORT_PCR_IRQC_MASK | PORT_PCR_ISF_MASK), PORT_PCR_IRQC(value)))
#define PORT_BWR_PCR_IRQC(base, index, value) (BME_BFI32(&PORT_PCR_REG(base, index), ((uint32_t)(value) << PORT_PCR_IRQC_SHIFT), PORT_PCR_IRQC_SHIFT, PORT_PCR_IRQC_WIDTH))
/*@}*/

/*!
 * @name Register PORT_PCR, field ISF[24] (W1C)
 *
 * This field is read-only for pins that do not support interrupt generation.
 * The pin interrupt configuration is valid in all digital pin muxing modes.
 *
 * Values:
 * - 0b0 - Configured interrupt is not detected.
 * - 0b1 - Configured interrupt is detected. If the pin is configured to
 *     generate a DMA request, then the corresponding flag will be cleared automatically
 *     at the completion of the requested DMA transfer. Otherwise, the flag
 *     remains set until a logic 1 is written to the flag. If the pin is configured
 *     for a level sensitive interrupt and the pin remains asserted, then the flag
 *     is set again immediately after it is cleared.
 */
/*@{*/
/*! @brief Read current value of the PORT_PCR_ISF field. */
#define PORT_RD_PCR_ISF(base, index) ((PORT_PCR_REG(base, index) & PORT_PCR_ISF_MASK) >> PORT_PCR_ISF_SHIFT)
#define PORT_BRD_PCR_ISF(base, index) (BME_UBFX32(&PORT_PCR_REG(base, index), PORT_PCR_ISF_SHIFT, PORT_PCR_ISF_WIDTH))

/*! @brief Set the ISF field to a new value. */
#define PORT_WR_PCR_ISF(base, index, value) (PORT_RMW_PCR(base, index, PORT_PCR_ISF_MASK, PORT_PCR_ISF(value)))
#define PORT_BWR_PCR_ISF(base, index, value) (BME_BFI32(&PORT_PCR_REG(base, index), ((uint32_t)(value) << PORT_PCR_ISF_SHIFT), PORT_PCR_ISF_SHIFT, PORT_PCR_ISF_WIDTH))
/*@}*/

/*******************************************************************************
 * PORT_GPCLR - Global Pin Control Low Register
 ******************************************************************************/

/*!
 * @brief PORT_GPCLR - Global Pin Control Low Register (WORZ)
 *
 * Reset value: 0x00000000U
 *
 * Only 32-bit writes are supported to this register.
 */
/*!
 * @name Constants and macros for entire PORT_GPCLR register
 */
/*@{*/
#define PORT_RD_GPCLR(base)      (PORT_GPCLR_REG(base))
#define PORT_WR_GPCLR(base, value) (PORT_GPCLR_REG(base) = (value))
#define PORT_RMW_GPCLR(base, mask, value) (PORT_WR_GPCLR(base, (PORT_RD_GPCLR(base) & ~(mask)) | (value)))
/*@}*/

/*
 * Constants & macros for individual PORT_GPCLR bitfields
 */

/*!
 * @name Register PORT_GPCLR, field GPWD[15:0] (WORZ)
 *
 * Write value that is written to all Pin Control Registers bits [15:0] that are
 * selected by GPWE.
 */
/*@{*/
/*! @brief Set the GPWD field to a new value. */
#define PORT_WR_GPCLR_GPWD(base, value) (PORT_RMW_GPCLR(base, PORT_GPCLR_GPWD_MASK, PORT_GPCLR_GPWD(value)))
#define PORT_BWR_GPCLR_GPWD(base, value) (BME_BFI32(&PORT_GPCLR_REG(base), ((uint32_t)(value) << PORT_GPCLR_GPWD_SHIFT), PORT_GPCLR_GPWD_SHIFT, PORT_GPCLR_GPWD_WIDTH))
/*@}*/

/*!
 * @name Register PORT_GPCLR, field GPWE[31:16] (WORZ)
 *
 * Selects which Pin Control Registers (15 through 0) bits [15:0] update with
 * the value in GPWD. If a selected Pin Control Register is locked then the write
 * to that register is ignored.
 *
 * Values:
 * - 0b0000000000000000 - Corresponding Pin Control Register is not updated with
 *     the value in GPWD.
 * - 0b0000000000000001 - Corresponding Pin Control Register is updated with the
 *     value in GPWD.
 */
/*@{*/
/*! @brief Set the GPWE field to a new value. */
#define PORT_WR_GPCLR_GPWE(base, value) (PORT_RMW_GPCLR(base, PORT_GPCLR_GPWE_MASK, PORT_GPCLR_GPWE(value)))
#define PORT_BWR_GPCLR_GPWE(base, value) (BME_BFI32(&PORT_GPCLR_REG(base), ((uint32_t)(value) << PORT_GPCLR_GPWE_SHIFT), PORT_GPCLR_GPWE_SHIFT, PORT_GPCLR_GPWE_WIDTH))
/*@}*/

/*******************************************************************************
 * PORT_GPCHR - Global Pin Control High Register
 ******************************************************************************/

/*!
 * @brief PORT_GPCHR - Global Pin Control High Register (WORZ)
 *
 * Reset value: 0x00000000U
 *
 * Only 32-bit writes are supported to this register.
 */
/*!
 * @name Constants and macros for entire PORT_GPCHR register
 */
/*@{*/
#define PORT_RD_GPCHR(base)      (PORT_GPCHR_REG(base))
#define PORT_WR_GPCHR(base, value) (PORT_GPCHR_REG(base) = (value))
#define PORT_RMW_GPCHR(base, mask, value) (PORT_WR_GPCHR(base, (PORT_RD_GPCHR(base) & ~(mask)) | (value)))
/*@}*/

/*
 * Constants & macros for individual PORT_GPCHR bitfields
 */

/*!
 * @name Register PORT_GPCHR, field GPWD[15:0] (WORZ)
 *
 * Write value that is written to all Pin Control Registers bits [15:0] that are
 * selected by GPWE.
 */
/*@{*/
/*! @brief Set the GPWD field to a new value. */
#define PORT_WR_GPCHR_GPWD(base, value) (PORT_RMW_GPCHR(base, PORT_GPCHR_GPWD_MASK, PORT_GPCHR_GPWD(value)))
#define PORT_BWR_GPCHR_GPWD(base, value) (BME_BFI32(&PORT_GPCHR_REG(base), ((uint32_t)(value) << PORT_GPCHR_GPWD_SHIFT), PORT_GPCHR_GPWD_SHIFT, PORT_GPCHR_GPWD_WIDTH))
/*@}*/

/*!
 * @name Register PORT_GPCHR, field GPWE[31:16] (WORZ)
 *
 * Selects which Pin Control Registers (31 through 16) bits [15:0] update with
 * the value in GPWD. If a selected Pin Control Register is locked then the write
 * to that register is ignored.
 *
 * Values:
 * - 0b0000000000000000 - Corresponding Pin Control Register is not updated with
 *     the value in GPWD.
 * - 0b0000000000000001 - Corresponding Pin Control Register is updated with the
 *     value in GPWD.
 */
/*@{*/
/*! @brief Set the GPWE field to a new value. */
#define PORT_WR_GPCHR_GPWE(base, value) (PORT_RMW_GPCHR(base, PORT_GPCHR_GPWE_MASK, PORT_GPCHR_GPWE(value)))
#define PORT_BWR_GPCHR_GPWE(base, value) (BME_BFI32(&PORT_GPCHR_REG(base), ((uint32_t)(value) << PORT_GPCHR_GPWE_SHIFT), PORT_GPCHR_GPWE_SHIFT, PORT_GPCHR_GPWE_WIDTH))
/*@}*/

/*******************************************************************************
 * PORT_ISFR - Interrupt Status Flag Register
 ******************************************************************************/

/*!
 * @brief PORT_ISFR - Interrupt Status Flag Register (W1C)
 *
 * Reset value: 0x00000000U
 *
 * The corresponding bit is read only for pins that do not support interrupt
 * generation. The pin interrupt configuration is valid in all digital pin muxing
 * modes. The Interrupt Status Flag for each pin is also visible in the
 * corresponding Pin Control Register, and each flag can be cleared in either location.
 */
/*!
 * @name Constants and macros for entire PORT_ISFR register
 */
/*@{*/
#define PORT_RD_ISFR(base)       (PORT_ISFR_REG(base))
#define PORT_WR_ISFR(base, value) (PORT_ISFR_REG(base) = (value))
#define PORT_RMW_ISFR(base, mask, value) (PORT_WR_ISFR(base, (PORT_RD_ISFR(base) & ~(mask)) | (value)))
#define PORT_SET_ISFR(base, value) (BME_OR32(&PORT_ISFR_REG(base), (uint32_t)(value)))
#define PORT_CLR_ISFR(base, value) (BME_AND32(&PORT_ISFR_REG(base), (uint32_t)(~(value))))
#define PORT_TOG_ISFR(base, value) (BME_XOR32(&PORT_ISFR_REG(base), (uint32_t)(value)))
/*@}*/

/*******************************************************************************
 * PORT_DFER - Digital Filter Enable Register
 ******************************************************************************/

/*!
 * @brief PORT_DFER - Digital Filter Enable Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The digital filter configuration is valid in all digital pin muxing modes.
 */
/*!
 * @name Constants and macros for entire PORT_DFER register
 */
/*@{*/
#define PORT_RD_DFER(base)       (PORT_DFER_REG(base))
#define PORT_WR_DFER(base, value) (PORT_DFER_REG(base) = (value))
#define PORT_RMW_DFER(base, mask, value) (PORT_WR_DFER(base, (PORT_RD_DFER(base) & ~(mask)) | (value)))
#define PORT_SET_DFER(base, value) (BME_OR32(&PORT_DFER_REG(base), (uint32_t)(value)))
#define PORT_CLR_DFER(base, value) (BME_AND32(&PORT_DFER_REG(base), (uint32_t)(~(value))))
#define PORT_TOG_DFER(base, value) (BME_XOR32(&PORT_DFER_REG(base), (uint32_t)(value)))
/*@}*/

/*******************************************************************************
 * PORT_DFCR - Digital Filter Clock Register
 ******************************************************************************/

/*!
 * @brief PORT_DFCR - Digital Filter Clock Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The digital filter configuration is valid in all digital pin muxing modes.
 */
/*!
 * @name Constants and macros for entire PORT_DFCR register
 */
/*@{*/
#define PORT_RD_DFCR(base)       (PORT_DFCR_REG(base))
#define PORT_WR_DFCR(base, value) (PORT_DFCR_REG(base) = (value))
#define PORT_RMW_DFCR(base, mask, value) (PORT_WR_DFCR(base, (PORT_RD_DFCR(base) & ~(mask)) | (value)))
#define PORT_SET_DFCR(base, value) (BME_OR32(&PORT_DFCR_REG(base), (uint32_t)(value)))
#define PORT_CLR_DFCR(base, value) (BME_AND32(&PORT_DFCR_REG(base), (uint32_t)(~(value))))
#define PORT_TOG_DFCR(base, value) (BME_XOR32(&PORT_DFCR_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual PORT_DFCR bitfields
 */

/*!
 * @name Register PORT_DFCR, field CS[0] (RW)
 *
 * The digital filter configuration is valid in all digital pin muxing modes.
 * Configures the clock source for the digital input filters. Changing the filter
 * clock source must be done only when all digital filters are disabled.
 *
 * Values:
 * - 0b0 - Digital filters are clocked by the bus clock.
 * - 0b1 - Digital filters are clocked by the LPO clock.
 */
/*@{*/
/*! @brief Read current value of the PORT_DFCR_CS field. */
#define PORT_RD_DFCR_CS(base) ((PORT_DFCR_REG(base) & PORT_DFCR_CS_MASK) >> PORT_DFCR_CS_SHIFT)
#define PORT_BRD_DFCR_CS(base) (BME_UBFX32(&PORT_DFCR_REG(base), PORT_DFCR_CS_SHIFT, PORT_DFCR_CS_WIDTH))

/*! @brief Set the CS field to a new value. */
#define PORT_WR_DFCR_CS(base, value) (PORT_RMW_DFCR(base, PORT_DFCR_CS_MASK, PORT_DFCR_CS(value)))
#define PORT_BWR_DFCR_CS(base, value) (BME_BFI32(&PORT_DFCR_REG(base), ((uint32_t)(value) << PORT_DFCR_CS_SHIFT), PORT_DFCR_CS_SHIFT, PORT_DFCR_CS_WIDTH))
/*@}*/

/*******************************************************************************
 * PORT_DFWR - Digital Filter Width Register
 ******************************************************************************/

/*!
 * @brief PORT_DFWR - Digital Filter Width Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The digital filter configuration is valid in all digital pin muxing modes.
 */
/*!
 * @name Constants and macros for entire PORT_DFWR register
 */
/*@{*/
#define PORT_RD_DFWR(base)       (PORT_DFWR_REG(base))
#define PORT_WR_DFWR(base, value) (PORT_DFWR_REG(base) = (value))
#define PORT_RMW_DFWR(base, mask, value) (PORT_WR_DFWR(base, (PORT_RD_DFWR(base) & ~(mask)) | (value)))
#define PORT_SET_DFWR(base, value) (BME_OR32(&PORT_DFWR_REG(base), (uint32_t)(value)))
#define PORT_CLR_DFWR(base, value) (BME_AND32(&PORT_DFWR_REG(base), (uint32_t)(~(value))))
#define PORT_TOG_DFWR(base, value) (BME_XOR32(&PORT_DFWR_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual PORT_DFWR bitfields
 */

/*!
 * @name Register PORT_DFWR, field FILT[4:0] (RW)
 *
 * The digital filter configuration is valid in all digital pin muxing modes.
 * Configures the maximum size of the glitches, in clock cycles, that the digital
 * filter absorbs for the enabled digital filters. Glitches that are longer than
 * this register setting will pass through the digital filter, and glitches that
 * are equal to or less than this register setting are filtered. Changing the
 * filter length must be done only after all filters are disabled.
 */
/*@{*/
/*! @brief Read current value of the PORT_DFWR_FILT field. */
#define PORT_RD_DFWR_FILT(base) ((PORT_DFWR_REG(base) & PORT_DFWR_FILT_MASK) >> PORT_DFWR_FILT_SHIFT)
#define PORT_BRD_DFWR_FILT(base) (BME_UBFX32(&PORT_DFWR_REG(base), PORT_DFWR_FILT_SHIFT, PORT_DFWR_FILT_WIDTH))

/*! @brief Set the FILT field to a new value. */
#define PORT_WR_DFWR_FILT(base, value) (PORT_RMW_DFWR(base, PORT_DFWR_FILT_MASK, PORT_DFWR_FILT(value)))
#define PORT_BWR_DFWR_FILT(base, value) (BME_BFI32(&PORT_DFWR_REG(base), ((uint32_t)(value) << PORT_DFWR_FILT_SHIFT), PORT_DFWR_FILT_SHIFT, PORT_DFWR_FILT_WIDTH))
/*@}*/

/*
 * MKM34Z7 RCM
 *
 * Reset Control Module
 *
 * Registers defined in this header file:
 * - RCM_SRS0 - System Reset Status Register 0
 * - RCM_SRS1 - System Reset Status Register 1
 * - RCM_RPFC - Reset Pin Filter Control register
 * - RCM_RPFW - Reset Pin Filter Width register
 * - RCM_SSRS0 - Sticky System Reset Status Register 0
 * - RCM_SSRS1 - Sticky System Reset Status Register 1
 */

#define RCM_INSTANCE_COUNT (1U) /*!< Number of instances of the RCM module. */
#define RCM_IDX (0U) /*!< Instance number for RCM. */

/*******************************************************************************
 * RCM_SRS0 - System Reset Status Register 0
 ******************************************************************************/

/*!
 * @brief RCM_SRS0 - System Reset Status Register 0 (RO)
 *
 * Reset value: 0x82U
 *
 * This register includes read-only status flags to indicate the source of the
 * most recent reset. The reset state of these bits depends on what caused the MCU
 * to reset. The reset value of this register depends on the reset source: POR
 * (including LVD) - 0x82 LVD (without POR) - 0x02 VLLS mode wakeup due to RESET
 * pin assertion - 0x41 VLLS mode wakeup due to other wakeup sources - 0x01 Other
 * reset - a bit is set if its corresponding reset source caused the reset
 */
/*!
 * @name Constants and macros for entire RCM_SRS0 register
 */
/*@{*/
#define RCM_RD_SRS0(base)        (RCM_SRS0_REG(base))
/*@}*/

/*
 * Constants & macros for individual RCM_SRS0 bitfields
 */

/*!
 * @name Register RCM_SRS0, field WAKEUP[0] (RO)
 *
 * Indicates a reset has been caused by an enabled wakeup source while the chip
 * was in a low leakage mode. Any enabled wakeup source in a VLLSx mode causes a
 * reset. This bit is cleared by any reset except WAKEUP.
 *
 * Values:
 * - 0b0 - Reset not caused by wakeup source
 * - 0b1 - Reset caused by wakeup source
 */
/*@{*/
/*! @brief Read current value of the RCM_SRS0_WAKEUP field. */
#define RCM_RD_SRS0_WAKEUP(base) ((RCM_SRS0_REG(base) & RCM_SRS0_WAKEUP_MASK) >> RCM_SRS0_WAKEUP_SHIFT)
#define RCM_BRD_SRS0_WAKEUP(base) (BME_UBFX8(&RCM_SRS0_REG(base), RCM_SRS0_WAKEUP_SHIFT, RCM_SRS0_WAKEUP_WIDTH))
/*@}*/

/*!
 * @name Register RCM_SRS0, field LVD[1] (RO)
 *
 * If PMC_LVDSC1[LVDRE] is set and the supply drops below the LVD trip voltage,
 * an LVD reset occurs. This field is also set by POR.
 *
 * Values:
 * - 0b0 - Reset not caused by LVD trip or POR
 * - 0b1 - Reset caused by LVD trip or POR
 */
/*@{*/
/*! @brief Read current value of the RCM_SRS0_LVD field. */
#define RCM_RD_SRS0_LVD(base) ((RCM_SRS0_REG(base) & RCM_SRS0_LVD_MASK) >> RCM_SRS0_LVD_SHIFT)
#define RCM_BRD_SRS0_LVD(base) (BME_UBFX8(&RCM_SRS0_REG(base), RCM_SRS0_LVD_SHIFT, RCM_SRS0_LVD_WIDTH))
/*@}*/

/*!
 * @name Register RCM_SRS0, field LOC[2] (RO)
 *
 * Indicates a reset has been caused by a loss of external clock. The MCG clock
 * monitor must be enabled for a loss of clock to be detected. Refer to the
 * detailed MCG description for information on enabling the clock monitor.
 *
 * Values:
 * - 0b0 - Reset not caused by a loss of external clock.
 * - 0b1 - Reset caused by a loss of external clock.
 */
/*@{*/
/*! @brief Read current value of the RCM_SRS0_LOC field. */
#define RCM_RD_SRS0_LOC(base) ((RCM_SRS0_REG(base) & RCM_SRS0_LOC_MASK) >> RCM_SRS0_LOC_SHIFT)
#define RCM_BRD_SRS0_LOC(base) (BME_UBFX8(&RCM_SRS0_REG(base), RCM_SRS0_LOC_SHIFT, RCM_SRS0_LOC_WIDTH))
/*@}*/

/*!
 * @name Register RCM_SRS0, field LOL[3] (RO)
 *
 * Indicates a reset has been caused by a loss of lock in the MCG PLL. See the
 * MCG description for information on the loss-of-clock event.
 *
 * Values:
 * - 0b0 - Reset not caused by a loss of lock in the PLL
 * - 0b1 - Reset caused by a loss of lock in the PLL
 */
/*@{*/
/*! @brief Read current value of the RCM_SRS0_LOL field. */
#define RCM_RD_SRS0_LOL(base) ((RCM_SRS0_REG(base) & RCM_SRS0_LOL_MASK) >> RCM_SRS0_LOL_SHIFT)
#define RCM_BRD_SRS0_LOL(base) (BME_UBFX8(&RCM_SRS0_REG(base), RCM_SRS0_LOL_SHIFT, RCM_SRS0_LOL_WIDTH))
/*@}*/

/*!
 * @name Register RCM_SRS0, field WDOG[5] (RO)
 *
 * Indicates a reset has been caused by the watchdog timer timing out. This
 * reset source can be blocked by disabling the watchdog.
 *
 * Values:
 * - 0b0 - Reset not caused by watchdog timeout
 * - 0b1 - Reset caused by watchdog timeout
 */
/*@{*/
/*! @brief Read current value of the RCM_SRS0_WDOG field. */
#define RCM_RD_SRS0_WDOG(base) ((RCM_SRS0_REG(base) & RCM_SRS0_WDOG_MASK) >> RCM_SRS0_WDOG_SHIFT)
#define RCM_BRD_SRS0_WDOG(base) (BME_UBFX8(&RCM_SRS0_REG(base), RCM_SRS0_WDOG_SHIFT, RCM_SRS0_WDOG_WIDTH))
/*@}*/

/*!
 * @name Register RCM_SRS0, field PIN[6] (RO)
 *
 * Indicates a reset has been caused by an active-low level on the external
 * RESET pin.
 *
 * Values:
 * - 0b0 - Reset not caused by external reset pin
 * - 0b1 - Reset caused by external reset pin
 */
/*@{*/
/*! @brief Read current value of the RCM_SRS0_PIN field. */
#define RCM_RD_SRS0_PIN(base) ((RCM_SRS0_REG(base) & RCM_SRS0_PIN_MASK) >> RCM_SRS0_PIN_SHIFT)
#define RCM_BRD_SRS0_PIN(base) (BME_UBFX8(&RCM_SRS0_REG(base), RCM_SRS0_PIN_SHIFT, RCM_SRS0_PIN_WIDTH))
/*@}*/

/*!
 * @name Register RCM_SRS0, field POR[7] (RO)
 *
 * Indicates a reset has been caused by the power-on detection logic. Because
 * the internal supply voltage was ramping up at the time, the low-voltage reset
 * (LVD) status bit is also set to indicate that the reset occurred while the
 * internal supply was below the LVD threshold.
 *
 * Values:
 * - 0b0 - Reset not caused by POR
 * - 0b1 - Reset caused by POR
 */
/*@{*/
/*! @brief Read current value of the RCM_SRS0_POR field. */
#define RCM_RD_SRS0_POR(base) ((RCM_SRS0_REG(base) & RCM_SRS0_POR_MASK) >> RCM_SRS0_POR_SHIFT)
#define RCM_BRD_SRS0_POR(base) (BME_UBFX8(&RCM_SRS0_REG(base), RCM_SRS0_POR_SHIFT, RCM_SRS0_POR_WIDTH))
/*@}*/

/*******************************************************************************
 * RCM_SRS1 - System Reset Status Register 1
 ******************************************************************************/

/*!
 * @brief RCM_SRS1 - System Reset Status Register 1 (RO)
 *
 * Reset value: 0x00U
 *
 * This register includes read-only status flags to indicate the source of the
 * most recent reset. The reset state of these bits depends on what caused the MCU
 * to reset. The reset value of this register depends on the reset source: POR
 * (including LVD) - 0x00 LVD (without POR) - 0x00 VLLS mode wakeup - 0x00 Other
 * reset - a bit is set if its corresponding reset source caused the reset
 */
/*!
 * @name Constants and macros for entire RCM_SRS1 register
 */
/*@{*/
#define RCM_RD_SRS1(base)        (RCM_SRS1_REG(base))
/*@}*/

/*
 * Constants & macros for individual RCM_SRS1 bitfields
 */

/*!
 * @name Register RCM_SRS1, field LOCKUP[1] (RO)
 *
 * Indicates a reset has been caused by the ARM core indication of a LOCKUP
 * event.
 *
 * Values:
 * - 0b0 - Reset not caused by core LOCKUP event
 * - 0b1 - Reset caused by core LOCKUP event
 */
/*@{*/
/*! @brief Read current value of the RCM_SRS1_LOCKUP field. */
#define RCM_RD_SRS1_LOCKUP(base) ((RCM_SRS1_REG(base) & RCM_SRS1_LOCKUP_MASK) >> RCM_SRS1_LOCKUP_SHIFT)
#define RCM_BRD_SRS1_LOCKUP(base) (BME_UBFX8(&RCM_SRS1_REG(base), RCM_SRS1_LOCKUP_SHIFT, RCM_SRS1_LOCKUP_WIDTH))
/*@}*/

/*!
 * @name Register RCM_SRS1, field SW[2] (RO)
 *
 * Indicates a reset has been caused by software setting of SYSRESETREQ bit in
 * Application Interrupt and Reset Control Register in the ARM core.
 *
 * Values:
 * - 0b0 - Reset not caused by software setting of SYSRESETREQ bit
 * - 0b1 - Reset caused by software setting of SYSRESETREQ bit
 */
/*@{*/
/*! @brief Read current value of the RCM_SRS1_SW field. */
#define RCM_RD_SRS1_SW(base) ((RCM_SRS1_REG(base) & RCM_SRS1_SW_MASK) >> RCM_SRS1_SW_SHIFT)
#define RCM_BRD_SRS1_SW(base) (BME_UBFX8(&RCM_SRS1_REG(base), RCM_SRS1_SW_SHIFT, RCM_SRS1_SW_WIDTH))
/*@}*/

/*!
 * @name Register RCM_SRS1, field MDM_AP[3] (RO)
 *
 * Indicates a reset has been caused by the host debugger system setting of the
 * System Reset Request bit in the MDM-AP Control Register.
 *
 * Values:
 * - 0b0 - Reset not caused by host debugger system setting of the System Reset
 *     Request bit
 * - 0b1 - Reset caused by host debugger system setting of the System Reset
 *     Request bit
 */
/*@{*/
/*! @brief Read current value of the RCM_SRS1_MDM_AP field. */
#define RCM_RD_SRS1_MDM_AP(base) ((RCM_SRS1_REG(base) & RCM_SRS1_MDM_AP_MASK) >> RCM_SRS1_MDM_AP_SHIFT)
#define RCM_BRD_SRS1_MDM_AP(base) (BME_UBFX8(&RCM_SRS1_REG(base), RCM_SRS1_MDM_AP_SHIFT, RCM_SRS1_MDM_AP_WIDTH))
/*@}*/

/*!
 * @name Register RCM_SRS1, field SACKERR[5] (RO)
 *
 * Indicates that after an attempt to enter Stop mode, a reset has been caused
 * by a failure of one or more peripherals to acknowledge within approximately one
 * second to enter stop mode.
 *
 * Values:
 * - 0b0 - Reset not caused by peripheral failure to acknowledge attempt to
 *     enter stop mode
 * - 0b1 - Reset caused by peripheral failure to acknowledge attempt to enter
 *     stop mode
 */
/*@{*/
/*! @brief Read current value of the RCM_SRS1_SACKERR field. */
#define RCM_RD_SRS1_SACKERR(base) ((RCM_SRS1_REG(base) & RCM_SRS1_SACKERR_MASK) >> RCM_SRS1_SACKERR_SHIFT)
#define RCM_BRD_SRS1_SACKERR(base) (BME_UBFX8(&RCM_SRS1_REG(base), RCM_SRS1_SACKERR_SHIFT, RCM_SRS1_SACKERR_WIDTH))
/*@}*/

/*******************************************************************************
 * RCM_RPFC - Reset Pin Filter Control register
 ******************************************************************************/

/*!
 * @brief RCM_RPFC - Reset Pin Filter Control register (RW)
 *
 * Reset value: 0x00U
 *
 * The reset values of bits 2-0 are for Chip POR only. They are unaffected by
 * other reset types. The bus clock filter is reset when disabled or when entering
 * stop mode. The LPO filter is reset when disabled .
 */
/*!
 * @name Constants and macros for entire RCM_RPFC register
 */
/*@{*/
#define RCM_RD_RPFC(base)        (RCM_RPFC_REG(base))
#define RCM_WR_RPFC(base, value) (RCM_RPFC_REG(base) = (value))
#define RCM_RMW_RPFC(base, mask, value) (RCM_WR_RPFC(base, (RCM_RD_RPFC(base) & ~(mask)) | (value)))
#define RCM_SET_RPFC(base, value) (BME_OR8(&RCM_RPFC_REG(base), (uint8_t)(value)))
#define RCM_CLR_RPFC(base, value) (BME_AND8(&RCM_RPFC_REG(base), (uint8_t)(~(value))))
#define RCM_TOG_RPFC(base, value) (BME_XOR8(&RCM_RPFC_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual RCM_RPFC bitfields
 */

/*!
 * @name Register RCM_RPFC, field RSTFLTSRW[1:0] (RW)
 *
 * Selects how the reset pin filter is enabled in run and wait modes.
 *
 * Values:
 * - 0b00 - All filtering disabled
 * - 0b01 - Bus clock filter enabled for normal operation
 * - 0b10 - LPO clock filter enabled for normal operation
 * - 0b11 - Reserved
 */
/*@{*/
/*! @brief Read current value of the RCM_RPFC_RSTFLTSRW field. */
#define RCM_RD_RPFC_RSTFLTSRW(base) ((RCM_RPFC_REG(base) & RCM_RPFC_RSTFLTSRW_MASK) >> RCM_RPFC_RSTFLTSRW_SHIFT)
#define RCM_BRD_RPFC_RSTFLTSRW(base) (BME_UBFX8(&RCM_RPFC_REG(base), RCM_RPFC_RSTFLTSRW_SHIFT, RCM_RPFC_RSTFLTSRW_WIDTH))

/*! @brief Set the RSTFLTSRW field to a new value. */
#define RCM_WR_RPFC_RSTFLTSRW(base, value) (RCM_RMW_RPFC(base, RCM_RPFC_RSTFLTSRW_MASK, RCM_RPFC_RSTFLTSRW(value)))
#define RCM_BWR_RPFC_RSTFLTSRW(base, value) (BME_BFI8(&RCM_RPFC_REG(base), ((uint8_t)(value) << RCM_RPFC_RSTFLTSRW_SHIFT), RCM_RPFC_RSTFLTSRW_SHIFT, RCM_RPFC_RSTFLTSRW_WIDTH))
/*@}*/

/*!
 * @name Register RCM_RPFC, field RSTFLTSS[2] (RW)
 *
 * Selects how the reset pin filter is enabled in Stop and VLPS modes , and also
 * during VLLS mode. On exit from VLLS mode, this bit should be reconfigured
 * before clearing PMC_REGSC[ACKISO].
 *
 * Values:
 * - 0b0 - All filtering disabled
 * - 0b1 - LPO clock filter enabled
 */
/*@{*/
/*! @brief Read current value of the RCM_RPFC_RSTFLTSS field. */
#define RCM_RD_RPFC_RSTFLTSS(base) ((RCM_RPFC_REG(base) & RCM_RPFC_RSTFLTSS_MASK) >> RCM_RPFC_RSTFLTSS_SHIFT)
#define RCM_BRD_RPFC_RSTFLTSS(base) (BME_UBFX8(&RCM_RPFC_REG(base), RCM_RPFC_RSTFLTSS_SHIFT, RCM_RPFC_RSTFLTSS_WIDTH))

/*! @brief Set the RSTFLTSS field to a new value. */
#define RCM_WR_RPFC_RSTFLTSS(base, value) (RCM_RMW_RPFC(base, RCM_RPFC_RSTFLTSS_MASK, RCM_RPFC_RSTFLTSS(value)))
#define RCM_BWR_RPFC_RSTFLTSS(base, value) (BME_BFI8(&RCM_RPFC_REG(base), ((uint8_t)(value) << RCM_RPFC_RSTFLTSS_SHIFT), RCM_RPFC_RSTFLTSS_SHIFT, RCM_RPFC_RSTFLTSS_WIDTH))
/*@}*/

/*******************************************************************************
 * RCM_RPFW - Reset Pin Filter Width register
 ******************************************************************************/

/*!
 * @brief RCM_RPFW - Reset Pin Filter Width register (RW)
 *
 * Reset value: 0x00U
 *
 * The reset values of the bits in the RSTFLTSEL field are for Chip POR only.
 * They are unaffected by other reset types.
 */
/*!
 * @name Constants and macros for entire RCM_RPFW register
 */
/*@{*/
#define RCM_RD_RPFW(base)        (RCM_RPFW_REG(base))
#define RCM_WR_RPFW(base, value) (RCM_RPFW_REG(base) = (value))
#define RCM_RMW_RPFW(base, mask, value) (RCM_WR_RPFW(base, (RCM_RD_RPFW(base) & ~(mask)) | (value)))
#define RCM_SET_RPFW(base, value) (BME_OR8(&RCM_RPFW_REG(base), (uint8_t)(value)))
#define RCM_CLR_RPFW(base, value) (BME_AND8(&RCM_RPFW_REG(base), (uint8_t)(~(value))))
#define RCM_TOG_RPFW(base, value) (BME_XOR8(&RCM_RPFW_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual RCM_RPFW bitfields
 */

/*!
 * @name Register RCM_RPFW, field RSTFLTSEL[4:0] (RW)
 *
 * Selects the reset pin bus clock filter width.
 *
 * Values:
 * - 0b00000 - Bus clock filter count is 1
 * - 0b00001 - Bus clock filter count is 2
 * - 0b00010 - Bus clock filter count is 3
 * - 0b00011 - Bus clock filter count is 4
 * - 0b00100 - Bus clock filter count is 5
 * - 0b00101 - Bus clock filter count is 6
 * - 0b00110 - Bus clock filter count is 7
 * - 0b00111 - Bus clock filter count is 8
 * - 0b01000 - Bus clock filter count is 9
 * - 0b01001 - Bus clock filter count is 10
 * - 0b01010 - Bus clock filter count is 11
 * - 0b01011 - Bus clock filter count is 12
 * - 0b01100 - Bus clock filter count is 13
 * - 0b01101 - Bus clock filter count is 14
 * - 0b01110 - Bus clock filter count is 15
 * - 0b01111 - Bus clock filter count is 16
 * - 0b10000 - Bus clock filter count is 17
 * - 0b10001 - Bus clock filter count is 18
 * - 0b10010 - Bus clock filter count is 19
 * - 0b10011 - Bus clock filter count is 20
 * - 0b10100 - Bus clock filter count is 21
 * - 0b10101 - Bus clock filter count is 22
 * - 0b10110 - Bus clock filter count is 23
 * - 0b10111 - Bus clock filter count is 24
 * - 0b11000 - Bus clock filter count is 25
 * - 0b11001 - Bus clock filter count is 26
 * - 0b11010 - Bus clock filter count is 27
 * - 0b11011 - Bus clock filter count is 28
 * - 0b11100 - Bus clock filter count is 29
 * - 0b11101 - Bus clock filter count is 30
 * - 0b11110 - Bus clock filter count is 31
 * - 0b11111 - Bus clock filter count is 32
 */
/*@{*/
/*! @brief Read current value of the RCM_RPFW_RSTFLTSEL field. */
#define RCM_RD_RPFW_RSTFLTSEL(base) ((RCM_RPFW_REG(base) & RCM_RPFW_RSTFLTSEL_MASK) >> RCM_RPFW_RSTFLTSEL_SHIFT)
#define RCM_BRD_RPFW_RSTFLTSEL(base) (BME_UBFX8(&RCM_RPFW_REG(base), RCM_RPFW_RSTFLTSEL_SHIFT, RCM_RPFW_RSTFLTSEL_WIDTH))

/*! @brief Set the RSTFLTSEL field to a new value. */
#define RCM_WR_RPFW_RSTFLTSEL(base, value) (RCM_RMW_RPFW(base, RCM_RPFW_RSTFLTSEL_MASK, RCM_RPFW_RSTFLTSEL(value)))
#define RCM_BWR_RPFW_RSTFLTSEL(base, value) (BME_BFI8(&RCM_RPFW_REG(base), ((uint8_t)(value) << RCM_RPFW_RSTFLTSEL_SHIFT), RCM_RPFW_RSTFLTSEL_SHIFT, RCM_RPFW_RSTFLTSEL_WIDTH))
/*@}*/

/*******************************************************************************
 * RCM_SSRS0 - Sticky System Reset Status Register 0
 ******************************************************************************/

/*!
 * @brief RCM_SSRS0 - Sticky System Reset Status Register 0 (RW)
 *
 * Reset value: 0x82U
 *
 * This register includes status flags to indicate all reset sources since the
 * last POR, LVD or VLLS Wakeup that have not been cleared by software. Software
 * can clear the status flags by writing a logic one to a flag.
 */
/*!
 * @name Constants and macros for entire RCM_SSRS0 register
 */
/*@{*/
#define RCM_RD_SSRS0(base)       (RCM_SSRS0_REG(base))
#define RCM_WR_SSRS0(base, value) (RCM_SSRS0_REG(base) = (value))
#define RCM_RMW_SSRS0(base, mask, value) (RCM_WR_SSRS0(base, (RCM_RD_SSRS0(base) & ~(mask)) | (value)))
#define RCM_SET_SSRS0(base, value) (BME_OR8(&RCM_SSRS0_REG(base), (uint8_t)(value)))
#define RCM_CLR_SSRS0(base, value) (BME_AND8(&RCM_SSRS0_REG(base), (uint8_t)(~(value))))
#define RCM_TOG_SSRS0(base, value) (BME_XOR8(&RCM_SSRS0_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual RCM_SSRS0 bitfields
 */

/*!
 * @name Register RCM_SSRS0, field SWAKEUP[0] (W1C)
 *
 * Indicates a reset has been caused by an enabled wakeup source while the chip
 * was in a low leakage mode. Any enabled wakeup source in a VLLSx mode causes a
 * reset.
 *
 * Values:
 * - 0b0 - Reset not caused by wakeup source
 * - 0b1 - Reset caused by wakeup source
 */
/*@{*/
/*! @brief Read current value of the RCM_SSRS0_SWAKEUP field. */
#define RCM_RD_SSRS0_SWAKEUP(base) ((RCM_SSRS0_REG(base) & RCM_SSRS0_SWAKEUP_MASK) >> RCM_SSRS0_SWAKEUP_SHIFT)
#define RCM_BRD_SSRS0_SWAKEUP(base) (BME_UBFX8(&RCM_SSRS0_REG(base), RCM_SSRS0_SWAKEUP_SHIFT, RCM_SSRS0_SWAKEUP_WIDTH))

/*! @brief Set the SWAKEUP field to a new value. */
#define RCM_WR_SSRS0_SWAKEUP(base, value) (RCM_RMW_SSRS0(base, (RCM_SSRS0_SWAKEUP_MASK | RCM_SSRS0_SLVD_MASK | RCM_SSRS0_SLOL_MASK | RCM_SSRS0_SWDOG_MASK | RCM_SSRS0_SPIN_MASK | RCM_SSRS0_SPOR_MASK), RCM_SSRS0_SWAKEUP(value)))
#define RCM_BWR_SSRS0_SWAKEUP(base, value) (BME_BFI8(&RCM_SSRS0_REG(base), ((uint8_t)(value) << RCM_SSRS0_SWAKEUP_SHIFT), RCM_SSRS0_SWAKEUP_SHIFT, RCM_SSRS0_SWAKEUP_WIDTH))
/*@}*/

/*!
 * @name Register RCM_SSRS0, field SLVD[1] (W1C)
 *
 * If PMC_LVDSC1[LVDRE] is set and the supply drops below the LVD trip voltage,
 * an LVD reset occurs. This field is also set by POR.
 *
 * Values:
 * - 0b0 - Reset not caused by LVD trip or POR
 * - 0b1 - Reset caused by LVD trip or POR
 */
/*@{*/
/*! @brief Read current value of the RCM_SSRS0_SLVD field. */
#define RCM_RD_SSRS0_SLVD(base) ((RCM_SSRS0_REG(base) & RCM_SSRS0_SLVD_MASK) >> RCM_SSRS0_SLVD_SHIFT)
#define RCM_BRD_SSRS0_SLVD(base) (BME_UBFX8(&RCM_SSRS0_REG(base), RCM_SSRS0_SLVD_SHIFT, RCM_SSRS0_SLVD_WIDTH))

/*! @brief Set the SLVD field to a new value. */
#define RCM_WR_SSRS0_SLVD(base, value) (RCM_RMW_SSRS0(base, (RCM_SSRS0_SLVD_MASK | RCM_SSRS0_SWAKEUP_MASK | RCM_SSRS0_SLOL_MASK | RCM_SSRS0_SWDOG_MASK | RCM_SSRS0_SPIN_MASK | RCM_SSRS0_SPOR_MASK), RCM_SSRS0_SLVD(value)))
#define RCM_BWR_SSRS0_SLVD(base, value) (BME_BFI8(&RCM_SSRS0_REG(base), ((uint8_t)(value) << RCM_SSRS0_SLVD_SHIFT), RCM_SSRS0_SLVD_SHIFT, RCM_SSRS0_SLVD_WIDTH))
/*@}*/

/*!
 * @name Register RCM_SSRS0, field SLOL[3] (W1C)
 *
 * Indicates a reset has been caused by a loss of lock in the MCG PLL. See the
 * MCG description for information on the loss-of-clock event.
 *
 * Values:
 * - 0b0 - Reset not caused by a loss of lock in the PLL
 * - 0b1 - Reset caused by a loss of lock in the PLL
 */
/*@{*/
/*! @brief Read current value of the RCM_SSRS0_SLOL field. */
#define RCM_RD_SSRS0_SLOL(base) ((RCM_SSRS0_REG(base) & RCM_SSRS0_SLOL_MASK) >> RCM_SSRS0_SLOL_SHIFT)
#define RCM_BRD_SSRS0_SLOL(base) (BME_UBFX8(&RCM_SSRS0_REG(base), RCM_SSRS0_SLOL_SHIFT, RCM_SSRS0_SLOL_WIDTH))

/*! @brief Set the SLOL field to a new value. */
#define RCM_WR_SSRS0_SLOL(base, value) (RCM_RMW_SSRS0(base, (RCM_SSRS0_SLOL_MASK | RCM_SSRS0_SWAKEUP_MASK | RCM_SSRS0_SLVD_MASK | RCM_SSRS0_SWDOG_MASK | RCM_SSRS0_SPIN_MASK | RCM_SSRS0_SPOR_MASK), RCM_SSRS0_SLOL(value)))
#define RCM_BWR_SSRS0_SLOL(base, value) (BME_BFI8(&RCM_SSRS0_REG(base), ((uint8_t)(value) << RCM_SSRS0_SLOL_SHIFT), RCM_SSRS0_SLOL_SHIFT, RCM_SSRS0_SLOL_WIDTH))
/*@}*/

/*!
 * @name Register RCM_SSRS0, field SWDOG[5] (W1C)
 *
 * Indicates a reset has been caused by the watchdog timer timing out. This
 * reset source can be blocked by disabling the watchdog.
 *
 * Values:
 * - 0b0 - Reset not caused by watchdog timeout
 * - 0b1 - Reset caused by watchdog timeout
 */
/*@{*/
/*! @brief Read current value of the RCM_SSRS0_SWDOG field. */
#define RCM_RD_SSRS0_SWDOG(base) ((RCM_SSRS0_REG(base) & RCM_SSRS0_SWDOG_MASK) >> RCM_SSRS0_SWDOG_SHIFT)
#define RCM_BRD_SSRS0_SWDOG(base) (BME_UBFX8(&RCM_SSRS0_REG(base), RCM_SSRS0_SWDOG_SHIFT, RCM_SSRS0_SWDOG_WIDTH))

/*! @brief Set the SWDOG field to a new value. */
#define RCM_WR_SSRS0_SWDOG(base, value) (RCM_RMW_SSRS0(base, (RCM_SSRS0_SWDOG_MASK | RCM_SSRS0_SWAKEUP_MASK | RCM_SSRS0_SLVD_MASK | RCM_SSRS0_SLOL_MASK | RCM_SSRS0_SPIN_MASK | RCM_SSRS0_SPOR_MASK), RCM_SSRS0_SWDOG(value)))
#define RCM_BWR_SSRS0_SWDOG(base, value) (BME_BFI8(&RCM_SSRS0_REG(base), ((uint8_t)(value) << RCM_SSRS0_SWDOG_SHIFT), RCM_SSRS0_SWDOG_SHIFT, RCM_SSRS0_SWDOG_WIDTH))
/*@}*/

/*!
 * @name Register RCM_SSRS0, field SPIN[6] (W1C)
 *
 * Indicates a reset has been caused by an active-low level on the external
 * RESET pin.
 *
 * Values:
 * - 0b0 - Reset not caused by external reset pin
 * - 0b1 - Reset caused by external reset pin
 */
/*@{*/
/*! @brief Read current value of the RCM_SSRS0_SPIN field. */
#define RCM_RD_SSRS0_SPIN(base) ((RCM_SSRS0_REG(base) & RCM_SSRS0_SPIN_MASK) >> RCM_SSRS0_SPIN_SHIFT)
#define RCM_BRD_SSRS0_SPIN(base) (BME_UBFX8(&RCM_SSRS0_REG(base), RCM_SSRS0_SPIN_SHIFT, RCM_SSRS0_SPIN_WIDTH))

/*! @brief Set the SPIN field to a new value. */
#define RCM_WR_SSRS0_SPIN(base, value) (RCM_RMW_SSRS0(base, (RCM_SSRS0_SPIN_MASK | RCM_SSRS0_SWAKEUP_MASK | RCM_SSRS0_SLVD_MASK | RCM_SSRS0_SLOL_MASK | RCM_SSRS0_SWDOG_MASK | RCM_SSRS0_SPOR_MASK), RCM_SSRS0_SPIN(value)))
#define RCM_BWR_SSRS0_SPIN(base, value) (BME_BFI8(&RCM_SSRS0_REG(base), ((uint8_t)(value) << RCM_SSRS0_SPIN_SHIFT), RCM_SSRS0_SPIN_SHIFT, RCM_SSRS0_SPIN_WIDTH))
/*@}*/

/*!
 * @name Register RCM_SSRS0, field SPOR[7] (W1C)
 *
 * Indicates a reset has been caused by the power-on detection logic. Because
 * the internal supply voltage was ramping up at the time, the low-voltage reset
 * (LVD) status bit is also set to indicate that the reset occurred while the
 * internal supply was below the LVD threshold.
 *
 * Values:
 * - 0b0 - Reset not caused by POR
 * - 0b1 - Reset caused by POR
 */
/*@{*/
/*! @brief Read current value of the RCM_SSRS0_SPOR field. */
#define RCM_RD_SSRS0_SPOR(base) ((RCM_SSRS0_REG(base) & RCM_SSRS0_SPOR_MASK) >> RCM_SSRS0_SPOR_SHIFT)
#define RCM_BRD_SSRS0_SPOR(base) (BME_UBFX8(&RCM_SSRS0_REG(base), RCM_SSRS0_SPOR_SHIFT, RCM_SSRS0_SPOR_WIDTH))

/*! @brief Set the SPOR field to a new value. */
#define RCM_WR_SSRS0_SPOR(base, value) (RCM_RMW_SSRS0(base, (RCM_SSRS0_SPOR_MASK | RCM_SSRS0_SWAKEUP_MASK | RCM_SSRS0_SLVD_MASK | RCM_SSRS0_SLOL_MASK | RCM_SSRS0_SWDOG_MASK | RCM_SSRS0_SPIN_MASK), RCM_SSRS0_SPOR(value)))
#define RCM_BWR_SSRS0_SPOR(base, value) (BME_BFI8(&RCM_SSRS0_REG(base), ((uint8_t)(value) << RCM_SSRS0_SPOR_SHIFT), RCM_SSRS0_SPOR_SHIFT, RCM_SSRS0_SPOR_WIDTH))
/*@}*/

/*******************************************************************************
 * RCM_SSRS1 - Sticky System Reset Status Register 1
 ******************************************************************************/

/*!
 * @brief RCM_SSRS1 - Sticky System Reset Status Register 1 (RW)
 *
 * Reset value: 0x00U
 *
 * This register includes status flags to indicate all reset sources since the
 * last POR, LVD or VLLS Wakeup that have not been cleared by software. Software
 * can clear the status flags by writing a logic one to a flag.
 */
/*!
 * @name Constants and macros for entire RCM_SSRS1 register
 */
/*@{*/
#define RCM_RD_SSRS1(base)       (RCM_SSRS1_REG(base))
#define RCM_WR_SSRS1(base, value) (RCM_SSRS1_REG(base) = (value))
#define RCM_RMW_SSRS1(base, mask, value) (RCM_WR_SSRS1(base, (RCM_RD_SSRS1(base) & ~(mask)) | (value)))
#define RCM_SET_SSRS1(base, value) (BME_OR8(&RCM_SSRS1_REG(base), (uint8_t)(value)))
#define RCM_CLR_SSRS1(base, value) (BME_AND8(&RCM_SSRS1_REG(base), (uint8_t)(~(value))))
#define RCM_TOG_SSRS1(base, value) (BME_XOR8(&RCM_SSRS1_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual RCM_SSRS1 bitfields
 */

/*!
 * @name Register RCM_SSRS1, field SLOCKUP[1] (W1C)
 *
 * Indicates a reset has been caused by the ARM core indication of a LOCKUP
 * event.
 *
 * Values:
 * - 0b0 - Reset not caused by core LOCKUP event
 * - 0b1 - Reset caused by core LOCKUP event
 */
/*@{*/
/*! @brief Read current value of the RCM_SSRS1_SLOCKUP field. */
#define RCM_RD_SSRS1_SLOCKUP(base) ((RCM_SSRS1_REG(base) & RCM_SSRS1_SLOCKUP_MASK) >> RCM_SSRS1_SLOCKUP_SHIFT)
#define RCM_BRD_SSRS1_SLOCKUP(base) (BME_UBFX8(&RCM_SSRS1_REG(base), RCM_SSRS1_SLOCKUP_SHIFT, RCM_SSRS1_SLOCKUP_WIDTH))

/*! @brief Set the SLOCKUP field to a new value. */
#define RCM_WR_SSRS1_SLOCKUP(base, value) (RCM_RMW_SSRS1(base, (RCM_SSRS1_SLOCKUP_MASK | RCM_SSRS1_SSW_MASK | RCM_SSRS1_SMDM_AP_MASK | RCM_SSRS1_SSACKERR_MASK), RCM_SSRS1_SLOCKUP(value)))
#define RCM_BWR_SSRS1_SLOCKUP(base, value) (BME_BFI8(&RCM_SSRS1_REG(base), ((uint8_t)(value) << RCM_SSRS1_SLOCKUP_SHIFT), RCM_SSRS1_SLOCKUP_SHIFT, RCM_SSRS1_SLOCKUP_WIDTH))
/*@}*/

/*!
 * @name Register RCM_SSRS1, field SSW[2] (W1C)
 *
 * Indicates a reset has been caused by software setting of SYSRESETREQ bit in
 * Application Interrupt and Reset Control Register in the ARM core.
 *
 * Values:
 * - 0b0 - Reset not caused by software setting of SYSRESETREQ bit
 * - 0b1 - Reset caused by software setting of SYSRESETREQ bit
 */
/*@{*/
/*! @brief Read current value of the RCM_SSRS1_SSW field. */
#define RCM_RD_SSRS1_SSW(base) ((RCM_SSRS1_REG(base) & RCM_SSRS1_SSW_MASK) >> RCM_SSRS1_SSW_SHIFT)
#define RCM_BRD_SSRS1_SSW(base) (BME_UBFX8(&RCM_SSRS1_REG(base), RCM_SSRS1_SSW_SHIFT, RCM_SSRS1_SSW_WIDTH))

/*! @brief Set the SSW field to a new value. */
#define RCM_WR_SSRS1_SSW(base, value) (RCM_RMW_SSRS1(base, (RCM_SSRS1_SSW_MASK | RCM_SSRS1_SLOCKUP_MASK | RCM_SSRS1_SMDM_AP_MASK | RCM_SSRS1_SSACKERR_MASK), RCM_SSRS1_SSW(value)))
#define RCM_BWR_SSRS1_SSW(base, value) (BME_BFI8(&RCM_SSRS1_REG(base), ((uint8_t)(value) << RCM_SSRS1_SSW_SHIFT), RCM_SSRS1_SSW_SHIFT, RCM_SSRS1_SSW_WIDTH))
/*@}*/

/*!
 * @name Register RCM_SSRS1, field SMDM_AP[3] (W1C)
 *
 * Indicates a reset has been caused by the host debugger system setting of the
 * System Reset Request bit in the MDM-AP Control Register.
 *
 * Values:
 * - 0b0 - Reset not caused by host debugger system setting of the System Reset
 *     Request bit
 * - 0b1 - Reset caused by host debugger system setting of the System Reset
 *     Request bit
 */
/*@{*/
/*! @brief Read current value of the RCM_SSRS1_SMDM_AP field. */
#define RCM_RD_SSRS1_SMDM_AP(base) ((RCM_SSRS1_REG(base) & RCM_SSRS1_SMDM_AP_MASK) >> RCM_SSRS1_SMDM_AP_SHIFT)
#define RCM_BRD_SSRS1_SMDM_AP(base) (BME_UBFX8(&RCM_SSRS1_REG(base), RCM_SSRS1_SMDM_AP_SHIFT, RCM_SSRS1_SMDM_AP_WIDTH))

/*! @brief Set the SMDM_AP field to a new value. */
#define RCM_WR_SSRS1_SMDM_AP(base, value) (RCM_RMW_SSRS1(base, (RCM_SSRS1_SMDM_AP_MASK | RCM_SSRS1_SLOCKUP_MASK | RCM_SSRS1_SSW_MASK | RCM_SSRS1_SSACKERR_MASK), RCM_SSRS1_SMDM_AP(value)))
#define RCM_BWR_SSRS1_SMDM_AP(base, value) (BME_BFI8(&RCM_SSRS1_REG(base), ((uint8_t)(value) << RCM_SSRS1_SMDM_AP_SHIFT), RCM_SSRS1_SMDM_AP_SHIFT, RCM_SSRS1_SMDM_AP_WIDTH))
/*@}*/

/*!
 * @name Register RCM_SSRS1, field SSACKERR[5] (W1C)
 *
 * Indicates that after an attempt to enter Stop mode, a reset has been caused
 * by a failure of one or more peripherals to acknowledge within approximately one
 * second to enter stop mode.
 *
 * Values:
 * - 0b0 - Reset not caused by peripheral failure to acknowledge attempt to
 *     enter stop mode
 * - 0b1 - Reset caused by peripheral failure to acknowledge attempt to enter
 *     stop mode
 */
/*@{*/
/*! @brief Read current value of the RCM_SSRS1_SSACKERR field. */
#define RCM_RD_SSRS1_SSACKERR(base) ((RCM_SSRS1_REG(base) & RCM_SSRS1_SSACKERR_MASK) >> RCM_SSRS1_SSACKERR_SHIFT)
#define RCM_BRD_SSRS1_SSACKERR(base) (BME_UBFX8(&RCM_SSRS1_REG(base), RCM_SSRS1_SSACKERR_SHIFT, RCM_SSRS1_SSACKERR_WIDTH))

/*! @brief Set the SSACKERR field to a new value. */
#define RCM_WR_SSRS1_SSACKERR(base, value) (RCM_RMW_SSRS1(base, (RCM_SSRS1_SSACKERR_MASK | RCM_SSRS1_SLOCKUP_MASK | RCM_SSRS1_SSW_MASK | RCM_SSRS1_SMDM_AP_MASK), RCM_SSRS1_SSACKERR(value)))
#define RCM_BWR_SSRS1_SSACKERR(base, value) (BME_BFI8(&RCM_SSRS1_REG(base), ((uint8_t)(value) << RCM_SSRS1_SSACKERR_SHIFT), RCM_SSRS1_SSACKERR_SHIFT, RCM_SSRS1_SSACKERR_WIDTH))
/*@}*/

/*
 * MKM34Z7 RNG
 *
 * Random Number Generator Accelerator
 *
 * Registers defined in this header file:
 * - RNG_CR - RNGA Control Register
 * - RNG_SR - RNGA Status Register
 * - RNG_ER - RNGA Entropy Register
 * - RNG_OR - RNGA Output Register
 */

#define RNG_INSTANCE_COUNT (1U) /*!< Number of instances of the RNG module. */
#define RNG_IDX (0U) /*!< Instance number for RNG. */

/*******************************************************************************
 * RNG_CR - RNGA Control Register
 ******************************************************************************/

/*!
 * @brief RNG_CR - RNGA Control Register (RW)
 *
 * Reset value: 0x00000010U
 *
 * Controls the operation of RNGA.
 */
/*!
 * @name Constants and macros for entire RNG_CR register
 */
/*@{*/
#define RNG_RD_CR(base)          (RNG_CR_REG(base))
#define RNG_WR_CR(base, value)   (RNG_CR_REG(base) = (value))
#define RNG_RMW_CR(base, mask, value) (RNG_WR_CR(base, (RNG_RD_CR(base) & ~(mask)) | (value)))
#define RNG_SET_CR(base, value)  (BME_OR32(&RNG_CR_REG(base), (uint32_t)(value)))
#define RNG_CLR_CR(base, value)  (BME_AND32(&RNG_CR_REG(base), (uint32_t)(~(value))))
#define RNG_TOG_CR(base, value)  (BME_XOR32(&RNG_CR_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual RNG_CR bitfields
 */

/*!
 * @name Register RNG_CR, field GO[0] (RW)
 *
 * Specifies whether random-data generation and loading (into OR[RANDOUT]) is
 * enabled.This field is sticky. You must reset RNGA to stop RNGA from loading
 * OR[RANDOUT] with data.
 *
 * Values:
 * - 0b0 - Disabled
 * - 0b1 - Enabled
 */
/*@{*/
/*! @brief Read current value of the RNG_CR_GO field. */
#define RNG_RD_CR_GO(base)   ((RNG_CR_REG(base) & RNG_CR_GO_MASK) >> RNG_CR_GO_SHIFT)
#define RNG_BRD_CR_GO(base)  (BME_UBFX32(&RNG_CR_REG(base), RNG_CR_GO_SHIFT, RNG_CR_GO_WIDTH))

/*! @brief Set the GO field to a new value. */
#define RNG_WR_CR_GO(base, value) (RNG_RMW_CR(base, RNG_CR_GO_MASK, RNG_CR_GO(value)))
#define RNG_BWR_CR_GO(base, value) (BME_BFI32(&RNG_CR_REG(base), ((uint32_t)(value) << RNG_CR_GO_SHIFT), RNG_CR_GO_SHIFT, RNG_CR_GO_WIDTH))
/*@}*/

/*!
 * @name Register RNG_CR, field HA[1] (RW)
 *
 * Enables notification of security violations (via SR[SECV]). A security
 * violation occurs when you read OR[RANDOUT] and SR[OREG_LVL]=0. This field is sticky.
 * After enabling notification of security violations, you must reset RNGA to
 * disable them again.
 *
 * Values:
 * - 0b0 - Disabled
 * - 0b1 - Enabled
 */
/*@{*/
/*! @brief Read current value of the RNG_CR_HA field. */
#define RNG_RD_CR_HA(base)   ((RNG_CR_REG(base) & RNG_CR_HA_MASK) >> RNG_CR_HA_SHIFT)
#define RNG_BRD_CR_HA(base)  (BME_UBFX32(&RNG_CR_REG(base), RNG_CR_HA_SHIFT, RNG_CR_HA_WIDTH))

/*! @brief Set the HA field to a new value. */
#define RNG_WR_CR_HA(base, value) (RNG_RMW_CR(base, RNG_CR_HA_MASK, RNG_CR_HA(value)))
#define RNG_BWR_CR_HA(base, value) (BME_BFI32(&RNG_CR_REG(base), ((uint32_t)(value) << RNG_CR_HA_SHIFT), RNG_CR_HA_SHIFT, RNG_CR_HA_WIDTH))
/*@}*/

/*!
 * @name Register RNG_CR, field INTM[2] (RW)
 *
 * Masks the triggering of an error interrupt to the interrupt controller when
 * an OR underflow condition occurs. An OR underflow condition occurs when you
 * read OR[RANDOUT] and SR[OREG_LVL]=0. See the Output Register (OR) description.
 *
 * Values:
 * - 0b0 - Not masked
 * - 0b1 - Masked
 */
/*@{*/
/*! @brief Read current value of the RNG_CR_INTM field. */
#define RNG_RD_CR_INTM(base) ((RNG_CR_REG(base) & RNG_CR_INTM_MASK) >> RNG_CR_INTM_SHIFT)
#define RNG_BRD_CR_INTM(base) (BME_UBFX32(&RNG_CR_REG(base), RNG_CR_INTM_SHIFT, RNG_CR_INTM_WIDTH))

/*! @brief Set the INTM field to a new value. */
#define RNG_WR_CR_INTM(base, value) (RNG_RMW_CR(base, RNG_CR_INTM_MASK, RNG_CR_INTM(value)))
#define RNG_BWR_CR_INTM(base, value) (BME_BFI32(&RNG_CR_REG(base), ((uint32_t)(value) << RNG_CR_INTM_SHIFT), RNG_CR_INTM_SHIFT, RNG_CR_INTM_WIDTH))
/*@}*/

/*!
 * @name Register RNG_CR, field CLRI[3] (WORZ)
 *
 * Clears the interrupt by resetting the error-interrupt indicator (SR[ERRI]).
 * Reading SR[ERRI] immediately after writing to CR[CLRI] is not recommended.
 *
 * Values:
 * - 0b0 - Do not clear the interrupt.
 * - 0b1 - Clear the interrupt. When you write 1 to this field, RNGA then resets
 *     the error-interrupt indicator (SR[ERRI]). This bit always reads as 0.
 */
/*@{*/
/*! @brief Set the CLRI field to a new value. */
#define RNG_WR_CR_CLRI(base, value) (RNG_RMW_CR(base, RNG_CR_CLRI_MASK, RNG_CR_CLRI(value)))
#define RNG_BWR_CR_CLRI(base, value) (BME_BFI32(&RNG_CR_REG(base), ((uint32_t)(value) << RNG_CR_CLRI_SHIFT), RNG_CR_CLRI_SHIFT, RNG_CR_CLRI_WIDTH))
/*@}*/

/*!
 * @name Register RNG_CR, field SLP[4] (RW)
 *
 * Specifies whether RNGA is in Sleep or Normal mode. You can also enter Sleep
 * mode by asserting the DOZE signal.
 *
 * Values:
 * - 0b0 - Normal mode
 * - 0b1 - Sleep (low-power) mode
 */
/*@{*/
/*! @brief Read current value of the RNG_CR_SLP field. */
#define RNG_RD_CR_SLP(base)  ((RNG_CR_REG(base) & RNG_CR_SLP_MASK) >> RNG_CR_SLP_SHIFT)
#define RNG_BRD_CR_SLP(base) (BME_UBFX32(&RNG_CR_REG(base), RNG_CR_SLP_SHIFT, RNG_CR_SLP_WIDTH))

/*! @brief Set the SLP field to a new value. */
#define RNG_WR_CR_SLP(base, value) (RNG_RMW_CR(base, RNG_CR_SLP_MASK, RNG_CR_SLP(value)))
#define RNG_BWR_CR_SLP(base, value) (BME_BFI32(&RNG_CR_REG(base), ((uint32_t)(value) << RNG_CR_SLP_SHIFT), RNG_CR_SLP_SHIFT, RNG_CR_SLP_WIDTH))
/*@}*/

/*******************************************************************************
 * RNG_SR - RNGA Status Register
 ******************************************************************************/

/*!
 * @brief RNG_SR - RNGA Status Register (RO)
 *
 * Reset value: 0x00010000U
 *
 * Indicates the status of RNGA. This register is read-only.
 */
/*!
 * @name Constants and macros for entire RNG_SR register
 */
/*@{*/
#define RNG_RD_SR(base)          (RNG_SR_REG(base))
/*@}*/

/*
 * Constants & macros for individual RNG_SR bitfields
 */

/*!
 * @name Register RNG_SR, field SECV[0] (RO)
 *
 * Used only when high assurance is enabled (CR[HA]). Indicates that a security
 * violation has occurred.This field is sticky. To clear SR[SECV], you must reset
 * RNGA.
 *
 * Values:
 * - 0b0 - No security violation
 * - 0b1 - Security violation
 */
/*@{*/
/*! @brief Read current value of the RNG_SR_SECV field. */
#define RNG_RD_SR_SECV(base) ((RNG_SR_REG(base) & RNG_SR_SECV_MASK) >> RNG_SR_SECV_SHIFT)
#define RNG_BRD_SR_SECV(base) (BME_UBFX32(&RNG_SR_REG(base), RNG_SR_SECV_SHIFT, RNG_SR_SECV_WIDTH))
/*@}*/

/*!
 * @name Register RNG_SR, field LRS[1] (RO)
 *
 * Indicates whether the most recent read of OR[RANDOUT] caused an OR underflow
 * condition, regardless of whether the error interrupt is masked (CR[INTM]). An
 * OR underflow condition occurs when you read OR[RANDOUT] and SR[OREG_LVL]=0.
 * After you read this register, RNGA writes 0 to this field.
 *
 * Values:
 * - 0b0 - No underflow
 * - 0b1 - Underflow
 */
/*@{*/
/*! @brief Read current value of the RNG_SR_LRS field. */
#define RNG_RD_SR_LRS(base)  ((RNG_SR_REG(base) & RNG_SR_LRS_MASK) >> RNG_SR_LRS_SHIFT)
#define RNG_BRD_SR_LRS(base) (BME_UBFX32(&RNG_SR_REG(base), RNG_SR_LRS_SHIFT, RNG_SR_LRS_WIDTH))
/*@}*/

/*!
 * @name Register RNG_SR, field ORU[2] (RO)
 *
 * Indicates whether an OR underflow condition has occurred since you last read
 * this register (SR) or RNGA was reset, regardless of whether the error
 * interrupt is masked (CR[INTM]). An OR underflow condition occurs when you read
 * OR[RANDOUT] and SR[OREG_LVL]=0. After you read this register, RNGA writes 0 to this
 * field.
 *
 * Values:
 * - 0b0 - No underflow
 * - 0b1 - Underflow
 */
/*@{*/
/*! @brief Read current value of the RNG_SR_ORU field. */
#define RNG_RD_SR_ORU(base)  ((RNG_SR_REG(base) & RNG_SR_ORU_MASK) >> RNG_SR_ORU_SHIFT)
#define RNG_BRD_SR_ORU(base) (BME_UBFX32(&RNG_SR_REG(base), RNG_SR_ORU_SHIFT, RNG_SR_ORU_WIDTH))
/*@}*/

/*!
 * @name Register RNG_SR, field ERRI[3] (RO)
 *
 * Indicates whether an OR underflow condition has occurred since you last
 * cleared the error interrupt (CR[CLRI]) or RNGA was reset, regardless of whether the
 * error interrupt is masked (CR[INTM]). An OR underflow condition occurs when
 * you read OR[RANDOUT] and SR[OREG_LVL]=0. After you reset the error-interrupt
 * indicator (via CR[CLRI]), RNGA writes 0 to this field.
 *
 * Values:
 * - 0b0 - No underflow
 * - 0b1 - Underflow
 */
/*@{*/
/*! @brief Read current value of the RNG_SR_ERRI field. */
#define RNG_RD_SR_ERRI(base) ((RNG_SR_REG(base) & RNG_SR_ERRI_MASK) >> RNG_SR_ERRI_SHIFT)
#define RNG_BRD_SR_ERRI(base) (BME_UBFX32(&RNG_SR_REG(base), RNG_SR_ERRI_SHIFT, RNG_SR_ERRI_WIDTH))
/*@}*/

/*!
 * @name Register RNG_SR, field SLP[4] (RO)
 *
 * Specifies whether RNGA is in Sleep or Normal mode. You can also enter Sleep
 * mode by asserting the DOZE signal.
 *
 * Values:
 * - 0b0 - Normal mode
 * - 0b1 - Sleep (low-power) mode
 */
/*@{*/
/*! @brief Read current value of the RNG_SR_SLP field. */
#define RNG_RD_SR_SLP(base)  ((RNG_SR_REG(base) & RNG_SR_SLP_MASK) >> RNG_SR_SLP_SHIFT)
#define RNG_BRD_SR_SLP(base) (BME_UBFX32(&RNG_SR_REG(base), RNG_SR_SLP_SHIFT, RNG_SR_SLP_WIDTH))
/*@}*/

/*!
 * @name Register RNG_SR, field OREG_LVL[15:8] (RO)
 *
 * Indicates the number of random-data words that are in OR[RANDOUT], which
 * indicates whether OR[RANDOUT] is valid.If you read OR[RANDOUT] when SR[OREG_LVL]
 * is not 0, then the contents of a random number contained in OR[RANDOUT] are
 * returned, and RNGA writes 0 to both OR[RANDOUT] and SR[OREG_LVL].
 *
 * Values:
 * - 0b00000000 - No words (empty)
 * - 0b00000001 - One word (valid)
 */
/*@{*/
/*! @brief Read current value of the RNG_SR_OREG_LVL field. */
#define RNG_RD_SR_OREG_LVL(base) ((RNG_SR_REG(base) & RNG_SR_OREG_LVL_MASK) >> RNG_SR_OREG_LVL_SHIFT)
#define RNG_BRD_SR_OREG_LVL(base) (BME_UBFX32(&RNG_SR_REG(base), RNG_SR_OREG_LVL_SHIFT, RNG_SR_OREG_LVL_WIDTH))
/*@}*/

/*!
 * @name Register RNG_SR, field OREG_SIZE[23:16] (RO)
 *
 * Indicates the size of the Output (OR) register in terms of the number of
 * 32-bit random-data words it can hold.
 *
 * Values:
 * - 0b00000001 - One word (this value is fixed)
 */
/*@{*/
/*! @brief Read current value of the RNG_SR_OREG_SIZE field. */
#define RNG_RD_SR_OREG_SIZE(base) ((RNG_SR_REG(base) & RNG_SR_OREG_SIZE_MASK) >> RNG_SR_OREG_SIZE_SHIFT)
#define RNG_BRD_SR_OREG_SIZE(base) (BME_UBFX32(&RNG_SR_REG(base), RNG_SR_OREG_SIZE_SHIFT, RNG_SR_OREG_SIZE_WIDTH))
/*@}*/

/*******************************************************************************
 * RNG_ER - RNGA Entropy Register
 ******************************************************************************/

/*!
 * @brief RNG_ER - RNGA Entropy Register (WORZ)
 *
 * Reset value: 0x00000000U
 *
 * Specifies an entropy value that RNGA uses in addition to its ring oscillators
 * to seed its pseudorandom algorithm. This is a write-only register; reads
 * return all zeros.
 */
/*!
 * @name Constants and macros for entire RNG_ER register
 */
/*@{*/
#define RNG_RD_ER(base)          (RNG_ER_REG(base))
#define RNG_WR_ER(base, value)   (RNG_ER_REG(base) = (value))
#define RNG_RMW_ER(base, mask, value) (RNG_WR_ER(base, (RNG_RD_ER(base) & ~(mask)) | (value)))
/*@}*/

/*******************************************************************************
 * RNG_OR - RNGA Output Register
 ******************************************************************************/

/*!
 * @brief RNG_OR - RNGA Output Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * Stores a random-data word generated by RNGA.
 */
/*!
 * @name Constants and macros for entire RNG_OR register
 */
/*@{*/
#define RNG_RD_OR(base)          (RNG_OR_REG(base))
/*@}*/

/*
 * MKM34Z7 ROM
 *
 * System ROM
 *
 * Registers defined in this header file:
 * - ROM_ENTRY - Entry
 * - ROM_TABLEMARK - End of Table Marker Register
 * - ROM_SYSACCESS - System Access Register
 * - ROM_PERIPHID4 - Peripheral ID Register
 * - ROM_PERIPHID5 - Peripheral ID Register
 * - ROM_PERIPHID6 - Peripheral ID Register
 * - ROM_PERIPHID7 - Peripheral ID Register
 * - ROM_PERIPHID0 - Peripheral ID Register
 * - ROM_PERIPHID1 - Peripheral ID Register
 * - ROM_PERIPHID2 - Peripheral ID Register
 * - ROM_PERIPHID3 - Peripheral ID Register
 * - ROM_COMPID - Component ID Register
 */

#define ROM_INSTANCE_COUNT (1U) /*!< Number of instances of the ROM module. */
#define ROM_IDX (0U) /*!< Instance number for ROM. */

/*******************************************************************************
 * ROM_ENTRY - Entry
 ******************************************************************************/

/*!
 * @brief ROM_ENTRY - Entry (RO)
 *
 * Reset value: 0x00000000U
 *
 * The System ROM Table begins with "n" relative 32-bit addresses, one for each
 * debug component present in the device and terminating with an all-zero value
 * signaling the end of the table at the "n+1"-th value. It is hardwired to
 * specific values used during the auto-discovery process by an external debug agent.
 */
/*!
 * @name Constants and macros for entire ROM_ENTRY register
 */
/*@{*/
#define ROM_RD_ENTRY(base, index) (ROM_ENTRY_REG(base, index))
/*@}*/

/*******************************************************************************
 * ROM_TABLEMARK - End of Table Marker Register
 ******************************************************************************/

/*!
 * @brief ROM_TABLEMARK - End of Table Marker Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * This register indicates end of table marker. It is hardwired to specific
 * values used during the auto-discovery process by an external debug agent.
 */
/*!
 * @name Constants and macros for entire ROM_TABLEMARK register
 */
/*@{*/
#define ROM_RD_TABLEMARK(base)   (ROM_TABLEMARK_REG(base))
/*@}*/

/*******************************************************************************
 * ROM_SYSACCESS - System Access Register
 ******************************************************************************/

/*!
 * @brief ROM_SYSACCESS - System Access Register (RO)
 *
 * Reset value: 0x00000001U
 *
 * This register indicates system access. It is hardwired to specific values
 * used during the auto-discovery process by an external debug agent.
 */
/*!
 * @name Constants and macros for entire ROM_SYSACCESS register
 */
/*@{*/
#define ROM_RD_SYSACCESS(base)   (ROM_SYSACCESS_REG(base))
/*@}*/

/*******************************************************************************
 * ROM_PERIPHID4 - Peripheral ID Register
 ******************************************************************************/

/*!
 * @brief ROM_PERIPHID4 - Peripheral ID Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * These registers indicate the peripheral IDs. They are hardwired to specific
 * values used during the auto-discovery process by an external debug agent.
 */
/*!
 * @name Constants and macros for entire ROM_PERIPHID4 register
 */
/*@{*/
#define ROM_RD_PERIPHID4(base)   (ROM_PERIPHID4_REG(base))
/*@}*/

/*******************************************************************************
 * ROM_PERIPHID5 - Peripheral ID Register
 ******************************************************************************/

/*!
 * @brief ROM_PERIPHID5 - Peripheral ID Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * These registers indicate the peripheral IDs. They are hardwired to specific
 * values used during the auto-discovery process by an external debug agent.
 */
/*!
 * @name Constants and macros for entire ROM_PERIPHID5 register
 */
/*@{*/
#define ROM_RD_PERIPHID5(base)   (ROM_PERIPHID5_REG(base))
/*@}*/

/*******************************************************************************
 * ROM_PERIPHID6 - Peripheral ID Register
 ******************************************************************************/

/*!
 * @brief ROM_PERIPHID6 - Peripheral ID Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * These registers indicate the peripheral IDs. They are hardwired to specific
 * values used during the auto-discovery process by an external debug agent.
 */
/*!
 * @name Constants and macros for entire ROM_PERIPHID6 register
 */
/*@{*/
#define ROM_RD_PERIPHID6(base)   (ROM_PERIPHID6_REG(base))
/*@}*/

/*******************************************************************************
 * ROM_PERIPHID7 - Peripheral ID Register
 ******************************************************************************/

/*!
 * @brief ROM_PERIPHID7 - Peripheral ID Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * These registers indicate the peripheral IDs. They are hardwired to specific
 * values used during the auto-discovery process by an external debug agent.
 */
/*!
 * @name Constants and macros for entire ROM_PERIPHID7 register
 */
/*@{*/
#define ROM_RD_PERIPHID7(base)   (ROM_PERIPHID7_REG(base))
/*@}*/

/*******************************************************************************
 * ROM_PERIPHID0 - Peripheral ID Register
 ******************************************************************************/

/*!
 * @brief ROM_PERIPHID0 - Peripheral ID Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * These registers indicate the peripheral IDs. They are hardwired to specific
 * values used during the auto-discovery process by an external debug agent.
 */
/*!
 * @name Constants and macros for entire ROM_PERIPHID0 register
 */
/*@{*/
#define ROM_RD_PERIPHID0(base)   (ROM_PERIPHID0_REG(base))
/*@}*/

/*******************************************************************************
 * ROM_PERIPHID1 - Peripheral ID Register
 ******************************************************************************/

/*!
 * @brief ROM_PERIPHID1 - Peripheral ID Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * These registers indicate the peripheral IDs. They are hardwired to specific
 * values used during the auto-discovery process by an external debug agent.
 */
/*!
 * @name Constants and macros for entire ROM_PERIPHID1 register
 */
/*@{*/
#define ROM_RD_PERIPHID1(base)   (ROM_PERIPHID1_REG(base))
/*@}*/

/*******************************************************************************
 * ROM_PERIPHID2 - Peripheral ID Register
 ******************************************************************************/

/*!
 * @brief ROM_PERIPHID2 - Peripheral ID Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * These registers indicate the peripheral IDs. They are hardwired to specific
 * values used during the auto-discovery process by an external debug agent.
 */
/*!
 * @name Constants and macros for entire ROM_PERIPHID2 register
 */
/*@{*/
#define ROM_RD_PERIPHID2(base)   (ROM_PERIPHID2_REG(base))
/*@}*/

/*******************************************************************************
 * ROM_PERIPHID3 - Peripheral ID Register
 ******************************************************************************/

/*!
 * @brief ROM_PERIPHID3 - Peripheral ID Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * These registers indicate the peripheral IDs. They are hardwired to specific
 * values used during the auto-discovery process by an external debug agent.
 */
/*!
 * @name Constants and macros for entire ROM_PERIPHID3 register
 */
/*@{*/
#define ROM_RD_PERIPHID3(base)   (ROM_PERIPHID3_REG(base))
/*@}*/

/*******************************************************************************
 * ROM_COMPID - Component ID Register
 ******************************************************************************/

/*!
 * @brief ROM_COMPID - Component ID Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * These registers indicate the component IDs. They are hardwired to specific
 * values used during the auto-discovery process by an external debug agent.
 */
/*!
 * @name Constants and macros for entire ROM_COMPID register
 */
/*@{*/
#define ROM_RD_COMPID(base, index) (ROM_COMPID_REG(base, index))
/*@}*/

/*
 * MKM34Z7 RTC
 *
 * Real Time Clock
 *
 * Registers defined in this header file:
 * - RTC_YEARMON - RTC Year and Month Counters Register
 * - RTC_DAYS - RTC Days and Day-of-Week Counters Register
 * - RTC_HOURMIN - RTC Hours and Minutes Counters Register
 * - RTC_SECONDS - RTC Seconds Counters Register
 * - RTC_ALM_YEARMON - RTC Year and Months Alarm Register
 * - RTC_ALM_DAYS - RTC Days Alarm Register
 * - RTC_ALM_HOURMIN - RTC Hours and Minutes Alarm Register
 * - RTC_ALM_SECONDS - RTC Seconds Alarm Register
 * - RTC_CTRL - RTC Control Register
 * - RTC_STATUS - RTC Status Register
 * - RTC_ISR - RTC Interrupt Status Register
 * - RTC_IER - RTC Interrupt Enable Register
 * - RTC_GP_DATA_REG - RTC General Purpose Data Register
 * - RTC_DST_HOUR - RTC Daylight Saving Hour Register
 * - RTC_DST_MONTH - RTC Daylight Saving Month Register
 * - RTC_DST_DAY - RTC Daylight Saving Day Register
 * - RTC_COMPEN - RTC Compensation Register
 * - RTC_TAMPER_SCR - RTC Tamper Status and Control Register
 * - RTC_FILTER01_CFG - RTC Tamper 0 1 Filter Configuration Register
 * - RTC_FILTER2_CFG - RTC Tamper 2 Filter Configuration Register
 * - RTC_CTRL2 - RTC Control 2 Register
 */

#define RTC_INSTANCE_COUNT (1U) /*!< Number of instances of the RTC module. */
#define RTC_IDX (0U) /*!< Instance number for RTC. */

/*******************************************************************************
 * RTC_YEARMON - RTC Year and Month Counters Register
 ******************************************************************************/

/*!
 * @brief RTC_YEARMON - RTC Year and Month Counters Register (RW)
 *
 * Reset value: 0x0001U
 *
 * This register stores the value of the month and year counters. The year field
 * does not store the actual year value but the offset in years from a hardcoded
 * BASE YEAR taken as the year 2112. This is a signed value and the ranges from
 * -128 to +127. The software should program the offset from that base year into
 * this register. For example, if the current year is 2007, then this will be
 * represented in this register as -105 or 0x97. The actual year value can be found
 * by adding the BASE YEAR and the offset in the YEARMON[15:8] register. Hence
 * the range of year supported will be 1984 (2112 - 128) to 2239 (2112 + 127).
 * Hence for year calculation: Actual Year = Base Year (for example, 2112) + Offset
 * Year The month register stores the count value of the months register. Writing
 * to this register loads the months counter with this new value. The valid
 * values are mentioned in table below. Both month and year are unaffected on software
 * reset. User software should first determine the state of the INVAL bit in the
 * STATUS (bit 0) to determine that the counters are stable before their value
 * can be read or changed. The assertion of INVAL bit ensures that no operation is
 * done at the boundary of a second when counters change value.
 */
/*!
 * @name Constants and macros for entire RTC_YEARMON register
 */
/*@{*/
#define RTC_RD_YEARMON(base)     (RTC_YEARMON_REG(base))
#define RTC_WR_YEARMON(base, value) (RTC_YEARMON_REG(base) = (value))
#define RTC_RMW_YEARMON(base, mask, value) (RTC_WR_YEARMON(base, (RTC_RD_YEARMON(base) & ~(mask)) | (value)))
#define RTC_SET_YEARMON(base, value) (BME_OR16(&RTC_YEARMON_REG(base), (uint16_t)(value)))
#define RTC_CLR_YEARMON(base, value) (BME_AND16(&RTC_YEARMON_REG(base), (uint16_t)(~(value))))
#define RTC_TOG_YEARMON(base, value) (BME_XOR16(&RTC_YEARMON_REG(base), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual RTC_YEARMON bitfields
 */

/*!
 * @name Register RTC_YEARMON, field MON_CNT[3:0] (RW)
 *
 * These bits give the value of the Months Counter . Valid Values are:
 *
 * Values:
 * - 0b0000 - Illegal Value
 * - 0b0001 - January
 * - 0b0010 - October
 * - 0b0011 - November
 */
/*@{*/
/*! @brief Read current value of the RTC_YEARMON_MON_CNT field. */
#define RTC_RD_YEARMON_MON_CNT(base) ((RTC_YEARMON_REG(base) & RTC_YEARMON_MON_CNT_MASK) >> RTC_YEARMON_MON_CNT_SHIFT)
#define RTC_BRD_YEARMON_MON_CNT(base) (BME_UBFX16(&RTC_YEARMON_REG(base), RTC_YEARMON_MON_CNT_SHIFT, RTC_YEARMON_MON_CNT_WIDTH))

/*! @brief Set the MON_CNT field to a new value. */
#define RTC_WR_YEARMON_MON_CNT(base, value) (RTC_RMW_YEARMON(base, RTC_YEARMON_MON_CNT_MASK, RTC_YEARMON_MON_CNT(value)))
#define RTC_BWR_YEARMON_MON_CNT(base, value) (BME_BFI16(&RTC_YEARMON_REG(base), ((uint16_t)(value) << RTC_YEARMON_MON_CNT_SHIFT), RTC_YEARMON_MON_CNT_SHIFT, RTC_YEARMON_MON_CNT_WIDTH))
/*@}*/

/*!
 * @name Register RTC_YEARMON, field YROFST[15:8] (RW)
 *
 * These bits indicate the offset in years from the base year (hard coded as
 * 2112) and do not show the actual year value. This is a signed value. Valid values
 * are -128 to 127. With the Base Year as 2112 and if the value of YEAR field is
 * 0x10, the actual year will be 2112 + 16 = 2128.
 */
/*@{*/
/*! @brief Read current value of the RTC_YEARMON_YROFST field. */
#define RTC_RD_YEARMON_YROFST(base) ((RTC_YEARMON_REG(base) & RTC_YEARMON_YROFST_MASK) >> RTC_YEARMON_YROFST_SHIFT)
#define RTC_BRD_YEARMON_YROFST(base) (BME_UBFX16(&RTC_YEARMON_REG(base), RTC_YEARMON_YROFST_SHIFT, RTC_YEARMON_YROFST_WIDTH))

/*! @brief Set the YROFST field to a new value. */
#define RTC_WR_YEARMON_YROFST(base, value) (RTC_RMW_YEARMON(base, RTC_YEARMON_YROFST_MASK, RTC_YEARMON_YROFST(value)))
#define RTC_BWR_YEARMON_YROFST(base, value) (BME_BFI16(&RTC_YEARMON_REG(base), ((uint16_t)(value) << RTC_YEARMON_YROFST_SHIFT), RTC_YEARMON_YROFST_SHIFT, RTC_YEARMON_YROFST_WIDTH))
/*@}*/

/*******************************************************************************
 * RTC_DAYS - RTC Days and Day-of-Week Counters Register
 ******************************************************************************/

/*!
 * @brief RTC_DAYS - RTC Days and Day-of-Week Counters Register (RW)
 *
 * Reset value: 0x0001U
 *
 * This read/write register shows the current value of the day-of-week counter
 * and days counter. Reading this register returns the latest value of the counter
 * s . Writing to this register loads the value to the day-of-week and days
 * counters and the counters continue to count from this new value. The day-of-week
 * is not calculated automatically and should be written by CPU. This register is
 * unaffected by software reset. User software should first determine the state
 * of the INVAL bit in the STATUS (bit 0) to determine that the counters are
 * stable before their value can be read or changed. The assertion of INVAL bit
 * ensures that no operation is done at the boundary of a second when counters change
 * value.
 */
/*!
 * @name Constants and macros for entire RTC_DAYS register
 */
/*@{*/
#define RTC_RD_DAYS(base)        (RTC_DAYS_REG(base))
#define RTC_WR_DAYS(base, value) (RTC_DAYS_REG(base) = (value))
#define RTC_RMW_DAYS(base, mask, value) (RTC_WR_DAYS(base, (RTC_RD_DAYS(base) & ~(mask)) | (value)))
#define RTC_SET_DAYS(base, value) (BME_OR16(&RTC_DAYS_REG(base), (uint16_t)(value)))
#define RTC_CLR_DAYS(base, value) (BME_AND16(&RTC_DAYS_REG(base), (uint16_t)(~(value))))
#define RTC_TOG_DAYS(base, value) (BME_XOR16(&RTC_DAYS_REG(base), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual RTC_DAYS bitfields
 */

/*!
 * @name Register RTC_DAYS, field DAY_CNT[4:0] (RW)
 *
 * Valid values are '1' to '31'.
 */
/*@{*/
/*! @brief Read current value of the RTC_DAYS_DAY_CNT field. */
#define RTC_RD_DAYS_DAY_CNT(base) ((RTC_DAYS_REG(base) & RTC_DAYS_DAY_CNT_MASK) >> RTC_DAYS_DAY_CNT_SHIFT)
#define RTC_BRD_DAYS_DAY_CNT(base) (BME_UBFX16(&RTC_DAYS_REG(base), RTC_DAYS_DAY_CNT_SHIFT, RTC_DAYS_DAY_CNT_WIDTH))

/*! @brief Set the DAY_CNT field to a new value. */
#define RTC_WR_DAYS_DAY_CNT(base, value) (RTC_RMW_DAYS(base, RTC_DAYS_DAY_CNT_MASK, RTC_DAYS_DAY_CNT(value)))
#define RTC_BWR_DAYS_DAY_CNT(base, value) (BME_BFI16(&RTC_DAYS_REG(base), ((uint16_t)(value) << RTC_DAYS_DAY_CNT_SHIFT), RTC_DAYS_DAY_CNT_SHIFT, RTC_DAYS_DAY_CNT_WIDTH))
/*@}*/

/*!
 * @name Register RTC_DAYS, field DOW[10:8] (RW)
 *
 * Values:
 * - 0b000 - Sunday
 * - 0b001 - Monday
 */
/*@{*/
/*! @brief Read current value of the RTC_DAYS_DOW field. */
#define RTC_RD_DAYS_DOW(base) ((RTC_DAYS_REG(base) & RTC_DAYS_DOW_MASK) >> RTC_DAYS_DOW_SHIFT)
#define RTC_BRD_DAYS_DOW(base) (BME_UBFX16(&RTC_DAYS_REG(base), RTC_DAYS_DOW_SHIFT, RTC_DAYS_DOW_WIDTH))

/*! @brief Set the DOW field to a new value. */
#define RTC_WR_DAYS_DOW(base, value) (RTC_RMW_DAYS(base, RTC_DAYS_DOW_MASK, RTC_DAYS_DOW(value)))
#define RTC_BWR_DAYS_DOW(base, value) (BME_BFI16(&RTC_DAYS_REG(base), ((uint16_t)(value) << RTC_DAYS_DOW_SHIFT), RTC_DAYS_DOW_SHIFT, RTC_DAYS_DOW_WIDTH))
/*@}*/

/*******************************************************************************
 * RTC_HOURMIN - RTC Hours and Minutes Counters Register
 ******************************************************************************/

/*!
 * @brief RTC_HOURMIN - RTC Hours and Minutes Counters Register (RW)
 *
 * Reset value: 0x0000U
 *
 * This register is used to program the hours and minutes counter. It can be
 * read anytime to get the current value of the counters. Only power-on reset can
 * reset this register. Hours counter can be set anything between 0 and 23. Minutes
 * counter can be set anything between 0 and 59. This register is unaffected by
 * software reset. User software should first determine the state of the INVAL
 * bit in the STATUS (bit 0) to determine that the counters are stable before their
 * value can be read or changed. The assertion of INVAL bit ensures that no
 * operation is done at the boundary of a second when counters change value.
 */
/*!
 * @name Constants and macros for entire RTC_HOURMIN register
 */
/*@{*/
#define RTC_RD_HOURMIN(base)     (RTC_HOURMIN_REG(base))
#define RTC_WR_HOURMIN(base, value) (RTC_HOURMIN_REG(base) = (value))
#define RTC_RMW_HOURMIN(base, mask, value) (RTC_WR_HOURMIN(base, (RTC_RD_HOURMIN(base) & ~(mask)) | (value)))
#define RTC_SET_HOURMIN(base, value) (BME_OR16(&RTC_HOURMIN_REG(base), (uint16_t)(value)))
#define RTC_CLR_HOURMIN(base, value) (BME_AND16(&RTC_HOURMIN_REG(base), (uint16_t)(~(value))))
#define RTC_TOG_HOURMIN(base, value) (BME_XOR16(&RTC_HOURMIN_REG(base), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual RTC_HOURMIN bitfields
 */

/*!
 * @name Register RTC_HOURMIN, field MIN_CNT[5:0] (RW)
 *
 * Valid count values are 0 to 59.
 */
/*@{*/
/*! @brief Read current value of the RTC_HOURMIN_MIN_CNT field. */
#define RTC_RD_HOURMIN_MIN_CNT(base) ((RTC_HOURMIN_REG(base) & RTC_HOURMIN_MIN_CNT_MASK) >> RTC_HOURMIN_MIN_CNT_SHIFT)
#define RTC_BRD_HOURMIN_MIN_CNT(base) (BME_UBFX16(&RTC_HOURMIN_REG(base), RTC_HOURMIN_MIN_CNT_SHIFT, RTC_HOURMIN_MIN_CNT_WIDTH))

/*! @brief Set the MIN_CNT field to a new value. */
#define RTC_WR_HOURMIN_MIN_CNT(base, value) (RTC_RMW_HOURMIN(base, RTC_HOURMIN_MIN_CNT_MASK, RTC_HOURMIN_MIN_CNT(value)))
#define RTC_BWR_HOURMIN_MIN_CNT(base, value) (BME_BFI16(&RTC_HOURMIN_REG(base), ((uint16_t)(value) << RTC_HOURMIN_MIN_CNT_SHIFT), RTC_HOURMIN_MIN_CNT_SHIFT, RTC_HOURMIN_MIN_CNT_WIDTH))
/*@}*/

/*!
 * @name Register RTC_HOURMIN, field HOUR_CNT[12:8] (RW)
 *
 * Valid count values are 0 to 23.
 */
/*@{*/
/*! @brief Read current value of the RTC_HOURMIN_HOUR_CNT field. */
#define RTC_RD_HOURMIN_HOUR_CNT(base) ((RTC_HOURMIN_REG(base) & RTC_HOURMIN_HOUR_CNT_MASK) >> RTC_HOURMIN_HOUR_CNT_SHIFT)
#define RTC_BRD_HOURMIN_HOUR_CNT(base) (BME_UBFX16(&RTC_HOURMIN_REG(base), RTC_HOURMIN_HOUR_CNT_SHIFT, RTC_HOURMIN_HOUR_CNT_WIDTH))

/*! @brief Set the HOUR_CNT field to a new value. */
#define RTC_WR_HOURMIN_HOUR_CNT(base, value) (RTC_RMW_HOURMIN(base, RTC_HOURMIN_HOUR_CNT_MASK, RTC_HOURMIN_HOUR_CNT(value)))
#define RTC_BWR_HOURMIN_HOUR_CNT(base, value) (BME_BFI16(&RTC_HOURMIN_REG(base), ((uint16_t)(value) << RTC_HOURMIN_HOUR_CNT_SHIFT), RTC_HOURMIN_HOUR_CNT_SHIFT, RTC_HOURMIN_HOUR_CNT_WIDTH))
/*@}*/

/*******************************************************************************
 * RTC_SECONDS - RTC Seconds Counters Register
 ******************************************************************************/

/*!
 * @brief RTC_SECONDS - RTC Seconds Counters Register (RW)
 *
 * Reset value: 0x0000U
 *
 * This register is used to program the seconds counter. It can be read anytime
 * to get the current value of the counter. Only power-on reset can reset this
 * register. Seconds counter can be set anything between 0 and 59 both included.
 * This register is unaffected by software reset. User software should first
 * determine the state of the INVAL bit in the STATUS (bit 0) to determine that the
 * counters are stable before their value can be read or changed. The assertion of
 * INVAL bit ensures that no operation is done at the boundary of a second when
 * counters change value.
 */
/*!
 * @name Constants and macros for entire RTC_SECONDS register
 */
/*@{*/
#define RTC_RD_SECONDS(base)     (RTC_SECONDS_REG(base))
#define RTC_WR_SECONDS(base, value) (RTC_SECONDS_REG(base) = (value))
#define RTC_RMW_SECONDS(base, mask, value) (RTC_WR_SECONDS(base, (RTC_RD_SECONDS(base) & ~(mask)) | (value)))
#define RTC_SET_SECONDS(base, value) (BME_OR16(&RTC_SECONDS_REG(base), (uint16_t)(value)))
#define RTC_CLR_SECONDS(base, value) (BME_AND16(&RTC_SECONDS_REG(base), (uint16_t)(~(value))))
#define RTC_TOG_SECONDS(base, value) (BME_XOR16(&RTC_SECONDS_REG(base), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual RTC_SECONDS bitfields
 */

/*!
 * @name Register RTC_SECONDS, field SEC_CNT[5:0] (RW)
 *
 * Valid count values are 0 to 59.
 */
/*@{*/
/*! @brief Read current value of the RTC_SECONDS_SEC_CNT field. */
#define RTC_RD_SECONDS_SEC_CNT(base) ((RTC_SECONDS_REG(base) & RTC_SECONDS_SEC_CNT_MASK) >> RTC_SECONDS_SEC_CNT_SHIFT)
#define RTC_BRD_SECONDS_SEC_CNT(base) (BME_UBFX16(&RTC_SECONDS_REG(base), RTC_SECONDS_SEC_CNT_SHIFT, RTC_SECONDS_SEC_CNT_WIDTH))

/*! @brief Set the SEC_CNT field to a new value. */
#define RTC_WR_SECONDS_SEC_CNT(base, value) (RTC_RMW_SECONDS(base, RTC_SECONDS_SEC_CNT_MASK, RTC_SECONDS_SEC_CNT(value)))
#define RTC_BWR_SECONDS_SEC_CNT(base, value) (BME_BFI16(&RTC_SECONDS_REG(base), ((uint16_t)(value) << RTC_SECONDS_SEC_CNT_SHIFT), RTC_SECONDS_SEC_CNT_SHIFT, RTC_SECONDS_SEC_CNT_WIDTH))
/*@}*/

/*******************************************************************************
 * RTC_ALM_YEARMON - RTC Year and Months Alarm Register
 ******************************************************************************/

/*!
 * @brief RTC_ALM_YEARMON - RTC Year and Months Alarm Register (RW)
 *
 * Reset value: 0x0000U
 *
 * This register is used to configure the months and year setting of the alarm.
 * The alarm setting can be read or written anytime. This register is reset to
 * its default state on software reset. Alarm interrupt bit is set when all values
 * of alarm seconds, minutes, hours, days, month, and year match their respective
 * counter values. User software can configure the type of alarm using the
 * ALM_TYPE bits in the CTRL register.
 */
/*!
 * @name Constants and macros for entire RTC_ALM_YEARMON register
 */
/*@{*/
#define RTC_RD_ALM_YEARMON(base) (RTC_ALM_YEARMON_REG(base))
#define RTC_WR_ALM_YEARMON(base, value) (RTC_ALM_YEARMON_REG(base) = (value))
#define RTC_RMW_ALM_YEARMON(base, mask, value) (RTC_WR_ALM_YEARMON(base, (RTC_RD_ALM_YEARMON(base) & ~(mask)) | (value)))
#define RTC_SET_ALM_YEARMON(base, value) (BME_OR16(&RTC_ALM_YEARMON_REG(base), (uint16_t)(value)))
#define RTC_CLR_ALM_YEARMON(base, value) (BME_AND16(&RTC_ALM_YEARMON_REG(base), (uint16_t)(~(value))))
#define RTC_TOG_ALM_YEARMON(base, value) (BME_XOR16(&RTC_ALM_YEARMON_REG(base), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual RTC_ALM_YEARMON bitfields
 */

/*!
 * @name Register RTC_ALM_YEARMON, field ALM_MON[3:0] (RW)
 *
 * Same as Months Counter Value in YEARMONRTC Year and Month Counters Register .
 */
/*@{*/
/*! @brief Read current value of the RTC_ALM_YEARMON_ALM_MON field. */
#define RTC_RD_ALM_YEARMON_ALM_MON(base) ((RTC_ALM_YEARMON_REG(base) & RTC_ALM_YEARMON_ALM_MON_MASK) >> RTC_ALM_YEARMON_ALM_MON_SHIFT)
#define RTC_BRD_ALM_YEARMON_ALM_MON(base) (BME_UBFX16(&RTC_ALM_YEARMON_REG(base), RTC_ALM_YEARMON_ALM_MON_SHIFT, RTC_ALM_YEARMON_ALM_MON_WIDTH))

/*! @brief Set the ALM_MON field to a new value. */
#define RTC_WR_ALM_YEARMON_ALM_MON(base, value) (RTC_RMW_ALM_YEARMON(base, RTC_ALM_YEARMON_ALM_MON_MASK, RTC_ALM_YEARMON_ALM_MON(value)))
#define RTC_BWR_ALM_YEARMON_ALM_MON(base, value) (BME_BFI16(&RTC_ALM_YEARMON_REG(base), ((uint16_t)(value) << RTC_ALM_YEARMON_ALM_MON_SHIFT), RTC_ALM_YEARMON_ALM_MON_SHIFT, RTC_ALM_YEARMON_ALM_MON_WIDTH))
/*@}*/

/*!
 * @name Register RTC_ALM_YEARMON, field ALM_YEAR[15:8] (RW)
 *
 * Same as Years Offset Value in YEARMONRTC Year and Month Counters Register .
 */
/*@{*/
/*! @brief Read current value of the RTC_ALM_YEARMON_ALM_YEAR field. */
#define RTC_RD_ALM_YEARMON_ALM_YEAR(base) ((RTC_ALM_YEARMON_REG(base) & RTC_ALM_YEARMON_ALM_YEAR_MASK) >> RTC_ALM_YEARMON_ALM_YEAR_SHIFT)
#define RTC_BRD_ALM_YEARMON_ALM_YEAR(base) (BME_UBFX16(&RTC_ALM_YEARMON_REG(base), RTC_ALM_YEARMON_ALM_YEAR_SHIFT, RTC_ALM_YEARMON_ALM_YEAR_WIDTH))

/*! @brief Set the ALM_YEAR field to a new value. */
#define RTC_WR_ALM_YEARMON_ALM_YEAR(base, value) (RTC_RMW_ALM_YEARMON(base, RTC_ALM_YEARMON_ALM_YEAR_MASK, RTC_ALM_YEARMON_ALM_YEAR(value)))
#define RTC_BWR_ALM_YEARMON_ALM_YEAR(base, value) (BME_BFI16(&RTC_ALM_YEARMON_REG(base), ((uint16_t)(value) << RTC_ALM_YEARMON_ALM_YEAR_SHIFT), RTC_ALM_YEARMON_ALM_YEAR_SHIFT, RTC_ALM_YEARMON_ALM_YEAR_WIDTH))
/*@}*/

/*******************************************************************************
 * RTC_ALM_DAYS - RTC Days Alarm Register
 ******************************************************************************/

/*!
 * @brief RTC_ALM_DAYS - RTC Days Alarm Register (RW)
 *
 * Reset value: 0x0000U
 *
 * The days alarm register is used to configure the day setting of the alarm.
 * The alarm setting can be read or written anytime. This register is reset to its
 * default state on software reset. Alarm interrupt bit is set when all values of
 * alarm seconds, minutes, hours, days, month and year match their respective
 * counter values. User software can configure the type of alarm using the ALM_TYPE
 * bits in the CTRL register.
 */
/*!
 * @name Constants and macros for entire RTC_ALM_DAYS register
 */
/*@{*/
#define RTC_RD_ALM_DAYS(base)    (RTC_ALM_DAYS_REG(base))
#define RTC_WR_ALM_DAYS(base, value) (RTC_ALM_DAYS_REG(base) = (value))
#define RTC_RMW_ALM_DAYS(base, mask, value) (RTC_WR_ALM_DAYS(base, (RTC_RD_ALM_DAYS(base) & ~(mask)) | (value)))
#define RTC_SET_ALM_DAYS(base, value) (BME_OR16(&RTC_ALM_DAYS_REG(base), (uint16_t)(value)))
#define RTC_CLR_ALM_DAYS(base, value) (BME_AND16(&RTC_ALM_DAYS_REG(base), (uint16_t)(~(value))))
#define RTC_TOG_ALM_DAYS(base, value) (BME_XOR16(&RTC_ALM_DAYS_REG(base), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual RTC_ALM_DAYS bitfields
 */

/*!
 * @name Register RTC_ALM_DAYS, field ALM_DAY[4:0] (RW)
 *
 * Same as Days Counter Value in DAYS RTC Days and Day-of-Week Counters Register
 * .
 */
/*@{*/
/*! @brief Read current value of the RTC_ALM_DAYS_ALM_DAY field. */
#define RTC_RD_ALM_DAYS_ALM_DAY(base) ((RTC_ALM_DAYS_REG(base) & RTC_ALM_DAYS_ALM_DAY_MASK) >> RTC_ALM_DAYS_ALM_DAY_SHIFT)
#define RTC_BRD_ALM_DAYS_ALM_DAY(base) (BME_UBFX16(&RTC_ALM_DAYS_REG(base), RTC_ALM_DAYS_ALM_DAY_SHIFT, RTC_ALM_DAYS_ALM_DAY_WIDTH))

/*! @brief Set the ALM_DAY field to a new value. */
#define RTC_WR_ALM_DAYS_ALM_DAY(base, value) (RTC_RMW_ALM_DAYS(base, RTC_ALM_DAYS_ALM_DAY_MASK, RTC_ALM_DAYS_ALM_DAY(value)))
#define RTC_BWR_ALM_DAYS_ALM_DAY(base, value) (BME_BFI16(&RTC_ALM_DAYS_REG(base), ((uint16_t)(value) << RTC_ALM_DAYS_ALM_DAY_SHIFT), RTC_ALM_DAYS_ALM_DAY_SHIFT, RTC_ALM_DAYS_ALM_DAY_WIDTH))
/*@}*/

/*******************************************************************************
 * RTC_ALM_HOURMIN - RTC Hours and Minutes Alarm Register
 ******************************************************************************/

/*!
 * @brief RTC_ALM_HOURMIN - RTC Hours and Minutes Alarm Register (RW)
 *
 * Reset value: 0x0000U
 *
 * The hours and minutes alarm register is used to configure the hour and minute
 * setting of the alarm. The alarm setting can be read or written anytime. This
 * register is reset to default state on software reset. User software can
 * configure the type of alarm using the ALM_TYPE bits in the CTRL register.
 */
/*!
 * @name Constants and macros for entire RTC_ALM_HOURMIN register
 */
/*@{*/
#define RTC_RD_ALM_HOURMIN(base) (RTC_ALM_HOURMIN_REG(base))
#define RTC_WR_ALM_HOURMIN(base, value) (RTC_ALM_HOURMIN_REG(base) = (value))
#define RTC_RMW_ALM_HOURMIN(base, mask, value) (RTC_WR_ALM_HOURMIN(base, (RTC_RD_ALM_HOURMIN(base) & ~(mask)) | (value)))
#define RTC_SET_ALM_HOURMIN(base, value) (BME_OR16(&RTC_ALM_HOURMIN_REG(base), (uint16_t)(value)))
#define RTC_CLR_ALM_HOURMIN(base, value) (BME_AND16(&RTC_ALM_HOURMIN_REG(base), (uint16_t)(~(value))))
#define RTC_TOG_ALM_HOURMIN(base, value) (BME_XOR16(&RTC_ALM_HOURMIN_REG(base), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual RTC_ALM_HOURMIN bitfields
 */

/*!
 * @name Register RTC_ALM_HOURMIN, field ALM_MIN[5:0] (RW)
 *
 * Same as Minutes Counter Value in HOURMINRTC Hours and Minutes Counters
 * Register .
 */
/*@{*/
/*! @brief Read current value of the RTC_ALM_HOURMIN_ALM_MIN field. */
#define RTC_RD_ALM_HOURMIN_ALM_MIN(base) ((RTC_ALM_HOURMIN_REG(base) & RTC_ALM_HOURMIN_ALM_MIN_MASK) >> RTC_ALM_HOURMIN_ALM_MIN_SHIFT)
#define RTC_BRD_ALM_HOURMIN_ALM_MIN(base) (BME_UBFX16(&RTC_ALM_HOURMIN_REG(base), RTC_ALM_HOURMIN_ALM_MIN_SHIFT, RTC_ALM_HOURMIN_ALM_MIN_WIDTH))

/*! @brief Set the ALM_MIN field to a new value. */
#define RTC_WR_ALM_HOURMIN_ALM_MIN(base, value) (RTC_RMW_ALM_HOURMIN(base, RTC_ALM_HOURMIN_ALM_MIN_MASK, RTC_ALM_HOURMIN_ALM_MIN(value)))
#define RTC_BWR_ALM_HOURMIN_ALM_MIN(base, value) (BME_BFI16(&RTC_ALM_HOURMIN_REG(base), ((uint16_t)(value) << RTC_ALM_HOURMIN_ALM_MIN_SHIFT), RTC_ALM_HOURMIN_ALM_MIN_SHIFT, RTC_ALM_HOURMIN_ALM_MIN_WIDTH))
/*@}*/

/*!
 * @name Register RTC_ALM_HOURMIN, field ALM_HOUR[12:8] (RW)
 *
 * Same as Hours Counter Value in HOURMINRTC Hours and Minutes Counters Register
 * .
 */
/*@{*/
/*! @brief Read current value of the RTC_ALM_HOURMIN_ALM_HOUR field. */
#define RTC_RD_ALM_HOURMIN_ALM_HOUR(base) ((RTC_ALM_HOURMIN_REG(base) & RTC_ALM_HOURMIN_ALM_HOUR_MASK) >> RTC_ALM_HOURMIN_ALM_HOUR_SHIFT)
#define RTC_BRD_ALM_HOURMIN_ALM_HOUR(base) (BME_UBFX16(&RTC_ALM_HOURMIN_REG(base), RTC_ALM_HOURMIN_ALM_HOUR_SHIFT, RTC_ALM_HOURMIN_ALM_HOUR_WIDTH))

/*! @brief Set the ALM_HOUR field to a new value. */
#define RTC_WR_ALM_HOURMIN_ALM_HOUR(base, value) (RTC_RMW_ALM_HOURMIN(base, RTC_ALM_HOURMIN_ALM_HOUR_MASK, RTC_ALM_HOURMIN_ALM_HOUR(value)))
#define RTC_BWR_ALM_HOURMIN_ALM_HOUR(base, value) (BME_BFI16(&RTC_ALM_HOURMIN_REG(base), ((uint16_t)(value) << RTC_ALM_HOURMIN_ALM_HOUR_SHIFT), RTC_ALM_HOURMIN_ALM_HOUR_SHIFT, RTC_ALM_HOURMIN_ALM_HOUR_WIDTH))
/*@}*/

/*******************************************************************************
 * RTC_ALM_SECONDS - RTC Seconds Alarm Register
 ******************************************************************************/

/*!
 * @brief RTC_ALM_SECONDS - RTC Seconds Alarm Register (RW)
 *
 * Reset value: 0x0000U
 *
 * The seconds alarm register is used to configure the seconds setting of the
 * alarm. The alarm setting can be read or written anytime. This register is reset
 * to default value on software reset. Bits 9:8 provide option to the user
 * software to perform correction on seconds counter to compensate for the leap
 * seconds. Write to these bits adds or subtracts 1 from the seconds counter and read
 * returns zeros. User software should first determine the state of the INVAL bit
 * in the STATUS (bit 0) to determine that the counters are stable before they can
 * be incremented or decremented. The assertion of INVAL bit ensures that no
 * operation is done at the boundary of a second when counters change value. User
 * software can configure the type of alarm using the ALM_TYPE bits in the CTRL
 * register.
 */
/*!
 * @name Constants and macros for entire RTC_ALM_SECONDS register
 */
/*@{*/
#define RTC_RD_ALM_SECONDS(base) (RTC_ALM_SECONDS_REG(base))
#define RTC_WR_ALM_SECONDS(base, value) (RTC_ALM_SECONDS_REG(base) = (value))
#define RTC_RMW_ALM_SECONDS(base, mask, value) (RTC_WR_ALM_SECONDS(base, (RTC_RD_ALM_SECONDS(base) & ~(mask)) | (value)))
#define RTC_SET_ALM_SECONDS(base, value) (BME_OR16(&RTC_ALM_SECONDS_REG(base), (uint16_t)(value)))
#define RTC_CLR_ALM_SECONDS(base, value) (BME_AND16(&RTC_ALM_SECONDS_REG(base), (uint16_t)(~(value))))
#define RTC_TOG_ALM_SECONDS(base, value) (BME_XOR16(&RTC_ALM_SECONDS_REG(base), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual RTC_ALM_SECONDS bitfields
 */

/*!
 * @name Register RTC_ALM_SECONDS, field ALM_SEC[5:0] (RW)
 *
 * Seconds Value for Alarm. Same as Seconds Counter Value in SECONDSRTC Seconds
 * Counters Register .
 */
/*@{*/
/*! @brief Read current value of the RTC_ALM_SECONDS_ALM_SEC field. */
#define RTC_RD_ALM_SECONDS_ALM_SEC(base) ((RTC_ALM_SECONDS_REG(base) & RTC_ALM_SECONDS_ALM_SEC_MASK) >> RTC_ALM_SECONDS_ALM_SEC_SHIFT)
#define RTC_BRD_ALM_SECONDS_ALM_SEC(base) (BME_UBFX16(&RTC_ALM_SECONDS_REG(base), RTC_ALM_SECONDS_ALM_SEC_SHIFT, RTC_ALM_SECONDS_ALM_SEC_WIDTH))

/*! @brief Set the ALM_SEC field to a new value. */
#define RTC_WR_ALM_SECONDS_ALM_SEC(base, value) (RTC_RMW_ALM_SECONDS(base, RTC_ALM_SECONDS_ALM_SEC_MASK, RTC_ALM_SECONDS_ALM_SEC(value)))
#define RTC_BWR_ALM_SECONDS_ALM_SEC(base, value) (BME_BFI16(&RTC_ALM_SECONDS_REG(base), ((uint16_t)(value) << RTC_ALM_SECONDS_ALM_SEC_SHIFT), RTC_ALM_SECONDS_ALM_SEC_SHIFT, RTC_ALM_SECONDS_ALM_SEC_WIDTH))
/*@}*/

/*!
 * @name Register RTC_ALM_SECONDS, field DEC_SEC[8] (WORZ)
 *
 * This bit controls the decrement of seconds counter incase the software wants
 * to make corrections to the seconds counter to compensate for the leap seconds
 * or to perform fine trimming of time when needed. Write to this bit has
 * decrements the seconds counter and then the bit gets cleared on next posedge of bus
 * clock.
 */
/*@{*/
/*! @brief Set the DEC_SEC field to a new value. */
#define RTC_WR_ALM_SECONDS_DEC_SEC(base, value) (RTC_RMW_ALM_SECONDS(base, RTC_ALM_SECONDS_DEC_SEC_MASK, RTC_ALM_SECONDS_DEC_SEC(value)))
#define RTC_BWR_ALM_SECONDS_DEC_SEC(base, value) (BME_BFI16(&RTC_ALM_SECONDS_REG(base), ((uint16_t)(value) << RTC_ALM_SECONDS_DEC_SEC_SHIFT), RTC_ALM_SECONDS_DEC_SEC_SHIFT, RTC_ALM_SECONDS_DEC_SEC_WIDTH))
/*@}*/

/*!
 * @name Register RTC_ALM_SECONDS, field INC_SEC[9] (WORZ)
 *
 * This bit controls the increment of seconds counter incase the software wants
 * to make corrections to the seconds counter to compensate for the leap seconds
 * or to perform fine trimming of time when needed. Write to this bit increments
 * the seconds counter and then the bit gets cleared on next posedge.
 */
/*@{*/
/*! @brief Set the INC_SEC field to a new value. */
#define RTC_WR_ALM_SECONDS_INC_SEC(base, value) (RTC_RMW_ALM_SECONDS(base, RTC_ALM_SECONDS_INC_SEC_MASK, RTC_ALM_SECONDS_INC_SEC(value)))
#define RTC_BWR_ALM_SECONDS_INC_SEC(base, value) (BME_BFI16(&RTC_ALM_SECONDS_REG(base), ((uint16_t)(value) << RTC_ALM_SECONDS_INC_SEC_SHIFT), RTC_ALM_SECONDS_INC_SEC_SHIFT, RTC_ALM_SECONDS_INC_SEC_WIDTH))
/*@}*/

/*******************************************************************************
 * RTC_CTRL - RTC Control Register
 ******************************************************************************/

/*!
 * @brief RTC_CTRL - RTC Control Register (RW)
 *
 * Reset value: 0x0000U
 *
 * This is the control register and governs all operations being done inside the
 * RTC. This register is used to specify the software reset, daylight controls,
 * and the type of alarm function needed.
 */
/*!
 * @name Constants and macros for entire RTC_CTRL register
 */
/*@{*/
#define RTC_RD_CTRL(base)        (RTC_CTRL_REG(base))
#define RTC_WR_CTRL(base, value) (RTC_CTRL_REG(base) = (value))
#define RTC_RMW_CTRL(base, mask, value) (RTC_WR_CTRL(base, (RTC_RD_CTRL(base) & ~(mask)) | (value)))
#define RTC_SET_CTRL(base, value) (BME_OR16(&RTC_CTRL_REG(base), (uint16_t)(value)))
#define RTC_CLR_CTRL(base, value) (BME_AND16(&RTC_CTRL_REG(base), (uint16_t)(~(value))))
#define RTC_TOG_CTRL(base, value) (BME_XOR16(&RTC_CTRL_REG(base), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual RTC_CTRL bitfields
 */

/*!
 * @name Register RTC_CTRL, field FINEEN[0] (RW)
 *
 * Values:
 * - 0b1 - Fine compensation is enabled.
 * - 0b0 - Fine compensation is disabled
 */
/*@{*/
/*! @brief Read current value of the RTC_CTRL_FINEEN field. */
#define RTC_RD_CTRL_FINEEN(base) ((RTC_CTRL_REG(base) & RTC_CTRL_FINEEN_MASK) >> RTC_CTRL_FINEEN_SHIFT)
#define RTC_BRD_CTRL_FINEEN(base) (BME_UBFX16(&RTC_CTRL_REG(base), RTC_CTRL_FINEEN_SHIFT, RTC_CTRL_FINEEN_WIDTH))

/*! @brief Set the FINEEN field to a new value. */
#define RTC_WR_CTRL_FINEEN(base, value) (RTC_RMW_CTRL(base, RTC_CTRL_FINEEN_MASK, RTC_CTRL_FINEEN(value)))
#define RTC_BWR_CTRL_FINEEN(base, value) (BME_BFI16(&RTC_CTRL_REG(base), ((uint16_t)(value) << RTC_CTRL_FINEEN_SHIFT), RTC_CTRL_FINEEN_SHIFT, RTC_CTRL_FINEEN_WIDTH))
/*@}*/

/*!
 * @name Register RTC_CTRL, field COMP_EN[1] (RW)
 *
 * Compensation enable bit 1'b0:- Coarse Compensation is disabled. 1'b1:- Coarse
 * Compensation is enabled. Note:- If both the bits are meant to be set "1'b1"
 * hardware will not let the COMP_EN bit to be written 1.
 */
/*@{*/
/*! @brief Read current value of the RTC_CTRL_COMP_EN field. */
#define RTC_RD_CTRL_COMP_EN(base) ((RTC_CTRL_REG(base) & RTC_CTRL_COMP_EN_MASK) >> RTC_CTRL_COMP_EN_SHIFT)
#define RTC_BRD_CTRL_COMP_EN(base) (BME_UBFX16(&RTC_CTRL_REG(base), RTC_CTRL_COMP_EN_SHIFT, RTC_CTRL_COMP_EN_WIDTH))

/*! @brief Set the COMP_EN field to a new value. */
#define RTC_WR_CTRL_COMP_EN(base, value) (RTC_RMW_CTRL(base, RTC_CTRL_COMP_EN_MASK, RTC_CTRL_COMP_EN(value)))
#define RTC_BWR_CTRL_COMP_EN(base, value) (BME_BFI16(&RTC_CTRL_REG(base), ((uint16_t)(value) << RTC_CTRL_COMP_EN_SHIFT), RTC_CTRL_COMP_EN_SHIFT, RTC_CTRL_COMP_EN_WIDTH))
/*@}*/

/*!
 * @name Register RTC_CTRL, field ALM_MATCH[3:2] (RW)
 *
 * These bits define the type of alarm function. These bits select which time
 * and calendar counters will be used for matching and generate an alarm.
 *
 * Values:
 * - 0b00 - Only Seconds, Minutes, and Hours matched.
 * - 0b01 - Only Seconds, Minutes, Hours, and Days matched.
 * - 0b10 - Only Seconds, Minutes, Hours, Days, and Months matched.
 */
/*@{*/
/*! @brief Read current value of the RTC_CTRL_ALM_MATCH field. */
#define RTC_RD_CTRL_ALM_MATCH(base) ((RTC_CTRL_REG(base) & RTC_CTRL_ALM_MATCH_MASK) >> RTC_CTRL_ALM_MATCH_SHIFT)
#define RTC_BRD_CTRL_ALM_MATCH(base) (BME_UBFX16(&RTC_CTRL_REG(base), RTC_CTRL_ALM_MATCH_SHIFT, RTC_CTRL_ALM_MATCH_WIDTH))

/*! @brief Set the ALM_MATCH field to a new value. */
#define RTC_WR_CTRL_ALM_MATCH(base, value) (RTC_RMW_CTRL(base, RTC_CTRL_ALM_MATCH_MASK, RTC_CTRL_ALM_MATCH(value)))
#define RTC_BWR_CTRL_ALM_MATCH(base, value) (BME_BFI16(&RTC_CTRL_REG(base), ((uint16_t)(value) << RTC_CTRL_ALM_MATCH_SHIFT), RTC_CTRL_ALM_MATCH_SHIFT, RTC_CTRL_ALM_MATCH_WIDTH))
/*@}*/

/*!
 * @name Register RTC_CTRL, field TIMER_STB_MASK[4] (RW)
 *
 * Values:
 * - 0b1 - Sampling clocks are gated in standby mode
 * - 0b0 - Sampling clocks are not gated when in standby mode
 */
/*@{*/
/*! @brief Read current value of the RTC_CTRL_TIMER_STB_MASK field. */
#define RTC_RD_CTRL_TIMER_STB_MASK(base) ((RTC_CTRL_REG(base) & RTC_CTRL_TIMER_STB_MASK_MASK) >> RTC_CTRL_TIMER_STB_MASK_SHIFT)
#define RTC_BRD_CTRL_TIMER_STB_MASK(base) (BME_UBFX16(&RTC_CTRL_REG(base), RTC_CTRL_TIMER_STB_MASK_SHIFT, RTC_CTRL_TIMER_STB_MASK_WIDTH))

/*! @brief Set the TIMER_STB_MASK field to a new value. */
#define RTC_WR_CTRL_TIMER_STB_MASK(base, value) (RTC_RMW_CTRL(base, RTC_CTRL_TIMER_STB_MASK_MASK, RTC_CTRL_TIMER_STB_MASK(value)))
#define RTC_BWR_CTRL_TIMER_STB_MASK(base, value) (BME_BFI16(&RTC_CTRL_REG(base), ((uint16_t)(value) << RTC_CTRL_TIMER_STB_MASK_SHIFT), RTC_CTRL_TIMER_STB_MASK_SHIFT, RTC_CTRL_TIMER_STB_MASK_WIDTH))
/*@}*/

/*!
 * @name Register RTC_CTRL, field DST_EN[6] (RW)
 *
 * The date and time for daylight saving changes are stored in the Daylight
 * Saving Registers. These registers can be changed when this bit is 0. Once this bit
 * is set, those registers cannot be changed and when time and date match the
 * values in those registers, daylight adjustment will happen. To disable Daylight
 * Saving function, this bit should be set to 0.
 *
 * Values:
 * - 0b0 - Disabled. Daylight saving changes are not applied. Daylight saving
 *     registers can be modified.
 * - 0b1 - Enabled. Daylight saving changes are applied.
 */
/*@{*/
/*! @brief Read current value of the RTC_CTRL_DST_EN field. */
#define RTC_RD_CTRL_DST_EN(base) ((RTC_CTRL_REG(base) & RTC_CTRL_DST_EN_MASK) >> RTC_CTRL_DST_EN_SHIFT)
#define RTC_BRD_CTRL_DST_EN(base) (BME_UBFX16(&RTC_CTRL_REG(base), RTC_CTRL_DST_EN_SHIFT, RTC_CTRL_DST_EN_WIDTH))

/*! @brief Set the DST_EN field to a new value. */
#define RTC_WR_CTRL_DST_EN(base, value) (RTC_RMW_CTRL(base, RTC_CTRL_DST_EN_MASK, RTC_CTRL_DST_EN(value)))
#define RTC_BWR_CTRL_DST_EN(base, value) (BME_BFI16(&RTC_CTRL_REG(base), ((uint16_t)(value) << RTC_CTRL_DST_EN_SHIFT), RTC_CTRL_DST_EN_SHIFT, RTC_CTRL_DST_EN_WIDTH))
/*@}*/

/*!
 * @name Register RTC_CTRL, field SWR[8] (WORZ)
 *
 * Self clearing bit. Asserting this field clears the contents of alarm,
 * interrupt (status and enable except tamper interrupt enable bit ) registers,
 * STATUS[CMP_DONE], and STATUS[BUS_ERR] and has no effect on DST, calendaring, Standby
 * time and tamper detect registers.
 *
 * Values:
 * - 0b0 - Software Reset cleared.
 * - 0b1 - Software Reset asserted.
 */
/*@{*/
/*! @brief Set the SWR field to a new value. */
#define RTC_WR_CTRL_SWR(base, value) (RTC_RMW_CTRL(base, RTC_CTRL_SWR_MASK, RTC_CTRL_SWR(value)))
#define RTC_BWR_CTRL_SWR(base, value) (BME_BFI16(&RTC_CTRL_REG(base), ((uint16_t)(value) << RTC_CTRL_SWR_SHIFT), RTC_CTRL_SWR_SHIFT, RTC_CTRL_SWR_WIDTH))
/*@}*/

/*!
 * @name Register RTC_CTRL, field CLKOUT[14:13] (RW)
 *
 * Selects which clock to output from SoC for use outside RTC.
 *
 * Values:
 * - 0b00 - No Output Clock
 * - 0b01 - Fine 1 Hz Clock
 * - 0b10 - 32.768 kHz Clock
 * - 0b11 - Coarse 1 Hz Clock
 */
/*@{*/
/*! @brief Read current value of the RTC_CTRL_CLKOUT field. */
#define RTC_RD_CTRL_CLKOUT(base) ((RTC_CTRL_REG(base) & RTC_CTRL_CLKOUT_MASK) >> RTC_CTRL_CLKOUT_SHIFT)
#define RTC_BRD_CTRL_CLKOUT(base) (BME_UBFX16(&RTC_CTRL_REG(base), RTC_CTRL_CLKOUT_SHIFT, RTC_CTRL_CLKOUT_WIDTH))

/*! @brief Set the CLKOUT field to a new value. */
#define RTC_WR_CTRL_CLKOUT(base, value) (RTC_RMW_CTRL(base, RTC_CTRL_CLKOUT_MASK, RTC_CTRL_CLKOUT(value)))
#define RTC_BWR_CTRL_CLKOUT(base, value) (BME_BFI16(&RTC_CTRL_REG(base), ((uint16_t)(value) << RTC_CTRL_CLKOUT_SHIFT), RTC_CTRL_CLKOUT_SHIFT, RTC_CTRL_CLKOUT_WIDTH))
/*@}*/

/*******************************************************************************
 * RTC_STATUS - RTC Status Register
 ******************************************************************************/

/*!
 * @brief RTC_STATUS - RTC Status Register (RW)
 *
 * Reset value: 0x0008U
 *
 * This register indicates the status of various processes going inside the RTC.
 * This register also helps the user software to read time or date register when
 * their values are stable and not changing. Bus Error bit get cleared by
 * writing '1' to them. Software Reset resets the whole register (except the RST_SRC
 * bit) to its default state. All memory mapped registers are protected against
 * spurious updates by the write protect mechanism. To unlock the registers , a
 * specific pattern (as mentioned in above table) has to be written in the write
 * enable bits (WE[1:0]) to enable or disable write protection.. The WE[1:0] bits are
 * the only bits that are freely writeable by user software. The write enable
 * bits are self clearing bits that always return zeros on read.
 */
/*!
 * @name Constants and macros for entire RTC_STATUS register
 */
/*@{*/
#define RTC_RD_STATUS(base)      (RTC_STATUS_REG(base))
#define RTC_WR_STATUS(base, value) (RTC_STATUS_REG(base) = (value))
#define RTC_RMW_STATUS(base, mask, value) (RTC_WR_STATUS(base, (RTC_RD_STATUS(base) & ~(mask)) | (value)))
#define RTC_SET_STATUS(base, value) (BME_OR16(&RTC_STATUS_REG(base), (uint16_t)(value)))
#define RTC_CLR_STATUS(base, value) (BME_AND16(&RTC_STATUS_REG(base), (uint16_t)(~(value))))
#define RTC_TOG_STATUS(base, value) (BME_XOR16(&RTC_STATUS_REG(base), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual RTC_STATUS bitfields
 */

/*!
 * @name Register RTC_STATUS, field INVAL_BIT[0] (RO)
 *
 * This read-only bit indicates the time /date counters are invalid or changing
 * and thus should not be read/written to. This bit is asserted for 1 oscillator
 * clock cycle before and after the 1 Hz (seconds clock) boundary/edge. Write
 * access to time /date registers gets nullified (terminate normally) and no
 * register value gets changed. Read during INVAL bit asserted returns 0xFFFF. No
 * Transfer Error is asserted.
 *
 * Values:
 * - 0b0 - Time /Date Counters can be read/written. Time /Date is valid.
 * - 0b1 - Time /Date Counter values are changing or Time /Date is invalid and
 *     cannot be read or written.
 */
/*@{*/
/*! @brief Read current value of the RTC_STATUS_INVAL_BIT field. */
#define RTC_RD_STATUS_INVAL_BIT(base) ((RTC_STATUS_REG(base) & RTC_STATUS_INVAL_BIT_MASK) >> RTC_STATUS_INVAL_BIT_SHIFT)
#define RTC_BRD_STATUS_INVAL_BIT(base) (BME_UBFX16(&RTC_STATUS_REG(base), RTC_STATUS_INVAL_BIT_SHIFT, RTC_STATUS_INVAL_BIT_WIDTH))
/*@}*/

/*!
 * @name Register RTC_STATUS, field WRITE_PROT_EN[1] (RO)
 *
 * This read-only bit indicates that registers are in locked mode and write to
 * them is disabled. Any write access made to the register space when write
 * protection is enabled (that is in locked mode) will cause the transfer error signal
 * to be asserted.
 *
 * Values:
 * - 0b0 - Registers are unlocked and can be accessed.
 * - 0b1 - Registers are locked and in read-only mode.
 */
/*@{*/
/*! @brief Read current value of the RTC_STATUS_WRITE_PROT_EN field. */
#define RTC_RD_STATUS_WRITE_PROT_EN(base) ((RTC_STATUS_REG(base) & RTC_STATUS_WRITE_PROT_EN_MASK) >> RTC_STATUS_WRITE_PROT_EN_SHIFT)
#define RTC_BRD_STATUS_WRITE_PROT_EN(base) (BME_UBFX16(&RTC_STATUS_REG(base), RTC_STATUS_WRITE_PROT_EN_SHIFT, RTC_STATUS_WRITE_PROT_EN_WIDTH))
/*@}*/

/*!
 * @name Register RTC_STATUS, field CPU_LOW_VOLT[2] (RO)
 *
 * This bit is asserted when the MCU/CPU power falls below the read only
 * threshold when all write cycles are terminated normally and no change is done to the
 * registers. Registers are read only. Transfer Error is not asserted on write
 * access.
 *
 * Values:
 * - 0b0 - CPU in Normal Operating Voltage.
 * - 0b1 - CPU Voltage is below Normal Operating Voltage. RTC Registers in
 *     read-only mode.
 */
/*@{*/
/*! @brief Read current value of the RTC_STATUS_CPU_LOW_VOLT field. */
#define RTC_RD_STATUS_CPU_LOW_VOLT(base) ((RTC_STATUS_REG(base) & RTC_STATUS_CPU_LOW_VOLT_MASK) >> RTC_STATUS_CPU_LOW_VOLT_SHIFT)
#define RTC_BRD_STATUS_CPU_LOW_VOLT(base) (BME_UBFX16(&RTC_STATUS_REG(base), RTC_STATUS_CPU_LOW_VOLT_SHIFT, RTC_STATUS_CPU_LOW_VOLT_WIDTH))
/*@}*/

/*!
 * @name Register RTC_STATUS, field RST_SRC[3] (RO)
 *
 * This bit indicates to the user software the cause for reset to the part and
 * subsequent boot up of CPU. This bit is asserted only on the power on reset that
 * is generated within RTC (that is Power On Reset when both VBAT and VDD are
 * powered up) and this indicates that part has been reset. On entering standby
 * mode, this bit is cleared which indicates the part is booting after Standby Mode
 * Exit, when the standby mode is actually exited.
 *
 * Values:
 * - 0b0 - Part was reset due to Standby Mode Exit (that is when VDD is powered
 *     up and VBAT was not powered down at all).
 * - 0b1 - Part was reset due to Power-On Reset (that is Power On Reset when
 *     both VBAT and VDD are powered up).
 */
/*@{*/
/*! @brief Read current value of the RTC_STATUS_RST_SRC field. */
#define RTC_RD_STATUS_RST_SRC(base) ((RTC_STATUS_REG(base) & RTC_STATUS_RST_SRC_MASK) >> RTC_STATUS_RST_SRC_SHIFT)
#define RTC_BRD_STATUS_RST_SRC(base) (BME_UBFX16(&RTC_STATUS_REG(base), RTC_STATUS_RST_SRC_SHIFT, RTC_STATUS_RST_SRC_WIDTH))
/*@}*/

/*!
 * @name Register RTC_STATUS, field CMP_INT[5] (RO)
 *
 * This read-only status bit is asserted for a time equal to compensation
 * interval seconds (as configured by user). This bit is used by MCU to calculate the
 * interrupts serviced during this interval and perform corrections in case of
 * deviations (i.e. Calibration). This bit toggles on every start of new
 * compensation interval and is either 0 or 1 during the entire duration. This bit will not
 * toggle if compensation logic has been disabled by MCU.
 */
/*@{*/
/*! @brief Read current value of the RTC_STATUS_CMP_INT field. */
#define RTC_RD_STATUS_CMP_INT(base) ((RTC_STATUS_REG(base) & RTC_STATUS_CMP_INT_MASK) >> RTC_STATUS_CMP_INT_SHIFT)
#define RTC_BRD_STATUS_CMP_INT(base) (BME_UBFX16(&RTC_STATUS_REG(base), RTC_STATUS_CMP_INT_SHIFT, RTC_STATUS_CMP_INT_WIDTH))
/*@}*/

/*!
 * @name Register RTC_STATUS, field WE[7:6] (WORZ)
 *
 * These bits control the entry and exit of the write protection mode. Both
 * registers are protected by the write protection mechanism. These are self clearing
 * bits. Reads will return zeros. When the registers are unlocked, they remain
 * in this unlocked state for a time of 2 seconds after which they get locked
 * automatically. After power-on-reset, the registers come out as unlocked but they
 * get locked automatically 15 seconds after power on.
 *
 * Values:
 * - 0b10 - Enable Write Protection - Registers are locked.
 */
/*@{*/
/*! @brief Set the WE field to a new value. */
#define RTC_WR_STATUS_WE(base, value) (RTC_RMW_STATUS(base, (RTC_STATUS_WE_MASK | RTC_STATUS_BUS_ERR_MASK | RTC_STATUS_CMP_DONE_MASK), RTC_STATUS_WE(value)))
#define RTC_BWR_STATUS_WE(base, value) (BME_BFI16(&RTC_STATUS_REG(base), ((uint16_t)(value) << RTC_STATUS_WE_SHIFT), RTC_STATUS_WE_SHIFT, RTC_STATUS_WE_WIDTH))
/*@}*/

/*!
 * @name Register RTC_STATUS, field BUS_ERR[8] (W1C)
 *
 * This bit indicates that a read or write cycle was initiated by software when
 * the INVAL_BIT was set. Write access to time /date registers gets nullified
 * (terminate normally) and no register value gets changed. Read during INVAL bit
 * asserted returns 16'hFFFF. No Transfer Error is asserted. This bit gets cleared
 * by writing 1 to it.
 *
 * Values:
 * - 0b0 - Read and Write accesses are normal.
 * - 0b1 - Read or Write accesses occurred when INVAL_BIT was asserted.
 */
/*@{*/
/*! @brief Read current value of the RTC_STATUS_BUS_ERR field. */
#define RTC_RD_STATUS_BUS_ERR(base) ((RTC_STATUS_REG(base) & RTC_STATUS_BUS_ERR_MASK) >> RTC_STATUS_BUS_ERR_SHIFT)
#define RTC_BRD_STATUS_BUS_ERR(base) (BME_UBFX16(&RTC_STATUS_REG(base), RTC_STATUS_BUS_ERR_SHIFT, RTC_STATUS_BUS_ERR_WIDTH))

/*! @brief Set the BUS_ERR field to a new value. */
#define RTC_WR_STATUS_BUS_ERR(base, value) (RTC_RMW_STATUS(base, (RTC_STATUS_BUS_ERR_MASK | RTC_STATUS_CMP_DONE_MASK), RTC_STATUS_BUS_ERR(value)))
#define RTC_BWR_STATUS_BUS_ERR(base, value) (BME_BFI16(&RTC_STATUS_REG(base), ((uint16_t)(value) << RTC_STATUS_BUS_ERR_SHIFT), RTC_STATUS_BUS_ERR_SHIFT, RTC_STATUS_BUS_ERR_WIDTH))
/*@}*/

/*!
 * @name Register RTC_STATUS, field CMP_DONE[11] (W1C)
 *
 * This bit indicates that current compensation cycle is complete. The bit gets
 * cleared by writing 1 to it. Done bit is asserted seven 32.768 kHz clock cycles
 * before actual compensation interval completes so that back to back
 * compensation can be enabled.
 *
 * Values:
 * - 0b0 - Compensation busy or not enabled.
 * - 0b1 - Compensation completed.
 */
/*@{*/
/*! @brief Read current value of the RTC_STATUS_CMP_DONE field. */
#define RTC_RD_STATUS_CMP_DONE(base) ((RTC_STATUS_REG(base) & RTC_STATUS_CMP_DONE_MASK) >> RTC_STATUS_CMP_DONE_SHIFT)
#define RTC_BRD_STATUS_CMP_DONE(base) (BME_UBFX16(&RTC_STATUS_REG(base), RTC_STATUS_CMP_DONE_SHIFT, RTC_STATUS_CMP_DONE_WIDTH))

/*! @brief Set the CMP_DONE field to a new value. */
#define RTC_WR_STATUS_CMP_DONE(base, value) (RTC_RMW_STATUS(base, (RTC_STATUS_CMP_DONE_MASK | RTC_STATUS_BUS_ERR_MASK), RTC_STATUS_CMP_DONE(value)))
#define RTC_BWR_STATUS_CMP_DONE(base, value) (BME_BFI16(&RTC_STATUS_REG(base), ((uint16_t)(value) << RTC_STATUS_CMP_DONE_SHIFT), RTC_STATUS_CMP_DONE_SHIFT, RTC_STATUS_CMP_DONE_WIDTH))
/*@}*/

/*******************************************************************************
 * RTC_ISR - RTC Interrupt Status Register
 ******************************************************************************/

/*!
 * @brief RTC_ISR - RTC Interrupt Status Register (RW)
 *
 * Reset value: 0x0001U
 *
 * For the sampling timer interrupt status bits [14:6], refer to chip
 * configuration chapter for the applicable sampling timer frequencies. This register
 * indicates the status of the various real-time clock interrupts. When an event of
 * the types included in this register occurs then the bit will be set in this
 * register regardless of its corresponding interrupt enable bit being set. The
 * status bits are cleared by writing a value of 1, which also clears the interrupt.
 * Interrupts may occur while the system clock is idle or in standby mode. When
 * the system enters the active power mode, interrupt will be indicated to the CPU.
 * The first event of the Sampling Timer interrupts after Power-on-Reset should
 * not used to qualify any periodic interval. However, the correct periodic
 * interval (that is 512 Hz or 256 Hz, and so on) should be determined using two
 * sampling timer interrupts. The time between two interrupt would always be the
 * correct time period. Tamper Interrupt Status is set on reset as POR is generated
 * when battery and CPU power are unavailable and either is powered up. Removal of
 * battery is considered as a tamper and hence this bit is set on reset. The
 * status register is also cleared on software reset except for the tamper status
 * which remains unaffected . Sampling interrupts from 512 Hz to 2 Hz are generated
 * using uncompensated clock. Only 1 Hz is compensated.
 */
/*!
 * @name Constants and macros for entire RTC_ISR register
 */
/*@{*/
#define RTC_RD_ISR(base)         (RTC_ISR_REG(base))
#define RTC_WR_ISR(base, value)  (RTC_ISR_REG(base) = (value))
#define RTC_RMW_ISR(base, mask, value) (RTC_WR_ISR(base, (RTC_RD_ISR(base) & ~(mask)) | (value)))
#define RTC_SET_ISR(base, value) (BME_OR16(&RTC_ISR_REG(base), (uint16_t)(value)))
#define RTC_CLR_ISR(base, value) (BME_AND16(&RTC_ISR_REG(base), (uint16_t)(~(value))))
#define RTC_TOG_ISR(base, value) (BME_XOR16(&RTC_ISR_REG(base), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual RTC_ISR bitfields
 */

/*!
 * @name Register RTC_ISR, field TAMPER_IS[0] (RO)
 *
 * This field is cleared when TAMPER_SCR[TMPR_STS] is cleared.
 *
 * Values:
 * - 0b0 - Interrupt is de-asserted.
 * - 0b1 - Interrupt is asserted (Default on reset) .
 */
/*@{*/
/*! @brief Read current value of the RTC_ISR_TAMPER_IS field. */
#define RTC_RD_ISR_TAMPER_IS(base) ((RTC_ISR_REG(base) & RTC_ISR_TAMPER_IS_MASK) >> RTC_ISR_TAMPER_IS_SHIFT)
#define RTC_BRD_ISR_TAMPER_IS(base) (BME_UBFX16(&RTC_ISR_REG(base), RTC_ISR_TAMPER_IS_SHIFT, RTC_ISR_TAMPER_IS_WIDTH))
/*@}*/

/*!
 * @name Register RTC_ISR, field ALM_IS[2] (W1C)
 *
 * This bit indicates that the alarm value programmed matches the counter values.
 *
 * Values:
 * - 0b0 - Interrupt is de-asserted.
 * - 0b1 - Interrupt is asserted.
 */
/*@{*/
/*! @brief Read current value of the RTC_ISR_ALM_IS field. */
#define RTC_RD_ISR_ALM_IS(base) ((RTC_ISR_REG(base) & RTC_ISR_ALM_IS_MASK) >> RTC_ISR_ALM_IS_SHIFT)
#define RTC_BRD_ISR_ALM_IS(base) (BME_UBFX16(&RTC_ISR_REG(base), RTC_ISR_ALM_IS_SHIFT, RTC_ISR_ALM_IS_WIDTH))

/*! @brief Set the ALM_IS field to a new value. */
#define RTC_WR_ISR_ALM_IS(base, value) (RTC_RMW_ISR(base, (RTC_ISR_ALM_IS_MASK | RTC_ISR_DAY_IS_MASK | RTC_ISR_HOUR_IS_MASK | RTC_ISR_MIN_IS_MASK | RTC_ISR_IS_1HZ_MASK | RTC_ISR_IS_2HZ_MASK | RTC_ISR_IS_4HZ_MASK | RTC_ISR_IS_8HZ_MASK | RTC_ISR_IS_16HZ_MASK | RTC_ISR_IS_32HZ_MASK | RTC_ISR_IS_64HZ_MASK | RTC_ISR_IS_128HZ_MASK | RTC_ISR_IS_256HZ_MASK | RTC_ISR_IS_512HZ_MASK), RTC_ISR_ALM_IS(value)))
#define RTC_BWR_ISR_ALM_IS(base, value) (BME_BFI16(&RTC_ISR_REG(base), ((uint16_t)(value) << RTC_ISR_ALM_IS_SHIFT), RTC_ISR_ALM_IS_SHIFT, RTC_ISR_ALM_IS_WIDTH))
/*@}*/

/*!
 * @name Register RTC_ISR, field DAY_IS[3] (W1C)
 *
 * Values:
 * - 0b0 - Interrupt is de-asserted.
 * - 0b1 - Interrupt is asserted.
 */
/*@{*/
/*! @brief Read current value of the RTC_ISR_DAY_IS field. */
#define RTC_RD_ISR_DAY_IS(base) ((RTC_ISR_REG(base) & RTC_ISR_DAY_IS_MASK) >> RTC_ISR_DAY_IS_SHIFT)
#define RTC_BRD_ISR_DAY_IS(base) (BME_UBFX16(&RTC_ISR_REG(base), RTC_ISR_DAY_IS_SHIFT, RTC_ISR_DAY_IS_WIDTH))

/*! @brief Set the DAY_IS field to a new value. */
#define RTC_WR_ISR_DAY_IS(base, value) (RTC_RMW_ISR(base, (RTC_ISR_DAY_IS_MASK | RTC_ISR_ALM_IS_MASK | RTC_ISR_HOUR_IS_MASK | RTC_ISR_MIN_IS_MASK | RTC_ISR_IS_1HZ_MASK | RTC_ISR_IS_2HZ_MASK | RTC_ISR_IS_4HZ_MASK | RTC_ISR_IS_8HZ_MASK | RTC_ISR_IS_16HZ_MASK | RTC_ISR_IS_32HZ_MASK | RTC_ISR_IS_64HZ_MASK | RTC_ISR_IS_128HZ_MASK | RTC_ISR_IS_256HZ_MASK | RTC_ISR_IS_512HZ_MASK), RTC_ISR_DAY_IS(value)))
#define RTC_BWR_ISR_DAY_IS(base, value) (BME_BFI16(&RTC_ISR_REG(base), ((uint16_t)(value) << RTC_ISR_DAY_IS_SHIFT), RTC_ISR_DAY_IS_SHIFT, RTC_ISR_DAY_IS_WIDTH))
/*@}*/

/*!
 * @name Register RTC_ISR, field HOUR_IS[4] (W1C)
 *
 * Values:
 * - 0b0 - Interrupt is de-asserted.
 * - 0b1 - Interrupt is asserted.
 */
/*@{*/
/*! @brief Read current value of the RTC_ISR_HOUR_IS field. */
#define RTC_RD_ISR_HOUR_IS(base) ((RTC_ISR_REG(base) & RTC_ISR_HOUR_IS_MASK) >> RTC_ISR_HOUR_IS_SHIFT)
#define RTC_BRD_ISR_HOUR_IS(base) (BME_UBFX16(&RTC_ISR_REG(base), RTC_ISR_HOUR_IS_SHIFT, RTC_ISR_HOUR_IS_WIDTH))

/*! @brief Set the HOUR_IS field to a new value. */
#define RTC_WR_ISR_HOUR_IS(base, value) (RTC_RMW_ISR(base, (RTC_ISR_HOUR_IS_MASK | RTC_ISR_ALM_IS_MASK | RTC_ISR_DAY_IS_MASK | RTC_ISR_MIN_IS_MASK | RTC_ISR_IS_1HZ_MASK | RTC_ISR_IS_2HZ_MASK | RTC_ISR_IS_4HZ_MASK | RTC_ISR_IS_8HZ_MASK | RTC_ISR_IS_16HZ_MASK | RTC_ISR_IS_32HZ_MASK | RTC_ISR_IS_64HZ_MASK | RTC_ISR_IS_128HZ_MASK | RTC_ISR_IS_256HZ_MASK | RTC_ISR_IS_512HZ_MASK), RTC_ISR_HOUR_IS(value)))
#define RTC_BWR_ISR_HOUR_IS(base, value) (BME_BFI16(&RTC_ISR_REG(base), ((uint16_t)(value) << RTC_ISR_HOUR_IS_SHIFT), RTC_ISR_HOUR_IS_SHIFT, RTC_ISR_HOUR_IS_WIDTH))
/*@}*/

/*!
 * @name Register RTC_ISR, field MIN_IS[5] (W1C)
 *
 * Values:
 * - 0b0 - Interrupt is de-asserted.
 * - 0b1 - Interrupt is asserted.
 */
/*@{*/
/*! @brief Read current value of the RTC_ISR_MIN_IS field. */
#define RTC_RD_ISR_MIN_IS(base) ((RTC_ISR_REG(base) & RTC_ISR_MIN_IS_MASK) >> RTC_ISR_MIN_IS_SHIFT)
#define RTC_BRD_ISR_MIN_IS(base) (BME_UBFX16(&RTC_ISR_REG(base), RTC_ISR_MIN_IS_SHIFT, RTC_ISR_MIN_IS_WIDTH))

/*! @brief Set the MIN_IS field to a new value. */
#define RTC_WR_ISR_MIN_IS(base, value) (RTC_RMW_ISR(base, (RTC_ISR_MIN_IS_MASK | RTC_ISR_ALM_IS_MASK | RTC_ISR_DAY_IS_MASK | RTC_ISR_HOUR_IS_MASK | RTC_ISR_IS_1HZ_MASK | RTC_ISR_IS_2HZ_MASK | RTC_ISR_IS_4HZ_MASK | RTC_ISR_IS_8HZ_MASK | RTC_ISR_IS_16HZ_MASK | RTC_ISR_IS_32HZ_MASK | RTC_ISR_IS_64HZ_MASK | RTC_ISR_IS_128HZ_MASK | RTC_ISR_IS_256HZ_MASK | RTC_ISR_IS_512HZ_MASK), RTC_ISR_MIN_IS(value)))
#define RTC_BWR_ISR_MIN_IS(base, value) (BME_BFI16(&RTC_ISR_REG(base), ((uint16_t)(value) << RTC_ISR_MIN_IS_SHIFT), RTC_ISR_MIN_IS_SHIFT, RTC_ISR_MIN_IS_WIDTH))
/*@}*/

/*!
 * @name Register RTC_ISR, field IS_1HZ[6] (W1C)
 *
 * Values:
 * - 0b0 - Interrupt is de-asserted.
 * - 0b1 - Interrupt is asserted.
 */
/*@{*/
/*! @brief Read current value of the RTC_ISR_IS_1HZ field. */
#define RTC_RD_ISR_IS_1HZ(base) ((RTC_ISR_REG(base) & RTC_ISR_IS_1HZ_MASK) >> RTC_ISR_IS_1HZ_SHIFT)
#define RTC_BRD_ISR_IS_1HZ(base) (BME_UBFX16(&RTC_ISR_REG(base), RTC_ISR_IS_1HZ_SHIFT, RTC_ISR_IS_1HZ_WIDTH))

/*! @brief Set the IS_1HZ field to a new value. */
#define RTC_WR_ISR_IS_1HZ(base, value) (RTC_RMW_ISR(base, (RTC_ISR_IS_1HZ_MASK | RTC_ISR_ALM_IS_MASK | RTC_ISR_DAY_IS_MASK | RTC_ISR_HOUR_IS_MASK | RTC_ISR_MIN_IS_MASK | RTC_ISR_IS_2HZ_MASK | RTC_ISR_IS_4HZ_MASK | RTC_ISR_IS_8HZ_MASK | RTC_ISR_IS_16HZ_MASK | RTC_ISR_IS_32HZ_MASK | RTC_ISR_IS_64HZ_MASK | RTC_ISR_IS_128HZ_MASK | RTC_ISR_IS_256HZ_MASK | RTC_ISR_IS_512HZ_MASK), RTC_ISR_IS_1HZ(value)))
#define RTC_BWR_ISR_IS_1HZ(base, value) (BME_BFI16(&RTC_ISR_REG(base), ((uint16_t)(value) << RTC_ISR_IS_1HZ_SHIFT), RTC_ISR_IS_1HZ_SHIFT, RTC_ISR_IS_1HZ_WIDTH))
/*@}*/

/*!
 * @name Register RTC_ISR, field IS_2HZ[7] (W1C)
 *
 * Values:
 * - 0b0 - Interrupt is de-asserted.
 * - 0b1 - Interrupt is asserted.
 */
/*@{*/
/*! @brief Read current value of the RTC_ISR_IS_2HZ field. */
#define RTC_RD_ISR_IS_2HZ(base) ((RTC_ISR_REG(base) & RTC_ISR_IS_2HZ_MASK) >> RTC_ISR_IS_2HZ_SHIFT)
#define RTC_BRD_ISR_IS_2HZ(base) (BME_UBFX16(&RTC_ISR_REG(base), RTC_ISR_IS_2HZ_SHIFT, RTC_ISR_IS_2HZ_WIDTH))

/*! @brief Set the IS_2HZ field to a new value. */
#define RTC_WR_ISR_IS_2HZ(base, value) (RTC_RMW_ISR(base, (RTC_ISR_IS_2HZ_MASK | RTC_ISR_ALM_IS_MASK | RTC_ISR_DAY_IS_MASK | RTC_ISR_HOUR_IS_MASK | RTC_ISR_MIN_IS_MASK | RTC_ISR_IS_1HZ_MASK | RTC_ISR_IS_4HZ_MASK | RTC_ISR_IS_8HZ_MASK | RTC_ISR_IS_16HZ_MASK | RTC_ISR_IS_32HZ_MASK | RTC_ISR_IS_64HZ_MASK | RTC_ISR_IS_128HZ_MASK | RTC_ISR_IS_256HZ_MASK | RTC_ISR_IS_512HZ_MASK), RTC_ISR_IS_2HZ(value)))
#define RTC_BWR_ISR_IS_2HZ(base, value) (BME_BFI16(&RTC_ISR_REG(base), ((uint16_t)(value) << RTC_ISR_IS_2HZ_SHIFT), RTC_ISR_IS_2HZ_SHIFT, RTC_ISR_IS_2HZ_WIDTH))
/*@}*/

/*!
 * @name Register RTC_ISR, field IS_4HZ[8] (W1C)
 *
 * Values:
 * - 0b0 - Interrupt is de-asserted.
 * - 0b1 - Interrupt is asserted.
 */
/*@{*/
/*! @brief Read current value of the RTC_ISR_IS_4HZ field. */
#define RTC_RD_ISR_IS_4HZ(base) ((RTC_ISR_REG(base) & RTC_ISR_IS_4HZ_MASK) >> RTC_ISR_IS_4HZ_SHIFT)
#define RTC_BRD_ISR_IS_4HZ(base) (BME_UBFX16(&RTC_ISR_REG(base), RTC_ISR_IS_4HZ_SHIFT, RTC_ISR_IS_4HZ_WIDTH))

/*! @brief Set the IS_4HZ field to a new value. */
#define RTC_WR_ISR_IS_4HZ(base, value) (RTC_RMW_ISR(base, (RTC_ISR_IS_4HZ_MASK | RTC_ISR_ALM_IS_MASK | RTC_ISR_DAY_IS_MASK | RTC_ISR_HOUR_IS_MASK | RTC_ISR_MIN_IS_MASK | RTC_ISR_IS_1HZ_MASK | RTC_ISR_IS_2HZ_MASK | RTC_ISR_IS_8HZ_MASK | RTC_ISR_IS_16HZ_MASK | RTC_ISR_IS_32HZ_MASK | RTC_ISR_IS_64HZ_MASK | RTC_ISR_IS_128HZ_MASK | RTC_ISR_IS_256HZ_MASK | RTC_ISR_IS_512HZ_MASK), RTC_ISR_IS_4HZ(value)))
#define RTC_BWR_ISR_IS_4HZ(base, value) (BME_BFI16(&RTC_ISR_REG(base), ((uint16_t)(value) << RTC_ISR_IS_4HZ_SHIFT), RTC_ISR_IS_4HZ_SHIFT, RTC_ISR_IS_4HZ_WIDTH))
/*@}*/

/*!
 * @name Register RTC_ISR, field IS_8HZ[9] (W1C)
 *
 * Values:
 * - 0b0 - Interrupt is de-asserted.
 * - 0b1 - Interrupt is asserted.
 */
/*@{*/
/*! @brief Read current value of the RTC_ISR_IS_8HZ field. */
#define RTC_RD_ISR_IS_8HZ(base) ((RTC_ISR_REG(base) & RTC_ISR_IS_8HZ_MASK) >> RTC_ISR_IS_8HZ_SHIFT)
#define RTC_BRD_ISR_IS_8HZ(base) (BME_UBFX16(&RTC_ISR_REG(base), RTC_ISR_IS_8HZ_SHIFT, RTC_ISR_IS_8HZ_WIDTH))

/*! @brief Set the IS_8HZ field to a new value. */
#define RTC_WR_ISR_IS_8HZ(base, value) (RTC_RMW_ISR(base, (RTC_ISR_IS_8HZ_MASK | RTC_ISR_ALM_IS_MASK | RTC_ISR_DAY_IS_MASK | RTC_ISR_HOUR_IS_MASK | RTC_ISR_MIN_IS_MASK | RTC_ISR_IS_1HZ_MASK | RTC_ISR_IS_2HZ_MASK | RTC_ISR_IS_4HZ_MASK | RTC_ISR_IS_16HZ_MASK | RTC_ISR_IS_32HZ_MASK | RTC_ISR_IS_64HZ_MASK | RTC_ISR_IS_128HZ_MASK | RTC_ISR_IS_256HZ_MASK | RTC_ISR_IS_512HZ_MASK), RTC_ISR_IS_8HZ(value)))
#define RTC_BWR_ISR_IS_8HZ(base, value) (BME_BFI16(&RTC_ISR_REG(base), ((uint16_t)(value) << RTC_ISR_IS_8HZ_SHIFT), RTC_ISR_IS_8HZ_SHIFT, RTC_ISR_IS_8HZ_WIDTH))
/*@}*/

/*!
 * @name Register RTC_ISR, field IS_16HZ[10] (W1C)
 *
 * Values:
 * - 0b0 - Interrupt is de-asserted.
 * - 0b1 - Interrupt is asserted.
 */
/*@{*/
/*! @brief Read current value of the RTC_ISR_IS_16HZ field. */
#define RTC_RD_ISR_IS_16HZ(base) ((RTC_ISR_REG(base) & RTC_ISR_IS_16HZ_MASK) >> RTC_ISR_IS_16HZ_SHIFT)
#define RTC_BRD_ISR_IS_16HZ(base) (BME_UBFX16(&RTC_ISR_REG(base), RTC_ISR_IS_16HZ_SHIFT, RTC_ISR_IS_16HZ_WIDTH))

/*! @brief Set the IS_16HZ field to a new value. */
#define RTC_WR_ISR_IS_16HZ(base, value) (RTC_RMW_ISR(base, (RTC_ISR_IS_16HZ_MASK | RTC_ISR_ALM_IS_MASK | RTC_ISR_DAY_IS_MASK | RTC_ISR_HOUR_IS_MASK | RTC_ISR_MIN_IS_MASK | RTC_ISR_IS_1HZ_MASK | RTC_ISR_IS_2HZ_MASK | RTC_ISR_IS_4HZ_MASK | RTC_ISR_IS_8HZ_MASK | RTC_ISR_IS_32HZ_MASK | RTC_ISR_IS_64HZ_MASK | RTC_ISR_IS_128HZ_MASK | RTC_ISR_IS_256HZ_MASK | RTC_ISR_IS_512HZ_MASK), RTC_ISR_IS_16HZ(value)))
#define RTC_BWR_ISR_IS_16HZ(base, value) (BME_BFI16(&RTC_ISR_REG(base), ((uint16_t)(value) << RTC_ISR_IS_16HZ_SHIFT), RTC_ISR_IS_16HZ_SHIFT, RTC_ISR_IS_16HZ_WIDTH))
/*@}*/

/*!
 * @name Register RTC_ISR, field IS_32HZ[11] (W1C)
 *
 * Values:
 * - 0b0 - Interrupt is de-asserted.
 * - 0b1 - Interrupt is asserted.
 */
/*@{*/
/*! @brief Read current value of the RTC_ISR_IS_32HZ field. */
#define RTC_RD_ISR_IS_32HZ(base) ((RTC_ISR_REG(base) & RTC_ISR_IS_32HZ_MASK) >> RTC_ISR_IS_32HZ_SHIFT)
#define RTC_BRD_ISR_IS_32HZ(base) (BME_UBFX16(&RTC_ISR_REG(base), RTC_ISR_IS_32HZ_SHIFT, RTC_ISR_IS_32HZ_WIDTH))

/*! @brief Set the IS_32HZ field to a new value. */
#define RTC_WR_ISR_IS_32HZ(base, value) (RTC_RMW_ISR(base, (RTC_ISR_IS_32HZ_MASK | RTC_ISR_ALM_IS_MASK | RTC_ISR_DAY_IS_MASK | RTC_ISR_HOUR_IS_MASK | RTC_ISR_MIN_IS_MASK | RTC_ISR_IS_1HZ_MASK | RTC_ISR_IS_2HZ_MASK | RTC_ISR_IS_4HZ_MASK | RTC_ISR_IS_8HZ_MASK | RTC_ISR_IS_16HZ_MASK | RTC_ISR_IS_64HZ_MASK | RTC_ISR_IS_128HZ_MASK | RTC_ISR_IS_256HZ_MASK | RTC_ISR_IS_512HZ_MASK), RTC_ISR_IS_32HZ(value)))
#define RTC_BWR_ISR_IS_32HZ(base, value) (BME_BFI16(&RTC_ISR_REG(base), ((uint16_t)(value) << RTC_ISR_IS_32HZ_SHIFT), RTC_ISR_IS_32HZ_SHIFT, RTC_ISR_IS_32HZ_WIDTH))
/*@}*/

/*!
 * @name Register RTC_ISR, field IS_64HZ[12] (W1C)
 *
 * Values:
 * - 0b0 - Interrupt is de-asserted.
 * - 0b1 - Interrupt is asserted.
 */
/*@{*/
/*! @brief Read current value of the RTC_ISR_IS_64HZ field. */
#define RTC_RD_ISR_IS_64HZ(base) ((RTC_ISR_REG(base) & RTC_ISR_IS_64HZ_MASK) >> RTC_ISR_IS_64HZ_SHIFT)
#define RTC_BRD_ISR_IS_64HZ(base) (BME_UBFX16(&RTC_ISR_REG(base), RTC_ISR_IS_64HZ_SHIFT, RTC_ISR_IS_64HZ_WIDTH))

/*! @brief Set the IS_64HZ field to a new value. */
#define RTC_WR_ISR_IS_64HZ(base, value) (RTC_RMW_ISR(base, (RTC_ISR_IS_64HZ_MASK | RTC_ISR_ALM_IS_MASK | RTC_ISR_DAY_IS_MASK | RTC_ISR_HOUR_IS_MASK | RTC_ISR_MIN_IS_MASK | RTC_ISR_IS_1HZ_MASK | RTC_ISR_IS_2HZ_MASK | RTC_ISR_IS_4HZ_MASK | RTC_ISR_IS_8HZ_MASK | RTC_ISR_IS_16HZ_MASK | RTC_ISR_IS_32HZ_MASK | RTC_ISR_IS_128HZ_MASK | RTC_ISR_IS_256HZ_MASK | RTC_ISR_IS_512HZ_MASK), RTC_ISR_IS_64HZ(value)))
#define RTC_BWR_ISR_IS_64HZ(base, value) (BME_BFI16(&RTC_ISR_REG(base), ((uint16_t)(value) << RTC_ISR_IS_64HZ_SHIFT), RTC_ISR_IS_64HZ_SHIFT, RTC_ISR_IS_64HZ_WIDTH))
/*@}*/

/*!
 * @name Register RTC_ISR, field IS_128HZ[13] (W1C)
 *
 * Values:
 * - 0b0 - Interrupt is de-asserted.
 * - 0b1 - Interrupt is asserted.
 */
/*@{*/
/*! @brief Read current value of the RTC_ISR_IS_128HZ field. */
#define RTC_RD_ISR_IS_128HZ(base) ((RTC_ISR_REG(base) & RTC_ISR_IS_128HZ_MASK) >> RTC_ISR_IS_128HZ_SHIFT)
#define RTC_BRD_ISR_IS_128HZ(base) (BME_UBFX16(&RTC_ISR_REG(base), RTC_ISR_IS_128HZ_SHIFT, RTC_ISR_IS_128HZ_WIDTH))

/*! @brief Set the IS_128HZ field to a new value. */
#define RTC_WR_ISR_IS_128HZ(base, value) (RTC_RMW_ISR(base, (RTC_ISR_IS_128HZ_MASK | RTC_ISR_ALM_IS_MASK | RTC_ISR_DAY_IS_MASK | RTC_ISR_HOUR_IS_MASK | RTC_ISR_MIN_IS_MASK | RTC_ISR_IS_1HZ_MASK | RTC_ISR_IS_2HZ_MASK | RTC_ISR_IS_4HZ_MASK | RTC_ISR_IS_8HZ_MASK | RTC_ISR_IS_16HZ_MASK | RTC_ISR_IS_32HZ_MASK | RTC_ISR_IS_64HZ_MASK | RTC_ISR_IS_256HZ_MASK | RTC_ISR_IS_512HZ_MASK), RTC_ISR_IS_128HZ(value)))
#define RTC_BWR_ISR_IS_128HZ(base, value) (BME_BFI16(&RTC_ISR_REG(base), ((uint16_t)(value) << RTC_ISR_IS_128HZ_SHIFT), RTC_ISR_IS_128HZ_SHIFT, RTC_ISR_IS_128HZ_WIDTH))
/*@}*/

/*!
 * @name Register RTC_ISR, field IS_256HZ[14] (W1C)
 *
 * Values:
 * - 0b0 - Interrupt is de-asserted.
 * - 0b1 - Interrupt is asserted.
 */
/*@{*/
/*! @brief Read current value of the RTC_ISR_IS_256HZ field. */
#define RTC_RD_ISR_IS_256HZ(base) ((RTC_ISR_REG(base) & RTC_ISR_IS_256HZ_MASK) >> RTC_ISR_IS_256HZ_SHIFT)
#define RTC_BRD_ISR_IS_256HZ(base) (BME_UBFX16(&RTC_ISR_REG(base), RTC_ISR_IS_256HZ_SHIFT, RTC_ISR_IS_256HZ_WIDTH))

/*! @brief Set the IS_256HZ field to a new value. */
#define RTC_WR_ISR_IS_256HZ(base, value) (RTC_RMW_ISR(base, (RTC_ISR_IS_256HZ_MASK | RTC_ISR_ALM_IS_MASK | RTC_ISR_DAY_IS_MASK | RTC_ISR_HOUR_IS_MASK | RTC_ISR_MIN_IS_MASK | RTC_ISR_IS_1HZ_MASK | RTC_ISR_IS_2HZ_MASK | RTC_ISR_IS_4HZ_MASK | RTC_ISR_IS_8HZ_MASK | RTC_ISR_IS_16HZ_MASK | RTC_ISR_IS_32HZ_MASK | RTC_ISR_IS_64HZ_MASK | RTC_ISR_IS_128HZ_MASK | RTC_ISR_IS_512HZ_MASK), RTC_ISR_IS_256HZ(value)))
#define RTC_BWR_ISR_IS_256HZ(base, value) (BME_BFI16(&RTC_ISR_REG(base), ((uint16_t)(value) << RTC_ISR_IS_256HZ_SHIFT), RTC_ISR_IS_256HZ_SHIFT, RTC_ISR_IS_256HZ_WIDTH))
/*@}*/

/*!
 * @name Register RTC_ISR, field IS_512HZ[15] (W1C)
 *
 * Values:
 * - 0b0 - Interrupt is de-asserted.
 * - 0b1 - Interrupt is asserted.
 */
/*@{*/
/*! @brief Read current value of the RTC_ISR_IS_512HZ field. */
#define RTC_RD_ISR_IS_512HZ(base) ((RTC_ISR_REG(base) & RTC_ISR_IS_512HZ_MASK) >> RTC_ISR_IS_512HZ_SHIFT)
#define RTC_BRD_ISR_IS_512HZ(base) (BME_UBFX16(&RTC_ISR_REG(base), RTC_ISR_IS_512HZ_SHIFT, RTC_ISR_IS_512HZ_WIDTH))

/*! @brief Set the IS_512HZ field to a new value. */
#define RTC_WR_ISR_IS_512HZ(base, value) (RTC_RMW_ISR(base, (RTC_ISR_IS_512HZ_MASK | RTC_ISR_ALM_IS_MASK | RTC_ISR_DAY_IS_MASK | RTC_ISR_HOUR_IS_MASK | RTC_ISR_MIN_IS_MASK | RTC_ISR_IS_1HZ_MASK | RTC_ISR_IS_2HZ_MASK | RTC_ISR_IS_4HZ_MASK | RTC_ISR_IS_8HZ_MASK | RTC_ISR_IS_16HZ_MASK | RTC_ISR_IS_32HZ_MASK | RTC_ISR_IS_64HZ_MASK | RTC_ISR_IS_128HZ_MASK | RTC_ISR_IS_256HZ_MASK), RTC_ISR_IS_512HZ(value)))
#define RTC_BWR_ISR_IS_512HZ(base, value) (BME_BFI16(&RTC_ISR_REG(base), ((uint16_t)(value) << RTC_ISR_IS_512HZ_SHIFT), RTC_ISR_IS_512HZ_SHIFT, RTC_ISR_IS_512HZ_WIDTH))
/*@}*/

/*******************************************************************************
 * RTC_IER - RTC Interrupt Enable Register
 ******************************************************************************/

/*!
 * @brief RTC_IER - RTC Interrupt Enable Register (RW)
 *
 * Reset value: 0x0001U
 *
 * For the sampling timer interrupt enable bits [14:6], refer to chip
 * configuration chapter for the applicable sampling timer frequencies. The real-time clock
 * interrupt enable register (IER) is used to enable/disable the various
 * real-time clock interrupts. De-asserting an interrupt enable bit has no effect on the
 * assertion of its corresponding status bit. Alarm interrupt is asserted on
 * counters matching the alarm setting done in the memory map. The counters matched
 * for the alarm interrupt are selected based on the Alarm Type set in CTRL[3:2]
 * bits. The various types of alarm available are as per the following table.
 * Only one alarm type can be used at a time. Alarm Match Table ALM_MATCH[1:0]
 * (CTRL[3:2]) Counters Matched Alarm Type 00 Seconds, Minutes, and Hours Daily 01
 * Seconds, Minutes, Hours, and Days Monthly 10 Seconds, Minutes, Hours, Days, and
 * Months Yearly 11 Seconds, Minutes, Hours, Days, Months, and Year One Time A
 * common interrupt is generated by the block. The user software should read the
 * status register in the interrupt service routine to determine which interrupt has
 * occurred. The tamper detect interrupt enable is an exception as it is enabled
 * after power on reset. All interrupts enables except tamper interrupt enable
 * are reset to default state on software reset.
 */
/*!
 * @name Constants and macros for entire RTC_IER register
 */
/*@{*/
#define RTC_RD_IER(base)         (RTC_IER_REG(base))
#define RTC_WR_IER(base, value)  (RTC_IER_REG(base) = (value))
#define RTC_RMW_IER(base, mask, value) (RTC_WR_IER(base, (RTC_RD_IER(base) & ~(mask)) | (value)))
#define RTC_SET_IER(base, value) (BME_OR16(&RTC_IER_REG(base), (uint16_t)(value)))
#define RTC_CLR_IER(base, value) (BME_AND16(&RTC_IER_REG(base), (uint16_t)(~(value))))
#define RTC_TOG_IER(base, value) (BME_XOR16(&RTC_IER_REG(base), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual RTC_IER bitfields
 */

/*!
 * @name Register RTC_IER, field TAMPER_IE[0] (RW)
 *
 * Values:
 * - 0b0 - Interrupt is disabled.
 * - 0b1 - Interrupt is enabled (Default on reset).
 */
/*@{*/
/*! @brief Read current value of the RTC_IER_TAMPER_IE field. */
#define RTC_RD_IER_TAMPER_IE(base) ((RTC_IER_REG(base) & RTC_IER_TAMPER_IE_MASK) >> RTC_IER_TAMPER_IE_SHIFT)
#define RTC_BRD_IER_TAMPER_IE(base) (BME_UBFX16(&RTC_IER_REG(base), RTC_IER_TAMPER_IE_SHIFT, RTC_IER_TAMPER_IE_WIDTH))

/*! @brief Set the TAMPER_IE field to a new value. */
#define RTC_WR_IER_TAMPER_IE(base, value) (RTC_RMW_IER(base, RTC_IER_TAMPER_IE_MASK, RTC_IER_TAMPER_IE(value)))
#define RTC_BWR_IER_TAMPER_IE(base, value) (BME_BFI16(&RTC_IER_REG(base), ((uint16_t)(value) << RTC_IER_TAMPER_IE_SHIFT), RTC_IER_TAMPER_IE_SHIFT, RTC_IER_TAMPER_IE_WIDTH))
/*@}*/

/*!
 * @name Register RTC_IER, field ALM_IE[2] (RW)
 *
 * This bit indicates that the alarm value programmed matches the counter values.
 *
 * Values:
 * - 0b0 - Interrupt is disabled.
 * - 0b1 - Interrupt is enabled.
 */
/*@{*/
/*! @brief Read current value of the RTC_IER_ALM_IE field. */
#define RTC_RD_IER_ALM_IE(base) ((RTC_IER_REG(base) & RTC_IER_ALM_IE_MASK) >> RTC_IER_ALM_IE_SHIFT)
#define RTC_BRD_IER_ALM_IE(base) (BME_UBFX16(&RTC_IER_REG(base), RTC_IER_ALM_IE_SHIFT, RTC_IER_ALM_IE_WIDTH))

/*! @brief Set the ALM_IE field to a new value. */
#define RTC_WR_IER_ALM_IE(base, value) (RTC_RMW_IER(base, RTC_IER_ALM_IE_MASK, RTC_IER_ALM_IE(value)))
#define RTC_BWR_IER_ALM_IE(base, value) (BME_BFI16(&RTC_IER_REG(base), ((uint16_t)(value) << RTC_IER_ALM_IE_SHIFT), RTC_IER_ALM_IE_SHIFT, RTC_IER_ALM_IE_WIDTH))
/*@}*/

/*!
 * @name Register RTC_IER, field DAY_IE[3] (RW)
 *
 * Values:
 * - 0b0 - Interrupt is disabled.
 * - 0b1 - Interrupt is enabled.
 */
/*@{*/
/*! @brief Read current value of the RTC_IER_DAY_IE field. */
#define RTC_RD_IER_DAY_IE(base) ((RTC_IER_REG(base) & RTC_IER_DAY_IE_MASK) >> RTC_IER_DAY_IE_SHIFT)
#define RTC_BRD_IER_DAY_IE(base) (BME_UBFX16(&RTC_IER_REG(base), RTC_IER_DAY_IE_SHIFT, RTC_IER_DAY_IE_WIDTH))

/*! @brief Set the DAY_IE field to a new value. */
#define RTC_WR_IER_DAY_IE(base, value) (RTC_RMW_IER(base, RTC_IER_DAY_IE_MASK, RTC_IER_DAY_IE(value)))
#define RTC_BWR_IER_DAY_IE(base, value) (BME_BFI16(&RTC_IER_REG(base), ((uint16_t)(value) << RTC_IER_DAY_IE_SHIFT), RTC_IER_DAY_IE_SHIFT, RTC_IER_DAY_IE_WIDTH))
/*@}*/

/*!
 * @name Register RTC_IER, field HOUR_IE[4] (RW)
 *
 * Values:
 * - 0b0 - Interrupt is disabled.
 * - 0b1 - Interrupt is enabled.
 */
/*@{*/
/*! @brief Read current value of the RTC_IER_HOUR_IE field. */
#define RTC_RD_IER_HOUR_IE(base) ((RTC_IER_REG(base) & RTC_IER_HOUR_IE_MASK) >> RTC_IER_HOUR_IE_SHIFT)
#define RTC_BRD_IER_HOUR_IE(base) (BME_UBFX16(&RTC_IER_REG(base), RTC_IER_HOUR_IE_SHIFT, RTC_IER_HOUR_IE_WIDTH))

/*! @brief Set the HOUR_IE field to a new value. */
#define RTC_WR_IER_HOUR_IE(base, value) (RTC_RMW_IER(base, RTC_IER_HOUR_IE_MASK, RTC_IER_HOUR_IE(value)))
#define RTC_BWR_IER_HOUR_IE(base, value) (BME_BFI16(&RTC_IER_REG(base), ((uint16_t)(value) << RTC_IER_HOUR_IE_SHIFT), RTC_IER_HOUR_IE_SHIFT, RTC_IER_HOUR_IE_WIDTH))
/*@}*/

/*!
 * @name Register RTC_IER, field MIN_IE[5] (RW)
 *
 * Values:
 * - 0b0 - Interrupt is disabled.
 * - 0b1 - Interrupt is enabled.
 */
/*@{*/
/*! @brief Read current value of the RTC_IER_MIN_IE field. */
#define RTC_RD_IER_MIN_IE(base) ((RTC_IER_REG(base) & RTC_IER_MIN_IE_MASK) >> RTC_IER_MIN_IE_SHIFT)
#define RTC_BRD_IER_MIN_IE(base) (BME_UBFX16(&RTC_IER_REG(base), RTC_IER_MIN_IE_SHIFT, RTC_IER_MIN_IE_WIDTH))

/*! @brief Set the MIN_IE field to a new value. */
#define RTC_WR_IER_MIN_IE(base, value) (RTC_RMW_IER(base, RTC_IER_MIN_IE_MASK, RTC_IER_MIN_IE(value)))
#define RTC_BWR_IER_MIN_IE(base, value) (BME_BFI16(&RTC_IER_REG(base), ((uint16_t)(value) << RTC_IER_MIN_IE_SHIFT), RTC_IER_MIN_IE_SHIFT, RTC_IER_MIN_IE_WIDTH))
/*@}*/

/*!
 * @name Register RTC_IER, field IE_1HZ[6] (RW)
 *
 * Values:
 * - 0b0 - Interrupt is disabled.
 * - 0b1 - Interrupt is enabled.
 */
/*@{*/
/*! @brief Read current value of the RTC_IER_IE_1HZ field. */
#define RTC_RD_IER_IE_1HZ(base) ((RTC_IER_REG(base) & RTC_IER_IE_1HZ_MASK) >> RTC_IER_IE_1HZ_SHIFT)
#define RTC_BRD_IER_IE_1HZ(base) (BME_UBFX16(&RTC_IER_REG(base), RTC_IER_IE_1HZ_SHIFT, RTC_IER_IE_1HZ_WIDTH))

/*! @brief Set the IE_1HZ field to a new value. */
#define RTC_WR_IER_IE_1HZ(base, value) (RTC_RMW_IER(base, RTC_IER_IE_1HZ_MASK, RTC_IER_IE_1HZ(value)))
#define RTC_BWR_IER_IE_1HZ(base, value) (BME_BFI16(&RTC_IER_REG(base), ((uint16_t)(value) << RTC_IER_IE_1HZ_SHIFT), RTC_IER_IE_1HZ_SHIFT, RTC_IER_IE_1HZ_WIDTH))
/*@}*/

/*!
 * @name Register RTC_IER, field IE_2HZ[7] (RW)
 *
 * Values:
 * - 0b0 - Interrupt is disabled.
 * - 0b1 - Interrupt is enabled.
 */
/*@{*/
/*! @brief Read current value of the RTC_IER_IE_2HZ field. */
#define RTC_RD_IER_IE_2HZ(base) ((RTC_IER_REG(base) & RTC_IER_IE_2HZ_MASK) >> RTC_IER_IE_2HZ_SHIFT)
#define RTC_BRD_IER_IE_2HZ(base) (BME_UBFX16(&RTC_IER_REG(base), RTC_IER_IE_2HZ_SHIFT, RTC_IER_IE_2HZ_WIDTH))

/*! @brief Set the IE_2HZ field to a new value. */
#define RTC_WR_IER_IE_2HZ(base, value) (RTC_RMW_IER(base, RTC_IER_IE_2HZ_MASK, RTC_IER_IE_2HZ(value)))
#define RTC_BWR_IER_IE_2HZ(base, value) (BME_BFI16(&RTC_IER_REG(base), ((uint16_t)(value) << RTC_IER_IE_2HZ_SHIFT), RTC_IER_IE_2HZ_SHIFT, RTC_IER_IE_2HZ_WIDTH))
/*@}*/

/*!
 * @name Register RTC_IER, field IE_4HZ[8] (RW)
 *
 * Values:
 * - 0b0 - Interrupt is disabled.
 * - 0b1 - Interrupt is enabled.
 */
/*@{*/
/*! @brief Read current value of the RTC_IER_IE_4HZ field. */
#define RTC_RD_IER_IE_4HZ(base) ((RTC_IER_REG(base) & RTC_IER_IE_4HZ_MASK) >> RTC_IER_IE_4HZ_SHIFT)
#define RTC_BRD_IER_IE_4HZ(base) (BME_UBFX16(&RTC_IER_REG(base), RTC_IER_IE_4HZ_SHIFT, RTC_IER_IE_4HZ_WIDTH))

/*! @brief Set the IE_4HZ field to a new value. */
#define RTC_WR_IER_IE_4HZ(base, value) (RTC_RMW_IER(base, RTC_IER_IE_4HZ_MASK, RTC_IER_IE_4HZ(value)))
#define RTC_BWR_IER_IE_4HZ(base, value) (BME_BFI16(&RTC_IER_REG(base), ((uint16_t)(value) << RTC_IER_IE_4HZ_SHIFT), RTC_IER_IE_4HZ_SHIFT, RTC_IER_IE_4HZ_WIDTH))
/*@}*/

/*!
 * @name Register RTC_IER, field IE_8HZ[9] (RW)
 *
 * Values:
 * - 0b0 - Interrupt is disabled.
 * - 0b1 - Interrupt is enabled.
 */
/*@{*/
/*! @brief Read current value of the RTC_IER_IE_8HZ field. */
#define RTC_RD_IER_IE_8HZ(base) ((RTC_IER_REG(base) & RTC_IER_IE_8HZ_MASK) >> RTC_IER_IE_8HZ_SHIFT)
#define RTC_BRD_IER_IE_8HZ(base) (BME_UBFX16(&RTC_IER_REG(base), RTC_IER_IE_8HZ_SHIFT, RTC_IER_IE_8HZ_WIDTH))

/*! @brief Set the IE_8HZ field to a new value. */
#define RTC_WR_IER_IE_8HZ(base, value) (RTC_RMW_IER(base, RTC_IER_IE_8HZ_MASK, RTC_IER_IE_8HZ(value)))
#define RTC_BWR_IER_IE_8HZ(base, value) (BME_BFI16(&RTC_IER_REG(base), ((uint16_t)(value) << RTC_IER_IE_8HZ_SHIFT), RTC_IER_IE_8HZ_SHIFT, RTC_IER_IE_8HZ_WIDTH))
/*@}*/

/*!
 * @name Register RTC_IER, field IE_16HZ[10] (RW)
 *
 * Values:
 * - 0b0 - Interrupt is disabled.
 * - 0b1 - Interrupt is enabled.
 */
/*@{*/
/*! @brief Read current value of the RTC_IER_IE_16HZ field. */
#define RTC_RD_IER_IE_16HZ(base) ((RTC_IER_REG(base) & RTC_IER_IE_16HZ_MASK) >> RTC_IER_IE_16HZ_SHIFT)
#define RTC_BRD_IER_IE_16HZ(base) (BME_UBFX16(&RTC_IER_REG(base), RTC_IER_IE_16HZ_SHIFT, RTC_IER_IE_16HZ_WIDTH))

/*! @brief Set the IE_16HZ field to a new value. */
#define RTC_WR_IER_IE_16HZ(base, value) (RTC_RMW_IER(base, RTC_IER_IE_16HZ_MASK, RTC_IER_IE_16HZ(value)))
#define RTC_BWR_IER_IE_16HZ(base, value) (BME_BFI16(&RTC_IER_REG(base), ((uint16_t)(value) << RTC_IER_IE_16HZ_SHIFT), RTC_IER_IE_16HZ_SHIFT, RTC_IER_IE_16HZ_WIDTH))
/*@}*/

/*!
 * @name Register RTC_IER, field IE_32HZ[11] (RW)
 *
 * Values:
 * - 0b0 - Interrupt is disabled.
 * - 0b1 - Interrupt is enabled.
 */
/*@{*/
/*! @brief Read current value of the RTC_IER_IE_32HZ field. */
#define RTC_RD_IER_IE_32HZ(base) ((RTC_IER_REG(base) & RTC_IER_IE_32HZ_MASK) >> RTC_IER_IE_32HZ_SHIFT)
#define RTC_BRD_IER_IE_32HZ(base) (BME_UBFX16(&RTC_IER_REG(base), RTC_IER_IE_32HZ_SHIFT, RTC_IER_IE_32HZ_WIDTH))

/*! @brief Set the IE_32HZ field to a new value. */
#define RTC_WR_IER_IE_32HZ(base, value) (RTC_RMW_IER(base, RTC_IER_IE_32HZ_MASK, RTC_IER_IE_32HZ(value)))
#define RTC_BWR_IER_IE_32HZ(base, value) (BME_BFI16(&RTC_IER_REG(base), ((uint16_t)(value) << RTC_IER_IE_32HZ_SHIFT), RTC_IER_IE_32HZ_SHIFT, RTC_IER_IE_32HZ_WIDTH))
/*@}*/

/*!
 * @name Register RTC_IER, field IE_64HZ[12] (RW)
 *
 * Values:
 * - 0b0 - Interrupt is disabled.
 * - 0b1 - Interrupt is enabled.
 */
/*@{*/
/*! @brief Read current value of the RTC_IER_IE_64HZ field. */
#define RTC_RD_IER_IE_64HZ(base) ((RTC_IER_REG(base) & RTC_IER_IE_64HZ_MASK) >> RTC_IER_IE_64HZ_SHIFT)
#define RTC_BRD_IER_IE_64HZ(base) (BME_UBFX16(&RTC_IER_REG(base), RTC_IER_IE_64HZ_SHIFT, RTC_IER_IE_64HZ_WIDTH))

/*! @brief Set the IE_64HZ field to a new value. */
#define RTC_WR_IER_IE_64HZ(base, value) (RTC_RMW_IER(base, RTC_IER_IE_64HZ_MASK, RTC_IER_IE_64HZ(value)))
#define RTC_BWR_IER_IE_64HZ(base, value) (BME_BFI16(&RTC_IER_REG(base), ((uint16_t)(value) << RTC_IER_IE_64HZ_SHIFT), RTC_IER_IE_64HZ_SHIFT, RTC_IER_IE_64HZ_WIDTH))
/*@}*/

/*!
 * @name Register RTC_IER, field IE_128HZ[13] (RW)
 *
 * Values:
 * - 0b0 - Interrupt is disabled.
 * - 0b1 - Interrupt is enabled.
 */
/*@{*/
/*! @brief Read current value of the RTC_IER_IE_128HZ field. */
#define RTC_RD_IER_IE_128HZ(base) ((RTC_IER_REG(base) & RTC_IER_IE_128HZ_MASK) >> RTC_IER_IE_128HZ_SHIFT)
#define RTC_BRD_IER_IE_128HZ(base) (BME_UBFX16(&RTC_IER_REG(base), RTC_IER_IE_128HZ_SHIFT, RTC_IER_IE_128HZ_WIDTH))

/*! @brief Set the IE_128HZ field to a new value. */
#define RTC_WR_IER_IE_128HZ(base, value) (RTC_RMW_IER(base, RTC_IER_IE_128HZ_MASK, RTC_IER_IE_128HZ(value)))
#define RTC_BWR_IER_IE_128HZ(base, value) (BME_BFI16(&RTC_IER_REG(base), ((uint16_t)(value) << RTC_IER_IE_128HZ_SHIFT), RTC_IER_IE_128HZ_SHIFT, RTC_IER_IE_128HZ_WIDTH))
/*@}*/

/*!
 * @name Register RTC_IER, field IE_256HZ[14] (RW)
 *
 * Values:
 * - 0b0 - Interrupt is disabled.
 * - 0b1 - Interrupt is enabled.
 */
/*@{*/
/*! @brief Read current value of the RTC_IER_IE_256HZ field. */
#define RTC_RD_IER_IE_256HZ(base) ((RTC_IER_REG(base) & RTC_IER_IE_256HZ_MASK) >> RTC_IER_IE_256HZ_SHIFT)
#define RTC_BRD_IER_IE_256HZ(base) (BME_UBFX16(&RTC_IER_REG(base), RTC_IER_IE_256HZ_SHIFT, RTC_IER_IE_256HZ_WIDTH))

/*! @brief Set the IE_256HZ field to a new value. */
#define RTC_WR_IER_IE_256HZ(base, value) (RTC_RMW_IER(base, RTC_IER_IE_256HZ_MASK, RTC_IER_IE_256HZ(value)))
#define RTC_BWR_IER_IE_256HZ(base, value) (BME_BFI16(&RTC_IER_REG(base), ((uint16_t)(value) << RTC_IER_IE_256HZ_SHIFT), RTC_IER_IE_256HZ_SHIFT, RTC_IER_IE_256HZ_WIDTH))
/*@}*/

/*!
 * @name Register RTC_IER, field IE_512HZ[15] (RW)
 *
 * Values:
 * - 0b0 - Interrupt is disabled.
 * - 0b1 - Interrupt is enabled.
 */
/*@{*/
/*! @brief Read current value of the RTC_IER_IE_512HZ field. */
#define RTC_RD_IER_IE_512HZ(base) ((RTC_IER_REG(base) & RTC_IER_IE_512HZ_MASK) >> RTC_IER_IE_512HZ_SHIFT)
#define RTC_BRD_IER_IE_512HZ(base) (BME_UBFX16(&RTC_IER_REG(base), RTC_IER_IE_512HZ_SHIFT, RTC_IER_IE_512HZ_WIDTH))

/*! @brief Set the IE_512HZ field to a new value. */
#define RTC_WR_IER_IE_512HZ(base, value) (RTC_RMW_IER(base, RTC_IER_IE_512HZ_MASK, RTC_IER_IE_512HZ(value)))
#define RTC_BWR_IER_IE_512HZ(base, value) (BME_BFI16(&RTC_IER_REG(base), ((uint16_t)(value) << RTC_IER_IE_512HZ_SHIFT), RTC_IER_IE_512HZ_SHIFT, RTC_IER_IE_512HZ_WIDTH))
/*@}*/

/*******************************************************************************
 * RTC_GP_DATA_REG - RTC General Purpose Data Register
 ******************************************************************************/

/*!
 * @brief RTC_GP_DATA_REG - RTC General Purpose Data Register (RW)
 *
 * Reset value: 0x0000U
 *
 * The use of the bits in this register are specific to the MCU. See the Chip
 * Configuration chapter for description of this register. Software reset has no
 * effect on the contents of this register.
 */
/*!
 * @name Constants and macros for entire RTC_GP_DATA_REG register
 */
/*@{*/
#define RTC_RD_GP_DATA_REG(base) (RTC_GP_DATA_REG_REG(base))
#define RTC_WR_GP_DATA_REG(base, value) (RTC_GP_DATA_REG_REG(base) = (value))
#define RTC_RMW_GP_DATA_REG(base, mask, value) (RTC_WR_GP_DATA_REG(base, (RTC_RD_GP_DATA_REG(base) & ~(mask)) | (value)))
#define RTC_SET_GP_DATA_REG(base, value) (BME_OR16(&RTC_GP_DATA_REG_REG(base), (uint16_t)(value)))
#define RTC_CLR_GP_DATA_REG(base, value) (BME_AND16(&RTC_GP_DATA_REG_REG(base), (uint16_t)(~(value))))
#define RTC_TOG_GP_DATA_REG(base, value) (BME_XOR16(&RTC_GP_DATA_REG_REG(base), (uint16_t)(value)))
/*@}*/

/*******************************************************************************
 * RTC_DST_HOUR - RTC Daylight Saving Hour Register
 ******************************************************************************/

/*!
 * @brief RTC_DST_HOUR - RTC Daylight Saving Hour Register (RW)
 *
 * Reset value: 0x0000U
 *
 * This register stores the time in hours when the Daylight Saving has to be
 * applied or reversed. This register is programmable when the DST_EN bit in CTRL
 * register is 'Zero'. When DST_EN bit is set, the contents of this register cannot
 * be changed. The user software should program the correct hour value (0 - 23)
 * as per the regional settings. For example, if the Daylight Saving starts at
 * 2:00 AM on March 25 and ends at 2:00 AM on October 28 in 2007 then the time at
 * which the RTC advances or falls back is actually 1:59 AM. Hence the user
 * software should program 1 for the hour count value (and not 2!) i.e. write 0x0101 in
 * this register. 59 minute count is automatically checked inside RTC and hence
 * not required to be programmed. This register has no effect on software reset.
 */
/*!
 * @name Constants and macros for entire RTC_DST_HOUR register
 */
/*@{*/
#define RTC_RD_DST_HOUR(base)    (RTC_DST_HOUR_REG(base))
#define RTC_WR_DST_HOUR(base, value) (RTC_DST_HOUR_REG(base) = (value))
#define RTC_RMW_DST_HOUR(base, mask, value) (RTC_WR_DST_HOUR(base, (RTC_RD_DST_HOUR(base) & ~(mask)) | (value)))
#define RTC_SET_DST_HOUR(base, value) (BME_OR16(&RTC_DST_HOUR_REG(base), (uint16_t)(value)))
#define RTC_CLR_DST_HOUR(base, value) (BME_AND16(&RTC_DST_HOUR_REG(base), (uint16_t)(~(value))))
#define RTC_TOG_DST_HOUR(base, value) (BME_XOR16(&RTC_DST_HOUR_REG(base), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual RTC_DST_HOUR bitfields
 */

/*!
 * @name Register RTC_DST_HOUR, field DST_END_HOUR[4:0] (RW)
 *
 * This is the hour value for the time when DST is reversed. Same as Hours
 * Counter Value in the HOURMINRTC Hours and Minutes Counters Register .
 */
/*@{*/
/*! @brief Read current value of the RTC_DST_HOUR_DST_END_HOUR field. */
#define RTC_RD_DST_HOUR_DST_END_HOUR(base) ((RTC_DST_HOUR_REG(base) & RTC_DST_HOUR_DST_END_HOUR_MASK) >> RTC_DST_HOUR_DST_END_HOUR_SHIFT)
#define RTC_BRD_DST_HOUR_DST_END_HOUR(base) (BME_UBFX16(&RTC_DST_HOUR_REG(base), RTC_DST_HOUR_DST_END_HOUR_SHIFT, RTC_DST_HOUR_DST_END_HOUR_WIDTH))

/*! @brief Set the DST_END_HOUR field to a new value. */
#define RTC_WR_DST_HOUR_DST_END_HOUR(base, value) (RTC_RMW_DST_HOUR(base, RTC_DST_HOUR_DST_END_HOUR_MASK, RTC_DST_HOUR_DST_END_HOUR(value)))
#define RTC_BWR_DST_HOUR_DST_END_HOUR(base, value) (BME_BFI16(&RTC_DST_HOUR_REG(base), ((uint16_t)(value) << RTC_DST_HOUR_DST_END_HOUR_SHIFT), RTC_DST_HOUR_DST_END_HOUR_SHIFT, RTC_DST_HOUR_DST_END_HOUR_WIDTH))
/*@}*/

/*!
 * @name Register RTC_DST_HOUR, field DST_START_HOUR[12:8] (RW)
 *
 * This is the hour value for the time when DST comes into effect. Same as Hours
 * Counter Value in the HOURMINRTC Hours and Minutes Counters Register .
 */
/*@{*/
/*! @brief Read current value of the RTC_DST_HOUR_DST_START_HOUR field. */
#define RTC_RD_DST_HOUR_DST_START_HOUR(base) ((RTC_DST_HOUR_REG(base) & RTC_DST_HOUR_DST_START_HOUR_MASK) >> RTC_DST_HOUR_DST_START_HOUR_SHIFT)
#define RTC_BRD_DST_HOUR_DST_START_HOUR(base) (BME_UBFX16(&RTC_DST_HOUR_REG(base), RTC_DST_HOUR_DST_START_HOUR_SHIFT, RTC_DST_HOUR_DST_START_HOUR_WIDTH))

/*! @brief Set the DST_START_HOUR field to a new value. */
#define RTC_WR_DST_HOUR_DST_START_HOUR(base, value) (RTC_RMW_DST_HOUR(base, RTC_DST_HOUR_DST_START_HOUR_MASK, RTC_DST_HOUR_DST_START_HOUR(value)))
#define RTC_BWR_DST_HOUR_DST_START_HOUR(base, value) (BME_BFI16(&RTC_DST_HOUR_REG(base), ((uint16_t)(value) << RTC_DST_HOUR_DST_START_HOUR_SHIFT), RTC_DST_HOUR_DST_START_HOUR_SHIFT, RTC_DST_HOUR_DST_START_HOUR_WIDTH))
/*@}*/

/*******************************************************************************
 * RTC_DST_MONTH - RTC Daylight Saving Month Register
 ******************************************************************************/

/*!
 * @brief RTC_DST_MONTH - RTC Daylight Saving Month Register (RW)
 *
 * Reset value: 0x0000U
 *
 * This register stores the month when the Daylight Saving has to be applied or
 * reversed. This register is programmable when the DST_EN bit in CTRL register
 * is Zero. When DST_EN bit is set, the contents of this register cannot be
 * changed. The CPU should program the correct month value (1 - 12) as per the regional
 * settings. For example, if the Daylight Saving starts at March 25 and ends at
 * October 28 in 2007. Hence the CPU should write 0x030A in this register. This
 * register has no effect on software reset.
 */
/*!
 * @name Constants and macros for entire RTC_DST_MONTH register
 */
/*@{*/
#define RTC_RD_DST_MONTH(base)   (RTC_DST_MONTH_REG(base))
#define RTC_WR_DST_MONTH(base, value) (RTC_DST_MONTH_REG(base) = (value))
#define RTC_RMW_DST_MONTH(base, mask, value) (RTC_WR_DST_MONTH(base, (RTC_RD_DST_MONTH(base) & ~(mask)) | (value)))
#define RTC_SET_DST_MONTH(base, value) (BME_OR16(&RTC_DST_MONTH_REG(base), (uint16_t)(value)))
#define RTC_CLR_DST_MONTH(base, value) (BME_AND16(&RTC_DST_MONTH_REG(base), (uint16_t)(~(value))))
#define RTC_TOG_DST_MONTH(base, value) (BME_XOR16(&RTC_DST_MONTH_REG(base), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual RTC_DST_MONTH bitfields
 */

/*!
 * @name Register RTC_DST_MONTH, field DST_END_MONTH[3:0] (RW)
 *
 * This is the month value for the time when DST is reversed. See the YEARMONRTC
 * Year and Month Counters Register .
 */
/*@{*/
/*! @brief Read current value of the RTC_DST_MONTH_DST_END_MONTH field. */
#define RTC_RD_DST_MONTH_DST_END_MONTH(base) ((RTC_DST_MONTH_REG(base) & RTC_DST_MONTH_DST_END_MONTH_MASK) >> RTC_DST_MONTH_DST_END_MONTH_SHIFT)
#define RTC_BRD_DST_MONTH_DST_END_MONTH(base) (BME_UBFX16(&RTC_DST_MONTH_REG(base), RTC_DST_MONTH_DST_END_MONTH_SHIFT, RTC_DST_MONTH_DST_END_MONTH_WIDTH))

/*! @brief Set the DST_END_MONTH field to a new value. */
#define RTC_WR_DST_MONTH_DST_END_MONTH(base, value) (RTC_RMW_DST_MONTH(base, RTC_DST_MONTH_DST_END_MONTH_MASK, RTC_DST_MONTH_DST_END_MONTH(value)))
#define RTC_BWR_DST_MONTH_DST_END_MONTH(base, value) (BME_BFI16(&RTC_DST_MONTH_REG(base), ((uint16_t)(value) << RTC_DST_MONTH_DST_END_MONTH_SHIFT), RTC_DST_MONTH_DST_END_MONTH_SHIFT, RTC_DST_MONTH_DST_END_MONTH_WIDTH))
/*@}*/

/*!
 * @name Register RTC_DST_MONTH, field DST_START_MONTH[11:8] (RW)
 *
 * This is the month value for the time when DST comes in to effect. See the
 * YEARMONRTC Year and Month Counters Register .
 */
/*@{*/
/*! @brief Read current value of the RTC_DST_MONTH_DST_START_MONTH field. */
#define RTC_RD_DST_MONTH_DST_START_MONTH(base) ((RTC_DST_MONTH_REG(base) & RTC_DST_MONTH_DST_START_MONTH_MASK) >> RTC_DST_MONTH_DST_START_MONTH_SHIFT)
#define RTC_BRD_DST_MONTH_DST_START_MONTH(base) (BME_UBFX16(&RTC_DST_MONTH_REG(base), RTC_DST_MONTH_DST_START_MONTH_SHIFT, RTC_DST_MONTH_DST_START_MONTH_WIDTH))

/*! @brief Set the DST_START_MONTH field to a new value. */
#define RTC_WR_DST_MONTH_DST_START_MONTH(base, value) (RTC_RMW_DST_MONTH(base, RTC_DST_MONTH_DST_START_MONTH_MASK, RTC_DST_MONTH_DST_START_MONTH(value)))
#define RTC_BWR_DST_MONTH_DST_START_MONTH(base, value) (BME_BFI16(&RTC_DST_MONTH_REG(base), ((uint16_t)(value) << RTC_DST_MONTH_DST_START_MONTH_SHIFT), RTC_DST_MONTH_DST_START_MONTH_SHIFT, RTC_DST_MONTH_DST_START_MONTH_WIDTH))
/*@}*/

/*******************************************************************************
 * RTC_DST_DAY - RTC Daylight Saving Day Register
 ******************************************************************************/

/*!
 * @brief RTC_DST_DAY - RTC Daylight Saving Day Register (RW)
 *
 * Reset value: 0x0000U
 *
 * This register stores the day when the Daylight Saving has to be applied or
 * reversed. This register is programmable when the DST_EN bit in CTRL register is
 * Zero. When DST_EN bit is set, the contents of this register cannot be changed.
 * The CPU should program the correct day value (1 - 31) as per the regional
 * settings. For example, if the Daylight Saving starts at March 25 and ends at
 * October 28 in 2007. Hence the CPU should write 0x191C in this register. This
 * register is unaffected by software reset.
 */
/*!
 * @name Constants and macros for entire RTC_DST_DAY register
 */
/*@{*/
#define RTC_RD_DST_DAY(base)     (RTC_DST_DAY_REG(base))
#define RTC_WR_DST_DAY(base, value) (RTC_DST_DAY_REG(base) = (value))
#define RTC_RMW_DST_DAY(base, mask, value) (RTC_WR_DST_DAY(base, (RTC_RD_DST_DAY(base) & ~(mask)) | (value)))
#define RTC_SET_DST_DAY(base, value) (BME_OR16(&RTC_DST_DAY_REG(base), (uint16_t)(value)))
#define RTC_CLR_DST_DAY(base, value) (BME_AND16(&RTC_DST_DAY_REG(base), (uint16_t)(~(value))))
#define RTC_TOG_DST_DAY(base, value) (BME_XOR16(&RTC_DST_DAY_REG(base), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual RTC_DST_DAY bitfields
 */

/*!
 * @name Register RTC_DST_DAY, field DST_END_DAY[4:0] (RW)
 *
 * This is the day value for the time when DST is reversed.
 */
/*@{*/
/*! @brief Read current value of the RTC_DST_DAY_DST_END_DAY field. */
#define RTC_RD_DST_DAY_DST_END_DAY(base) ((RTC_DST_DAY_REG(base) & RTC_DST_DAY_DST_END_DAY_MASK) >> RTC_DST_DAY_DST_END_DAY_SHIFT)
#define RTC_BRD_DST_DAY_DST_END_DAY(base) (BME_UBFX16(&RTC_DST_DAY_REG(base), RTC_DST_DAY_DST_END_DAY_SHIFT, RTC_DST_DAY_DST_END_DAY_WIDTH))

/*! @brief Set the DST_END_DAY field to a new value. */
#define RTC_WR_DST_DAY_DST_END_DAY(base, value) (RTC_RMW_DST_DAY(base, RTC_DST_DAY_DST_END_DAY_MASK, RTC_DST_DAY_DST_END_DAY(value)))
#define RTC_BWR_DST_DAY_DST_END_DAY(base, value) (BME_BFI16(&RTC_DST_DAY_REG(base), ((uint16_t)(value) << RTC_DST_DAY_DST_END_DAY_SHIFT), RTC_DST_DAY_DST_END_DAY_SHIFT, RTC_DST_DAY_DST_END_DAY_WIDTH))
/*@}*/

/*!
 * @name Register RTC_DST_DAY, field DST_START_DAY[12:8] (RW)
 *
 * This is the day value for the time when DST comes into effect.
 */
/*@{*/
/*! @brief Read current value of the RTC_DST_DAY_DST_START_DAY field. */
#define RTC_RD_DST_DAY_DST_START_DAY(base) ((RTC_DST_DAY_REG(base) & RTC_DST_DAY_DST_START_DAY_MASK) >> RTC_DST_DAY_DST_START_DAY_SHIFT)
#define RTC_BRD_DST_DAY_DST_START_DAY(base) (BME_UBFX16(&RTC_DST_DAY_REG(base), RTC_DST_DAY_DST_START_DAY_SHIFT, RTC_DST_DAY_DST_START_DAY_WIDTH))

/*! @brief Set the DST_START_DAY field to a new value. */
#define RTC_WR_DST_DAY_DST_START_DAY(base, value) (RTC_RMW_DST_DAY(base, RTC_DST_DAY_DST_START_DAY_MASK, RTC_DST_DAY_DST_START_DAY(value)))
#define RTC_BWR_DST_DAY_DST_START_DAY(base, value) (BME_BFI16(&RTC_DST_DAY_REG(base), ((uint16_t)(value) << RTC_DST_DAY_DST_START_DAY_SHIFT), RTC_DST_DAY_DST_START_DAY_SHIFT, RTC_DST_DAY_DST_START_DAY_WIDTH))
/*@}*/

/*******************************************************************************
 * RTC_COMPEN - RTC Compensation Register
 ******************************************************************************/

/*!
 * @brief RTC_COMPEN - RTC Compensation Register (RW)
 *
 * Reset value: 0x0000U
 *
 * The compensation register stores the compensation value that will be used by
 * the compensation block to correct the 1 Hz clock.
 */
/*!
 * @name Constants and macros for entire RTC_COMPEN register
 */
/*@{*/
#define RTC_RD_COMPEN(base)      (RTC_COMPEN_REG(base))
#define RTC_WR_COMPEN(base, value) (RTC_COMPEN_REG(base) = (value))
#define RTC_RMW_COMPEN(base, mask, value) (RTC_WR_COMPEN(base, (RTC_RD_COMPEN(base) & ~(mask)) | (value)))
#define RTC_SET_COMPEN(base, value) (BME_OR16(&RTC_COMPEN_REG(base), (uint16_t)(value)))
#define RTC_CLR_COMPEN(base, value) (BME_AND16(&RTC_COMPEN_REG(base), (uint16_t)(~(value))))
#define RTC_TOG_COMPEN(base, value) (BME_XOR16(&RTC_COMPEN_REG(base), (uint16_t)(value)))
/*@}*/

/*******************************************************************************
 * RTC_TAMPER_SCR - RTC Tamper Status and Control Register
 ******************************************************************************/

/*!
 * @brief RTC_TAMPER_SCR - RTC Tamper Status and Control Register (RW)
 *
 * Reset value: 0x080FU
 *
 * For the implementation of this register in the MCU, refer to chip
 * configuration chapter. This register stores the tamper event and provides control to the
 * user to enable or disable each tamper individually. No tamper is disabled
 * automatically unless corresponding control bit is de-asserted by software. The
 * tamper statuses are stored as active high. The tamper status bits store the
 * tamper event irrespective of their corresponding control bit being asserted or not.
 * The control bits gate the assertion of tamper interrupt bit in ISR. These
 * status and controls bits combined assert the tamper interrupt in the ISR
 * register. The tamper interrupt will be cleared when all above Status bits are cleared.
 */
/*!
 * @name Constants and macros for entire RTC_TAMPER_SCR register
 */
/*@{*/
#define RTC_RD_TAMPER_SCR(base)  (RTC_TAMPER_SCR_REG(base))
#define RTC_WR_TAMPER_SCR(base, value) (RTC_TAMPER_SCR_REG(base) = (value))
#define RTC_RMW_TAMPER_SCR(base, mask, value) (RTC_WR_TAMPER_SCR(base, (RTC_RD_TAMPER_SCR(base) & ~(mask)) | (value)))
#define RTC_SET_TAMPER_SCR(base, value) (BME_OR16(&RTC_TAMPER_SCR_REG(base), (uint16_t)(value)))
#define RTC_CLR_TAMPER_SCR(base, value) (BME_AND16(&RTC_TAMPER_SCR_REG(base), (uint16_t)(~(value))))
#define RTC_TOG_TAMPER_SCR(base, value) (BME_XOR16(&RTC_TAMPER_SCR_REG(base), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual RTC_TAMPER_SCR bitfields
 */

/*!
 * @name Register RTC_TAMPER_SCR, field TMPR_EN[3:0] (RW)
 *
 * Controls the generation of tamper interrupt from corresponding tamper status
 * bit. Enabled on reset.
 */
/*@{*/
/*! @brief Read current value of the RTC_TAMPER_SCR_TMPR_EN field. */
#define RTC_RD_TAMPER_SCR_TMPR_EN(base) ((RTC_TAMPER_SCR_REG(base) & RTC_TAMPER_SCR_TMPR_EN_MASK) >> RTC_TAMPER_SCR_TMPR_EN_SHIFT)
#define RTC_BRD_TAMPER_SCR_TMPR_EN(base) (BME_UBFX16(&RTC_TAMPER_SCR_REG(base), RTC_TAMPER_SCR_TMPR_EN_SHIFT, RTC_TAMPER_SCR_TMPR_EN_WIDTH))

/*! @brief Set the TMPR_EN field to a new value. */
#define RTC_WR_TAMPER_SCR_TMPR_EN(base, value) (RTC_RMW_TAMPER_SCR(base, RTC_TAMPER_SCR_TMPR_EN_MASK, RTC_TAMPER_SCR_TMPR_EN(value)))
#define RTC_BWR_TAMPER_SCR_TMPR_EN(base, value) (BME_BFI16(&RTC_TAMPER_SCR_REG(base), ((uint16_t)(value) << RTC_TAMPER_SCR_TMPR_EN_SHIFT), RTC_TAMPER_SCR_TMPR_EN_SHIFT, RTC_TAMPER_SCR_TMPR_EN_WIDTH))
/*@}*/

/*!
 * @name Register RTC_TAMPER_SCR, field TMPR_STS[11:8] (RW)
 *
 * Indicates if a tamper event was detected or not. Writing '1' to this field
 * clears the tamper status.
 */
/*@{*/
/*! @brief Read current value of the RTC_TAMPER_SCR_TMPR_STS field. */
#define RTC_RD_TAMPER_SCR_TMPR_STS(base) ((RTC_TAMPER_SCR_REG(base) & RTC_TAMPER_SCR_TMPR_STS_MASK) >> RTC_TAMPER_SCR_TMPR_STS_SHIFT)
#define RTC_BRD_TAMPER_SCR_TMPR_STS(base) (BME_UBFX16(&RTC_TAMPER_SCR_REG(base), RTC_TAMPER_SCR_TMPR_STS_SHIFT, RTC_TAMPER_SCR_TMPR_STS_WIDTH))

/*! @brief Set the TMPR_STS field to a new value. */
#define RTC_WR_TAMPER_SCR_TMPR_STS(base, value) (RTC_RMW_TAMPER_SCR(base, RTC_TAMPER_SCR_TMPR_STS_MASK, RTC_TAMPER_SCR_TMPR_STS(value)))
#define RTC_BWR_TAMPER_SCR_TMPR_STS(base, value) (BME_BFI16(&RTC_TAMPER_SCR_REG(base), ((uint16_t)(value) << RTC_TAMPER_SCR_TMPR_STS_SHIFT), RTC_TAMPER_SCR_TMPR_STS_SHIFT, RTC_TAMPER_SCR_TMPR_STS_WIDTH))
/*@}*/

/*******************************************************************************
 * RTC_FILTER01_CFG - RTC Tamper 0 1 Filter Configuration Register
 ******************************************************************************/

/*!
 * @brief RTC_FILTER01_CFG - RTC Tamper 0 1 Filter Configuration Register (RW)
 *
 * Reset value: 0x0000U
 *
 * This register must be configured once during the initial startup of
 * application and must not be changed on the fly to avoid any erratic behavior. Changing
 * the register on the fly might lead to missing of tamper events or assertion of
 * false tamper events.
 */
/*!
 * @name Constants and macros for entire RTC_FILTER01_CFG register
 */
/*@{*/
#define RTC_RD_FILTER01_CFG(base) (RTC_FILTER01_CFG_REG(base))
#define RTC_WR_FILTER01_CFG(base, value) (RTC_FILTER01_CFG_REG(base) = (value))
#define RTC_RMW_FILTER01_CFG(base, mask, value) (RTC_WR_FILTER01_CFG(base, (RTC_RD_FILTER01_CFG(base) & ~(mask)) | (value)))
#define RTC_SET_FILTER01_CFG(base, value) (BME_OR16(&RTC_FILTER01_CFG_REG(base), (uint16_t)(value)))
#define RTC_CLR_FILTER01_CFG(base, value) (BME_AND16(&RTC_FILTER01_CFG_REG(base), (uint16_t)(~(value))))
#define RTC_TOG_FILTER01_CFG(base, value) (BME_XOR16(&RTC_FILTER01_CFG_REG(base), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual RTC_FILTER01_CFG bitfields
 */

/*!
 * @name Register RTC_FILTER01_CFG, field FIL_DUR1[3:0] (RW)
 *
 * This bit indicates the number of tamper filter clock cycles for which the
 * TAMPER[1] signal should remains stable before being detected as a tamper. These
 * bits are used by the tamper filtering operation. With the tamper duration set
 * to Zero any tamper detected on the tamper pins will directly set the tamper
 * status and interrupt bits. Caution is required when making the tamper filter
 * duration equal to 0 as any glitches on the tamper pins will cause a tamper
 * interrupt.
 *
 * Values:
 * - 0b0000 - Filtering operation disabled.
 */
/*@{*/
/*! @brief Read current value of the RTC_FILTER01_CFG_FIL_DUR1 field. */
#define RTC_RD_FILTER01_CFG_FIL_DUR1(base) ((RTC_FILTER01_CFG_REG(base) & RTC_FILTER01_CFG_FIL_DUR1_MASK) >> RTC_FILTER01_CFG_FIL_DUR1_SHIFT)
#define RTC_BRD_FILTER01_CFG_FIL_DUR1(base) (BME_UBFX16(&RTC_FILTER01_CFG_REG(base), RTC_FILTER01_CFG_FIL_DUR1_SHIFT, RTC_FILTER01_CFG_FIL_DUR1_WIDTH))

/*! @brief Set the FIL_DUR1 field to a new value. */
#define RTC_WR_FILTER01_CFG_FIL_DUR1(base, value) (RTC_RMW_FILTER01_CFG(base, RTC_FILTER01_CFG_FIL_DUR1_MASK, RTC_FILTER01_CFG_FIL_DUR1(value)))
#define RTC_BWR_FILTER01_CFG_FIL_DUR1(base, value) (BME_BFI16(&RTC_FILTER01_CFG_REG(base), ((uint16_t)(value) << RTC_FILTER01_CFG_FIL_DUR1_SHIFT), RTC_FILTER01_CFG_FIL_DUR1_SHIFT, RTC_FILTER01_CFG_FIL_DUR1_WIDTH))
/*@}*/

/*!
 * @name Register RTC_FILTER01_CFG, field CLK_SEL1[6:4] (RW)
 *
 * This bit is a write once bit and selects the clock source for tamper filter
 * for tamper detect input bit 1.
 *
 * Values:
 * - 0b000 - 32 kHz clock
 * - 0b001 - 512 Hz clock
 * - 0b010 - 128 Hz clock
 * - 0b011 - 64 Hz clock
 * - 0b100 - 16 Hz clock
 * - 0b101 - 8 Hz clock
 * - 0b110 - 4 Hz clock
 * - 0b111 - 2 Hz clock
 */
/*@{*/
/*! @brief Read current value of the RTC_FILTER01_CFG_CLK_SEL1 field. */
#define RTC_RD_FILTER01_CFG_CLK_SEL1(base) ((RTC_FILTER01_CFG_REG(base) & RTC_FILTER01_CFG_CLK_SEL1_MASK) >> RTC_FILTER01_CFG_CLK_SEL1_SHIFT)
#define RTC_BRD_FILTER01_CFG_CLK_SEL1(base) (BME_UBFX16(&RTC_FILTER01_CFG_REG(base), RTC_FILTER01_CFG_CLK_SEL1_SHIFT, RTC_FILTER01_CFG_CLK_SEL1_WIDTH))

/*! @brief Set the CLK_SEL1 field to a new value. */
#define RTC_WR_FILTER01_CFG_CLK_SEL1(base, value) (RTC_RMW_FILTER01_CFG(base, RTC_FILTER01_CFG_CLK_SEL1_MASK, RTC_FILTER01_CFG_CLK_SEL1(value)))
#define RTC_BWR_FILTER01_CFG_CLK_SEL1(base, value) (BME_BFI16(&RTC_FILTER01_CFG_REG(base), ((uint16_t)(value) << RTC_FILTER01_CFG_CLK_SEL1_SHIFT), RTC_FILTER01_CFG_CLK_SEL1_SHIFT, RTC_FILTER01_CFG_CLK_SEL1_WIDTH))
/*@}*/

/*!
 * @name Register RTC_FILTER01_CFG, field POL1[7] (RW)
 *
 * This bit controls the polarity of tamper detect input bit 1 (TAMPER[1]).
 *
 * Values:
 * - 0b0 - Tamper detect input bit 1 is active high.
 * - 0b1 - Tamper detect input bit 1 is active low.
 */
/*@{*/
/*! @brief Read current value of the RTC_FILTER01_CFG_POL1 field. */
#define RTC_RD_FILTER01_CFG_POL1(base) ((RTC_FILTER01_CFG_REG(base) & RTC_FILTER01_CFG_POL1_MASK) >> RTC_FILTER01_CFG_POL1_SHIFT)
#define RTC_BRD_FILTER01_CFG_POL1(base) (BME_UBFX16(&RTC_FILTER01_CFG_REG(base), RTC_FILTER01_CFG_POL1_SHIFT, RTC_FILTER01_CFG_POL1_WIDTH))

/*! @brief Set the POL1 field to a new value. */
#define RTC_WR_FILTER01_CFG_POL1(base, value) (RTC_RMW_FILTER01_CFG(base, RTC_FILTER01_CFG_POL1_MASK, RTC_FILTER01_CFG_POL1(value)))
#define RTC_BWR_FILTER01_CFG_POL1(base, value) (BME_BFI16(&RTC_FILTER01_CFG_REG(base), ((uint16_t)(value) << RTC_FILTER01_CFG_POL1_SHIFT), RTC_FILTER01_CFG_POL1_SHIFT, RTC_FILTER01_CFG_POL1_WIDTH))
/*@}*/

/*!
 * @name Register RTC_FILTER01_CFG, field FIL_DUR0[11:8] (RW)
 *
 * This bit indicates the number of tamper filter clock cycles for which the
 * TAMPER[0] signal should remains stable before being detected as a tamper. These
 * bits are used by the tamper filtering operation. With the tamper duration set
 * to Zero any tamper detected on the tamper pins will directly set the tamper
 * status and interrupt bits. Caution is required when making the tamper filter
 * duration equal to 0 as any glitches on the tamper pins will cause a tamper
 * interrupt.
 *
 * Values:
 * - 0b0000 - Filtering operation disabled.
 */
/*@{*/
/*! @brief Read current value of the RTC_FILTER01_CFG_FIL_DUR0 field. */
#define RTC_RD_FILTER01_CFG_FIL_DUR0(base) ((RTC_FILTER01_CFG_REG(base) & RTC_FILTER01_CFG_FIL_DUR0_MASK) >> RTC_FILTER01_CFG_FIL_DUR0_SHIFT)
#define RTC_BRD_FILTER01_CFG_FIL_DUR0(base) (BME_UBFX16(&RTC_FILTER01_CFG_REG(base), RTC_FILTER01_CFG_FIL_DUR0_SHIFT, RTC_FILTER01_CFG_FIL_DUR0_WIDTH))

/*! @brief Set the FIL_DUR0 field to a new value. */
#define RTC_WR_FILTER01_CFG_FIL_DUR0(base, value) (RTC_RMW_FILTER01_CFG(base, RTC_FILTER01_CFG_FIL_DUR0_MASK, RTC_FILTER01_CFG_FIL_DUR0(value)))
#define RTC_BWR_FILTER01_CFG_FIL_DUR0(base, value) (BME_BFI16(&RTC_FILTER01_CFG_REG(base), ((uint16_t)(value) << RTC_FILTER01_CFG_FIL_DUR0_SHIFT), RTC_FILTER01_CFG_FIL_DUR0_SHIFT, RTC_FILTER01_CFG_FIL_DUR0_WIDTH))
/*@}*/

/*!
 * @name Register RTC_FILTER01_CFG, field CLK_SEL0[14:12] (RW)
 *
 * This bit is a write once bit and selects the clock source for tamper filter
 * for tamper detect input bit 0.
 *
 * Values:
 * - 0b000 - 32 kHz clock
 * - 0b001 - 512 Hz clock
 * - 0b010 - 128 Hz clock
 * - 0b011 - 64 Hz clock
 * - 0b100 - 16 Hz clock
 * - 0b101 - 8 Hz clock
 * - 0b110 - 4 Hz clock
 * - 0b111 - 2 Hz clock
 */
/*@{*/
/*! @brief Read current value of the RTC_FILTER01_CFG_CLK_SEL0 field. */
#define RTC_RD_FILTER01_CFG_CLK_SEL0(base) ((RTC_FILTER01_CFG_REG(base) & RTC_FILTER01_CFG_CLK_SEL0_MASK) >> RTC_FILTER01_CFG_CLK_SEL0_SHIFT)
#define RTC_BRD_FILTER01_CFG_CLK_SEL0(base) (BME_UBFX16(&RTC_FILTER01_CFG_REG(base), RTC_FILTER01_CFG_CLK_SEL0_SHIFT, RTC_FILTER01_CFG_CLK_SEL0_WIDTH))

/*! @brief Set the CLK_SEL0 field to a new value. */
#define RTC_WR_FILTER01_CFG_CLK_SEL0(base, value) (RTC_RMW_FILTER01_CFG(base, RTC_FILTER01_CFG_CLK_SEL0_MASK, RTC_FILTER01_CFG_CLK_SEL0(value)))
#define RTC_BWR_FILTER01_CFG_CLK_SEL0(base, value) (BME_BFI16(&RTC_FILTER01_CFG_REG(base), ((uint16_t)(value) << RTC_FILTER01_CFG_CLK_SEL0_SHIFT), RTC_FILTER01_CFG_CLK_SEL0_SHIFT, RTC_FILTER01_CFG_CLK_SEL0_WIDTH))
/*@}*/

/*!
 * @name Register RTC_FILTER01_CFG, field POL0[15] (RW)
 *
 * This bit controls the polarity of tamper detect input bit 0 (TAMPER[0]).
 *
 * Values:
 * - 0b0 - Tamper detect input bit 0 is active high.
 * - 0b1 - Tamper detect input bit 0 is active low.
 */
/*@{*/
/*! @brief Read current value of the RTC_FILTER01_CFG_POL0 field. */
#define RTC_RD_FILTER01_CFG_POL0(base) ((RTC_FILTER01_CFG_REG(base) & RTC_FILTER01_CFG_POL0_MASK) >> RTC_FILTER01_CFG_POL0_SHIFT)
#define RTC_BRD_FILTER01_CFG_POL0(base) (BME_UBFX16(&RTC_FILTER01_CFG_REG(base), RTC_FILTER01_CFG_POL0_SHIFT, RTC_FILTER01_CFG_POL0_WIDTH))

/*! @brief Set the POL0 field to a new value. */
#define RTC_WR_FILTER01_CFG_POL0(base, value) (RTC_RMW_FILTER01_CFG(base, RTC_FILTER01_CFG_POL0_MASK, RTC_FILTER01_CFG_POL0(value)))
#define RTC_BWR_FILTER01_CFG_POL0(base, value) (BME_BFI16(&RTC_FILTER01_CFG_REG(base), ((uint16_t)(value) << RTC_FILTER01_CFG_POL0_SHIFT), RTC_FILTER01_CFG_POL0_SHIFT, RTC_FILTER01_CFG_POL0_WIDTH))
/*@}*/

/*******************************************************************************
 * RTC_FILTER2_CFG - RTC Tamper 2 Filter Configuration Register
 ******************************************************************************/

/*!
 * @brief RTC_FILTER2_CFG - RTC Tamper 2 Filter Configuration Register (RW)
 *
 * Reset value: 0x0000U
 *
 * This register must be configured once during the initial startup of
 * application and must not be changed on the fly to avoid any erratic behavior. Changing
 * the register on the fly might lead to missing of tamper events or assertion of
 * false tamper events. Tamper 3 is an internal tamper detect bit and hence does
 * not require any filtering.
 */
/*!
 * @name Constants and macros for entire RTC_FILTER2_CFG register
 */
/*@{*/
#define RTC_RD_FILTER2_CFG(base) (RTC_FILTER2_CFG_REG(base))
#define RTC_WR_FILTER2_CFG(base, value) (RTC_FILTER2_CFG_REG(base) = (value))
#define RTC_RMW_FILTER2_CFG(base, mask, value) (RTC_WR_FILTER2_CFG(base, (RTC_RD_FILTER2_CFG(base) & ~(mask)) | (value)))
#define RTC_SET_FILTER2_CFG(base, value) (BME_OR16(&RTC_FILTER2_CFG_REG(base), (uint16_t)(value)))
#define RTC_CLR_FILTER2_CFG(base, value) (BME_AND16(&RTC_FILTER2_CFG_REG(base), (uint16_t)(~(value))))
#define RTC_TOG_FILTER2_CFG(base, value) (BME_XOR16(&RTC_FILTER2_CFG_REG(base), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual RTC_FILTER2_CFG bitfields
 */

/*!
 * @name Register RTC_FILTER2_CFG, field FIL_DUR2[11:8] (RW)
 *
 * This bit indicates the number of tamper filter clock cycles for which the
 * TAMPER[2] signal should remains stable before being detected as a tamper. These
 * bits are used by the tamper filtering operation. With the tamper duration set
 * to Zero any tamper detected on the tamper pins will directly set the tamper
 * status and interrupt bits. Caution is required when making the tamper filter
 * duration equal to 0 as any glitches on the tamper pins will cause a tamper
 * interrupt.
 *
 * Values:
 * - 0b0000 - Filtering operation disabled.
 */
/*@{*/
/*! @brief Read current value of the RTC_FILTER2_CFG_FIL_DUR2 field. */
#define RTC_RD_FILTER2_CFG_FIL_DUR2(base) ((RTC_FILTER2_CFG_REG(base) & RTC_FILTER2_CFG_FIL_DUR2_MASK) >> RTC_FILTER2_CFG_FIL_DUR2_SHIFT)
#define RTC_BRD_FILTER2_CFG_FIL_DUR2(base) (BME_UBFX16(&RTC_FILTER2_CFG_REG(base), RTC_FILTER2_CFG_FIL_DUR2_SHIFT, RTC_FILTER2_CFG_FIL_DUR2_WIDTH))

/*! @brief Set the FIL_DUR2 field to a new value. */
#define RTC_WR_FILTER2_CFG_FIL_DUR2(base, value) (RTC_RMW_FILTER2_CFG(base, RTC_FILTER2_CFG_FIL_DUR2_MASK, RTC_FILTER2_CFG_FIL_DUR2(value)))
#define RTC_BWR_FILTER2_CFG_FIL_DUR2(base, value) (BME_BFI16(&RTC_FILTER2_CFG_REG(base), ((uint16_t)(value) << RTC_FILTER2_CFG_FIL_DUR2_SHIFT), RTC_FILTER2_CFG_FIL_DUR2_SHIFT, RTC_FILTER2_CFG_FIL_DUR2_WIDTH))
/*@}*/

/*!
 * @name Register RTC_FILTER2_CFG, field CLK_SEL2[14:12] (RW)
 *
 * This bit is a write once bit and selects the clock source for tamper filter
 * for tamper detect input bit 2.
 *
 * Values:
 * - 0b000 - 32 kHz clock
 * - 0b001 - 512 Hz clock
 * - 0b010 - 128 Hz clock
 * - 0b011 - 64 Hz clock
 * - 0b100 - 16 Hz clock
 * - 0b101 - 8 Hz clock
 * - 0b110 - 4 Hz clock
 * - 0b111 - 2 Hz clock
 */
/*@{*/
/*! @brief Read current value of the RTC_FILTER2_CFG_CLK_SEL2 field. */
#define RTC_RD_FILTER2_CFG_CLK_SEL2(base) ((RTC_FILTER2_CFG_REG(base) & RTC_FILTER2_CFG_CLK_SEL2_MASK) >> RTC_FILTER2_CFG_CLK_SEL2_SHIFT)
#define RTC_BRD_FILTER2_CFG_CLK_SEL2(base) (BME_UBFX16(&RTC_FILTER2_CFG_REG(base), RTC_FILTER2_CFG_CLK_SEL2_SHIFT, RTC_FILTER2_CFG_CLK_SEL2_WIDTH))

/*! @brief Set the CLK_SEL2 field to a new value. */
#define RTC_WR_FILTER2_CFG_CLK_SEL2(base, value) (RTC_RMW_FILTER2_CFG(base, RTC_FILTER2_CFG_CLK_SEL2_MASK, RTC_FILTER2_CFG_CLK_SEL2(value)))
#define RTC_BWR_FILTER2_CFG_CLK_SEL2(base, value) (BME_BFI16(&RTC_FILTER2_CFG_REG(base), ((uint16_t)(value) << RTC_FILTER2_CFG_CLK_SEL2_SHIFT), RTC_FILTER2_CFG_CLK_SEL2_SHIFT, RTC_FILTER2_CFG_CLK_SEL2_WIDTH))
/*@}*/

/*!
 * @name Register RTC_FILTER2_CFG, field POL2[15] (RW)
 *
 * This bit controls the polarity of tamper detect input bit 2 (TAMPER[2]).
 *
 * Values:
 * - 0b0 - Tamper detect input bit 2 is active high.
 * - 0b1 - Tamper detect input bit 2 is active low.
 */
/*@{*/
/*! @brief Read current value of the RTC_FILTER2_CFG_POL2 field. */
#define RTC_RD_FILTER2_CFG_POL2(base) ((RTC_FILTER2_CFG_REG(base) & RTC_FILTER2_CFG_POL2_MASK) >> RTC_FILTER2_CFG_POL2_SHIFT)
#define RTC_BRD_FILTER2_CFG_POL2(base) (BME_UBFX16(&RTC_FILTER2_CFG_REG(base), RTC_FILTER2_CFG_POL2_SHIFT, RTC_FILTER2_CFG_POL2_WIDTH))

/*! @brief Set the POL2 field to a new value. */
#define RTC_WR_FILTER2_CFG_POL2(base, value) (RTC_RMW_FILTER2_CFG(base, RTC_FILTER2_CFG_POL2_MASK, RTC_FILTER2_CFG_POL2(value)))
#define RTC_BWR_FILTER2_CFG_POL2(base, value) (BME_BFI16(&RTC_FILTER2_CFG_REG(base), ((uint16_t)(value) << RTC_FILTER2_CFG_POL2_SHIFT), RTC_FILTER2_CFG_POL2_SHIFT, RTC_FILTER2_CFG_POL2_WIDTH))
/*@}*/

/*******************************************************************************
 * RTC_CTRL2 - RTC Control 2 Register
 ******************************************************************************/

/*!
 * @brief RTC_CTRL2 - RTC Control 2 Register (RW)
 *
 * Reset value: 0x0080U
 *
 * RTC control 2 register defines the attributes for the configuration of tamper
 * pins.
 */
/*!
 * @name Constants and macros for entire RTC_CTRL2 register
 */
/*@{*/
#define RTC_RD_CTRL2(base)       (RTC_CTRL2_REG(base))
#define RTC_WR_CTRL2(base, value) (RTC_CTRL2_REG(base) = (value))
#define RTC_RMW_CTRL2(base, mask, value) (RTC_WR_CTRL2(base, (RTC_RD_CTRL2(base) & ~(mask)) | (value)))
#define RTC_SET_CTRL2(base, value) (BME_OR16(&RTC_CTRL2_REG(base), (uint16_t)(value)))
#define RTC_CLR_CTRL2(base, value) (BME_AND16(&RTC_CTRL2_REG(base), (uint16_t)(~(value))))
#define RTC_TOG_CTRL2(base, value) (BME_XOR16(&RTC_CTRL2_REG(base), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual RTC_CTRL2 bitfields
 */

/*!
 * @name Register RTC_CTRL2, field TAMP_CFG_OVER[0] (RW)
 *
 * Set this field to 1 only when all the tamper_cfg registers are programmed.
 *
 * Values:
 * - 0b0 - Tamper filter processing disabled.
 * - 0b1 - Tamper filter processing enabled. To enable the tamper feature, this
 *     bitfield should be set.
 */
/*@{*/
/*! @brief Read current value of the RTC_CTRL2_TAMP_CFG_OVER field. */
#define RTC_RD_CTRL2_TAMP_CFG_OVER(base) ((RTC_CTRL2_REG(base) & RTC_CTRL2_TAMP_CFG_OVER_MASK) >> RTC_CTRL2_TAMP_CFG_OVER_SHIFT)
#define RTC_BRD_CTRL2_TAMP_CFG_OVER(base) (BME_UBFX16(&RTC_CTRL2_REG(base), RTC_CTRL2_TAMP_CFG_OVER_SHIFT, RTC_CTRL2_TAMP_CFG_OVER_WIDTH))

/*! @brief Set the TAMP_CFG_OVER field to a new value. */
#define RTC_WR_CTRL2_TAMP_CFG_OVER(base, value) (RTC_RMW_CTRL2(base, RTC_CTRL2_TAMP_CFG_OVER_MASK, RTC_CTRL2_TAMP_CFG_OVER(value)))
#define RTC_BWR_CTRL2_TAMP_CFG_OVER(base, value) (BME_BFI16(&RTC_CTRL2_REG(base), ((uint16_t)(value) << RTC_CTRL2_TAMP_CFG_OVER_SHIFT), RTC_CTRL2_TAMP_CFG_OVER_SHIFT, RTC_CTRL2_TAMP_CFG_OVER_WIDTH))
/*@}*/

/*!
 * @name Register RTC_CTRL2, field WAKEUP_STATUS[6:5] (RW)
 *
 * Values:
 * - 0b00 - The wakeup/hibernation pin is in HiZ mode.
 * - 0b01 - The wakeup/hibernation pin is at logic 0. MCU is in sleep mode.
 * - 0b10 - The wakeup/ hibernation pin is at logic 1. MCU is in sleep mode.
 * - 0b11 - Reserved
 */
/*@{*/
/*! @brief Read current value of the RTC_CTRL2_WAKEUP_STATUS field. */
#define RTC_RD_CTRL2_WAKEUP_STATUS(base) ((RTC_CTRL2_REG(base) & RTC_CTRL2_WAKEUP_STATUS_MASK) >> RTC_CTRL2_WAKEUP_STATUS_SHIFT)
#define RTC_BRD_CTRL2_WAKEUP_STATUS(base) (BME_UBFX16(&RTC_CTRL2_REG(base), RTC_CTRL2_WAKEUP_STATUS_SHIFT, RTC_CTRL2_WAKEUP_STATUS_WIDTH))

/*! @brief Set the WAKEUP_STATUS field to a new value. */
#define RTC_WR_CTRL2_WAKEUP_STATUS(base, value) (RTC_RMW_CTRL2(base, RTC_CTRL2_WAKEUP_STATUS_MASK, RTC_CTRL2_WAKEUP_STATUS(value)))
#define RTC_BWR_CTRL2_WAKEUP_STATUS(base, value) (BME_BFI16(&RTC_CTRL2_REG(base), ((uint16_t)(value) << RTC_CTRL2_WAKEUP_STATUS_SHIFT), RTC_CTRL2_WAKEUP_STATUS_SHIFT, RTC_CTRL2_WAKEUP_STATUS_WIDTH))
/*@}*/

/*!
 * @name Register RTC_CTRL2, field WAKEUP_MODE[7] (RW)
 *
 * Values:
 * - 0b0 - Tamper pin 0 is used as the tamper pin.
 * - 0b1 - Tamper pin 0 is used as a wakeup/hibernation pin.
 */
/*@{*/
/*! @brief Read current value of the RTC_CTRL2_WAKEUP_MODE field. */
#define RTC_RD_CTRL2_WAKEUP_MODE(base) ((RTC_CTRL2_REG(base) & RTC_CTRL2_WAKEUP_MODE_MASK) >> RTC_CTRL2_WAKEUP_MODE_SHIFT)
#define RTC_BRD_CTRL2_WAKEUP_MODE(base) (BME_UBFX16(&RTC_CTRL2_REG(base), RTC_CTRL2_WAKEUP_MODE_SHIFT, RTC_CTRL2_WAKEUP_MODE_WIDTH))

/*! @brief Set the WAKEUP_MODE field to a new value. */
#define RTC_WR_CTRL2_WAKEUP_MODE(base, value) (RTC_RMW_CTRL2(base, RTC_CTRL2_WAKEUP_MODE_MASK, RTC_CTRL2_WAKEUP_MODE(value)))
#define RTC_BWR_CTRL2_WAKEUP_MODE(base, value) (BME_BFI16(&RTC_CTRL2_REG(base), ((uint16_t)(value) << RTC_CTRL2_WAKEUP_MODE_SHIFT), RTC_CTRL2_WAKEUP_MODE_SHIFT, RTC_CTRL2_WAKEUP_MODE_WIDTH))
/*@}*/

/*
 * MKM34Z7 SIM
 *
 * System Integration Module
 *
 * Registers defined in this header file:
 * - SIM_SOPT1 - System Options Register 1
 * - SIM_SOPT1_CFG - SOPT1 Configuration Register
 * - SIM_CTRL_REG - System Control Register
 * - SIM_SDID - System Device Identification Register
 * - SIM_SCGC4 - System Clock Gating Control Register 4
 * - SIM_SCGC5 - System Clock Gating Control Register 5
 * - SIM_SCGC6 - System Clock Gating Control Register 6
 * - SIM_SCGC7 - System Clock Gating Control Register 7
 * - SIM_CLKDIV1 - System Clock Divider Register 1
 * - SIM_FCFG1 - Flash Configuration Register 1
 * - SIM_FCFG2 - Flash Configuration Register 2
 * - SIM_UIDH - Unique Identification Register High
 * - SIM_UIDMH - Unique Identification Register Mid-High
 * - SIM_UIDML - Unique Identification Register Mid-Low
 * - SIM_UIDL - Unique Identification Register Low
 * - SIM_MISC_CTL - Miscellaneous Control Register
 * - SIM_ADC_COMP0 - ADC Compensation Register 0
 * - SIM_ADC_COMP1 - ADC Compensation Register 1
 */

#define SIM_INSTANCE_COUNT (1U) /*!< Number of instances of the SIM module. */
#define SIM_IDX (0U) /*!< Instance number for SIM. */

/*******************************************************************************
 * SIM_SOPT1 - System Options Register 1
 ******************************************************************************/

/*!
 * @brief SIM_SOPT1 - System Options Register 1 (RW)
 *
 * Reset value: 0x00006000U
 *
 * The SOPT1 register is only reset on POR or LVD.
 */
/*!
 * @name Constants and macros for entire SIM_SOPT1 register
 */
/*@{*/
#define SIM_RD_SOPT1(base)       (SIM_SOPT1_REG(base))
#define SIM_WR_SOPT1(base, value) (SIM_SOPT1_REG(base) = (value))
#define SIM_RMW_SOPT1(base, mask, value) (SIM_WR_SOPT1(base, (SIM_RD_SOPT1(base) & ~(mask)) | (value)))
#define SIM_SET_SOPT1(base, value) (BME_OR32(&SIM_SOPT1_REG(base), (uint32_t)(value)))
#define SIM_CLR_SOPT1(base, value) (BME_AND32(&SIM_SOPT1_REG(base), (uint32_t)(~(value))))
#define SIM_TOG_SOPT1(base, value) (BME_XOR32(&SIM_SOPT1_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual SIM_SOPT1 bitfields
 */

/*!
 * @name Register SIM_SOPT1, field SRAMSIZE[15:12] (RO)
 *
 * Values:
 * - 0b0110 - 32 KB System RAM
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT1_SRAMSIZE field. */
#define SIM_RD_SOPT1_SRAMSIZE(base) ((SIM_SOPT1_REG(base) & SIM_SOPT1_SRAMSIZE_MASK) >> SIM_SOPT1_SRAMSIZE_SHIFT)
#define SIM_BRD_SOPT1_SRAMSIZE(base) (BME_UBFX32(&SIM_SOPT1_REG(base), SIM_SOPT1_SRAMSIZE_SHIFT, SIM_SOPT1_SRAMSIZE_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SOPT1, field OSC32KSEL[19:18] (RW)
 *
 * Selects the 32 kHz clock source for LPTMR , CLKOUT , LCD , EWM, WDOG. This
 * bit is reset only on POR/LVD.
 *
 * Values:
 * - 0b00 - OSC32KCLK (RTC Oscillator output)
 * - 0b01 - ERCLK32K
 * - 0b10 - MCGIRCLK
 * - 0b11 - LPO
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT1_OSC32KSEL field. */
#define SIM_RD_SOPT1_OSC32KSEL(base) ((SIM_SOPT1_REG(base) & SIM_SOPT1_OSC32KSEL_MASK) >> SIM_SOPT1_OSC32KSEL_SHIFT)
#define SIM_BRD_SOPT1_OSC32KSEL(base) (BME_UBFX32(&SIM_SOPT1_REG(base), SIM_SOPT1_OSC32KSEL_SHIFT, SIM_SOPT1_OSC32KSEL_WIDTH))

/*! @brief Set the OSC32KSEL field to a new value. */
#define SIM_WR_SOPT1_OSC32KSEL(base, value) (SIM_RMW_SOPT1(base, SIM_SOPT1_OSC32KSEL_MASK, SIM_SOPT1_OSC32KSEL(value)))
#define SIM_BWR_SOPT1_OSC32KSEL(base, value) (BME_BFI32(&SIM_SOPT1_REG(base), ((uint32_t)(value) << SIM_SOPT1_OSC32KSEL_SHIFT), SIM_SOPT1_OSC32KSEL_SHIFT, SIM_SOPT1_OSC32KSEL_WIDTH))
/*@}*/

/*******************************************************************************
 * SIM_SOPT1_CFG - SOPT1 Configuration Register
 ******************************************************************************/

/*!
 * @brief SIM_SOPT1_CFG - SOPT1 Configuration Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The SOPT1CFG register is reset on system reset not VLLS.
 */
/*!
 * @name Constants and macros for entire SIM_SOPT1_CFG register
 */
/*@{*/
#define SIM_RD_SOPT1_CFG(base)   (SIM_SOPT1_CFG_REG(base))
#define SIM_WR_SOPT1_CFG(base, value) (SIM_SOPT1_CFG_REG(base) = (value))
#define SIM_RMW_SOPT1_CFG(base, mask, value) (SIM_WR_SOPT1_CFG(base, (SIM_RD_SOPT1_CFG(base) & ~(mask)) | (value)))
#define SIM_SET_SOPT1_CFG(base, value) (BME_OR32(&SIM_SOPT1_CFG_REG(base), (uint32_t)(value)))
#define SIM_CLR_SOPT1_CFG(base, value) (BME_AND32(&SIM_SOPT1_CFG_REG(base), (uint32_t)(~(value))))
#define SIM_TOG_SOPT1_CFG(base, value) (BME_XOR32(&SIM_SOPT1_CFG_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual SIM_SOPT1_CFG bitfields
 */

/*!
 * @name Register SIM_SOPT1_CFG, field LPTMR0SEL[1:0] (RW)
 *
 * This field is used to select source for LP timer channel0.
 *
 * Values:
 * - 0b00 - CMP[0] output
 * - 0b01 - CMP[1] output
 * - 0b10 - CMP[2] output
 * - 0b11 - Reserved
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT1_CFG_LPTMR0SEL field. */
#define SIM_RD_SOPT1_CFG_LPTMR0SEL(base) ((SIM_SOPT1_CFG_REG(base) & SIM_SOPT1_CFG_LPTMR0SEL_MASK) >> SIM_SOPT1_CFG_LPTMR0SEL_SHIFT)
#define SIM_BRD_SOPT1_CFG_LPTMR0SEL(base) (BME_UBFX32(&SIM_SOPT1_CFG_REG(base), SIM_SOPT1_CFG_LPTMR0SEL_SHIFT, SIM_SOPT1_CFG_LPTMR0SEL_WIDTH))

/*! @brief Set the LPTMR0SEL field to a new value. */
#define SIM_WR_SOPT1_CFG_LPTMR0SEL(base, value) (SIM_RMW_SOPT1_CFG(base, SIM_SOPT1_CFG_LPTMR0SEL_MASK, SIM_SOPT1_CFG_LPTMR0SEL(value)))
#define SIM_BWR_SOPT1_CFG_LPTMR0SEL(base, value) (BME_BFI32(&SIM_SOPT1_CFG_REG(base), ((uint32_t)(value) << SIM_SOPT1_CFG_LPTMR0SEL_SHIFT), SIM_SOPT1_CFG_LPTMR0SEL_SHIFT, SIM_SOPT1_CFG_LPTMR0SEL_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SOPT1_CFG, field LPTMR1SEL[3:2] (RW)
 *
 * This field is used to select source for LP timer channel1.
 *
 * Values:
 * - 0b00 - Pad PTE4
 * - 0b01 - Pad PTF4
 * - 0b10 - Pad PTG1
 * - 0b11 - Reserved
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT1_CFG_LPTMR1SEL field. */
#define SIM_RD_SOPT1_CFG_LPTMR1SEL(base) ((SIM_SOPT1_CFG_REG(base) & SIM_SOPT1_CFG_LPTMR1SEL_MASK) >> SIM_SOPT1_CFG_LPTMR1SEL_SHIFT)
#define SIM_BRD_SOPT1_CFG_LPTMR1SEL(base) (BME_UBFX32(&SIM_SOPT1_CFG_REG(base), SIM_SOPT1_CFG_LPTMR1SEL_SHIFT, SIM_SOPT1_CFG_LPTMR1SEL_WIDTH))

/*! @brief Set the LPTMR1SEL field to a new value. */
#define SIM_WR_SOPT1_CFG_LPTMR1SEL(base, value) (SIM_RMW_SOPT1_CFG(base, SIM_SOPT1_CFG_LPTMR1SEL_MASK, SIM_SOPT1_CFG_LPTMR1SEL(value)))
#define SIM_BWR_SOPT1_CFG_LPTMR1SEL(base, value) (BME_BFI32(&SIM_SOPT1_CFG_REG(base), ((uint32_t)(value) << SIM_SOPT1_CFG_LPTMR1SEL_SHIFT), SIM_SOPT1_CFG_LPTMR1SEL_SHIFT, SIM_SOPT1_CFG_LPTMR1SEL_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SOPT1_CFG, field LPTMR2SEL[5:4] (RW)
 *
 * This field is used to select source for LP timer channel2.
 *
 * Values:
 * - 0b00 - Pad PTD6
 * - 0b01 - Pad PTF3
 * - 0b10 - Pad PTG5
 * - 0b11 - Reserved
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT1_CFG_LPTMR2SEL field. */
#define SIM_RD_SOPT1_CFG_LPTMR2SEL(base) ((SIM_SOPT1_CFG_REG(base) & SIM_SOPT1_CFG_LPTMR2SEL_MASK) >> SIM_SOPT1_CFG_LPTMR2SEL_SHIFT)
#define SIM_BRD_SOPT1_CFG_LPTMR2SEL(base) (BME_UBFX32(&SIM_SOPT1_CFG_REG(base), SIM_SOPT1_CFG_LPTMR2SEL_SHIFT, SIM_SOPT1_CFG_LPTMR2SEL_WIDTH))

/*! @brief Set the LPTMR2SEL field to a new value. */
#define SIM_WR_SOPT1_CFG_LPTMR2SEL(base, value) (SIM_RMW_SOPT1_CFG(base, SIM_SOPT1_CFG_LPTMR2SEL_MASK, SIM_SOPT1_CFG_LPTMR2SEL(value)))
#define SIM_BWR_SOPT1_CFG_LPTMR2SEL(base, value) (BME_BFI32(&SIM_SOPT1_CFG_REG(base), ((uint32_t)(value) << SIM_SOPT1_CFG_LPTMR2SEL_SHIFT), SIM_SOPT1_CFG_LPTMR2SEL_SHIFT, SIM_SOPT1_CFG_LPTMR2SEL_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SOPT1_CFG, field LPTMR3SEL[7:6] (RW)
 *
 * This field is used to select source for LP timer channel3.
 *
 * Values:
 * - 0b00 - Pad PTD5
 * - 0b01 - Pad PTG0
 * - 0b10 - Pad PTG6
 * - 0b11 - Reserved
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT1_CFG_LPTMR3SEL field. */
#define SIM_RD_SOPT1_CFG_LPTMR3SEL(base) ((SIM_SOPT1_CFG_REG(base) & SIM_SOPT1_CFG_LPTMR3SEL_MASK) >> SIM_SOPT1_CFG_LPTMR3SEL_SHIFT)
#define SIM_BRD_SOPT1_CFG_LPTMR3SEL(base) (BME_UBFX32(&SIM_SOPT1_CFG_REG(base), SIM_SOPT1_CFG_LPTMR3SEL_SHIFT, SIM_SOPT1_CFG_LPTMR3SEL_WIDTH))

/*! @brief Set the LPTMR3SEL field to a new value. */
#define SIM_WR_SOPT1_CFG_LPTMR3SEL(base, value) (SIM_RMW_SOPT1_CFG(base, SIM_SOPT1_CFG_LPTMR3SEL_MASK, SIM_SOPT1_CFG_LPTMR3SEL(value)))
#define SIM_BWR_SOPT1_CFG_LPTMR3SEL(base, value) (BME_BFI32(&SIM_SOPT1_CFG_REG(base), ((uint32_t)(value) << SIM_SOPT1_CFG_LPTMR3SEL_SHIFT), SIM_SOPT1_CFG_LPTMR3SEL_SHIFT, SIM_SOPT1_CFG_LPTMR3SEL_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SOPT1_CFG, field RAMSBDIS[8] (RW)
 *
 * Disable source bias of System SRAM arrays during VLPR and VLPW modes.
 *
 * Values:
 * - 0b0 - Source bias of System SRAM enabled during VLPR and VLPW modes.
 * - 0b1 - Source bias of System SRAM disabled during VLPR and VLPW modes.
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT1_CFG_RAMSBDIS field. */
#define SIM_RD_SOPT1_CFG_RAMSBDIS(base) ((SIM_SOPT1_CFG_REG(base) & SIM_SOPT1_CFG_RAMSBDIS_MASK) >> SIM_SOPT1_CFG_RAMSBDIS_SHIFT)
#define SIM_BRD_SOPT1_CFG_RAMSBDIS(base) (BME_UBFX32(&SIM_SOPT1_CFG_REG(base), SIM_SOPT1_CFG_RAMSBDIS_SHIFT, SIM_SOPT1_CFG_RAMSBDIS_WIDTH))

/*! @brief Set the RAMSBDIS field to a new value. */
#define SIM_WR_SOPT1_CFG_RAMSBDIS(base, value) (SIM_RMW_SOPT1_CFG(base, SIM_SOPT1_CFG_RAMSBDIS_MASK, SIM_SOPT1_CFG_RAMSBDIS(value)))
#define SIM_BWR_SOPT1_CFG_RAMSBDIS(base, value) (BME_BFI32(&SIM_SOPT1_CFG_REG(base), ((uint32_t)(value) << SIM_SOPT1_CFG_RAMSBDIS_SHIFT), SIM_SOPT1_CFG_RAMSBDIS_SHIFT, SIM_SOPT1_CFG_RAMSBDIS_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SOPT1_CFG, field RAMBPEN[9] (RW)
 *
 * Enable System SRAM bitline precharge during VLPR and VLPW modes.
 *
 * Values:
 * - 0b0 - Bitline precharge of system SRAM disabled during VLPR and VLPW modes.
 * - 0b1 - Bitline precharge of system SRAM enabled during VLPR and VLPW modes.
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT1_CFG_RAMBPEN field. */
#define SIM_RD_SOPT1_CFG_RAMBPEN(base) ((SIM_SOPT1_CFG_REG(base) & SIM_SOPT1_CFG_RAMBPEN_MASK) >> SIM_SOPT1_CFG_RAMBPEN_SHIFT)
#define SIM_BRD_SOPT1_CFG_RAMBPEN(base) (BME_UBFX32(&SIM_SOPT1_CFG_REG(base), SIM_SOPT1_CFG_RAMBPEN_SHIFT, SIM_SOPT1_CFG_RAMBPEN_WIDTH))

/*! @brief Set the RAMBPEN field to a new value. */
#define SIM_WR_SOPT1_CFG_RAMBPEN(base, value) (SIM_RMW_SOPT1_CFG(base, SIM_SOPT1_CFG_RAMBPEN_MASK, SIM_SOPT1_CFG_RAMBPEN(value)))
#define SIM_BWR_SOPT1_CFG_RAMBPEN(base, value) (BME_BFI32(&SIM_SOPT1_CFG_REG(base), ((uint32_t)(value) << SIM_SOPT1_CFG_RAMBPEN_SHIFT), SIM_SOPT1_CFG_RAMBPEN_SHIFT, SIM_SOPT1_CFG_RAMBPEN_WIDTH))
/*@}*/

/*******************************************************************************
 * SIM_CTRL_REG - System Control Register
 ******************************************************************************/

/*!
 * @brief SIM_CTRL_REG - System Control Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * Writes to this register can only be performed in Supervisor mode
 */
/*!
 * @name Constants and macros for entire SIM_CTRL_REG register
 */
/*@{*/
#define SIM_RD_CTRL_REG(base)    (SIM_CTRL_REG_REG(base))
#define SIM_WR_CTRL_REG(base, value) (SIM_CTRL_REG_REG(base) = (value))
#define SIM_RMW_CTRL_REG(base, mask, value) (SIM_WR_CTRL_REG(base, (SIM_RD_CTRL_REG(base) & ~(mask)) | (value)))
#define SIM_SET_CTRL_REG(base, value) (BME_OR32(&SIM_CTRL_REG_REG(base), (uint32_t)(value)))
#define SIM_CLR_CTRL_REG(base, value) (BME_AND32(&SIM_CTRL_REG_REG(base), (uint32_t)(~(value))))
#define SIM_TOG_CTRL_REG(base, value) (BME_XOR32(&SIM_CTRL_REG_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual SIM_CTRL_REG bitfields
 */

/*!
 * @name Register SIM_CTRL_REG, field NMIDIS[0] (RW)
 *
 * This field is used as an alternate to FTFL_FOPT[2] to disable the NMI
 * temporarily. It is also advised to program this bit while changing the state of the
 * NMI pin from NMI to GPIO functionality.
 *
 * Values:
 * - 0b0 - NMI enabled
 * - 0b1 - NMI disabled
 */
/*@{*/
/*! @brief Read current value of the SIM_CTRL_REG_NMIDIS field. */
#define SIM_RD_CTRL_REG_NMIDIS(base) ((SIM_CTRL_REG_REG(base) & SIM_CTRL_REG_NMIDIS_MASK) >> SIM_CTRL_REG_NMIDIS_SHIFT)
#define SIM_BRD_CTRL_REG_NMIDIS(base) (BME_UBFX32(&SIM_CTRL_REG_REG(base), SIM_CTRL_REG_NMIDIS_SHIFT, SIM_CTRL_REG_NMIDIS_WIDTH))

/*! @brief Set the NMIDIS field to a new value. */
#define SIM_WR_CTRL_REG_NMIDIS(base, value) (SIM_RMW_CTRL_REG(base, SIM_CTRL_REG_NMIDIS_MASK, SIM_CTRL_REG_NMIDIS(value)))
#define SIM_BWR_CTRL_REG_NMIDIS(base, value) (BME_BFI32(&SIM_CTRL_REG_REG(base), ((uint32_t)(value) << SIM_CTRL_REG_NMIDIS_SHIFT), SIM_CTRL_REG_NMIDIS_SHIFT, SIM_CTRL_REG_NMIDIS_WIDTH))
/*@}*/

/*!
 * @name Register SIM_CTRL_REG, field PLLVLPEN[1] (RW)
 *
 * When set, this bit enables the PLL in VLP modes. Valid operating mode
 * transitions with PLLVLPEN enabled are: RUN->VLPR(also with PSTOP1)->RUN and
 * RUN->VLPR(+PSTOP1)->RESET. MCG must be set to BLPI mode by software, if PLLVLPEN is
 * enabled before entering VLPR mode. Prior to entering any low power mode, disable
 * PLLVLPEN. When in VLPR mode with PLL module operating, do not disable the PMC
 * bandgap.
 */
/*@{*/
/*! @brief Read current value of the SIM_CTRL_REG_PLLVLPEN field. */
#define SIM_RD_CTRL_REG_PLLVLPEN(base) ((SIM_CTRL_REG_REG(base) & SIM_CTRL_REG_PLLVLPEN_MASK) >> SIM_CTRL_REG_PLLVLPEN_SHIFT)
#define SIM_BRD_CTRL_REG_PLLVLPEN(base) (BME_UBFX32(&SIM_CTRL_REG_REG(base), SIM_CTRL_REG_PLLVLPEN_SHIFT, SIM_CTRL_REG_PLLVLPEN_WIDTH))

/*! @brief Set the PLLVLPEN field to a new value. */
#define SIM_WR_CTRL_REG_PLLVLPEN(base, value) (SIM_RMW_CTRL_REG(base, SIM_CTRL_REG_PLLVLPEN_MASK, SIM_CTRL_REG_PLLVLPEN(value)))
#define SIM_BWR_CTRL_REG_PLLVLPEN(base, value) (BME_BFI32(&SIM_CTRL_REG_REG(base), ((uint32_t)(value) << SIM_CTRL_REG_PLLVLPEN_SHIFT), SIM_CTRL_REG_PLLVLPEN_SHIFT, SIM_CTRL_REG_PLLVLPEN_WIDTH))
/*@}*/

/*!
 * @name Register SIM_CTRL_REG, field ADCTRGSEL[4:3] (RW)
 *
 * Selects the clock used to generate the ADC triggers.
 *
 * Values:
 * - 0b00 - Bus ClockDuring Low Power Modes such as stop, the Bus clock is not
 *     available for conversion and should not be selected in case a conversion
 *     needs to be performed while in stop.
 * - 0b01 - ADC asynchronous Clock
 * - 0b10 - ERCLK32K
 * - 0b11 - OSCCLK
 */
/*@{*/
/*! @brief Read current value of the SIM_CTRL_REG_ADCTRGSEL field. */
#define SIM_RD_CTRL_REG_ADCTRGSEL(base) ((SIM_CTRL_REG_REG(base) & SIM_CTRL_REG_ADCTRGSEL_MASK) >> SIM_CTRL_REG_ADCTRGSEL_SHIFT)
#define SIM_BRD_CTRL_REG_ADCTRGSEL(base) (BME_UBFX32(&SIM_CTRL_REG_REG(base), SIM_CTRL_REG_ADCTRGSEL_SHIFT, SIM_CTRL_REG_ADCTRGSEL_WIDTH))

/*! @brief Set the ADCTRGSEL field to a new value. */
#define SIM_WR_CTRL_REG_ADCTRGSEL(base, value) (SIM_RMW_CTRL_REG(base, SIM_CTRL_REG_ADCTRGSEL_MASK, SIM_CTRL_REG_ADCTRGSEL(value)))
#define SIM_BWR_CTRL_REG_ADCTRGSEL(base, value) (BME_BFI32(&SIM_CTRL_REG_REG(base), ((uint32_t)(value) << SIM_CTRL_REG_ADCTRGSEL_SHIFT), SIM_CTRL_REG_ADCTRGSEL_SHIFT, SIM_CTRL_REG_ADCTRGSEL_WIDTH))
/*@}*/

/*!
 * @name Register SIM_CTRL_REG, field CLKOUT[7:5] (RW)
 *
 * This field can be used to select one of the following clocks for CLKOUT pin.
 *
 * Values:
 * - 0b000 - Disabled
 * - 0b001 - Gated Core Clk
 * - 0b010 - Bus Clk
 * - 0b011 - LPO clock from PMC
 * - 0b100 - IRC clock from MCG
 * - 0b101 - Muxed 32Khz source (please refer to SOPT1[19:18] for possible
 *     options)
 * - 0b110 - MHz Oscillator external reference clock
 * - 0b111 - PLL clock output from MCG
 */
/*@{*/
/*! @brief Read current value of the SIM_CTRL_REG_CLKOUT field. */
#define SIM_RD_CTRL_REG_CLKOUT(base) ((SIM_CTRL_REG_REG(base) & SIM_CTRL_REG_CLKOUT_MASK) >> SIM_CTRL_REG_CLKOUT_SHIFT)
#define SIM_BRD_CTRL_REG_CLKOUT(base) (BME_UBFX32(&SIM_CTRL_REG_REG(base), SIM_CTRL_REG_CLKOUT_SHIFT, SIM_CTRL_REG_CLKOUT_WIDTH))

/*! @brief Set the CLKOUT field to a new value. */
#define SIM_WR_CTRL_REG_CLKOUT(base, value) (SIM_RMW_CTRL_REG(base, SIM_CTRL_REG_CLKOUT_MASK, SIM_CTRL_REG_CLKOUT(value)))
#define SIM_BWR_CTRL_REG_CLKOUT(base, value) (BME_BFI32(&SIM_CTRL_REG_REG(base), ((uint32_t)(value) << SIM_CTRL_REG_CLKOUT_SHIFT), SIM_CTRL_REG_CLKOUT_SHIFT, SIM_CTRL_REG_CLKOUT_WIDTH))
/*@}*/

/*!
 * @name Register SIM_CTRL_REG, field SPI0_INV0[8] (RW)
 *
 * This bit inverts the SPI0 signal output.
 *
 * Values:
 * - 0b0 - not inverted
 * - 0b1 - inverts SS
 */
/*@{*/
/*! @brief Read current value of the SIM_CTRL_REG_SPI0_INV0 field. */
#define SIM_RD_CTRL_REG_SPI0_INV0(base) ((SIM_CTRL_REG_REG(base) & SIM_CTRL_REG_SPI0_INV0_MASK) >> SIM_CTRL_REG_SPI0_INV0_SHIFT)
#define SIM_BRD_CTRL_REG_SPI0_INV0(base) (BME_UBFX32(&SIM_CTRL_REG_REG(base), SIM_CTRL_REG_SPI0_INV0_SHIFT, SIM_CTRL_REG_SPI0_INV0_WIDTH))

/*! @brief Set the SPI0_INV0 field to a new value. */
#define SIM_WR_CTRL_REG_SPI0_INV0(base, value) (SIM_RMW_CTRL_REG(base, SIM_CTRL_REG_SPI0_INV0_MASK, SIM_CTRL_REG_SPI0_INV0(value)))
#define SIM_BWR_CTRL_REG_SPI0_INV0(base, value) (BME_BFI32(&SIM_CTRL_REG_REG(base), ((uint32_t)(value) << SIM_CTRL_REG_SPI0_INV0_SHIFT), SIM_CTRL_REG_SPI0_INV0_SHIFT, SIM_CTRL_REG_SPI0_INV0_WIDTH))
/*@}*/

/*!
 * @name Register SIM_CTRL_REG, field SPI0_INV1[9] (RW)
 *
 * This bit inverts the SPI0 signal output.
 *
 * Values:
 * - 0b0 - not inverted
 * - 0b1 - inverts SCK
 */
/*@{*/
/*! @brief Read current value of the SIM_CTRL_REG_SPI0_INV1 field. */
#define SIM_RD_CTRL_REG_SPI0_INV1(base) ((SIM_CTRL_REG_REG(base) & SIM_CTRL_REG_SPI0_INV1_MASK) >> SIM_CTRL_REG_SPI0_INV1_SHIFT)
#define SIM_BRD_CTRL_REG_SPI0_INV1(base) (BME_UBFX32(&SIM_CTRL_REG_REG(base), SIM_CTRL_REG_SPI0_INV1_SHIFT, SIM_CTRL_REG_SPI0_INV1_WIDTH))

/*! @brief Set the SPI0_INV1 field to a new value. */
#define SIM_WR_CTRL_REG_SPI0_INV1(base, value) (SIM_RMW_CTRL_REG(base, SIM_CTRL_REG_SPI0_INV1_MASK, SIM_CTRL_REG_SPI0_INV1(value)))
#define SIM_BWR_CTRL_REG_SPI0_INV1(base, value) (BME_BFI32(&SIM_CTRL_REG_REG(base), ((uint32_t)(value) << SIM_CTRL_REG_SPI0_INV1_SHIFT), SIM_CTRL_REG_SPI0_INV1_SHIFT, SIM_CTRL_REG_SPI0_INV1_WIDTH))
/*@}*/

/*!
 * @name Register SIM_CTRL_REG, field SPI0_INV2[10] (RW)
 *
 * This bit inverts the SPI0 signal output.
 *
 * Values:
 * - 0b0 - not inverted
 * - 0b1 - inverts MOSI
 */
/*@{*/
/*! @brief Read current value of the SIM_CTRL_REG_SPI0_INV2 field. */
#define SIM_RD_CTRL_REG_SPI0_INV2(base) ((SIM_CTRL_REG_REG(base) & SIM_CTRL_REG_SPI0_INV2_MASK) >> SIM_CTRL_REG_SPI0_INV2_SHIFT)
#define SIM_BRD_CTRL_REG_SPI0_INV2(base) (BME_UBFX32(&SIM_CTRL_REG_REG(base), SIM_CTRL_REG_SPI0_INV2_SHIFT, SIM_CTRL_REG_SPI0_INV2_WIDTH))

/*! @brief Set the SPI0_INV2 field to a new value. */
#define SIM_WR_CTRL_REG_SPI0_INV2(base, value) (SIM_RMW_CTRL_REG(base, SIM_CTRL_REG_SPI0_INV2_MASK, SIM_CTRL_REG_SPI0_INV2(value)))
#define SIM_BWR_CTRL_REG_SPI0_INV2(base, value) (BME_BFI32(&SIM_CTRL_REG_REG(base), ((uint32_t)(value) << SIM_CTRL_REG_SPI0_INV2_SHIFT), SIM_CTRL_REG_SPI0_INV2_SHIFT, SIM_CTRL_REG_SPI0_INV2_WIDTH))
/*@}*/

/*!
 * @name Register SIM_CTRL_REG, field SPI0_INV3[11] (RW)
 *
 * This bit inverts the SPI0 signal output.
 *
 * Values:
 * - 0b0 - not inverted
 * - 0b1 - inverts MISO
 */
/*@{*/
/*! @brief Read current value of the SIM_CTRL_REG_SPI0_INV3 field. */
#define SIM_RD_CTRL_REG_SPI0_INV3(base) ((SIM_CTRL_REG_REG(base) & SIM_CTRL_REG_SPI0_INV3_MASK) >> SIM_CTRL_REG_SPI0_INV3_SHIFT)
#define SIM_BRD_CTRL_REG_SPI0_INV3(base) (BME_UBFX32(&SIM_CTRL_REG_REG(base), SIM_CTRL_REG_SPI0_INV3_SHIFT, SIM_CTRL_REG_SPI0_INV3_WIDTH))

/*! @brief Set the SPI0_INV3 field to a new value. */
#define SIM_WR_CTRL_REG_SPI0_INV3(base, value) (SIM_RMW_CTRL_REG(base, SIM_CTRL_REG_SPI0_INV3_MASK, SIM_CTRL_REG_SPI0_INV3(value)))
#define SIM_BWR_CTRL_REG_SPI0_INV3(base, value) (BME_BFI32(&SIM_CTRL_REG_REG(base), ((uint32_t)(value) << SIM_CTRL_REG_SPI0_INV3_SHIFT), SIM_CTRL_REG_SPI0_INV3_SHIFT, SIM_CTRL_REG_SPI0_INV3_WIDTH))
/*@}*/

/*!
 * @name Register SIM_CTRL_REG, field SPI1_INV0[12] (RW)
 *
 * This bit inverts the SPI1 signal output.
 *
 * Values:
 * - 0b0 - not inverted
 * - 0b1 - inverts SS
 */
/*@{*/
/*! @brief Read current value of the SIM_CTRL_REG_SPI1_INV0 field. */
#define SIM_RD_CTRL_REG_SPI1_INV0(base) ((SIM_CTRL_REG_REG(base) & SIM_CTRL_REG_SPI1_INV0_MASK) >> SIM_CTRL_REG_SPI1_INV0_SHIFT)
#define SIM_BRD_CTRL_REG_SPI1_INV0(base) (BME_UBFX32(&SIM_CTRL_REG_REG(base), SIM_CTRL_REG_SPI1_INV0_SHIFT, SIM_CTRL_REG_SPI1_INV0_WIDTH))

/*! @brief Set the SPI1_INV0 field to a new value. */
#define SIM_WR_CTRL_REG_SPI1_INV0(base, value) (SIM_RMW_CTRL_REG(base, SIM_CTRL_REG_SPI1_INV0_MASK, SIM_CTRL_REG_SPI1_INV0(value)))
#define SIM_BWR_CTRL_REG_SPI1_INV0(base, value) (BME_BFI32(&SIM_CTRL_REG_REG(base), ((uint32_t)(value) << SIM_CTRL_REG_SPI1_INV0_SHIFT), SIM_CTRL_REG_SPI1_INV0_SHIFT, SIM_CTRL_REG_SPI1_INV0_WIDTH))
/*@}*/

/*!
 * @name Register SIM_CTRL_REG, field SPI1_INV1[13] (RW)
 *
 * This bit inverts the SPI1 signal output.
 *
 * Values:
 * - 0b0 - not inverted
 * - 0b1 - inverts SCK
 */
/*@{*/
/*! @brief Read current value of the SIM_CTRL_REG_SPI1_INV1 field. */
#define SIM_RD_CTRL_REG_SPI1_INV1(base) ((SIM_CTRL_REG_REG(base) & SIM_CTRL_REG_SPI1_INV1_MASK) >> SIM_CTRL_REG_SPI1_INV1_SHIFT)
#define SIM_BRD_CTRL_REG_SPI1_INV1(base) (BME_UBFX32(&SIM_CTRL_REG_REG(base), SIM_CTRL_REG_SPI1_INV1_SHIFT, SIM_CTRL_REG_SPI1_INV1_WIDTH))

/*! @brief Set the SPI1_INV1 field to a new value. */
#define SIM_WR_CTRL_REG_SPI1_INV1(base, value) (SIM_RMW_CTRL_REG(base, SIM_CTRL_REG_SPI1_INV1_MASK, SIM_CTRL_REG_SPI1_INV1(value)))
#define SIM_BWR_CTRL_REG_SPI1_INV1(base, value) (BME_BFI32(&SIM_CTRL_REG_REG(base), ((uint32_t)(value) << SIM_CTRL_REG_SPI1_INV1_SHIFT), SIM_CTRL_REG_SPI1_INV1_SHIFT, SIM_CTRL_REG_SPI1_INV1_WIDTH))
/*@}*/

/*!
 * @name Register SIM_CTRL_REG, field SPI1_INV2[14] (RW)
 *
 * This bit inverts the SPI1 signal output.
 *
 * Values:
 * - 0b0 - not inverted
 * - 0b1 - inverts MOSI
 */
/*@{*/
/*! @brief Read current value of the SIM_CTRL_REG_SPI1_INV2 field. */
#define SIM_RD_CTRL_REG_SPI1_INV2(base) ((SIM_CTRL_REG_REG(base) & SIM_CTRL_REG_SPI1_INV2_MASK) >> SIM_CTRL_REG_SPI1_INV2_SHIFT)
#define SIM_BRD_CTRL_REG_SPI1_INV2(base) (BME_UBFX32(&SIM_CTRL_REG_REG(base), SIM_CTRL_REG_SPI1_INV2_SHIFT, SIM_CTRL_REG_SPI1_INV2_WIDTH))

/*! @brief Set the SPI1_INV2 field to a new value. */
#define SIM_WR_CTRL_REG_SPI1_INV2(base, value) (SIM_RMW_CTRL_REG(base, SIM_CTRL_REG_SPI1_INV2_MASK, SIM_CTRL_REG_SPI1_INV2(value)))
#define SIM_BWR_CTRL_REG_SPI1_INV2(base, value) (BME_BFI32(&SIM_CTRL_REG_REG(base), ((uint32_t)(value) << SIM_CTRL_REG_SPI1_INV2_SHIFT), SIM_CTRL_REG_SPI1_INV2_SHIFT, SIM_CTRL_REG_SPI1_INV2_WIDTH))
/*@}*/

/*!
 * @name Register SIM_CTRL_REG, field SPI1_INV3[15] (RW)
 *
 * This bit inverts the SPI1 signal output.
 *
 * Values:
 * - 0b0 - not inverted
 * - 0b1 - inverts MISO
 */
/*@{*/
/*! @brief Read current value of the SIM_CTRL_REG_SPI1_INV3 field. */
#define SIM_RD_CTRL_REG_SPI1_INV3(base) ((SIM_CTRL_REG_REG(base) & SIM_CTRL_REG_SPI1_INV3_MASK) >> SIM_CTRL_REG_SPI1_INV3_SHIFT)
#define SIM_BRD_CTRL_REG_SPI1_INV3(base) (BME_UBFX32(&SIM_CTRL_REG_REG(base), SIM_CTRL_REG_SPI1_INV3_SHIFT, SIM_CTRL_REG_SPI1_INV3_WIDTH))

/*! @brief Set the SPI1_INV3 field to a new value. */
#define SIM_WR_CTRL_REG_SPI1_INV3(base, value) (SIM_RMW_CTRL_REG(base, SIM_CTRL_REG_SPI1_INV3_MASK, SIM_CTRL_REG_SPI1_INV3(value)))
#define SIM_BWR_CTRL_REG_SPI1_INV3(base, value) (BME_BFI32(&SIM_CTRL_REG_REG(base), ((uint32_t)(value) << SIM_CTRL_REG_SPI1_INV3_SHIFT), SIM_CTRL_REG_SPI1_INV3_SHIFT, SIM_CTRL_REG_SPI1_INV3_WIDTH))
/*@}*/

/*!
 * @name Register SIM_CTRL_REG, field PLLFLLSEL[17:16] (RW)
 *
 * This bitfield configures the MCGPLLCLK/MCGFLLCLK.
 *
 * Values:
 * - 0b00 - MCGFLLCLK
 * - 0b01 - MCGPLLCLK
 * - 0b10 - BUSCLK
 * - 0b11 - OSC32KCLK (RTC Oscillator output)
 */
/*@{*/
/*! @brief Read current value of the SIM_CTRL_REG_PLLFLLSEL field. */
#define SIM_RD_CTRL_REG_PLLFLLSEL(base) ((SIM_CTRL_REG_REG(base) & SIM_CTRL_REG_PLLFLLSEL_MASK) >> SIM_CTRL_REG_PLLFLLSEL_SHIFT)
#define SIM_BRD_CTRL_REG_PLLFLLSEL(base) (BME_UBFX32(&SIM_CTRL_REG_REG(base), SIM_CTRL_REG_PLLFLLSEL_SHIFT, SIM_CTRL_REG_PLLFLLSEL_WIDTH))

/*! @brief Set the PLLFLLSEL field to a new value. */
#define SIM_WR_CTRL_REG_PLLFLLSEL(base, value) (SIM_RMW_CTRL_REG(base, SIM_CTRL_REG_PLLFLLSEL_MASK, SIM_CTRL_REG_PLLFLLSEL(value)))
#define SIM_BWR_CTRL_REG_PLLFLLSEL(base, value) (BME_BFI32(&SIM_CTRL_REG_REG(base), ((uint32_t)(value) << SIM_CTRL_REG_PLLFLLSEL_SHIFT), SIM_CTRL_REG_PLLFLLSEL_SHIFT, SIM_CTRL_REG_PLLFLLSEL_WIDTH))
/*@}*/

/*!
 * @name Register SIM_CTRL_REG, field XBARCLKOUT[23:21] (RW)
 *
 * Selects the clock to XBAR_IN[5]
 *
 * Values:
 * - 0b000 - Disabled
 * - 0b001 - Gated Core Clk
 * - 0b010 - Bus Clk
 * - 0b011 - LPO clock from PMC
 * - 0b100 - IRC clock from MCG
 * - 0b101 - MUXed 32 kHz source (please refer to SOPT1[19:18] for possible
 *     options)
 * - 0b110 - MHz Oscillator external reference clock
 * - 0b111 - PLL clock output from MCG
 */
/*@{*/
/*! @brief Read current value of the SIM_CTRL_REG_XBARCLKOUT field. */
#define SIM_RD_CTRL_REG_XBARCLKOUT(base) ((SIM_CTRL_REG_REG(base) & SIM_CTRL_REG_XBARCLKOUT_MASK) >> SIM_CTRL_REG_XBARCLKOUT_SHIFT)
#define SIM_BRD_CTRL_REG_XBARCLKOUT(base) (BME_UBFX32(&SIM_CTRL_REG_REG(base), SIM_CTRL_REG_XBARCLKOUT_SHIFT, SIM_CTRL_REG_XBARCLKOUT_WIDTH))

/*! @brief Set the XBARCLKOUT field to a new value. */
#define SIM_WR_CTRL_REG_XBARCLKOUT(base, value) (SIM_RMW_CTRL_REG(base, SIM_CTRL_REG_XBARCLKOUT_MASK, SIM_CTRL_REG_XBARCLKOUT(value)))
#define SIM_BWR_CTRL_REG_XBARCLKOUT(base, value) (BME_BFI32(&SIM_CTRL_REG_REG(base), ((uint32_t)(value) << SIM_CTRL_REG_XBARCLKOUT_SHIFT), SIM_CTRL_REG_XBARCLKOUT_SHIFT, SIM_CTRL_REG_XBARCLKOUT_WIDTH))
/*@}*/

/*!
 * @name Register SIM_CTRL_REG, field AFEOUTCLKSEL[24] (RW)
 *
 * Values:
 * - 0b0 - AFE output clock is divided by AFE clock prescaler.
 * - 0b1 - AFE output clock is NOT divided by AFE clock prescaler.
 */
/*@{*/
/*! @brief Read current value of the SIM_CTRL_REG_AFEOUTCLKSEL field. */
#define SIM_RD_CTRL_REG_AFEOUTCLKSEL(base) ((SIM_CTRL_REG_REG(base) & SIM_CTRL_REG_AFEOUTCLKSEL_MASK) >> SIM_CTRL_REG_AFEOUTCLKSEL_SHIFT)
#define SIM_BRD_CTRL_REG_AFEOUTCLKSEL(base) (BME_UBFX32(&SIM_CTRL_REG_REG(base), SIM_CTRL_REG_AFEOUTCLKSEL_SHIFT, SIM_CTRL_REG_AFEOUTCLKSEL_WIDTH))

/*! @brief Set the AFEOUTCLKSEL field to a new value. */
#define SIM_WR_CTRL_REG_AFEOUTCLKSEL(base, value) (SIM_RMW_CTRL_REG(base, SIM_CTRL_REG_AFEOUTCLKSEL_MASK, SIM_CTRL_REG_AFEOUTCLKSEL(value)))
#define SIM_BWR_CTRL_REG_AFEOUTCLKSEL(base, value) (BME_BFI32(&SIM_CTRL_REG_REG(base), ((uint32_t)(value) << SIM_CTRL_REG_AFEOUTCLKSEL_SHIFT), SIM_CTRL_REG_AFEOUTCLKSEL_SHIFT, SIM_CTRL_REG_AFEOUTCLKSEL_WIDTH))
/*@}*/

/*!
 * @name Register SIM_CTRL_REG, field LPUARTSRC[27:26] (RW)
 *
 * Values:
 * - 0b00 - Clock disabled
 * - 0b01 - MCGPLLCLK/MCGFLLCLK
 * - 0b10 - OSCERCLK
 * - 0b11 - MCGIRCLK
 */
/*@{*/
/*! @brief Read current value of the SIM_CTRL_REG_LPUARTSRC field. */
#define SIM_RD_CTRL_REG_LPUARTSRC(base) ((SIM_CTRL_REG_REG(base) & SIM_CTRL_REG_LPUARTSRC_MASK) >> SIM_CTRL_REG_LPUARTSRC_SHIFT)
#define SIM_BRD_CTRL_REG_LPUARTSRC(base) (BME_UBFX32(&SIM_CTRL_REG_REG(base), SIM_CTRL_REG_LPUARTSRC_SHIFT, SIM_CTRL_REG_LPUARTSRC_WIDTH))

/*! @brief Set the LPUARTSRC field to a new value. */
#define SIM_WR_CTRL_REG_LPUARTSRC(base, value) (SIM_RMW_CTRL_REG(base, SIM_CTRL_REG_LPUARTSRC_MASK, SIM_CTRL_REG_LPUARTSRC(value)))
#define SIM_BWR_CTRL_REG_LPUARTSRC(base, value) (BME_BFI32(&SIM_CTRL_REG_REG(base), ((uint32_t)(value) << SIM_CTRL_REG_LPUARTSRC_SHIFT), SIM_CTRL_REG_LPUARTSRC_SHIFT, SIM_CTRL_REG_LPUARTSRC_WIDTH))
/*@}*/

/*!
 * @name Register SIM_CTRL_REG, field TMRFREEZE[31] (RW)
 *
 * Values:
 * - 0b0 - QTMR counters operate normally.
 * - 0b1 - QTMR counters and OFLAGs are reset. Clearing this bit will resume
 *     QTMR operation.
 */
/*@{*/
/*! @brief Read current value of the SIM_CTRL_REG_TMRFREEZE field. */
#define SIM_RD_CTRL_REG_TMRFREEZE(base) ((SIM_CTRL_REG_REG(base) & SIM_CTRL_REG_TMRFREEZE_MASK) >> SIM_CTRL_REG_TMRFREEZE_SHIFT)
#define SIM_BRD_CTRL_REG_TMRFREEZE(base) (BME_UBFX32(&SIM_CTRL_REG_REG(base), SIM_CTRL_REG_TMRFREEZE_SHIFT, SIM_CTRL_REG_TMRFREEZE_WIDTH))

/*! @brief Set the TMRFREEZE field to a new value. */
#define SIM_WR_CTRL_REG_TMRFREEZE(base, value) (SIM_RMW_CTRL_REG(base, SIM_CTRL_REG_TMRFREEZE_MASK, SIM_CTRL_REG_TMRFREEZE(value)))
#define SIM_BWR_CTRL_REG_TMRFREEZE(base, value) (BME_BFI32(&SIM_CTRL_REG_REG(base), ((uint32_t)(value) << SIM_CTRL_REG_TMRFREEZE_SHIFT), SIM_CTRL_REG_TMRFREEZE_SHIFT, SIM_CTRL_REG_TMRFREEZE_WIDTH))
/*@}*/

/*******************************************************************************
 * SIM_SDID - System Device Identification Register
 ******************************************************************************/

/*!
 * @brief SIM_SDID - System Device Identification Register (RO)
 *
 * Reset value: 0x00006000U
 */
/*!
 * @name Constants and macros for entire SIM_SDID register
 */
/*@{*/
#define SIM_RD_SDID(base)        (SIM_SDID_REG(base))
/*@}*/

/*
 * Constants & macros for individual SIM_SDID bitfields
 */

/*!
 * @name Register SIM_SDID, field PINID[3:0] (RO)
 *
 * Specifies the pincount of the device.
 *
 * Values:
 * - 0b0011 - Reserved
 * - 0b0100 - Reserved
 * - 0b0101 - 64-pin
 * - 0b0110 - Reserved
 * - 0b0111 - Reserved
 * - 0b1000 - 100-pin
 * - 0b1001 - 128-pin
 * - 0b1010 - 144-pin
 * - 0b1011 - Reserved
 * - 0b1100 - Reserved
 * - 0b1101 - Reserved
 * - 0b1110 - Reserved
 * - 0b1111 - Reserved
 */
/*@{*/
/*! @brief Read current value of the SIM_SDID_PINID field. */
#define SIM_RD_SDID_PINID(base) ((SIM_SDID_REG(base) & SIM_SDID_PINID_MASK) >> SIM_SDID_PINID_SHIFT)
#define SIM_BRD_SDID_PINID(base) (BME_UBFX32(&SIM_SDID_REG(base), SIM_SDID_PINID_SHIFT, SIM_SDID_PINID_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SDID, field DIEID[7:4] (RO)
 *
 * Marks the change in Base Layer
 *
 * Values:
 * - 0b0000 - First cut
 */
/*@{*/
/*! @brief Read current value of the SIM_SDID_DIEID field. */
#define SIM_RD_SDID_DIEID(base) ((SIM_SDID_REG(base) & SIM_SDID_DIEID_MASK) >> SIM_SDID_DIEID_SHIFT)
#define SIM_BRD_SDID_DIEID(base) (BME_UBFX32(&SIM_SDID_REG(base), SIM_SDID_DIEID_SHIFT, SIM_SDID_DIEID_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SDID, field REVID[11:8] (RO)
 *
 * Marks the changes with every Mask Set
 *
 * Values:
 * - 0b0000 - First cut
 */
/*@{*/
/*! @brief Read current value of the SIM_SDID_REVID field. */
#define SIM_RD_SDID_REVID(base) ((SIM_SDID_REG(base) & SIM_SDID_REVID_MASK) >> SIM_SDID_REVID_SHIFT)
#define SIM_BRD_SDID_REVID(base) (BME_UBFX32(&SIM_SDID_REG(base), SIM_SDID_REVID_SHIFT, SIM_SDID_REVID_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SDID, field SRAMSIZE[15:12] (RO)
 *
 * Indicates the size of SRAM present on the device
 *
 * Values:
 * - 0b0110 - 32 KB SRAM
 */
/*@{*/
/*! @brief Read current value of the SIM_SDID_SRAMSIZE field. */
#define SIM_RD_SDID_SRAMSIZE(base) ((SIM_SDID_REG(base) & SIM_SDID_SRAMSIZE_MASK) >> SIM_SDID_SRAMSIZE_SHIFT)
#define SIM_BRD_SDID_SRAMSIZE(base) (BME_UBFX32(&SIM_SDID_REG(base), SIM_SDID_SRAMSIZE_SHIFT, SIM_SDID_SRAMSIZE_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SDID, field ATTR[19:16] (RO)
 *
 * Specifies type of Core on the device
 *
 * Values:
 * - 0b0000 - M0+ core
 */
/*@{*/
/*! @brief Read current value of the SIM_SDID_ATTR field. */
#define SIM_RD_SDID_ATTR(base) ((SIM_SDID_REG(base) & SIM_SDID_ATTR_MASK) >> SIM_SDID_ATTR_SHIFT)
#define SIM_BRD_SDID_ATTR(base) (BME_UBFX32(&SIM_SDID_REG(base), SIM_SDID_ATTR_SHIFT, SIM_SDID_ATTR_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SDID, field SERIESID[23:20] (RO)
 *
 * Metering Series
 *
 * Values:
 * - 0b0011 - Metering Series
 */
/*@{*/
/*! @brief Read current value of the SIM_SDID_SERIESID field. */
#define SIM_RD_SDID_SERIESID(base) ((SIM_SDID_REG(base) & SIM_SDID_SERIESID_MASK) >> SIM_SDID_SERIESID_SHIFT)
#define SIM_BRD_SDID_SERIESID(base) (BME_UBFX32(&SIM_SDID_REG(base), SIM_SDID_SERIESID_SHIFT, SIM_SDID_SERIESID_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SDID, field SUBFAMID[27:24] (RO)
 *
 * Specifies the number of AFE channels supported
 *
 * Values:
 * - 0b0000 - Device derivatives with NO AFE enabled
 * - 0b0001 - Device derivatives with 1 AFE enabled
 * - 0b0010 - Device derivatives with 2 AFE enabled
 * - 0b0011 - Device derivatives with 3 AFE enabled
 * - 0b0100 - Device derivatives with 4 AFE enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SDID_SUBFAMID field. */
#define SIM_RD_SDID_SUBFAMID(base) ((SIM_SDID_REG(base) & SIM_SDID_SUBFAMID_MASK) >> SIM_SDID_SUBFAMID_SHIFT)
#define SIM_BRD_SDID_SUBFAMID(base) (BME_UBFX32(&SIM_SDID_REG(base), SIM_SDID_SUBFAMID_SHIFT, SIM_SDID_SUBFAMID_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SDID, field FAMID[31:28] (RO)
 *
 * Indicates Presence of LCD module
 *
 * Values:
 * - 0b0001 - Device derivatives without LCD
 * - 0b0011 - Device derivatives with LCD
 */
/*@{*/
/*! @brief Read current value of the SIM_SDID_FAMID field. */
#define SIM_RD_SDID_FAMID(base) ((SIM_SDID_REG(base) & SIM_SDID_FAMID_MASK) >> SIM_SDID_FAMID_SHIFT)
#define SIM_BRD_SDID_FAMID(base) (BME_UBFX32(&SIM_SDID_REG(base), SIM_SDID_FAMID_SHIFT, SIM_SDID_FAMID_WIDTH))
/*@}*/

/*******************************************************************************
 * SIM_SCGC4 - System Clock Gating Control Register 4
 ******************************************************************************/

/*!
 * @brief SIM_SCGC4 - System Clock Gating Control Register 4 (RW)
 *
 * Reset value: 0x78008050U
 *
 * Writes to this register can only be performed in Supervisor mode
 */
/*!
 * @name Constants and macros for entire SIM_SCGC4 register
 */
/*@{*/
#define SIM_RD_SCGC4(base)       (SIM_SCGC4_REG(base))
#define SIM_WR_SCGC4(base, value) (SIM_SCGC4_REG(base) = (value))
#define SIM_RMW_SCGC4(base, mask, value) (SIM_WR_SCGC4(base, (SIM_RD_SCGC4(base) & ~(mask)) | (value)))
#define SIM_SET_SCGC4(base, value) (BME_OR32(&SIM_SCGC4_REG(base), (uint32_t)(value)))
#define SIM_CLR_SCGC4(base, value) (BME_AND32(&SIM_SCGC4_REG(base), (uint32_t)(~(value))))
#define SIM_TOG_SCGC4(base, value) (BME_XOR32(&SIM_SCGC4_REG(base), (uint32_t)(value)))
/*@}*/

/* Unified clock gate bit access macros */
#define SIM_SCGC_BIT_REG(base, index)        (*((volatile uint32_t *)&SIM_SCGC4_REG(base) + (((uint32_t)(index) >> 5) - 3U)))
#define SIM_SCGC_BIT_SHIFT(index)            ((uint32_t)(index) & ((1U << 5) - 1U))
#define SIM_RD_SCGC_BIT(base, index)         (SIM_SCGC_BIT_REG((base), (index)) & (1U << SIM_SCGC_BIT_SHIFT(index)))
#define SIM_BRD_SCGC_BIT(base, index)        (BME_UBFX32(&SIM_SCGC_BIT_REG((base), (index)), SIM_SCGC_BIT_SHIFT(index), 1))
#define SIM_WR_SCGC_BIT(base, index, value)  (SIM_SCGC_BIT_REG((base), (index)) = (SIM_SCGC_BIT_REG((base), (index)) & ~(1U << SIM_SCGC_BIT_SHIFT(index))) | ((uint32_t)(value) << SIM_SCGC_BIT_SHIFT(index)))
#define SIM_BWR_SCGC_BIT(base, index, value) (BME_BFI32(&SIM_SCGC_BIT_REG((base), (index)), ((uint32_t)(value) << SIM_SCGC_BIT_SHIFT(index)), SIM_SCGC_BIT_SHIFT(index), 1))

/*
 * Constants & macros for individual SIM_SCGC4 bitfields
 */

/*!
 * @name Register SIM_SCGC4, field EWM[1] (RW)
 *
 * This bit controls the clock gate to the EWM module.
 *
 * Values:
 * - 0b0 - Clock disabled
 * - 0b1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC4_EWM field. */
#define SIM_RD_SCGC4_EWM(base) ((SIM_SCGC4_REG(base) & SIM_SCGC4_EWM_MASK) >> SIM_SCGC4_EWM_SHIFT)
#define SIM_BRD_SCGC4_EWM(base) (BME_UBFX32(&SIM_SCGC4_REG(base), SIM_SCGC4_EWM_SHIFT, SIM_SCGC4_EWM_WIDTH))

/*! @brief Set the EWM field to a new value. */
#define SIM_WR_SCGC4_EWM(base, value) (SIM_RMW_SCGC4(base, SIM_SCGC4_EWM_MASK, SIM_SCGC4_EWM(value)))
#define SIM_BWR_SCGC4_EWM(base, value) (BME_BFI32(&SIM_SCGC4_REG(base), ((uint32_t)(value) << SIM_SCGC4_EWM_SHIFT), SIM_SCGC4_EWM_SHIFT, SIM_SCGC4_EWM_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SCGC4, field I2C0[7] (RW)
 *
 * This bit controls the clock gate to the I2C0 module.
 *
 * Values:
 * - 0b0 - Clock disabled
 * - 0b1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC4_I2C0 field. */
#define SIM_RD_SCGC4_I2C0(base) ((SIM_SCGC4_REG(base) & SIM_SCGC4_I2C0_MASK) >> SIM_SCGC4_I2C0_SHIFT)
#define SIM_BRD_SCGC4_I2C0(base) (BME_UBFX32(&SIM_SCGC4_REG(base), SIM_SCGC4_I2C0_SHIFT, SIM_SCGC4_I2C0_WIDTH))

/*! @brief Set the I2C0 field to a new value. */
#define SIM_WR_SCGC4_I2C0(base, value) (SIM_RMW_SCGC4(base, SIM_SCGC4_I2C0_MASK, SIM_SCGC4_I2C0(value)))
#define SIM_BWR_SCGC4_I2C0(base, value) (BME_BFI32(&SIM_SCGC4_REG(base), ((uint32_t)(value) << SIM_SCGC4_I2C0_SHIFT), SIM_SCGC4_I2C0_SHIFT, SIM_SCGC4_I2C0_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SCGC4, field I2C1[8] (RW)
 *
 * This bit controls the clock gate to the I2C1 module.
 *
 * Values:
 * - 0b0 - Clock disabled
 * - 0b1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC4_I2C1 field. */
#define SIM_RD_SCGC4_I2C1(base) ((SIM_SCGC4_REG(base) & SIM_SCGC4_I2C1_MASK) >> SIM_SCGC4_I2C1_SHIFT)
#define SIM_BRD_SCGC4_I2C1(base) (BME_UBFX32(&SIM_SCGC4_REG(base), SIM_SCGC4_I2C1_SHIFT, SIM_SCGC4_I2C1_WIDTH))

/*! @brief Set the I2C1 field to a new value. */
#define SIM_WR_SCGC4_I2C1(base, value) (SIM_RMW_SCGC4(base, SIM_SCGC4_I2C1_MASK, SIM_SCGC4_I2C1(value)))
#define SIM_BWR_SCGC4_I2C1(base, value) (BME_BFI32(&SIM_SCGC4_REG(base), ((uint32_t)(value) << SIM_SCGC4_I2C1_SHIFT), SIM_SCGC4_I2C1_SHIFT, SIM_SCGC4_I2C1_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SCGC4, field UART0[10] (RW)
 *
 * This bit controls the clock gate to the UART0 module.
 *
 * Values:
 * - 0b0 - Clock disabled
 * - 0b1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC4_UART0 field. */
#define SIM_RD_SCGC4_UART0(base) ((SIM_SCGC4_REG(base) & SIM_SCGC4_UART0_MASK) >> SIM_SCGC4_UART0_SHIFT)
#define SIM_BRD_SCGC4_UART0(base) (BME_UBFX32(&SIM_SCGC4_REG(base), SIM_SCGC4_UART0_SHIFT, SIM_SCGC4_UART0_WIDTH))

/*! @brief Set the UART0 field to a new value. */
#define SIM_WR_SCGC4_UART0(base, value) (SIM_RMW_SCGC4(base, SIM_SCGC4_UART0_MASK, SIM_SCGC4_UART0(value)))
#define SIM_BWR_SCGC4_UART0(base, value) (BME_BFI32(&SIM_SCGC4_REG(base), ((uint32_t)(value) << SIM_SCGC4_UART0_SHIFT), SIM_SCGC4_UART0_SHIFT, SIM_SCGC4_UART0_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SCGC4, field UART1[11] (RW)
 *
 * This bit controls the clock gate to the UART1 module.
 *
 * Values:
 * - 0b0 - Clock disabled
 * - 0b1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC4_UART1 field. */
#define SIM_RD_SCGC4_UART1(base) ((SIM_SCGC4_REG(base) & SIM_SCGC4_UART1_MASK) >> SIM_SCGC4_UART1_SHIFT)
#define SIM_BRD_SCGC4_UART1(base) (BME_UBFX32(&SIM_SCGC4_REG(base), SIM_SCGC4_UART1_SHIFT, SIM_SCGC4_UART1_WIDTH))

/*! @brief Set the UART1 field to a new value. */
#define SIM_WR_SCGC4_UART1(base, value) (SIM_RMW_SCGC4(base, SIM_SCGC4_UART1_MASK, SIM_SCGC4_UART1(value)))
#define SIM_BWR_SCGC4_UART1(base, value) (BME_BFI32(&SIM_SCGC4_REG(base), ((uint32_t)(value) << SIM_SCGC4_UART1_SHIFT), SIM_SCGC4_UART1_SHIFT, SIM_SCGC4_UART1_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SCGC4, field UART2[12] (RW)
 *
 * This bit controls the clock gate to the UART2 module.
 *
 * Values:
 * - 0b0 - Clock disabled
 * - 0b1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC4_UART2 field. */
#define SIM_RD_SCGC4_UART2(base) ((SIM_SCGC4_REG(base) & SIM_SCGC4_UART2_MASK) >> SIM_SCGC4_UART2_SHIFT)
#define SIM_BRD_SCGC4_UART2(base) (BME_UBFX32(&SIM_SCGC4_REG(base), SIM_SCGC4_UART2_SHIFT, SIM_SCGC4_UART2_WIDTH))

/*! @brief Set the UART2 field to a new value. */
#define SIM_WR_SCGC4_UART2(base, value) (SIM_RMW_SCGC4(base, SIM_SCGC4_UART2_MASK, SIM_SCGC4_UART2(value)))
#define SIM_BWR_SCGC4_UART2(base, value) (BME_BFI32(&SIM_SCGC4_REG(base), ((uint32_t)(value) << SIM_SCGC4_UART2_SHIFT), SIM_SCGC4_UART2_SHIFT, SIM_SCGC4_UART2_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SCGC4, field UART3[13] (RW)
 *
 * This bit controls the clock gate to the UART3 module.
 *
 * Values:
 * - 0b0 - Clock disabled
 * - 0b1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC4_UART3 field. */
#define SIM_RD_SCGC4_UART3(base) ((SIM_SCGC4_REG(base) & SIM_SCGC4_UART3_MASK) >> SIM_SCGC4_UART3_SHIFT)
#define SIM_BRD_SCGC4_UART3(base) (BME_UBFX32(&SIM_SCGC4_REG(base), SIM_SCGC4_UART3_SHIFT, SIM_SCGC4_UART3_WIDTH))

/*! @brief Set the UART3 field to a new value. */
#define SIM_WR_SCGC4_UART3(base, value) (SIM_RMW_SCGC4(base, SIM_SCGC4_UART3_MASK, SIM_SCGC4_UART3(value)))
#define SIM_BWR_SCGC4_UART3(base, value) (BME_BFI32(&SIM_SCGC4_REG(base), ((uint32_t)(value) << SIM_SCGC4_UART3_SHIFT), SIM_SCGC4_UART3_SHIFT, SIM_SCGC4_UART3_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SCGC4, field VREF[15] (RW)
 *
 * This bit controls the clock gate to the VREF module.
 *
 * Values:
 * - 0b0 - Clock disabled
 * - 0b1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC4_VREF field. */
#define SIM_RD_SCGC4_VREF(base) ((SIM_SCGC4_REG(base) & SIM_SCGC4_VREF_MASK) >> SIM_SCGC4_VREF_SHIFT)
#define SIM_BRD_SCGC4_VREF(base) (BME_UBFX32(&SIM_SCGC4_REG(base), SIM_SCGC4_VREF_SHIFT, SIM_SCGC4_VREF_WIDTH))

/*! @brief Set the VREF field to a new value. */
#define SIM_WR_SCGC4_VREF(base, value) (SIM_RMW_SCGC4(base, SIM_SCGC4_VREF_MASK, SIM_SCGC4_VREF(value)))
#define SIM_BWR_SCGC4_VREF(base, value) (BME_BFI32(&SIM_SCGC4_REG(base), ((uint32_t)(value) << SIM_SCGC4_VREF_SHIFT), SIM_SCGC4_VREF_SHIFT, SIM_SCGC4_VREF_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SCGC4, field CMP[18] (RW)
 *
 * This bit controls the clock gate to the CMP module.
 *
 * Values:
 * - 0b0 - Clock disabled
 * - 0b1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC4_CMP field. */
#define SIM_RD_SCGC4_CMP(base) ((SIM_SCGC4_REG(base) & SIM_SCGC4_CMP_MASK) >> SIM_SCGC4_CMP_SHIFT)
#define SIM_BRD_SCGC4_CMP(base) (BME_UBFX32(&SIM_SCGC4_REG(base), SIM_SCGC4_CMP_SHIFT, SIM_SCGC4_CMP_WIDTH))

/*! @brief Set the CMP field to a new value. */
#define SIM_WR_SCGC4_CMP(base, value) (SIM_RMW_SCGC4(base, SIM_SCGC4_CMP_MASK, SIM_SCGC4_CMP(value)))
#define SIM_BWR_SCGC4_CMP(base, value) (BME_BFI32(&SIM_SCGC4_REG(base), ((uint32_t)(value) << SIM_SCGC4_CMP_SHIFT), SIM_SCGC4_CMP_SHIFT, SIM_SCGC4_CMP_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SCGC4, field SPI0[21] (RW)
 *
 * This bit controls the clock gate to the SPI0 module.
 *
 * Values:
 * - 0b0 - Clock disabled
 * - 0b1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC4_SPI0 field. */
#define SIM_RD_SCGC4_SPI0(base) ((SIM_SCGC4_REG(base) & SIM_SCGC4_SPI0_MASK) >> SIM_SCGC4_SPI0_SHIFT)
#define SIM_BRD_SCGC4_SPI0(base) (BME_UBFX32(&SIM_SCGC4_REG(base), SIM_SCGC4_SPI0_SHIFT, SIM_SCGC4_SPI0_WIDTH))

/*! @brief Set the SPI0 field to a new value. */
#define SIM_WR_SCGC4_SPI0(base, value) (SIM_RMW_SCGC4(base, SIM_SCGC4_SPI0_MASK, SIM_SCGC4_SPI0(value)))
#define SIM_BWR_SCGC4_SPI0(base, value) (BME_BFI32(&SIM_SCGC4_REG(base), ((uint32_t)(value) << SIM_SCGC4_SPI0_SHIFT), SIM_SCGC4_SPI0_SHIFT, SIM_SCGC4_SPI0_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SCGC4, field SPI1[22] (RW)
 *
 * This bit controls the clock gate to the SPI1 module.
 *
 * Values:
 * - 0b0 - Clock disabled
 * - 0b1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC4_SPI1 field. */
#define SIM_RD_SCGC4_SPI1(base) ((SIM_SCGC4_REG(base) & SIM_SCGC4_SPI1_MASK) >> SIM_SCGC4_SPI1_SHIFT)
#define SIM_BRD_SCGC4_SPI1(base) (BME_UBFX32(&SIM_SCGC4_REG(base), SIM_SCGC4_SPI1_SHIFT, SIM_SCGC4_SPI1_WIDTH))

/*! @brief Set the SPI1 field to a new value. */
#define SIM_WR_SCGC4_SPI1(base, value) (SIM_RMW_SCGC4(base, SIM_SCGC4_SPI1_MASK, SIM_SCGC4_SPI1(value)))
#define SIM_BWR_SCGC4_SPI1(base, value) (BME_BFI32(&SIM_SCGC4_REG(base), ((uint32_t)(value) << SIM_SCGC4_SPI1_SHIFT), SIM_SCGC4_SPI1_SHIFT, SIM_SCGC4_SPI1_WIDTH))
/*@}*/

/*******************************************************************************
 * SIM_SCGC5 - System Clock Gating Control Register 5
 ******************************************************************************/

/*!
 * @brief SIM_SCGC5 - System Clock Gating Control Register 5 (RW)
 *
 * Reset value: 0x000B0000U
 *
 * Writes to this register can only be performed in Supervisor mode.
 */
/*!
 * @name Constants and macros for entire SIM_SCGC5 register
 */
/*@{*/
#define SIM_RD_SCGC5(base)       (SIM_SCGC5_REG(base))
#define SIM_WR_SCGC5(base, value) (SIM_SCGC5_REG(base) = (value))
#define SIM_RMW_SCGC5(base, mask, value) (SIM_WR_SCGC5(base, (SIM_RD_SCGC5(base) & ~(mask)) | (value)))
#define SIM_SET_SCGC5(base, value) (BME_OR32(&SIM_SCGC5_REG(base), (uint32_t)(value)))
#define SIM_CLR_SCGC5(base, value) (BME_AND32(&SIM_SCGC5_REG(base), (uint32_t)(~(value))))
#define SIM_TOG_SCGC5(base, value) (BME_XOR32(&SIM_SCGC5_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual SIM_SCGC5 bitfields
 */

/*!
 * @name Register SIM_SCGC5, field SLCD[3] (RW)
 *
 * This bit controls the clock gate to the SLCD module.
 *
 * Values:
 * - 0b0 - Clock disabled
 * - 0b1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC5_SLCD field. */
#define SIM_RD_SCGC5_SLCD(base) ((SIM_SCGC5_REG(base) & SIM_SCGC5_SLCD_MASK) >> SIM_SCGC5_SLCD_SHIFT)
#define SIM_BRD_SCGC5_SLCD(base) (BME_UBFX32(&SIM_SCGC5_REG(base), SIM_SCGC5_SLCD_SHIFT, SIM_SCGC5_SLCD_WIDTH))

/*! @brief Set the SLCD field to a new value. */
#define SIM_WR_SCGC5_SLCD(base, value) (SIM_RMW_SCGC5(base, SIM_SCGC5_SLCD_MASK, SIM_SCGC5_SLCD(value)))
#define SIM_BWR_SCGC5_SLCD(base, value) (BME_BFI32(&SIM_SCGC5_REG(base), ((uint32_t)(value) << SIM_SCGC5_SLCD_SHIFT), SIM_SCGC5_SLCD_SHIFT, SIM_SCGC5_SLCD_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SCGC5, field PORTA[6] (RW)
 *
 * This bit controls the clock gate to the PCTLA module.
 *
 * Values:
 * - 0b0 - Clock disabled
 * - 0b1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC5_PORTA field. */
#define SIM_RD_SCGC5_PORTA(base) ((SIM_SCGC5_REG(base) & SIM_SCGC5_PORTA_MASK) >> SIM_SCGC5_PORTA_SHIFT)
#define SIM_BRD_SCGC5_PORTA(base) (BME_UBFX32(&SIM_SCGC5_REG(base), SIM_SCGC5_PORTA_SHIFT, SIM_SCGC5_PORTA_WIDTH))

/*! @brief Set the PORTA field to a new value. */
#define SIM_WR_SCGC5_PORTA(base, value) (SIM_RMW_SCGC5(base, SIM_SCGC5_PORTA_MASK, SIM_SCGC5_PORTA(value)))
#define SIM_BWR_SCGC5_PORTA(base, value) (BME_BFI32(&SIM_SCGC5_REG(base), ((uint32_t)(value) << SIM_SCGC5_PORTA_SHIFT), SIM_SCGC5_PORTA_SHIFT, SIM_SCGC5_PORTA_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SCGC5, field PORTB[7] (RW)
 *
 * This bit controls the clock gate to the PCTLB module.
 *
 * Values:
 * - 0b0 - Clock disabled
 * - 0b1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC5_PORTB field. */
#define SIM_RD_SCGC5_PORTB(base) ((SIM_SCGC5_REG(base) & SIM_SCGC5_PORTB_MASK) >> SIM_SCGC5_PORTB_SHIFT)
#define SIM_BRD_SCGC5_PORTB(base) (BME_UBFX32(&SIM_SCGC5_REG(base), SIM_SCGC5_PORTB_SHIFT, SIM_SCGC5_PORTB_WIDTH))

/*! @brief Set the PORTB field to a new value. */
#define SIM_WR_SCGC5_PORTB(base, value) (SIM_RMW_SCGC5(base, SIM_SCGC5_PORTB_MASK, SIM_SCGC5_PORTB(value)))
#define SIM_BWR_SCGC5_PORTB(base, value) (BME_BFI32(&SIM_SCGC5_REG(base), ((uint32_t)(value) << SIM_SCGC5_PORTB_SHIFT), SIM_SCGC5_PORTB_SHIFT, SIM_SCGC5_PORTB_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SCGC5, field PORTC[8] (RW)
 *
 * This bit controls the clock gate to the PCTLC module.
 *
 * Values:
 * - 0b0 - Clock disabled
 * - 0b1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC5_PORTC field. */
#define SIM_RD_SCGC5_PORTC(base) ((SIM_SCGC5_REG(base) & SIM_SCGC5_PORTC_MASK) >> SIM_SCGC5_PORTC_SHIFT)
#define SIM_BRD_SCGC5_PORTC(base) (BME_UBFX32(&SIM_SCGC5_REG(base), SIM_SCGC5_PORTC_SHIFT, SIM_SCGC5_PORTC_WIDTH))

/*! @brief Set the PORTC field to a new value. */
#define SIM_WR_SCGC5_PORTC(base, value) (SIM_RMW_SCGC5(base, SIM_SCGC5_PORTC_MASK, SIM_SCGC5_PORTC(value)))
#define SIM_BWR_SCGC5_PORTC(base, value) (BME_BFI32(&SIM_SCGC5_REG(base), ((uint32_t)(value) << SIM_SCGC5_PORTC_SHIFT), SIM_SCGC5_PORTC_SHIFT, SIM_SCGC5_PORTC_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SCGC5, field PORTD[9] (RW)
 *
 * This bit controls the clock gate to the PCTLD module.
 *
 * Values:
 * - 0b0 - Clock disabled
 * - 0b1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC5_PORTD field. */
#define SIM_RD_SCGC5_PORTD(base) ((SIM_SCGC5_REG(base) & SIM_SCGC5_PORTD_MASK) >> SIM_SCGC5_PORTD_SHIFT)
#define SIM_BRD_SCGC5_PORTD(base) (BME_UBFX32(&SIM_SCGC5_REG(base), SIM_SCGC5_PORTD_SHIFT, SIM_SCGC5_PORTD_WIDTH))

/*! @brief Set the PORTD field to a new value. */
#define SIM_WR_SCGC5_PORTD(base, value) (SIM_RMW_SCGC5(base, SIM_SCGC5_PORTD_MASK, SIM_SCGC5_PORTD(value)))
#define SIM_BWR_SCGC5_PORTD(base, value) (BME_BFI32(&SIM_SCGC5_REG(base), ((uint32_t)(value) << SIM_SCGC5_PORTD_SHIFT), SIM_SCGC5_PORTD_SHIFT, SIM_SCGC5_PORTD_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SCGC5, field PORTE[10] (RW)
 *
 * This bit controls the clock gate to the PCTLE module.
 *
 * Values:
 * - 0b0 - Clock disabled
 * - 0b1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC5_PORTE field. */
#define SIM_RD_SCGC5_PORTE(base) ((SIM_SCGC5_REG(base) & SIM_SCGC5_PORTE_MASK) >> SIM_SCGC5_PORTE_SHIFT)
#define SIM_BRD_SCGC5_PORTE(base) (BME_UBFX32(&SIM_SCGC5_REG(base), SIM_SCGC5_PORTE_SHIFT, SIM_SCGC5_PORTE_WIDTH))

/*! @brief Set the PORTE field to a new value. */
#define SIM_WR_SCGC5_PORTE(base, value) (SIM_RMW_SCGC5(base, SIM_SCGC5_PORTE_MASK, SIM_SCGC5_PORTE(value)))
#define SIM_BWR_SCGC5_PORTE(base, value) (BME_BFI32(&SIM_SCGC5_REG(base), ((uint32_t)(value) << SIM_SCGC5_PORTE_SHIFT), SIM_SCGC5_PORTE_SHIFT, SIM_SCGC5_PORTE_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SCGC5, field PORTF[11] (RW)
 *
 * This bit controls the clock gate to the PCTLF module.
 *
 * Values:
 * - 0b0 - Clock disabled
 * - 0b1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC5_PORTF field. */
#define SIM_RD_SCGC5_PORTF(base) ((SIM_SCGC5_REG(base) & SIM_SCGC5_PORTF_MASK) >> SIM_SCGC5_PORTF_SHIFT)
#define SIM_BRD_SCGC5_PORTF(base) (BME_UBFX32(&SIM_SCGC5_REG(base), SIM_SCGC5_PORTF_SHIFT, SIM_SCGC5_PORTF_WIDTH))

/*! @brief Set the PORTF field to a new value. */
#define SIM_WR_SCGC5_PORTF(base, value) (SIM_RMW_SCGC5(base, SIM_SCGC5_PORTF_MASK, SIM_SCGC5_PORTF(value)))
#define SIM_BWR_SCGC5_PORTF(base, value) (BME_BFI32(&SIM_SCGC5_REG(base), ((uint32_t)(value) << SIM_SCGC5_PORTF_SHIFT), SIM_SCGC5_PORTF_SHIFT, SIM_SCGC5_PORTF_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SCGC5, field PORTG[12] (RW)
 *
 * This bit controls the clock gate to the PCTLG module.
 *
 * Values:
 * - 0b0 - Clock disabled
 * - 0b1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC5_PORTG field. */
#define SIM_RD_SCGC5_PORTG(base) ((SIM_SCGC5_REG(base) & SIM_SCGC5_PORTG_MASK) >> SIM_SCGC5_PORTG_SHIFT)
#define SIM_BRD_SCGC5_PORTG(base) (BME_UBFX32(&SIM_SCGC5_REG(base), SIM_SCGC5_PORTG_SHIFT, SIM_SCGC5_PORTG_WIDTH))

/*! @brief Set the PORTG field to a new value. */
#define SIM_WR_SCGC5_PORTG(base, value) (SIM_RMW_SCGC5(base, SIM_SCGC5_PORTG_MASK, SIM_SCGC5_PORTG(value)))
#define SIM_BWR_SCGC5_PORTG(base, value) (BME_BFI32(&SIM_SCGC5_REG(base), ((uint32_t)(value) << SIM_SCGC5_PORTG_SHIFT), SIM_SCGC5_PORTG_SHIFT, SIM_SCGC5_PORTG_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SCGC5, field PORTH[13] (RW)
 *
 * This bit controls the clock gate to the PCTLH module.
 *
 * Values:
 * - 0b0 - Clock disabled
 * - 0b1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC5_PORTH field. */
#define SIM_RD_SCGC5_PORTH(base) ((SIM_SCGC5_REG(base) & SIM_SCGC5_PORTH_MASK) >> SIM_SCGC5_PORTH_SHIFT)
#define SIM_BRD_SCGC5_PORTH(base) (BME_UBFX32(&SIM_SCGC5_REG(base), SIM_SCGC5_PORTH_SHIFT, SIM_SCGC5_PORTH_WIDTH))

/*! @brief Set the PORTH field to a new value. */
#define SIM_WR_SCGC5_PORTH(base, value) (SIM_RMW_SCGC5(base, SIM_SCGC5_PORTH_MASK, SIM_SCGC5_PORTH(value)))
#define SIM_BWR_SCGC5_PORTH(base, value) (BME_BFI32(&SIM_SCGC5_REG(base), ((uint32_t)(value) << SIM_SCGC5_PORTH_SHIFT), SIM_SCGC5_PORTH_SHIFT, SIM_SCGC5_PORTH_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SCGC5, field PORTI[14] (RW)
 *
 * This bit controls the clock gate to the PCTLI module.
 *
 * Values:
 * - 0b0 - Clock disabled
 * - 0b1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC5_PORTI field. */
#define SIM_RD_SCGC5_PORTI(base) ((SIM_SCGC5_REG(base) & SIM_SCGC5_PORTI_MASK) >> SIM_SCGC5_PORTI_SHIFT)
#define SIM_BRD_SCGC5_PORTI(base) (BME_UBFX32(&SIM_SCGC5_REG(base), SIM_SCGC5_PORTI_SHIFT, SIM_SCGC5_PORTI_WIDTH))

/*! @brief Set the PORTI field to a new value. */
#define SIM_WR_SCGC5_PORTI(base, value) (SIM_RMW_SCGC5(base, SIM_SCGC5_PORTI_MASK, SIM_SCGC5_PORTI(value)))
#define SIM_BWR_SCGC5_PORTI(base, value) (BME_BFI32(&SIM_SCGC5_REG(base), ((uint32_t)(value) << SIM_SCGC5_PORTI_SHIFT), SIM_SCGC5_PORTI_SHIFT, SIM_SCGC5_PORTI_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SCGC5, field RTC[16] (RW)
 *
 * This bit controls the clock gate to the iRTC module.
 *
 * Values:
 * - 0b0 - Clock disabled
 * - 0b1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC5_RTC field. */
#define SIM_RD_SCGC5_RTC(base) ((SIM_SCGC5_REG(base) & SIM_SCGC5_RTC_MASK) >> SIM_SCGC5_RTC_SHIFT)
#define SIM_BRD_SCGC5_RTC(base) (BME_UBFX32(&SIM_SCGC5_REG(base), SIM_SCGC5_RTC_SHIFT, SIM_SCGC5_RTC_WIDTH))

/*! @brief Set the RTC field to a new value. */
#define SIM_WR_SCGC5_RTC(base, value) (SIM_RMW_SCGC5(base, SIM_SCGC5_RTC_MASK, SIM_SCGC5_RTC(value)))
#define SIM_BWR_SCGC5_RTC(base, value) (BME_BFI32(&SIM_SCGC5_REG(base), ((uint32_t)(value) << SIM_SCGC5_RTC_SHIFT), SIM_SCGC5_RTC_SHIFT, SIM_SCGC5_RTC_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SCGC5, field RTCREG[17] (RW)
 *
 * This bit controls the clock gate to the iRTC_REG_FILE.
 *
 * Values:
 * - 0b0 - Clock disabled
 * - 0b1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC5_RTCREG field. */
#define SIM_RD_SCGC5_RTCREG(base) ((SIM_SCGC5_REG(base) & SIM_SCGC5_RTCREG_MASK) >> SIM_SCGC5_RTCREG_SHIFT)
#define SIM_BRD_SCGC5_RTCREG(base) (BME_UBFX32(&SIM_SCGC5_REG(base), SIM_SCGC5_RTCREG_SHIFT, SIM_SCGC5_RTCREG_WIDTH))

/*! @brief Set the RTCREG field to a new value. */
#define SIM_WR_SCGC5_RTCREG(base, value) (SIM_RMW_SCGC5(base, SIM_SCGC5_RTCREG_MASK, SIM_SCGC5_RTCREG(value)))
#define SIM_BWR_SCGC5_RTCREG(base, value) (BME_BFI32(&SIM_SCGC5_REG(base), ((uint32_t)(value) << SIM_SCGC5_RTCREG_SHIFT), SIM_SCGC5_RTCREG_SHIFT, SIM_SCGC5_RTCREG_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SCGC5, field XBAR[21] (RW)
 *
 * This bit controls the clock gate to the XBAR module.
 *
 * Values:
 * - 0b0 - Clock disabled
 * - 0b1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC5_XBAR field. */
#define SIM_RD_SCGC5_XBAR(base) ((SIM_SCGC5_REG(base) & SIM_SCGC5_XBAR_MASK) >> SIM_SCGC5_XBAR_SHIFT)
#define SIM_BRD_SCGC5_XBAR(base) (BME_UBFX32(&SIM_SCGC5_REG(base), SIM_SCGC5_XBAR_SHIFT, SIM_SCGC5_XBAR_WIDTH))

/*! @brief Set the XBAR field to a new value. */
#define SIM_WR_SCGC5_XBAR(base, value) (SIM_RMW_SCGC5(base, SIM_SCGC5_XBAR_MASK, SIM_SCGC5_XBAR(value)))
#define SIM_BWR_SCGC5_XBAR(base, value) (BME_BFI32(&SIM_SCGC5_REG(base), ((uint32_t)(value) << SIM_SCGC5_XBAR_SHIFT), SIM_SCGC5_XBAR_SHIFT, SIM_SCGC5_XBAR_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SCGC5, field TMR0[23] (RW)
 *
 * This bit controls the clock gate to the QTMR0_TMR0.
 *
 * Values:
 * - 0b0 - Clock disabled
 * - 0b1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC5_TMR0 field. */
#define SIM_RD_SCGC5_TMR0(base) ((SIM_SCGC5_REG(base) & SIM_SCGC5_TMR0_MASK) >> SIM_SCGC5_TMR0_SHIFT)
#define SIM_BRD_SCGC5_TMR0(base) (BME_UBFX32(&SIM_SCGC5_REG(base), SIM_SCGC5_TMR0_SHIFT, SIM_SCGC5_TMR0_WIDTH))

/*! @brief Set the TMR0 field to a new value. */
#define SIM_WR_SCGC5_TMR0(base, value) (SIM_RMW_SCGC5(base, SIM_SCGC5_TMR0_MASK, SIM_SCGC5_TMR0(value)))
#define SIM_BWR_SCGC5_TMR0(base, value) (BME_BFI32(&SIM_SCGC5_REG(base), ((uint32_t)(value) << SIM_SCGC5_TMR0_SHIFT), SIM_SCGC5_TMR0_SHIFT, SIM_SCGC5_TMR0_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SCGC5, field TMR1[24] (RW)
 *
 * This bit controls the clock gate to the QTMR0_TMR1.
 *
 * Values:
 * - 0b0 - Clock disabled
 * - 0b1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC5_TMR1 field. */
#define SIM_RD_SCGC5_TMR1(base) ((SIM_SCGC5_REG(base) & SIM_SCGC5_TMR1_MASK) >> SIM_SCGC5_TMR1_SHIFT)
#define SIM_BRD_SCGC5_TMR1(base) (BME_UBFX32(&SIM_SCGC5_REG(base), SIM_SCGC5_TMR1_SHIFT, SIM_SCGC5_TMR1_WIDTH))

/*! @brief Set the TMR1 field to a new value. */
#define SIM_WR_SCGC5_TMR1(base, value) (SIM_RMW_SCGC5(base, SIM_SCGC5_TMR1_MASK, SIM_SCGC5_TMR1(value)))
#define SIM_BWR_SCGC5_TMR1(base, value) (BME_BFI32(&SIM_SCGC5_REG(base), ((uint32_t)(value) << SIM_SCGC5_TMR1_SHIFT), SIM_SCGC5_TMR1_SHIFT, SIM_SCGC5_TMR1_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SCGC5, field TMR2[25] (RW)
 *
 * This bit controls the clock gate to the QTMR0_TMR2.
 *
 * Values:
 * - 0b0 - Clock disabled
 * - 0b1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC5_TMR2 field. */
#define SIM_RD_SCGC5_TMR2(base) ((SIM_SCGC5_REG(base) & SIM_SCGC5_TMR2_MASK) >> SIM_SCGC5_TMR2_SHIFT)
#define SIM_BRD_SCGC5_TMR2(base) (BME_UBFX32(&SIM_SCGC5_REG(base), SIM_SCGC5_TMR2_SHIFT, SIM_SCGC5_TMR2_WIDTH))

/*! @brief Set the TMR2 field to a new value. */
#define SIM_WR_SCGC5_TMR2(base, value) (SIM_RMW_SCGC5(base, SIM_SCGC5_TMR2_MASK, SIM_SCGC5_TMR2(value)))
#define SIM_BWR_SCGC5_TMR2(base, value) (BME_BFI32(&SIM_SCGC5_REG(base), ((uint32_t)(value) << SIM_SCGC5_TMR2_SHIFT), SIM_SCGC5_TMR2_SHIFT, SIM_SCGC5_TMR2_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SCGC5, field TMR3[26] (RW)
 *
 * This bit controls the clock gate to the QTMR0_TMR3.
 *
 * Values:
 * - 0b0 - Clock disabled
 * - 0b1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC5_TMR3 field. */
#define SIM_RD_SCGC5_TMR3(base) ((SIM_SCGC5_REG(base) & SIM_SCGC5_TMR3_MASK) >> SIM_SCGC5_TMR3_SHIFT)
#define SIM_BRD_SCGC5_TMR3(base) (BME_UBFX32(&SIM_SCGC5_REG(base), SIM_SCGC5_TMR3_SHIFT, SIM_SCGC5_TMR3_WIDTH))

/*! @brief Set the TMR3 field to a new value. */
#define SIM_WR_SCGC5_TMR3(base, value) (SIM_RMW_SCGC5(base, SIM_SCGC5_TMR3_MASK, SIM_SCGC5_TMR3(value)))
#define SIM_BWR_SCGC5_TMR3(base, value) (BME_BFI32(&SIM_SCGC5_REG(base), ((uint32_t)(value) << SIM_SCGC5_TMR3_SHIFT), SIM_SCGC5_TMR3_SHIFT, SIM_SCGC5_TMR3_WIDTH))
/*@}*/

/*******************************************************************************
 * SIM_SCGC6 - System Clock Gating Control Register 6
 ******************************************************************************/

/*!
 * @brief SIM_SCGC6 - System Clock Gating Control Register 6 (RW)
 *
 * Reset value: 0xC0000001U
 *
 * Writes to this register can only be performed in Supervisor mode
 */
/*!
 * @name Constants and macros for entire SIM_SCGC6 register
 */
/*@{*/
#define SIM_RD_SCGC6(base)       (SIM_SCGC6_REG(base))
#define SIM_WR_SCGC6(base, value) (SIM_SCGC6_REG(base) = (value))
#define SIM_RMW_SCGC6(base, mask, value) (SIM_WR_SCGC6(base, (SIM_RD_SCGC6(base) & ~(mask)) | (value)))
#define SIM_SET_SCGC6(base, value) (BME_OR32(&SIM_SCGC6_REG(base), (uint32_t)(value)))
#define SIM_CLR_SCGC6(base, value) (BME_AND32(&SIM_SCGC6_REG(base), (uint32_t)(~(value))))
#define SIM_TOG_SCGC6(base, value) (BME_XOR32(&SIM_SCGC6_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual SIM_SCGC6 bitfields
 */

/*!
 * @name Register SIM_SCGC6, field FTFA[0] (RW)
 *
 * This bit controls the clock gate to the FTFA Module.
 *
 * Values:
 * - 0b0 - Clock disabled
 * - 0b1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC6_FTFA field. */
#define SIM_RD_SCGC6_FTFA(base) ((SIM_SCGC6_REG(base) & SIM_SCGC6_FTFA_MASK) >> SIM_SCGC6_FTFA_SHIFT)
#define SIM_BRD_SCGC6_FTFA(base) (BME_UBFX32(&SIM_SCGC6_REG(base), SIM_SCGC6_FTFA_SHIFT, SIM_SCGC6_FTFA_WIDTH))

/*! @brief Set the FTFA field to a new value. */
#define SIM_WR_SCGC6_FTFA(base, value) (SIM_RMW_SCGC6(base, SIM_SCGC6_FTFA_MASK, SIM_SCGC6_FTFA(value)))
#define SIM_BWR_SCGC6_FTFA(base, value) (BME_BFI32(&SIM_SCGC6_REG(base), ((uint32_t)(value) << SIM_SCGC6_FTFA_SHIFT), SIM_SCGC6_FTFA_SHIFT, SIM_SCGC6_FTFA_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SCGC6, field DMACHMUX[1] (RW)
 *
 * This bit controls the clock gate to the DMA channel MUX module.
 *
 * Values:
 * - 0b0 - Clock disabled
 * - 0b1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC6_DMACHMUX field. */
#define SIM_RD_SCGC6_DMACHMUX(base) ((SIM_SCGC6_REG(base) & SIM_SCGC6_DMACHMUX_MASK) >> SIM_SCGC6_DMACHMUX_SHIFT)
#define SIM_BRD_SCGC6_DMACHMUX(base) (BME_UBFX32(&SIM_SCGC6_REG(base), SIM_SCGC6_DMACHMUX_SHIFT, SIM_SCGC6_DMACHMUX_WIDTH))

/*! @brief Set the DMACHMUX field to a new value. */
#define SIM_WR_SCGC6_DMACHMUX(base, value) (SIM_RMW_SCGC6(base, SIM_SCGC6_DMACHMUX_MASK, SIM_SCGC6_DMACHMUX(value)))
#define SIM_BWR_SCGC6_DMACHMUX(base, value) (BME_BFI32(&SIM_SCGC6_REG(base), ((uint32_t)(value) << SIM_SCGC6_DMACHMUX_SHIFT), SIM_SCGC6_DMACHMUX_SHIFT, SIM_SCGC6_DMACHMUX_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SCGC6, field RNGA[9] (RW)
 *
 * This bit controls the clock gate to the RNGA module.
 *
 * Values:
 * - 0b0 - Clock disabled
 * - 0b1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC6_RNGA field. */
#define SIM_RD_SCGC6_RNGA(base) ((SIM_SCGC6_REG(base) & SIM_SCGC6_RNGA_MASK) >> SIM_SCGC6_RNGA_SHIFT)
#define SIM_BRD_SCGC6_RNGA(base) (BME_UBFX32(&SIM_SCGC6_REG(base), SIM_SCGC6_RNGA_SHIFT, SIM_SCGC6_RNGA_WIDTH))

/*! @brief Set the RNGA field to a new value. */
#define SIM_WR_SCGC6_RNGA(base, value) (SIM_RMW_SCGC6(base, SIM_SCGC6_RNGA_MASK, SIM_SCGC6_RNGA(value)))
#define SIM_BWR_SCGC6_RNGA(base, value) (BME_BFI32(&SIM_SCGC6_REG(base), ((uint32_t)(value) << SIM_SCGC6_RNGA_SHIFT), SIM_SCGC6_RNGA_SHIFT, SIM_SCGC6_RNGA_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SCGC6, field LPUART[10] (RW)
 *
 * This bit controls the clock gate to the LPUART module.
 *
 * Values:
 * - 0b0 - Clock disabled
 * - 0b1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC6_LPUART field. */
#define SIM_RD_SCGC6_LPUART(base) ((SIM_SCGC6_REG(base) & SIM_SCGC6_LPUART_MASK) >> SIM_SCGC6_LPUART_SHIFT)
#define SIM_BRD_SCGC6_LPUART(base) (BME_UBFX32(&SIM_SCGC6_REG(base), SIM_SCGC6_LPUART_SHIFT, SIM_SCGC6_LPUART_WIDTH))

/*! @brief Set the LPUART field to a new value. */
#define SIM_WR_SCGC6_LPUART(base, value) (SIM_RMW_SCGC6(base, SIM_SCGC6_LPUART_MASK, SIM_SCGC6_LPUART(value)))
#define SIM_BWR_SCGC6_LPUART(base, value) (BME_BFI32(&SIM_SCGC6_REG(base), ((uint32_t)(value) << SIM_SCGC6_LPUART_SHIFT), SIM_SCGC6_LPUART_SHIFT, SIM_SCGC6_LPUART_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SCGC6, field ADC[11] (RW)
 *
 * This bit controls the clock gate to the SAR ADC module.
 *
 * Values:
 * - 0b0 - Clock disabled
 * - 0b1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC6_ADC field. */
#define SIM_RD_SCGC6_ADC(base) ((SIM_SCGC6_REG(base) & SIM_SCGC6_ADC_MASK) >> SIM_SCGC6_ADC_SHIFT)
#define SIM_BRD_SCGC6_ADC(base) (BME_UBFX32(&SIM_SCGC6_REG(base), SIM_SCGC6_ADC_SHIFT, SIM_SCGC6_ADC_WIDTH))

/*! @brief Set the ADC field to a new value. */
#define SIM_WR_SCGC6_ADC(base, value) (SIM_RMW_SCGC6(base, SIM_SCGC6_ADC_MASK, SIM_SCGC6_ADC(value)))
#define SIM_BWR_SCGC6_ADC(base, value) (BME_BFI32(&SIM_SCGC6_REG(base), ((uint32_t)(value) << SIM_SCGC6_ADC_SHIFT), SIM_SCGC6_ADC_SHIFT, SIM_SCGC6_ADC_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SCGC6, field PIT0[13] (RW)
 *
 * This bit controls the clock gate to the PIT0 module.
 *
 * Values:
 * - 0b0 - Clock disabled
 * - 0b1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC6_PIT0 field. */
#define SIM_RD_SCGC6_PIT0(base) ((SIM_SCGC6_REG(base) & SIM_SCGC6_PIT0_MASK) >> SIM_SCGC6_PIT0_SHIFT)
#define SIM_BRD_SCGC6_PIT0(base) (BME_UBFX32(&SIM_SCGC6_REG(base), SIM_SCGC6_PIT0_SHIFT, SIM_SCGC6_PIT0_WIDTH))

/*! @brief Set the PIT0 field to a new value. */
#define SIM_WR_SCGC6_PIT0(base, value) (SIM_RMW_SCGC6(base, SIM_SCGC6_PIT0_MASK, SIM_SCGC6_PIT0(value)))
#define SIM_BWR_SCGC6_PIT0(base, value) (BME_BFI32(&SIM_SCGC6_REG(base), ((uint32_t)(value) << SIM_SCGC6_PIT0_SHIFT), SIM_SCGC6_PIT0_SHIFT, SIM_SCGC6_PIT0_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SCGC6, field PIT1[14] (RW)
 *
 * This bit controls the clock gate to the PIT1 module.
 *
 * Values:
 * - 0b0 - Clock disabled
 * - 0b1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC6_PIT1 field. */
#define SIM_RD_SCGC6_PIT1(base) ((SIM_SCGC6_REG(base) & SIM_SCGC6_PIT1_MASK) >> SIM_SCGC6_PIT1_SHIFT)
#define SIM_BRD_SCGC6_PIT1(base) (BME_UBFX32(&SIM_SCGC6_REG(base), SIM_SCGC6_PIT1_SHIFT, SIM_SCGC6_PIT1_WIDTH))

/*! @brief Set the PIT1 field to a new value. */
#define SIM_WR_SCGC6_PIT1(base, value) (SIM_RMW_SCGC6(base, SIM_SCGC6_PIT1_MASK, SIM_SCGC6_PIT1(value)))
#define SIM_BWR_SCGC6_PIT1(base, value) (BME_BFI32(&SIM_SCGC6_REG(base), ((uint32_t)(value) << SIM_SCGC6_PIT1_SHIFT), SIM_SCGC6_PIT1_SHIFT, SIM_SCGC6_PIT1_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SCGC6, field AFE[16] (RW)
 *
 * This bit controls the clock to all four AFE channels.
 *
 * Values:
 * - 0b0 - Clock disabled
 * - 0b1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC6_AFE field. */
#define SIM_RD_SCGC6_AFE(base) ((SIM_SCGC6_REG(base) & SIM_SCGC6_AFE_MASK) >> SIM_SCGC6_AFE_SHIFT)
#define SIM_BRD_SCGC6_AFE(base) (BME_UBFX32(&SIM_SCGC6_REG(base), SIM_SCGC6_AFE_SHIFT, SIM_SCGC6_AFE_WIDTH))

/*! @brief Set the AFE field to a new value. */
#define SIM_WR_SCGC6_AFE(base, value) (SIM_RMW_SCGC6(base, SIM_SCGC6_AFE_MASK, SIM_SCGC6_AFE(value)))
#define SIM_BWR_SCGC6_AFE(base, value) (BME_BFI32(&SIM_SCGC6_REG(base), ((uint32_t)(value) << SIM_SCGC6_AFE_SHIFT), SIM_SCGC6_AFE_SHIFT, SIM_SCGC6_AFE_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SCGC6, field CRC[20] (RW)
 *
 * This bit controls the clock gate to the PCRC module.
 *
 * Values:
 * - 0b0 - Clock disabled
 * - 0b1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC6_CRC field. */
#define SIM_RD_SCGC6_CRC(base) ((SIM_SCGC6_REG(base) & SIM_SCGC6_CRC_MASK) >> SIM_SCGC6_CRC_SHIFT)
#define SIM_BRD_SCGC6_CRC(base) (BME_UBFX32(&SIM_SCGC6_REG(base), SIM_SCGC6_CRC_SHIFT, SIM_SCGC6_CRC_WIDTH))

/*! @brief Set the CRC field to a new value. */
#define SIM_WR_SCGC6_CRC(base, value) (SIM_RMW_SCGC6(base, SIM_SCGC6_CRC_MASK, SIM_SCGC6_CRC(value)))
#define SIM_BWR_SCGC6_CRC(base, value) (BME_BFI32(&SIM_SCGC6_REG(base), ((uint32_t)(value) << SIM_SCGC6_CRC_SHIFT), SIM_SCGC6_CRC_SHIFT, SIM_SCGC6_CRC_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SCGC6, field PDB[22] (RW)
 *
 * This bit controls the clock gate to the PDB module.
 *
 * Values:
 * - 0b0 - Clock disabled
 * - 0b1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC6_PDB field. */
#define SIM_RD_SCGC6_PDB(base) ((SIM_SCGC6_REG(base) & SIM_SCGC6_PDB_MASK) >> SIM_SCGC6_PDB_SHIFT)
#define SIM_BRD_SCGC6_PDB(base) (BME_UBFX32(&SIM_SCGC6_REG(base), SIM_SCGC6_PDB_SHIFT, SIM_SCGC6_PDB_WIDTH))

/*! @brief Set the PDB field to a new value. */
#define SIM_WR_SCGC6_PDB(base, value) (SIM_RMW_SCGC6(base, SIM_SCGC6_PDB_MASK, SIM_SCGC6_PDB(value)))
#define SIM_BWR_SCGC6_PDB(base, value) (BME_BFI32(&SIM_SCGC6_REG(base), ((uint32_t)(value) << SIM_SCGC6_PDB_SHIFT), SIM_SCGC6_PDB_SHIFT, SIM_SCGC6_PDB_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SCGC6, field PORTJ[23] (RW)
 *
 * This bit controls the clock gate to the PCTLJ module.
 *
 * Values:
 * - 0b0 - Clock disabled
 * - 0b1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC6_PORTJ field. */
#define SIM_RD_SCGC6_PORTJ(base) ((SIM_SCGC6_REG(base) & SIM_SCGC6_PORTJ_MASK) >> SIM_SCGC6_PORTJ_SHIFT)
#define SIM_BRD_SCGC6_PORTJ(base) (BME_UBFX32(&SIM_SCGC6_REG(base), SIM_SCGC6_PORTJ_SHIFT, SIM_SCGC6_PORTJ_WIDTH))

/*! @brief Set the PORTJ field to a new value. */
#define SIM_WR_SCGC6_PORTJ(base, value) (SIM_RMW_SCGC6(base, SIM_SCGC6_PORTJ_MASK, SIM_SCGC6_PORTJ(value)))
#define SIM_BWR_SCGC6_PORTJ(base, value) (BME_BFI32(&SIM_SCGC6_REG(base), ((uint32_t)(value) << SIM_SCGC6_PORTJ_SHIFT), SIM_SCGC6_PORTJ_SHIFT, SIM_SCGC6_PORTJ_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SCGC6, field PORTK[24] (RW)
 *
 * This bit controls the clock gate to the PCTLK module.
 *
 * Values:
 * - 0b0 - Clock disabled
 * - 0b1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC6_PORTK field. */
#define SIM_RD_SCGC6_PORTK(base) ((SIM_SCGC6_REG(base) & SIM_SCGC6_PORTK_MASK) >> SIM_SCGC6_PORTK_SHIFT)
#define SIM_BRD_SCGC6_PORTK(base) (BME_UBFX32(&SIM_SCGC6_REG(base), SIM_SCGC6_PORTK_SHIFT, SIM_SCGC6_PORTK_WIDTH))

/*! @brief Set the PORTK field to a new value. */
#define SIM_WR_SCGC6_PORTK(base, value) (SIM_RMW_SCGC6(base, SIM_SCGC6_PORTK_MASK, SIM_SCGC6_PORTK(value)))
#define SIM_BWR_SCGC6_PORTK(base, value) (BME_BFI32(&SIM_SCGC6_REG(base), ((uint32_t)(value) << SIM_SCGC6_PORTK_SHIFT), SIM_SCGC6_PORTK_SHIFT, SIM_SCGC6_PORTK_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SCGC6, field PORTL[25] (RW)
 *
 * This bit controls the clock gate to the PCTLL module.
 *
 * Values:
 * - 0b0 - Clock disabled
 * - 0b1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC6_PORTL field. */
#define SIM_RD_SCGC6_PORTL(base) ((SIM_SCGC6_REG(base) & SIM_SCGC6_PORTL_MASK) >> SIM_SCGC6_PORTL_SHIFT)
#define SIM_BRD_SCGC6_PORTL(base) (BME_UBFX32(&SIM_SCGC6_REG(base), SIM_SCGC6_PORTL_SHIFT, SIM_SCGC6_PORTL_WIDTH))

/*! @brief Set the PORTL field to a new value. */
#define SIM_WR_SCGC6_PORTL(base, value) (SIM_RMW_SCGC6(base, SIM_SCGC6_PORTL_MASK, SIM_SCGC6_PORTL(value)))
#define SIM_BWR_SCGC6_PORTL(base, value) (BME_BFI32(&SIM_SCGC6_REG(base), ((uint32_t)(value) << SIM_SCGC6_PORTL_SHIFT), SIM_SCGC6_PORTL_SHIFT, SIM_SCGC6_PORTL_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SCGC6, field PORTM[26] (RW)
 *
 * This bit controls the clock gate to the PCTLM module.
 *
 * Values:
 * - 0b0 - Clock disabled
 * - 0b1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC6_PORTM field. */
#define SIM_RD_SCGC6_PORTM(base) ((SIM_SCGC6_REG(base) & SIM_SCGC6_PORTM_MASK) >> SIM_SCGC6_PORTM_SHIFT)
#define SIM_BRD_SCGC6_PORTM(base) (BME_UBFX32(&SIM_SCGC6_REG(base), SIM_SCGC6_PORTM_SHIFT, SIM_SCGC6_PORTM_WIDTH))

/*! @brief Set the PORTM field to a new value. */
#define SIM_WR_SCGC6_PORTM(base, value) (SIM_RMW_SCGC6(base, SIM_SCGC6_PORTM_MASK, SIM_SCGC6_PORTM(value)))
#define SIM_BWR_SCGC6_PORTM(base, value) (BME_BFI32(&SIM_SCGC6_REG(base), ((uint32_t)(value) << SIM_SCGC6_PORTM_SHIFT), SIM_SCGC6_PORTM_SHIFT, SIM_SCGC6_PORTM_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SCGC6, field LPTMR[28] (RW)
 *
 * This bit controls the clock gate to the LPTMR module.
 *
 * Values:
 * - 0b0 - Clock disabled
 * - 0b1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC6_LPTMR field. */
#define SIM_RD_SCGC6_LPTMR(base) ((SIM_SCGC6_REG(base) & SIM_SCGC6_LPTMR_MASK) >> SIM_SCGC6_LPTMR_SHIFT)
#define SIM_BRD_SCGC6_LPTMR(base) (BME_UBFX32(&SIM_SCGC6_REG(base), SIM_SCGC6_LPTMR_SHIFT, SIM_SCGC6_LPTMR_WIDTH))

/*! @brief Set the LPTMR field to a new value. */
#define SIM_WR_SCGC6_LPTMR(base, value) (SIM_RMW_SCGC6(base, SIM_SCGC6_LPTMR_MASK, SIM_SCGC6_LPTMR(value)))
#define SIM_BWR_SCGC6_LPTMR(base, value) (BME_BFI32(&SIM_SCGC6_REG(base), ((uint32_t)(value) << SIM_SCGC6_LPTMR_SHIFT), SIM_SCGC6_LPTMR_SHIFT, SIM_SCGC6_LPTMR_WIDTH))
/*@}*/

/*******************************************************************************
 * SIM_SCGC7 - System Clock Gating Control Register 7
 ******************************************************************************/

/*!
 * @brief SIM_SCGC7 - System Clock Gating Control Register 7 (RW)
 *
 * Reset value: 0x00000003U
 *
 * Writes to this register can only be performed in Supervisor mode
 */
/*!
 * @name Constants and macros for entire SIM_SCGC7 register
 */
/*@{*/
#define SIM_RD_SCGC7(base)       (SIM_SCGC7_REG(base))
#define SIM_WR_SCGC7(base, value) (SIM_SCGC7_REG(base) = (value))
#define SIM_RMW_SCGC7(base, mask, value) (SIM_WR_SCGC7(base, (SIM_RD_SCGC7(base) & ~(mask)) | (value)))
#define SIM_SET_SCGC7(base, value) (BME_OR32(&SIM_SCGC7_REG(base), (uint32_t)(value)))
#define SIM_CLR_SCGC7(base, value) (BME_AND32(&SIM_SCGC7_REG(base), (uint32_t)(~(value))))
#define SIM_TOG_SCGC7(base, value) (BME_XOR32(&SIM_SCGC7_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual SIM_SCGC7 bitfields
 */

/*!
 * @name Register SIM_SCGC7, field MPU[0] (RW)
 *
 * This bit controls the clock gate to the MPU module.
 *
 * Values:
 * - 0b0 - Clock disabled
 * - 0b1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC7_MPU field. */
#define SIM_RD_SCGC7_MPU(base) ((SIM_SCGC7_REG(base) & SIM_SCGC7_MPU_MASK) >> SIM_SCGC7_MPU_SHIFT)
#define SIM_BRD_SCGC7_MPU(base) (BME_UBFX32(&SIM_SCGC7_REG(base), SIM_SCGC7_MPU_SHIFT, SIM_SCGC7_MPU_WIDTH))

/*! @brief Set the MPU field to a new value. */
#define SIM_WR_SCGC7_MPU(base, value) (SIM_RMW_SCGC7(base, SIM_SCGC7_MPU_MASK, SIM_SCGC7_MPU(value)))
#define SIM_BWR_SCGC7_MPU(base, value) (BME_BFI32(&SIM_SCGC7_REG(base), ((uint32_t)(value) << SIM_SCGC7_MPU_SHIFT), SIM_SCGC7_MPU_SHIFT, SIM_SCGC7_MPU_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SCGC7, field DMA[1] (RW)
 *
 * This bit controls the clock gate to the DMA module.
 *
 * Values:
 * - 0b0 - Clock disabled
 * - 0b1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC7_DMA field. */
#define SIM_RD_SCGC7_DMA(base) ((SIM_SCGC7_REG(base) & SIM_SCGC7_DMA_MASK) >> SIM_SCGC7_DMA_SHIFT)
#define SIM_BRD_SCGC7_DMA(base) (BME_UBFX32(&SIM_SCGC7_REG(base), SIM_SCGC7_DMA_SHIFT, SIM_SCGC7_DMA_WIDTH))

/*! @brief Set the DMA field to a new value. */
#define SIM_WR_SCGC7_DMA(base, value) (SIM_RMW_SCGC7(base, SIM_SCGC7_DMA_MASK, SIM_SCGC7_DMA(value)))
#define SIM_BWR_SCGC7_DMA(base, value) (BME_BFI32(&SIM_SCGC7_REG(base), ((uint32_t)(value) << SIM_SCGC7_DMA_SHIFT), SIM_SCGC7_DMA_SHIFT, SIM_SCGC7_DMA_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SCGC7, field CAU[2] (RW)
 *
 * This bit controls the clock gate to the CAU module.
 *
 * Values:
 * - 0b0 - Clock disabled
 * - 0b1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC7_CAU field. */
#define SIM_RD_SCGC7_CAU(base) ((SIM_SCGC7_REG(base) & SIM_SCGC7_CAU_MASK) >> SIM_SCGC7_CAU_SHIFT)
#define SIM_BRD_SCGC7_CAU(base) (BME_UBFX32(&SIM_SCGC7_REG(base), SIM_SCGC7_CAU_SHIFT, SIM_SCGC7_CAU_WIDTH))

/*! @brief Set the CAU field to a new value. */
#define SIM_WR_SCGC7_CAU(base, value) (SIM_RMW_SCGC7(base, SIM_SCGC7_CAU_MASK, SIM_SCGC7_CAU(value)))
#define SIM_BWR_SCGC7_CAU(base, value) (BME_BFI32(&SIM_SCGC7_REG(base), ((uint32_t)(value) << SIM_SCGC7_CAU_SHIFT), SIM_SCGC7_CAU_SHIFT, SIM_SCGC7_CAU_WIDTH))
/*@}*/

/*******************************************************************************
 * SIM_CLKDIV1 - System Clock Divider Register 1
 ******************************************************************************/

/*!
 * @brief SIM_CLKDIV1 - System Clock Divider Register 1 (RW)
 *
 * Reset value: 0x01000000U
 *
 * Writes to this register can only be performed in Supervisor mode.
 */
/*!
 * @name Constants and macros for entire SIM_CLKDIV1 register
 */
/*@{*/
#define SIM_RD_CLKDIV1(base)     (SIM_CLKDIV1_REG(base))
#define SIM_WR_CLKDIV1(base, value) (SIM_CLKDIV1_REG(base) = (value))
#define SIM_RMW_CLKDIV1(base, mask, value) (SIM_WR_CLKDIV1(base, (SIM_RD_CLKDIV1(base) & ~(mask)) | (value)))
#define SIM_SET_CLKDIV1(base, value) (BME_OR32(&SIM_CLKDIV1_REG(base), (uint32_t)(value)))
#define SIM_CLR_CLKDIV1(base, value) (BME_AND32(&SIM_CLKDIV1_REG(base), (uint32_t)(~(value))))
#define SIM_TOG_CLKDIV1(base, value) (BME_XOR32(&SIM_CLKDIV1_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual SIM_CLKDIV1 bitfields
 */

/*!
 * @name Register SIM_CLKDIV1, field FLASHCLKMODE[16] (RW)
 *
 * This field is used to select the Flash clock mode.
 *
 * Values:
 * - 0b0 - Flash Clock is the same as BUS clock.
 * - 0b1 - Flash Clock is a half of BUS clock.
 */
/*@{*/
/*! @brief Read current value of the SIM_CLKDIV1_FLASHCLKMODE field. */
#define SIM_RD_CLKDIV1_FLASHCLKMODE(base) ((SIM_CLKDIV1_REG(base) & SIM_CLKDIV1_FLASHCLKMODE_MASK) >> SIM_CLKDIV1_FLASHCLKMODE_SHIFT)
#define SIM_BRD_CLKDIV1_FLASHCLKMODE(base) (BME_UBFX32(&SIM_CLKDIV1_REG(base), SIM_CLKDIV1_FLASHCLKMODE_SHIFT, SIM_CLKDIV1_FLASHCLKMODE_WIDTH))

/*! @brief Set the FLASHCLKMODE field to a new value. */
#define SIM_WR_CLKDIV1_FLASHCLKMODE(base, value) (SIM_RMW_CLKDIV1(base, SIM_CLKDIV1_FLASHCLKMODE_MASK, SIM_CLKDIV1_FLASHCLKMODE(value)))
#define SIM_BWR_CLKDIV1_FLASHCLKMODE(base, value) (BME_BFI32(&SIM_CLKDIV1_REG(base), ((uint32_t)(value) << SIM_CLKDIV1_FLASHCLKMODE_SHIFT), SIM_CLKDIV1_FLASHCLKMODE_SHIFT, SIM_CLKDIV1_FLASHCLKMODE_WIDTH))
/*@}*/

/*!
 * @name Register SIM_CLKDIV1, field CLKDIVBUS[25:24] (RW)
 *
 * This field can be used to program Bus clock divider.
 *
 * Values:
 * - 0b00 - SYSCLK:BUSCLK = 1:1
 * - 0b01 - SYSCLK:BUSCLK = 2:1
 * - 0b10 - SYSCLK:BUSCLK = 3:1
 * - 0b11 - SYSCLK:BUSCLK = 4:1
 */
/*@{*/
/*! @brief Read current value of the SIM_CLKDIV1_CLKDIVBUS field. */
#define SIM_RD_CLKDIV1_CLKDIVBUS(base) ((SIM_CLKDIV1_REG(base) & SIM_CLKDIV1_CLKDIVBUS_MASK) >> SIM_CLKDIV1_CLKDIVBUS_SHIFT)
#define SIM_BRD_CLKDIV1_CLKDIVBUS(base) (BME_UBFX32(&SIM_CLKDIV1_REG(base), SIM_CLKDIV1_CLKDIVBUS_SHIFT, SIM_CLKDIV1_CLKDIVBUS_WIDTH))

/*! @brief Set the CLKDIVBUS field to a new value. */
#define SIM_WR_CLKDIV1_CLKDIVBUS(base, value) (SIM_RMW_CLKDIV1(base, SIM_CLKDIV1_CLKDIVBUS_MASK, SIM_CLKDIV1_CLKDIVBUS(value)))
#define SIM_BWR_CLKDIV1_CLKDIVBUS(base, value) (BME_BFI32(&SIM_CLKDIV1_REG(base), ((uint32_t)(value) << SIM_CLKDIV1_CLKDIVBUS_SHIFT), SIM_CLKDIV1_CLKDIVBUS_SHIFT, SIM_CLKDIV1_CLKDIVBUS_WIDTH))
/*@}*/

/*!
 * @name Register SIM_CLKDIV1, field CLKDIVSYS[31:28] (RW)
 *
 * This field can be used to program Core/Platform divider.
 *
 * Values:
 * - 0b0000 - Divide by 1
 * - 0b0001 - Divide by 2
 * - 0b0010 - Divide by 3
 * - 0b0011 - Divide by 4 and so on... If FOPT[0] is 0, the divider is set to
 *     div-by-8 after system reset is deasserted (after completion of system
 *     initialization sequence).
 */
/*@{*/
/*! @brief Read current value of the SIM_CLKDIV1_CLKDIVSYS field. */
#define SIM_RD_CLKDIV1_CLKDIVSYS(base) ((SIM_CLKDIV1_REG(base) & SIM_CLKDIV1_CLKDIVSYS_MASK) >> SIM_CLKDIV1_CLKDIVSYS_SHIFT)
#define SIM_BRD_CLKDIV1_CLKDIVSYS(base) (BME_UBFX32(&SIM_CLKDIV1_REG(base), SIM_CLKDIV1_CLKDIVSYS_SHIFT, SIM_CLKDIV1_CLKDIVSYS_WIDTH))

/*! @brief Set the CLKDIVSYS field to a new value. */
#define SIM_WR_CLKDIV1_CLKDIVSYS(base, value) (SIM_RMW_CLKDIV1(base, SIM_CLKDIV1_CLKDIVSYS_MASK, SIM_CLKDIV1_CLKDIVSYS(value)))
#define SIM_BWR_CLKDIV1_CLKDIVSYS(base, value) (BME_BFI32(&SIM_CLKDIV1_REG(base), ((uint32_t)(value) << SIM_CLKDIV1_CLKDIVSYS_SHIFT), SIM_CLKDIV1_CLKDIVSYS_SHIFT, SIM_CLKDIV1_CLKDIVSYS_WIDTH))
/*@}*/

/*******************************************************************************
 * SIM_FCFG1 - Flash Configuration Register 1
 ******************************************************************************/

/*!
 * @brief SIM_FCFG1 - Flash Configuration Register 1 (RW)
 *
 * Reset value: 0x070F0000U
 *
 * Writes to this register can only be performed in Supervisor mode
 */
/*!
 * @name Constants and macros for entire SIM_FCFG1 register
 */
/*@{*/
#define SIM_RD_FCFG1(base)       (SIM_FCFG1_REG(base))
#define SIM_WR_FCFG1(base, value) (SIM_FCFG1_REG(base) = (value))
#define SIM_RMW_FCFG1(base, mask, value) (SIM_WR_FCFG1(base, (SIM_RD_FCFG1(base) & ~(mask)) | (value)))
#define SIM_SET_FCFG1(base, value) (BME_OR32(&SIM_FCFG1_REG(base), (uint32_t)(value)))
#define SIM_CLR_FCFG1(base, value) (BME_AND32(&SIM_FCFG1_REG(base), (uint32_t)(~(value))))
#define SIM_TOG_FCFG1(base, value) (BME_XOR32(&SIM_FCFG1_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual SIM_FCFG1 bitfields
 */

/*!
 * @name Register SIM_FCFG1, field FLASHDIS[0] (RW)
 *
 * Flash accesses are disabled (and generate a bus error) and the Flash memory
 * is placed in a low power state. This bit should not be changed during VLP
 * modes. Relocate the interrupt vectors out of Flash memory before disabling the
 * Flash.
 *
 * Values:
 * - 0b0 - Flash is enabled
 * - 0b1 - Flash is disabled
 */
/*@{*/
/*! @brief Read current value of the SIM_FCFG1_FLASHDIS field. */
#define SIM_RD_FCFG1_FLASHDIS(base) ((SIM_FCFG1_REG(base) & SIM_FCFG1_FLASHDIS_MASK) >> SIM_FCFG1_FLASHDIS_SHIFT)
#define SIM_BRD_FCFG1_FLASHDIS(base) (BME_UBFX32(&SIM_FCFG1_REG(base), SIM_FCFG1_FLASHDIS_SHIFT, SIM_FCFG1_FLASHDIS_WIDTH))

/*! @brief Set the FLASHDIS field to a new value. */
#define SIM_WR_FCFG1_FLASHDIS(base, value) (SIM_RMW_FCFG1(base, SIM_FCFG1_FLASHDIS_MASK, SIM_FCFG1_FLASHDIS(value)))
#define SIM_BWR_FCFG1_FLASHDIS(base, value) (BME_BFI32(&SIM_FCFG1_REG(base), ((uint32_t)(value) << SIM_FCFG1_FLASHDIS_SHIFT), SIM_FCFG1_FLASHDIS_SHIFT, SIM_FCFG1_FLASHDIS_WIDTH))
/*@}*/

/*!
 * @name Register SIM_FCFG1, field FLASHDOZE[1] (RW)
 *
 * When set, Flash memory is disabled for the duration of Wait mode. An attempt
 * by the DMA or other bus master to access the Flash when the Flash is disabled
 * will result in a bus error. This bit should be clear during VLP modes. The
 * Flash will be automatically enabled again at the end of Wait mode so interrupt
 * vectors do not need to be relocated out of Flash memory. The wakeup time from
 * Wait mode is extended when this bit is set.
 *
 * Values:
 * - 0b0 - Flash remains enabled during Wait mode
 * - 0b1 - Flash is disabled for the duration of Wait mode
 */
/*@{*/
/*! @brief Read current value of the SIM_FCFG1_FLASHDOZE field. */
#define SIM_RD_FCFG1_FLASHDOZE(base) ((SIM_FCFG1_REG(base) & SIM_FCFG1_FLASHDOZE_MASK) >> SIM_FCFG1_FLASHDOZE_SHIFT)
#define SIM_BRD_FCFG1_FLASHDOZE(base) (BME_UBFX32(&SIM_FCFG1_REG(base), SIM_FCFG1_FLASHDOZE_SHIFT, SIM_FCFG1_FLASHDOZE_WIDTH))

/*! @brief Set the FLASHDOZE field to a new value. */
#define SIM_WR_FCFG1_FLASHDOZE(base, value) (SIM_RMW_FCFG1(base, SIM_FCFG1_FLASHDOZE_MASK, SIM_FCFG1_FLASHDOZE(value)))
#define SIM_BWR_FCFG1_FLASHDOZE(base, value) (BME_BFI32(&SIM_FCFG1_REG(base), ((uint32_t)(value) << SIM_FCFG1_FLASHDOZE_SHIFT), SIM_FCFG1_FLASHDOZE_SHIFT, SIM_FCFG1_FLASHDOZE_WIDTH))
/*@}*/

/*!
 * @name Register SIM_FCFG1, field PFSIZE[27:24] (RO)
 *
 * This field specifies the amount of program flash memory available on the
 * device . Undefined values are reserved.
 *
 * Values:
 * - 0b0000 - Reserved
 * - 0b0001 - Reserved
 * - 0b0011 - Reserved
 * - 0b0100 - Reserved
 * - 0b0101 - Reserved
 * - 0b0110 - Reserved
 * - 0b0111 - 128 KB of program flash memory
 * - 0b1000 - Reserved
 * - 0b1001 - 256 KB of program flash memory
 * - 0b1111 - (Default)
 */
/*@{*/
/*! @brief Read current value of the SIM_FCFG1_PFSIZE field. */
#define SIM_RD_FCFG1_PFSIZE(base) ((SIM_FCFG1_REG(base) & SIM_FCFG1_PFSIZE_MASK) >> SIM_FCFG1_PFSIZE_SHIFT)
#define SIM_BRD_FCFG1_PFSIZE(base) (BME_UBFX32(&SIM_FCFG1_REG(base), SIM_FCFG1_PFSIZE_SHIFT, SIM_FCFG1_PFSIZE_WIDTH))
/*@}*/

/*******************************************************************************
 * SIM_FCFG2 - Flash Configuration Register 2
 ******************************************************************************/

/*!
 * @brief SIM_FCFG2 - Flash Configuration Register 2 (RO)
 *
 * Reset value: 0x10000000U
 *
 * Writes to this register can only be performed in Supervisor mode.
 */
/*!
 * @name Constants and macros for entire SIM_FCFG2 register
 */
/*@{*/
#define SIM_RD_FCFG2(base)       (SIM_FCFG2_REG(base))
/*@}*/

/*
 * Constants & macros for individual SIM_FCFG2 bitfields
 */

/*!
 * @name Register SIM_FCFG2, field MAXADDR[30:24] (RO)
 *
 * This field concatenated with 13 trailing zeros indicates the first invalid
 * address of each program flash block. For example, if MAXADDR0 = 0x20, the first
 * invalid address of flash is 0x0004_0000. This would be the MAXADDR value for a
 * device with 256 KB program flash in flash memory.
 */
/*@{*/
/*! @brief Read current value of the SIM_FCFG2_MAXADDR field. */
#define SIM_RD_FCFG2_MAXADDR(base) ((SIM_FCFG2_REG(base) & SIM_FCFG2_MAXADDR_MASK) >> SIM_FCFG2_MAXADDR_SHIFT)
#define SIM_BRD_FCFG2_MAXADDR(base) (BME_UBFX32(&SIM_FCFG2_REG(base), SIM_FCFG2_MAXADDR_SHIFT, SIM_FCFG2_MAXADDR_WIDTH))
/*@}*/

/*******************************************************************************
 * SIM_UIDH - Unique Identification Register High
 ******************************************************************************/

/*!
 * @brief SIM_UIDH - Unique Identification Register High (RO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire SIM_UIDH register
 */
/*@{*/
#define SIM_RD_UIDH(base)        (SIM_UIDH_REG(base))
/*@}*/

/*******************************************************************************
 * SIM_UIDMH - Unique Identification Register Mid-High
 ******************************************************************************/

/*!
 * @brief SIM_UIDMH - Unique Identification Register Mid-High (RO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire SIM_UIDMH register
 */
/*@{*/
#define SIM_RD_UIDMH(base)       (SIM_UIDMH_REG(base))
/*@}*/

/*******************************************************************************
 * SIM_UIDML - Unique Identification Register Mid-Low
 ******************************************************************************/

/*!
 * @brief SIM_UIDML - Unique Identification Register Mid-Low (RO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire SIM_UIDML register
 */
/*@{*/
#define SIM_RD_UIDML(base)       (SIM_UIDML_REG(base))
/*@}*/

/*******************************************************************************
 * SIM_UIDL - Unique Identification Register Low
 ******************************************************************************/

/*!
 * @brief SIM_UIDL - Unique Identification Register Low (RO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire SIM_UIDL register
 */
/*@{*/
#define SIM_RD_UIDL(base)        (SIM_UIDL_REG(base))
/*@}*/

/*******************************************************************************
 * SIM_MISC_CTL - Miscellaneous Control Register
 ******************************************************************************/

/*!
 * @brief SIM_MISC_CTL - Miscellaneous Control Register (RW)
 *
 * Reset value: 0x80000000U
 *
 * This register contains various fields to control miscellaneous features such
 * as receive/ transmit select for UART, PIT output selection, EWM input
 * selection, ClkOut selection, etc. Writes to this register can only be performed in
 * Supervisor mode.
 */
/*!
 * @name Constants and macros for entire SIM_MISC_CTL register
 */
/*@{*/
#define SIM_RD_MISC_CTL(base)    (SIM_MISC_CTL_REG(base))
#define SIM_WR_MISC_CTL(base, value) (SIM_MISC_CTL_REG(base) = (value))
#define SIM_RMW_MISC_CTL(base, mask, value) (SIM_WR_MISC_CTL(base, (SIM_RD_MISC_CTL(base) & ~(mask)) | (value)))
#define SIM_SET_MISC_CTL(base, value) (BME_OR32(&SIM_MISC_CTL_REG(base), (uint32_t)(value)))
#define SIM_CLR_MISC_CTL(base, value) (BME_AND32(&SIM_MISC_CTL_REG(base), (uint32_t)(~(value))))
#define SIM_TOG_MISC_CTL(base, value) (BME_XOR32(&SIM_MISC_CTL_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual SIM_MISC_CTL bitfields
 */

/*!
 * @name Register SIM_MISC_CTL, field OSCON[0] (RO)
 *
 * This field shows the status of RTC oscillator.
 *
 * Values:
 * - 0b0 - RTC oscillator is disabled.
 * - 0b1 - RTC oscillator is enabled.
 */
/*@{*/
/*! @brief Read current value of the SIM_MISC_CTL_OSCON field. */
#define SIM_RD_MISC_CTL_OSCON(base) ((SIM_MISC_CTL_REG(base) & SIM_MISC_CTL_OSCON_MASK) >> SIM_MISC_CTL_OSCON_SHIFT)
#define SIM_BRD_MISC_CTL_OSCON(base) (BME_UBFX32(&SIM_MISC_CTL_REG(base), SIM_MISC_CTL_OSCON_SHIFT, SIM_MISC_CTL_OSCON_WIDTH))
/*@}*/

/*!
 * @name Register SIM_MISC_CTL, field PDBADCTRG[1] (RW)
 *
 * This field can make PDB to trigger ADC directly.
 *
 * Values:
 * - 0b0 - XBAR to trigger ADC
 * - 0b1 - PDB output to trigger ADC
 */
/*@{*/
/*! @brief Read current value of the SIM_MISC_CTL_PDBADCTRG field. */
#define SIM_RD_MISC_CTL_PDBADCTRG(base) ((SIM_MISC_CTL_REG(base) & SIM_MISC_CTL_PDBADCTRG_MASK) >> SIM_MISC_CTL_PDBADCTRG_SHIFT)
#define SIM_BRD_MISC_CTL_PDBADCTRG(base) (BME_UBFX32(&SIM_MISC_CTL_REG(base), SIM_MISC_CTL_PDBADCTRG_SHIFT, SIM_MISC_CTL_PDBADCTRG_WIDTH))

/*! @brief Set the PDBADCTRG field to a new value. */
#define SIM_WR_MISC_CTL_PDBADCTRG(base, value) (SIM_RMW_MISC_CTL(base, SIM_MISC_CTL_PDBADCTRG_MASK, SIM_MISC_CTL_PDBADCTRG(value)))
#define SIM_BWR_MISC_CTL_PDBADCTRG(base, value) (BME_BFI32(&SIM_MISC_CTL_REG(base), ((uint32_t)(value) << SIM_MISC_CTL_PDBADCTRG_SHIFT), SIM_MISC_CTL_PDBADCTRG_SHIFT, SIM_MISC_CTL_PDBADCTRG_WIDTH))
/*@}*/

/*!
 * @name Register SIM_MISC_CTL, field DMADONESEL[3:2] (RW)
 *
 * This field can be used to select the DMA Done flag to drive XBAR_IN[32]
 *
 * Values:
 * - 0b00 - DMA0
 * - 0b01 - DMA1
 * - 0b10 - DMA2
 * - 0b11 - DMA3
 */
/*@{*/
/*! @brief Read current value of the SIM_MISC_CTL_DMADONESEL field. */
#define SIM_RD_MISC_CTL_DMADONESEL(base) ((SIM_MISC_CTL_REG(base) & SIM_MISC_CTL_DMADONESEL_MASK) >> SIM_MISC_CTL_DMADONESEL_SHIFT)
#define SIM_BRD_MISC_CTL_DMADONESEL(base) (BME_UBFX32(&SIM_MISC_CTL_REG(base), SIM_MISC_CTL_DMADONESEL_SHIFT, SIM_MISC_CTL_DMADONESEL_WIDTH))

/*! @brief Set the DMADONESEL field to a new value. */
#define SIM_WR_MISC_CTL_DMADONESEL(base, value) (SIM_RMW_MISC_CTL(base, SIM_MISC_CTL_DMADONESEL_MASK, SIM_MISC_CTL_DMADONESEL(value)))
#define SIM_BWR_MISC_CTL_DMADONESEL(base, value) (BME_BFI32(&SIM_MISC_CTL_REG(base), ((uint32_t)(value) << SIM_MISC_CTL_DMADONESEL_SHIFT), SIM_MISC_CTL_DMADONESEL_SHIFT, SIM_MISC_CTL_DMADONESEL_WIDTH))
/*@}*/

/*!
 * @name Register SIM_MISC_CTL, field AFECLKSEL[5:4] (RW)
 *
 * Selects between PLL, FLL and OSC clock as the source for the PLL clock branch
 * for AFE Clock Mux
 *
 * Values:
 * - 0b00 - MCG PLL Clock selected
 * - 0b01 - MCG FLL Clock selected
 * - 0b10 - OSC Clock selected
 * - 0b11 - Disabled
 */
/*@{*/
/*! @brief Read current value of the SIM_MISC_CTL_AFECLKSEL field. */
#define SIM_RD_MISC_CTL_AFECLKSEL(base) ((SIM_MISC_CTL_REG(base) & SIM_MISC_CTL_AFECLKSEL_MASK) >> SIM_MISC_CTL_AFECLKSEL_SHIFT)
#define SIM_BRD_MISC_CTL_AFECLKSEL(base) (BME_UBFX32(&SIM_MISC_CTL_REG(base), SIM_MISC_CTL_AFECLKSEL_SHIFT, SIM_MISC_CTL_AFECLKSEL_WIDTH))

/*! @brief Set the AFECLKSEL field to a new value. */
#define SIM_WR_MISC_CTL_AFECLKSEL(base, value) (SIM_RMW_MISC_CTL(base, SIM_MISC_CTL_AFECLKSEL_MASK, SIM_MISC_CTL_AFECLKSEL(value)))
#define SIM_BWR_MISC_CTL_AFECLKSEL(base, value) (BME_BFI32(&SIM_MISC_CTL_REG(base), ((uint32_t)(value) << SIM_MISC_CTL_AFECLKSEL_SHIFT), SIM_MISC_CTL_AFECLKSEL_SHIFT, SIM_MISC_CTL_AFECLKSEL_WIDTH))
/*@}*/

/*!
 * @name Register SIM_MISC_CTL, field AFECLKPADDIR[6] (RW)
 *
 * Controls the direction of the AFE CLK pin
 *
 * Values:
 * - 0b0 - AFE CLK PAD is input
 * - 0b1 - AFE CLK PAD is output
 */
/*@{*/
/*! @brief Read current value of the SIM_MISC_CTL_AFECLKPADDIR field. */
#define SIM_RD_MISC_CTL_AFECLKPADDIR(base) ((SIM_MISC_CTL_REG(base) & SIM_MISC_CTL_AFECLKPADDIR_MASK) >> SIM_MISC_CTL_AFECLKPADDIR_SHIFT)
#define SIM_BRD_MISC_CTL_AFECLKPADDIR(base) (BME_UBFX32(&SIM_MISC_CTL_REG(base), SIM_MISC_CTL_AFECLKPADDIR_SHIFT, SIM_MISC_CTL_AFECLKPADDIR_WIDTH))

/*! @brief Set the AFECLKPADDIR field to a new value. */
#define SIM_WR_MISC_CTL_AFECLKPADDIR(base, value) (SIM_RMW_MISC_CTL(base, SIM_MISC_CTL_AFECLKPADDIR_MASK, SIM_MISC_CTL_AFECLKPADDIR(value)))
#define SIM_BWR_MISC_CTL_AFECLKPADDIR(base, value) (BME_BFI32(&SIM_MISC_CTL_REG(base), ((uint32_t)(value) << SIM_MISC_CTL_AFECLKPADDIR_SHIFT), SIM_MISC_CTL_AFECLKPADDIR_SHIFT, SIM_MISC_CTL_AFECLKPADDIR_WIDTH))
/*@}*/

/*!
 * @name Register SIM_MISC_CTL, field UARTMODTYPE[7] (RW)
 *
 * Selects between TypeA and TypeB modulation for IrDA support
 *
 * Values:
 * - 0b0 - TypeA (OR'ed) Modulation selected for IrDA
 * - 0b1 - TypeB (AND'ed) Modulation selected for IrDA
 */
/*@{*/
/*! @brief Read current value of the SIM_MISC_CTL_UARTMODTYPE field. */
#define SIM_RD_MISC_CTL_UARTMODTYPE(base) ((SIM_MISC_CTL_REG(base) & SIM_MISC_CTL_UARTMODTYPE_MASK) >> SIM_MISC_CTL_UARTMODTYPE_SHIFT)
#define SIM_BRD_MISC_CTL_UARTMODTYPE(base) (BME_UBFX32(&SIM_MISC_CTL_REG(base), SIM_MISC_CTL_UARTMODTYPE_SHIFT, SIM_MISC_CTL_UARTMODTYPE_WIDTH))

/*! @brief Set the UARTMODTYPE field to a new value. */
#define SIM_WR_MISC_CTL_UARTMODTYPE(base, value) (SIM_RMW_MISC_CTL(base, SIM_MISC_CTL_UARTMODTYPE_MASK, SIM_MISC_CTL_UARTMODTYPE(value)))
#define SIM_BWR_MISC_CTL_UARTMODTYPE(base, value) (BME_BFI32(&SIM_MISC_CTL_REG(base), ((uint32_t)(value) << SIM_MISC_CTL_UARTMODTYPE_SHIFT), SIM_MISC_CTL_UARTMODTYPE_SHIFT, SIM_MISC_CTL_UARTMODTYPE_WIDTH))
/*@}*/

/*!
 * @name Register SIM_MISC_CTL, field UART0IRSEL[8] (RW)
 *
 * Exclusive selection with other UARTs. Do not select while another UART is
 * selected for the same functionality
 *
 * Values:
 * - 0b0 - Pad RX input (PTD[0], PTF[3] or PTK[3], as selected in Pinmux
 *     control) selected for RX input of UART0 and UART0 TX signal is not used for
 *     modulation
 * - 0b1 - UART0 selected for IrDA modulation. UART0 TX modulated by
 *     XBAR_OUT[14] and UART0 RX input connected to XBAR_OUT[13]. UARTxIRSEL cannot
 *     configure XBAR_OUT[14] and XBAR_OUT[13] automatically, and they need extra
 *     configuration in XBAR. User should configure XBAR[14:13] accordingly.
 */
/*@{*/
/*! @brief Read current value of the SIM_MISC_CTL_UART0IRSEL field. */
#define SIM_RD_MISC_CTL_UART0IRSEL(base) ((SIM_MISC_CTL_REG(base) & SIM_MISC_CTL_UART0IRSEL_MASK) >> SIM_MISC_CTL_UART0IRSEL_SHIFT)
#define SIM_BRD_MISC_CTL_UART0IRSEL(base) (BME_UBFX32(&SIM_MISC_CTL_REG(base), SIM_MISC_CTL_UART0IRSEL_SHIFT, SIM_MISC_CTL_UART0IRSEL_WIDTH))

/*! @brief Set the UART0IRSEL field to a new value. */
#define SIM_WR_MISC_CTL_UART0IRSEL(base, value) (SIM_RMW_MISC_CTL(base, SIM_MISC_CTL_UART0IRSEL_MASK, SIM_MISC_CTL_UART0IRSEL(value)))
#define SIM_BWR_MISC_CTL_UART0IRSEL(base, value) (BME_BFI32(&SIM_MISC_CTL_REG(base), ((uint32_t)(value) << SIM_MISC_CTL_UART0IRSEL_SHIFT), SIM_MISC_CTL_UART0IRSEL_SHIFT, SIM_MISC_CTL_UART0IRSEL_WIDTH))
/*@}*/

/*!
 * @name Register SIM_MISC_CTL, field UART1IRSEL[9] (RW)
 *
 * Exclusive selection with other UARTs. Do not select while another UART is
 * selected for the same functionality
 *
 * Values:
 * - 0b0 - Pad RX input (PTD[2], PTI[0] or PTK[5], as selected in Pinmux
 *     control) selected for RX input of UART1 and UART1 TX signal is not used for
 *     modulation
 * - 0b1 - UART1 selected for IrDA modulation. UART1 TX modulated by
 *     XBAR_OUT[14] and UART1 RX input connected to XBAR_OUT[13].UARTxIRSEL cannot configure
 *     XBAR_OUT[14] and XBAR_OUT[13] automatically, and they need extra
 *     configuration in XBAR. User should configure XBAR[14:13] accordingly.
 */
/*@{*/
/*! @brief Read current value of the SIM_MISC_CTL_UART1IRSEL field. */
#define SIM_RD_MISC_CTL_UART1IRSEL(base) ((SIM_MISC_CTL_REG(base) & SIM_MISC_CTL_UART1IRSEL_MASK) >> SIM_MISC_CTL_UART1IRSEL_SHIFT)
#define SIM_BRD_MISC_CTL_UART1IRSEL(base) (BME_UBFX32(&SIM_MISC_CTL_REG(base), SIM_MISC_CTL_UART1IRSEL_SHIFT, SIM_MISC_CTL_UART1IRSEL_WIDTH))

/*! @brief Set the UART1IRSEL field to a new value. */
#define SIM_WR_MISC_CTL_UART1IRSEL(base, value) (SIM_RMW_MISC_CTL(base, SIM_MISC_CTL_UART1IRSEL_MASK, SIM_MISC_CTL_UART1IRSEL(value)))
#define SIM_BWR_MISC_CTL_UART1IRSEL(base, value) (BME_BFI32(&SIM_MISC_CTL_REG(base), ((uint32_t)(value) << SIM_MISC_CTL_UART1IRSEL_SHIFT), SIM_MISC_CTL_UART1IRSEL_SHIFT, SIM_MISC_CTL_UART1IRSEL_WIDTH))
/*@}*/

/*!
 * @name Register SIM_MISC_CTL, field UART2IRSEL[10] (RW)
 *
 * Exclusive selection with other UARTs. Do not select while another UART is
 * selected for the same functionality
 *
 * Values:
 * - 0b0 - Pad RX input PTI[6] or PTE[6] selected for RX input of UART2 and
 *     UART2 TX signal is not used for modulation
 * - 0b1 - UART2 selected for IrDA modulation. UART2 TX modulated by
 *     XBAR_OUT[14] and UART2 RX input connected to XBAR_OUT[13].UARTxIRSEL cannot configure
 *     XBAR_OUT[14] and XBAR_OUT[13] automatically, and they need extra
 *     configuration in XBAR. User should configure XBAR[14:13] accordingly.
 */
/*@{*/
/*! @brief Read current value of the SIM_MISC_CTL_UART2IRSEL field. */
#define SIM_RD_MISC_CTL_UART2IRSEL(base) ((SIM_MISC_CTL_REG(base) & SIM_MISC_CTL_UART2IRSEL_MASK) >> SIM_MISC_CTL_UART2IRSEL_SHIFT)
#define SIM_BRD_MISC_CTL_UART2IRSEL(base) (BME_UBFX32(&SIM_MISC_CTL_REG(base), SIM_MISC_CTL_UART2IRSEL_SHIFT, SIM_MISC_CTL_UART2IRSEL_WIDTH))

/*! @brief Set the UART2IRSEL field to a new value. */
#define SIM_WR_MISC_CTL_UART2IRSEL(base, value) (SIM_RMW_MISC_CTL(base, SIM_MISC_CTL_UART2IRSEL_MASK, SIM_MISC_CTL_UART2IRSEL(value)))
#define SIM_BWR_MISC_CTL_UART2IRSEL(base, value) (BME_BFI32(&SIM_MISC_CTL_REG(base), ((uint32_t)(value) << SIM_MISC_CTL_UART2IRSEL_SHIFT), SIM_MISC_CTL_UART2IRSEL_SHIFT, SIM_MISC_CTL_UART2IRSEL_WIDTH))
/*@}*/

/*!
 * @name Register SIM_MISC_CTL, field UART3IRSEL[11] (RW)
 *
 * Exclusive selection with other UARTs. Do not select while another UART is
 * selected for the same functionality
 *
 * Values:
 * - 0b0 - Pad RX input (PTC[3] or PTD[7], as selected in Pinmux control)
 *     selected for RX input of UART3 and UART3 TX signal is not used for modulation
 * - 0b1 - UART3 selected for IrDA modulation. UART3 TX modulated by
 *     XBAR_OUT[14] and UART3 RX input connected to XBAR_OUT[13]. UARTxIRSEL cannot
 *     configure XBAR_OUT[14] and XBAR_OUT[13] automatically, and they need extra
 *     configuration in XBAR. User should configure XBAR[14:13] accordingly.
 */
/*@{*/
/*! @brief Read current value of the SIM_MISC_CTL_UART3IRSEL field. */
#define SIM_RD_MISC_CTL_UART3IRSEL(base) ((SIM_MISC_CTL_REG(base) & SIM_MISC_CTL_UART3IRSEL_MASK) >> SIM_MISC_CTL_UART3IRSEL_SHIFT)
#define SIM_BRD_MISC_CTL_UART3IRSEL(base) (BME_UBFX32(&SIM_MISC_CTL_REG(base), SIM_MISC_CTL_UART3IRSEL_SHIFT, SIM_MISC_CTL_UART3IRSEL_WIDTH))

/*! @brief Set the UART3IRSEL field to a new value. */
#define SIM_WR_MISC_CTL_UART3IRSEL(base, value) (SIM_RMW_MISC_CTL(base, SIM_MISC_CTL_UART3IRSEL_MASK, SIM_MISC_CTL_UART3IRSEL(value)))
#define SIM_BWR_MISC_CTL_UART3IRSEL(base, value) (BME_BFI32(&SIM_MISC_CTL_REG(base), ((uint32_t)(value) << SIM_MISC_CTL_UART3IRSEL_SHIFT), SIM_MISC_CTL_UART3IRSEL_SHIFT, SIM_MISC_CTL_UART3IRSEL_WIDTH))
/*@}*/

/*!
 * @name Register SIM_MISC_CTL, field EWMINSEL[14] (RW)
 *
 * This field is used to select input for external watchdog monitor.
 *
 * Values:
 * - 0b0 - Input from PAD (PTL[3], PTE[2] or PTE[3] as selected from Pinmux
 *     control )
 * - 0b1 - Peripheral Crossbar (XBAR) Output[32]
 */
/*@{*/
/*! @brief Read current value of the SIM_MISC_CTL_EWMINSEL field. */
#define SIM_RD_MISC_CTL_EWMINSEL(base) ((SIM_MISC_CTL_REG(base) & SIM_MISC_CTL_EWMINSEL_MASK) >> SIM_MISC_CTL_EWMINSEL_SHIFT)
#define SIM_BRD_MISC_CTL_EWMINSEL(base) (BME_UBFX32(&SIM_MISC_CTL_REG(base), SIM_MISC_CTL_EWMINSEL_SHIFT, SIM_MISC_CTL_EWMINSEL_WIDTH))

/*! @brief Set the EWMINSEL field to a new value. */
#define SIM_WR_MISC_CTL_EWMINSEL(base, value) (SIM_RMW_MISC_CTL(base, SIM_MISC_CTL_EWMINSEL_MASK, SIM_MISC_CTL_EWMINSEL(value)))
#define SIM_BWR_MISC_CTL_EWMINSEL(base, value) (BME_BFI32(&SIM_MISC_CTL_REG(base), ((uint32_t)(value) << SIM_MISC_CTL_EWMINSEL_SHIFT), SIM_MISC_CTL_EWMINSEL_SHIFT, SIM_MISC_CTL_EWMINSEL_WIDTH))
/*@}*/

/*!
 * @name Register SIM_MISC_CTL, field TMR0PLLSEL[15] (RW)
 *
 * Values:
 * - 0b0 - Selects Bus Clock as source for the Timer CH0
 * - 0b1 - Selects the PLL_AFE clock as the source for Timer CH0. The PLL_AFE
 *     clock source is itself selected using the MISC_CTL[5:4]
 */
/*@{*/
/*! @brief Read current value of the SIM_MISC_CTL_TMR0PLLSEL field. */
#define SIM_RD_MISC_CTL_TMR0PLLSEL(base) ((SIM_MISC_CTL_REG(base) & SIM_MISC_CTL_TMR0PLLSEL_MASK) >> SIM_MISC_CTL_TMR0PLLSEL_SHIFT)
#define SIM_BRD_MISC_CTL_TMR0PLLSEL(base) (BME_UBFX32(&SIM_MISC_CTL_REG(base), SIM_MISC_CTL_TMR0PLLSEL_SHIFT, SIM_MISC_CTL_TMR0PLLSEL_WIDTH))

/*! @brief Set the TMR0PLLSEL field to a new value. */
#define SIM_WR_MISC_CTL_TMR0PLLSEL(base, value) (SIM_RMW_MISC_CTL(base, SIM_MISC_CTL_TMR0PLLSEL_MASK, SIM_MISC_CTL_TMR0PLLSEL(value)))
#define SIM_BWR_MISC_CTL_TMR0PLLSEL(base, value) (BME_BFI32(&SIM_MISC_CTL_REG(base), ((uint32_t)(value) << SIM_MISC_CTL_TMR0PLLSEL_SHIFT), SIM_MISC_CTL_TMR0PLLSEL_SHIFT, SIM_MISC_CTL_TMR0PLLSEL_WIDTH))
/*@}*/

/*!
 * @name Register SIM_MISC_CTL, field TMR0SCSEL[16] (RW)
 *
 * This field is used to select secondary count input source for Quadtimer
 * Channel0. Configure TMR0_CTRL[SCS] = 00b to route selected secondary source to the
 * timer Channel0.
 *
 * Values:
 * - 0b0 - Pad PTF1 or PTD5, depending upon PCTL configuration.
 * - 0b1 - Peripheral Crossbar (XBAR) Output[5]
 */
/*@{*/
/*! @brief Read current value of the SIM_MISC_CTL_TMR0SCSEL field. */
#define SIM_RD_MISC_CTL_TMR0SCSEL(base) ((SIM_MISC_CTL_REG(base) & SIM_MISC_CTL_TMR0SCSEL_MASK) >> SIM_MISC_CTL_TMR0SCSEL_SHIFT)
#define SIM_BRD_MISC_CTL_TMR0SCSEL(base) (BME_UBFX32(&SIM_MISC_CTL_REG(base), SIM_MISC_CTL_TMR0SCSEL_SHIFT, SIM_MISC_CTL_TMR0SCSEL_WIDTH))

/*! @brief Set the TMR0SCSEL field to a new value. */
#define SIM_WR_MISC_CTL_TMR0SCSEL(base, value) (SIM_RMW_MISC_CTL(base, SIM_MISC_CTL_TMR0SCSEL_MASK, SIM_MISC_CTL_TMR0SCSEL(value)))
#define SIM_BWR_MISC_CTL_TMR0SCSEL(base, value) (BME_BFI32(&SIM_MISC_CTL_REG(base), ((uint32_t)(value) << SIM_MISC_CTL_TMR0SCSEL_SHIFT), SIM_MISC_CTL_TMR0SCSEL_SHIFT, SIM_MISC_CTL_TMR0SCSEL_WIDTH))
/*@}*/

/*!
 * @name Register SIM_MISC_CTL, field TMR1SCSEL[17] (RW)
 *
 * This field is used to select secondary count input source for Quadtimer
 * Channel1. Configure TMR1_CTRL[SCS] = 01b to route selected secondary source to the
 * timer Channel1.
 *
 * Values:
 * - 0b0 - Pad PTG0 or PTC6, depending upon PCTL configuration.
 * - 0b1 - Peripheral Crossbar (XBAR) Output[6]
 */
/*@{*/
/*! @brief Read current value of the SIM_MISC_CTL_TMR1SCSEL field. */
#define SIM_RD_MISC_CTL_TMR1SCSEL(base) ((SIM_MISC_CTL_REG(base) & SIM_MISC_CTL_TMR1SCSEL_MASK) >> SIM_MISC_CTL_TMR1SCSEL_SHIFT)
#define SIM_BRD_MISC_CTL_TMR1SCSEL(base) (BME_UBFX32(&SIM_MISC_CTL_REG(base), SIM_MISC_CTL_TMR1SCSEL_SHIFT, SIM_MISC_CTL_TMR1SCSEL_WIDTH))

/*! @brief Set the TMR1SCSEL field to a new value. */
#define SIM_WR_MISC_CTL_TMR1SCSEL(base, value) (SIM_RMW_MISC_CTL(base, SIM_MISC_CTL_TMR1SCSEL_MASK, SIM_MISC_CTL_TMR1SCSEL(value)))
#define SIM_BWR_MISC_CTL_TMR1SCSEL(base, value) (BME_BFI32(&SIM_MISC_CTL_REG(base), ((uint32_t)(value) << SIM_MISC_CTL_TMR1SCSEL_SHIFT), SIM_MISC_CTL_TMR1SCSEL_SHIFT, SIM_MISC_CTL_TMR1SCSEL_WIDTH))
/*@}*/

/*!
 * @name Register SIM_MISC_CTL, field TMR2SCSEL[18] (RW)
 *
 * This field is used to select secondary count input source for Quadtimer
 * Channel2. Configure TMR2_CTRL[SCS] = 10b to route selected secondary source to the
 * timer Channel2.
 *
 * Values:
 * - 0b0 - Pad PTF7 or PTF0, depending upon PCTL configuration.
 * - 0b1 - Peripheral Crossbar (XBAR) Output[7]
 */
/*@{*/
/*! @brief Read current value of the SIM_MISC_CTL_TMR2SCSEL field. */
#define SIM_RD_MISC_CTL_TMR2SCSEL(base) ((SIM_MISC_CTL_REG(base) & SIM_MISC_CTL_TMR2SCSEL_MASK) >> SIM_MISC_CTL_TMR2SCSEL_SHIFT)
#define SIM_BRD_MISC_CTL_TMR2SCSEL(base) (BME_UBFX32(&SIM_MISC_CTL_REG(base), SIM_MISC_CTL_TMR2SCSEL_SHIFT, SIM_MISC_CTL_TMR2SCSEL_WIDTH))

/*! @brief Set the TMR2SCSEL field to a new value. */
#define SIM_WR_MISC_CTL_TMR2SCSEL(base, value) (SIM_RMW_MISC_CTL(base, SIM_MISC_CTL_TMR2SCSEL_MASK, SIM_MISC_CTL_TMR2SCSEL(value)))
#define SIM_BWR_MISC_CTL_TMR2SCSEL(base, value) (BME_BFI32(&SIM_MISC_CTL_REG(base), ((uint32_t)(value) << SIM_MISC_CTL_TMR2SCSEL_SHIFT), SIM_MISC_CTL_TMR2SCSEL_SHIFT, SIM_MISC_CTL_TMR2SCSEL_WIDTH))
/*@}*/

/*!
 * @name Register SIM_MISC_CTL, field TMR3SCSEL[19] (RW)
 *
 * This field is used to select secondary count input source for Quadtimer
 * Channel3. Configure TMR3_CTRL[SCS] = 11b to route selected secondary source to the
 * timer Channel3.
 *
 * Values:
 * - 0b0 - Pad PTE5 or PTD1, depending upon PCTL configuration.
 * - 0b1 - Peripheral Crossbar (XBAR) Output[8]
 */
/*@{*/
/*! @brief Read current value of the SIM_MISC_CTL_TMR3SCSEL field. */
#define SIM_RD_MISC_CTL_TMR3SCSEL(base) ((SIM_MISC_CTL_REG(base) & SIM_MISC_CTL_TMR3SCSEL_MASK) >> SIM_MISC_CTL_TMR3SCSEL_SHIFT)
#define SIM_BRD_MISC_CTL_TMR3SCSEL(base) (BME_UBFX32(&SIM_MISC_CTL_REG(base), SIM_MISC_CTL_TMR3SCSEL_SHIFT, SIM_MISC_CTL_TMR3SCSEL_WIDTH))

/*! @brief Set the TMR3SCSEL field to a new value. */
#define SIM_WR_MISC_CTL_TMR3SCSEL(base, value) (SIM_RMW_MISC_CTL(base, SIM_MISC_CTL_TMR3SCSEL_MASK, SIM_MISC_CTL_TMR3SCSEL(value)))
#define SIM_BWR_MISC_CTL_TMR3SCSEL(base, value) (BME_BFI32(&SIM_MISC_CTL_REG(base), ((uint32_t)(value) << SIM_MISC_CTL_TMR3SCSEL_SHIFT), SIM_MISC_CTL_TMR3SCSEL_SHIFT, SIM_MISC_CTL_TMR3SCSEL_WIDTH))
/*@}*/

/*!
 * @name Register SIM_MISC_CTL, field TMR0PCSSEL[21:20] (RW)
 *
 * This is used to select primary count source (clock) for Quadtimer Channel0.
 * Configure TMR0_CTRL[PCS] = 1xxxb to route selected primary clock source to the
 * timer Channel0.
 *
 * Values:
 * - 0b00 - Bus Clock
 * - 0b01 - Peripheral Crossbar Output [9]
 * - 0b10 - Peripheral Crossbar Output [10]
 * - 0b11 - Disabled
 */
/*@{*/
/*! @brief Read current value of the SIM_MISC_CTL_TMR0PCSSEL field. */
#define SIM_RD_MISC_CTL_TMR0PCSSEL(base) ((SIM_MISC_CTL_REG(base) & SIM_MISC_CTL_TMR0PCSSEL_MASK) >> SIM_MISC_CTL_TMR0PCSSEL_SHIFT)
#define SIM_BRD_MISC_CTL_TMR0PCSSEL(base) (BME_UBFX32(&SIM_MISC_CTL_REG(base), SIM_MISC_CTL_TMR0PCSSEL_SHIFT, SIM_MISC_CTL_TMR0PCSSEL_WIDTH))

/*! @brief Set the TMR0PCSSEL field to a new value. */
#define SIM_WR_MISC_CTL_TMR0PCSSEL(base, value) (SIM_RMW_MISC_CTL(base, SIM_MISC_CTL_TMR0PCSSEL_MASK, SIM_MISC_CTL_TMR0PCSSEL(value)))
#define SIM_BWR_MISC_CTL_TMR0PCSSEL(base, value) (BME_BFI32(&SIM_MISC_CTL_REG(base), ((uint32_t)(value) << SIM_MISC_CTL_TMR0PCSSEL_SHIFT), SIM_MISC_CTL_TMR0PCSSEL_SHIFT, SIM_MISC_CTL_TMR0PCSSEL_WIDTH))
/*@}*/

/*!
 * @name Register SIM_MISC_CTL, field TMR1PCSSEL[23:22] (RW)
 *
 * This is used to select primary count source (clock) for Quadtimer Channel1.
 * Configure TMR1_CTRL[PCS] = 1xxxb to route selected primary clock source to the
 * timer Channel1.
 *
 * Values:
 * - 0b00 - Bus Clock
 * - 0b01 - Peripheral Crossbar Output [9]
 * - 0b10 - Peripheral Crossbar Output [10]
 * - 0b11 - Disabled
 */
/*@{*/
/*! @brief Read current value of the SIM_MISC_CTL_TMR1PCSSEL field. */
#define SIM_RD_MISC_CTL_TMR1PCSSEL(base) ((SIM_MISC_CTL_REG(base) & SIM_MISC_CTL_TMR1PCSSEL_MASK) >> SIM_MISC_CTL_TMR1PCSSEL_SHIFT)
#define SIM_BRD_MISC_CTL_TMR1PCSSEL(base) (BME_UBFX32(&SIM_MISC_CTL_REG(base), SIM_MISC_CTL_TMR1PCSSEL_SHIFT, SIM_MISC_CTL_TMR1PCSSEL_WIDTH))

/*! @brief Set the TMR1PCSSEL field to a new value. */
#define SIM_WR_MISC_CTL_TMR1PCSSEL(base, value) (SIM_RMW_MISC_CTL(base, SIM_MISC_CTL_TMR1PCSSEL_MASK, SIM_MISC_CTL_TMR1PCSSEL(value)))
#define SIM_BWR_MISC_CTL_TMR1PCSSEL(base, value) (BME_BFI32(&SIM_MISC_CTL_REG(base), ((uint32_t)(value) << SIM_MISC_CTL_TMR1PCSSEL_SHIFT), SIM_MISC_CTL_TMR1PCSSEL_SHIFT, SIM_MISC_CTL_TMR1PCSSEL_WIDTH))
/*@}*/

/*!
 * @name Register SIM_MISC_CTL, field TMR2PCSSEL[25:24] (RW)
 *
 * This is used to select primary count source (clock) for Quadtimer Channel2.
 * Configure TMR2_CTRL[PCS] = 1xxxb to route selected primary clock source to the
 * timer Channel2.
 *
 * Values:
 * - 0b00 - Bus Clock
 * - 0b01 - Peripheral Crossbar Output [9]
 * - 0b10 - Peripheral Crossbar Output [10]
 * - 0b11 - Disabled
 */
/*@{*/
/*! @brief Read current value of the SIM_MISC_CTL_TMR2PCSSEL field. */
#define SIM_RD_MISC_CTL_TMR2PCSSEL(base) ((SIM_MISC_CTL_REG(base) & SIM_MISC_CTL_TMR2PCSSEL_MASK) >> SIM_MISC_CTL_TMR2PCSSEL_SHIFT)
#define SIM_BRD_MISC_CTL_TMR2PCSSEL(base) (BME_UBFX32(&SIM_MISC_CTL_REG(base), SIM_MISC_CTL_TMR2PCSSEL_SHIFT, SIM_MISC_CTL_TMR2PCSSEL_WIDTH))

/*! @brief Set the TMR2PCSSEL field to a new value. */
#define SIM_WR_MISC_CTL_TMR2PCSSEL(base, value) (SIM_RMW_MISC_CTL(base, SIM_MISC_CTL_TMR2PCSSEL_MASK, SIM_MISC_CTL_TMR2PCSSEL(value)))
#define SIM_BWR_MISC_CTL_TMR2PCSSEL(base, value) (BME_BFI32(&SIM_MISC_CTL_REG(base), ((uint32_t)(value) << SIM_MISC_CTL_TMR2PCSSEL_SHIFT), SIM_MISC_CTL_TMR2PCSSEL_SHIFT, SIM_MISC_CTL_TMR2PCSSEL_WIDTH))
/*@}*/

/*!
 * @name Register SIM_MISC_CTL, field TMR3PCSSEL[27:26] (RW)
 *
 * This is used to select primary count source (clock) for Quadtimer Channel3.
 * Configure TMR3_CTRL[PCS] = 1xxxb to route selected primary clock source to the
 * timer Channel3.
 *
 * Values:
 * - 0b00 - Bus Clock
 * - 0b01 - Peripheral Crossbar Output [9]
 * - 0b10 - Peripheral Crossbar Output [10]
 * - 0b11 - Disabled
 */
/*@{*/
/*! @brief Read current value of the SIM_MISC_CTL_TMR3PCSSEL field. */
#define SIM_RD_MISC_CTL_TMR3PCSSEL(base) ((SIM_MISC_CTL_REG(base) & SIM_MISC_CTL_TMR3PCSSEL_MASK) >> SIM_MISC_CTL_TMR3PCSSEL_SHIFT)
#define SIM_BRD_MISC_CTL_TMR3PCSSEL(base) (BME_UBFX32(&SIM_MISC_CTL_REG(base), SIM_MISC_CTL_TMR3PCSSEL_SHIFT, SIM_MISC_CTL_TMR3PCSSEL_WIDTH))

/*! @brief Set the TMR3PCSSEL field to a new value. */
#define SIM_WR_MISC_CTL_TMR3PCSSEL(base, value) (SIM_RMW_MISC_CTL(base, SIM_MISC_CTL_TMR3PCSSEL_MASK, SIM_MISC_CTL_TMR3PCSSEL(value)))
#define SIM_BWR_MISC_CTL_TMR3PCSSEL(base, value) (BME_BFI32(&SIM_MISC_CTL_REG(base), ((uint32_t)(value) << SIM_MISC_CTL_TMR3PCSSEL_SHIFT), SIM_MISC_CTL_TMR3PCSSEL_SHIFT, SIM_MISC_CTL_TMR3PCSSEL_WIDTH))
/*@}*/

/*!
 * @name Register SIM_MISC_CTL, field RTCCLKSEL[28] (RW)
 *
 * Selects between MCGIRCLK and OSC_32K clk for RTC operation
 *
 * Values:
 * - 0b0 - RTC OSC_32K clock selected
 * - 0b1 - MCGIRCLK selected
 */
/*@{*/
/*! @brief Read current value of the SIM_MISC_CTL_RTCCLKSEL field. */
#define SIM_RD_MISC_CTL_RTCCLKSEL(base) ((SIM_MISC_CTL_REG(base) & SIM_MISC_CTL_RTCCLKSEL_MASK) >> SIM_MISC_CTL_RTCCLKSEL_SHIFT)
#define SIM_BRD_MISC_CTL_RTCCLKSEL(base) (BME_UBFX32(&SIM_MISC_CTL_REG(base), SIM_MISC_CTL_RTCCLKSEL_SHIFT, SIM_MISC_CTL_RTCCLKSEL_WIDTH))

/*! @brief Set the RTCCLKSEL field to a new value. */
#define SIM_WR_MISC_CTL_RTCCLKSEL(base, value) (SIM_RMW_MISC_CTL(base, SIM_MISC_CTL_RTCCLKSEL_MASK, SIM_MISC_CTL_RTCCLKSEL(value)))
#define SIM_BWR_MISC_CTL_RTCCLKSEL(base, value) (BME_BFI32(&SIM_MISC_CTL_REG(base), ((uint32_t)(value) << SIM_MISC_CTL_RTCCLKSEL_SHIFT), SIM_MISC_CTL_RTCCLKSEL_SHIFT, SIM_MISC_CTL_RTCCLKSEL_WIDTH))
/*@}*/

/*!
 * @name Register SIM_MISC_CTL, field VREFBUFOUTEN[29] (RW)
 *
 * Operates switch in VrefBuffer to enable the internal 1.2v reference to be
 * driven to VREF pad.
 *
 * Values:
 * - 0b0 - Buffer does not drive PAD
 * - 0b1 - Buffer drives selected voltage (selected by vref_buffer_sel) on pad
 */
/*@{*/
/*! @brief Read current value of the SIM_MISC_CTL_VREFBUFOUTEN field. */
#define SIM_RD_MISC_CTL_VREFBUFOUTEN(base) ((SIM_MISC_CTL_REG(base) & SIM_MISC_CTL_VREFBUFOUTEN_MASK) >> SIM_MISC_CTL_VREFBUFOUTEN_SHIFT)
#define SIM_BRD_MISC_CTL_VREFBUFOUTEN(base) (BME_UBFX32(&SIM_MISC_CTL_REG(base), SIM_MISC_CTL_VREFBUFOUTEN_SHIFT, SIM_MISC_CTL_VREFBUFOUTEN_WIDTH))

/*! @brief Set the VREFBUFOUTEN field to a new value. */
#define SIM_WR_MISC_CTL_VREFBUFOUTEN(base, value) (SIM_RMW_MISC_CTL(base, SIM_MISC_CTL_VREFBUFOUTEN_MASK, SIM_MISC_CTL_VREFBUFOUTEN(value)))
#define SIM_BWR_MISC_CTL_VREFBUFOUTEN(base, value) (BME_BFI32(&SIM_MISC_CTL_REG(base), ((uint32_t)(value) << SIM_MISC_CTL_VREFBUFOUTEN_SHIFT), SIM_MISC_CTL_VREFBUFOUTEN_SHIFT, SIM_MISC_CTL_VREFBUFOUTEN_WIDTH))
/*@}*/

/*!
 * @name Register SIM_MISC_CTL, field VREFBUFINSEL[30] (RW)
 *
 * Selects Between Internal 1.2v reference and external reference for SAR and DAC
 *
 * Values:
 * - 0b0 - Internal Reference selected as Buffer Input
 * - 0b1 - External Reference selected as Buffer Input
 */
/*@{*/
/*! @brief Read current value of the SIM_MISC_CTL_VREFBUFINSEL field. */
#define SIM_RD_MISC_CTL_VREFBUFINSEL(base) ((SIM_MISC_CTL_REG(base) & SIM_MISC_CTL_VREFBUFINSEL_MASK) >> SIM_MISC_CTL_VREFBUFINSEL_SHIFT)
#define SIM_BRD_MISC_CTL_VREFBUFINSEL(base) (BME_UBFX32(&SIM_MISC_CTL_REG(base), SIM_MISC_CTL_VREFBUFINSEL_SHIFT, SIM_MISC_CTL_VREFBUFINSEL_WIDTH))

/*! @brief Set the VREFBUFINSEL field to a new value. */
#define SIM_WR_MISC_CTL_VREFBUFINSEL(base, value) (SIM_RMW_MISC_CTL(base, SIM_MISC_CTL_VREFBUFINSEL_MASK, SIM_MISC_CTL_VREFBUFINSEL(value)))
#define SIM_BWR_MISC_CTL_VREFBUFINSEL(base, value) (BME_BFI32(&SIM_MISC_CTL_REG(base), ((uint32_t)(value) << SIM_MISC_CTL_VREFBUFINSEL_SHIFT), SIM_MISC_CTL_VREFBUFINSEL_SHIFT, SIM_MISC_CTL_VREFBUFINSEL_WIDTH))
/*@}*/

/*!
 * @name Register SIM_MISC_CTL, field VREFBUFPD[31] (RW)
 *
 * Powers down VrefBuffer when set
 *
 * Values:
 * - 0b0 - Buffer Enabled
 * - 0b1 - Buffer Powered Down
 */
/*@{*/
/*! @brief Read current value of the SIM_MISC_CTL_VREFBUFPD field. */
#define SIM_RD_MISC_CTL_VREFBUFPD(base) ((SIM_MISC_CTL_REG(base) & SIM_MISC_CTL_VREFBUFPD_MASK) >> SIM_MISC_CTL_VREFBUFPD_SHIFT)
#define SIM_BRD_MISC_CTL_VREFBUFPD(base) (BME_UBFX32(&SIM_MISC_CTL_REG(base), SIM_MISC_CTL_VREFBUFPD_SHIFT, SIM_MISC_CTL_VREFBUFPD_WIDTH))

/*! @brief Set the VREFBUFPD field to a new value. */
#define SIM_WR_MISC_CTL_VREFBUFPD(base, value) (SIM_RMW_MISC_CTL(base, SIM_MISC_CTL_VREFBUFPD_MASK, SIM_MISC_CTL_VREFBUFPD(value)))
#define SIM_BWR_MISC_CTL_VREFBUFPD(base, value) (BME_BFI32(&SIM_MISC_CTL_REG(base), ((uint32_t)(value) << SIM_MISC_CTL_VREFBUFPD_SHIFT), SIM_MISC_CTL_VREFBUFPD_SHIFT, SIM_MISC_CTL_VREFBUFPD_WIDTH))
/*@}*/

/*******************************************************************************
 * SIM_ADC_COMP0 - ADC Compensation Register 0
 ******************************************************************************/

/*!
 * @brief SIM_ADC_COMP0 - ADC Compensation Register 0 (RO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire SIM_ADC_COMP0 register
 */
/*@{*/
#define SIM_RD_ADC_COMP0(base)   (SIM_ADC_COMP0_REG(base))
/*@}*/

/*
 * Constants & macros for individual SIM_ADC_COMP0 bitfields
 */

/*!
 * @name Register SIM_ADC_COMP0, field ADCCOMPVAL0[15:0] (RO)
 *
 * ADC Temperature Compensation Value at 25℃ (ambient).
 */
/*@{*/
/*! @brief Read current value of the SIM_ADC_COMP0_ADCCOMPVAL0 field. */
#define SIM_RD_ADC_COMP0_ADCCOMPVAL0(base) ((SIM_ADC_COMP0_REG(base) & SIM_ADC_COMP0_ADCCOMPVAL0_MASK) >> SIM_ADC_COMP0_ADCCOMPVAL0_SHIFT)
#define SIM_BRD_ADC_COMP0_ADCCOMPVAL0(base) (BME_UBFX32(&SIM_ADC_COMP0_REG(base), SIM_ADC_COMP0_ADCCOMPVAL0_SHIFT, SIM_ADC_COMP0_ADCCOMPVAL0_WIDTH))
/*@}*/

/*!
 * @name Register SIM_ADC_COMP0, field ADCCOMPVAL1[31:16] (RO)
 *
 * ADC Temperature Compensation Value at -40℃ (ambient).
 */
/*@{*/
/*! @brief Read current value of the SIM_ADC_COMP0_ADCCOMPVAL1 field. */
#define SIM_RD_ADC_COMP0_ADCCOMPVAL1(base) ((SIM_ADC_COMP0_REG(base) & SIM_ADC_COMP0_ADCCOMPVAL1_MASK) >> SIM_ADC_COMP0_ADCCOMPVAL1_SHIFT)
#define SIM_BRD_ADC_COMP0_ADCCOMPVAL1(base) (BME_UBFX32(&SIM_ADC_COMP0_REG(base), SIM_ADC_COMP0_ADCCOMPVAL1_SHIFT, SIM_ADC_COMP0_ADCCOMPVAL1_WIDTH))
/*@}*/

/*******************************************************************************
 * SIM_ADC_COMP1 - ADC Compensation Register 1
 ******************************************************************************/

/*!
 * @brief SIM_ADC_COMP1 - ADC Compensation Register 1 (RO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire SIM_ADC_COMP1 register
 */
/*@{*/
#define SIM_RD_ADC_COMP1(base)   (SIM_ADC_COMP1_REG(base))
/*@}*/

/*
 * Constants & macros for individual SIM_ADC_COMP1 bitfields
 */

/*!
 * @name Register SIM_ADC_COMP1, field ADCCOMPVAL2[15:0] (RO)
 *
 * ADC Temperature Compensation Value at 105 ℃ (ambient).
 */
/*@{*/
/*! @brief Read current value of the SIM_ADC_COMP1_ADCCOMPVAL2 field. */
#define SIM_RD_ADC_COMP1_ADCCOMPVAL2(base) ((SIM_ADC_COMP1_REG(base) & SIM_ADC_COMP1_ADCCOMPVAL2_MASK) >> SIM_ADC_COMP1_ADCCOMPVAL2_SHIFT)
#define SIM_BRD_ADC_COMP1_ADCCOMPVAL2(base) (BME_UBFX32(&SIM_ADC_COMP1_REG(base), SIM_ADC_COMP1_ADCCOMPVAL2_SHIFT, SIM_ADC_COMP1_ADCCOMPVAL2_WIDTH))
/*@}*/

/*
 * MKM34Z7 SMC
 *
 * System Mode Controller
 *
 * Registers defined in this header file:
 * - SMC_PMPROT - Power Mode Protection register
 * - SMC_PMCTRL - Power Mode Control register
 * - SMC_STOPCTRL - Stop Control Register
 * - SMC_PMSTAT - Power Mode Status register
 */

#define SMC_INSTANCE_COUNT (1U) /*!< Number of instances of the SMC module. */
#define SMC_IDX (0U) /*!< Instance number for SMC. */

/*******************************************************************************
 * SMC_PMPROT - Power Mode Protection register
 ******************************************************************************/

/*!
 * @brief SMC_PMPROT - Power Mode Protection register (RW)
 *
 * Reset value: 0x20U
 *
 * This register provides protection for entry into any low-power run or stop
 * mode. The enabling of the low-power run or stop mode occurs by configuring the
 * Power Mode Control register (PMCTRL). The PMPROT register can be written only
 * once after any system reset. If the MCU is configured for a disallowed or
 * reserved power mode, the MCU remains in its current power mode. For example, if the
 * MCU is in normal RUN mode and AVLP is 0, an attempt to enter VLPR mode using
 * PMCTRL[RUNM] is blocked and PMCTRL[RUNM] remains 00b, indicating the MCU is
 * still in Normal Run mode. This register is reset on Chip Reset not VLLS and by
 * reset types that trigger Chip Reset not VLLS. It is unaffected by reset types
 * that do not trigger Chip Reset not VLLS. See the Reset section details for more
 * information.
 */
/*!
 * @name Constants and macros for entire SMC_PMPROT register
 */
/*@{*/
#define SMC_RD_PMPROT(base)      (SMC_PMPROT_REG(base))
#define SMC_WR_PMPROT(base, value) (SMC_PMPROT_REG(base) = (value))
#define SMC_RMW_PMPROT(base, mask, value) (SMC_WR_PMPROT(base, (SMC_RD_PMPROT(base) & ~(mask)) | (value)))
#define SMC_SET_PMPROT(base, value) (BME_OR8(&SMC_PMPROT_REG(base), (uint8_t)(value)))
#define SMC_CLR_PMPROT(base, value) (BME_AND8(&SMC_PMPROT_REG(base), (uint8_t)(~(value))))
#define SMC_TOG_PMPROT(base, value) (BME_XOR8(&SMC_PMPROT_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual SMC_PMPROT bitfields
 */

/*!
 * @name Register SMC_PMPROT, field AVLLS[1] (RW)
 *
 * Provided the appropriate control bits are set up in PMCTRL, this write once
 * bit allows the MCU to enter any very-low-leakage stop mode (VLLSx).
 *
 * Values:
 * - 0b0 - Any VLLSx mode is not allowed
 * - 0b1 - Any VLLSx mode is allowed
 */
/*@{*/
/*! @brief Read current value of the SMC_PMPROT_AVLLS field. */
#define SMC_RD_PMPROT_AVLLS(base) ((SMC_PMPROT_REG(base) & SMC_PMPROT_AVLLS_MASK) >> SMC_PMPROT_AVLLS_SHIFT)
#define SMC_BRD_PMPROT_AVLLS(base) (BME_UBFX8(&SMC_PMPROT_REG(base), SMC_PMPROT_AVLLS_SHIFT, SMC_PMPROT_AVLLS_WIDTH))

/*! @brief Set the AVLLS field to a new value. */
#define SMC_WR_PMPROT_AVLLS(base, value) (SMC_RMW_PMPROT(base, SMC_PMPROT_AVLLS_MASK, SMC_PMPROT_AVLLS(value)))
#define SMC_BWR_PMPROT_AVLLS(base, value) (BME_BFI8(&SMC_PMPROT_REG(base), ((uint8_t)(value) << SMC_PMPROT_AVLLS_SHIFT), SMC_PMPROT_AVLLS_SHIFT, SMC_PMPROT_AVLLS_WIDTH))
/*@}*/

/*!
 * @name Register SMC_PMPROT, field AVLP[5] (RW)
 *
 * Provided the appropriate control bits are set up in PMCTRL, this write-once
 * field allows the MCU to enter any very-low-power mode (VLPR, VLPW, and VLPS).
 *
 * Values:
 * - 0b0 - VLPR, VLPW, and VLPS are not allowed.
 * - 0b1 - VLPR, VLPW, and VLPS are allowed.
 */
/*@{*/
/*! @brief Read current value of the SMC_PMPROT_AVLP field. */
#define SMC_RD_PMPROT_AVLP(base) ((SMC_PMPROT_REG(base) & SMC_PMPROT_AVLP_MASK) >> SMC_PMPROT_AVLP_SHIFT)
#define SMC_BRD_PMPROT_AVLP(base) (BME_UBFX8(&SMC_PMPROT_REG(base), SMC_PMPROT_AVLP_SHIFT, SMC_PMPROT_AVLP_WIDTH))

/*! @brief Set the AVLP field to a new value. */
#define SMC_WR_PMPROT_AVLP(base, value) (SMC_RMW_PMPROT(base, SMC_PMPROT_AVLP_MASK, SMC_PMPROT_AVLP(value)))
#define SMC_BWR_PMPROT_AVLP(base, value) (BME_BFI8(&SMC_PMPROT_REG(base), ((uint8_t)(value) << SMC_PMPROT_AVLP_SHIFT), SMC_PMPROT_AVLP_SHIFT, SMC_PMPROT_AVLP_WIDTH))
/*@}*/

/*******************************************************************************
 * SMC_PMCTRL - Power Mode Control register
 ******************************************************************************/

/*!
 * @brief SMC_PMCTRL - Power Mode Control register (RW)
 *
 * Reset value: 0x40U
 *
 * The PMCTRL register controls entry into low-power Run and Stop modes,
 * provided that the selected power mode is allowed via an appropriate setting of the
 * protection (PMPROT) register. This register is reset on Chip POR not VLLS and by
 * reset types that trigger Chip POR not VLLS. It is unaffected by reset types
 * that do not trigger Chip POR not VLLS. See the Reset section details for more
 * information.
 */
/*!
 * @name Constants and macros for entire SMC_PMCTRL register
 */
/*@{*/
#define SMC_RD_PMCTRL(base)      (SMC_PMCTRL_REG(base))
#define SMC_WR_PMCTRL(base, value) (SMC_PMCTRL_REG(base) = (value))
#define SMC_RMW_PMCTRL(base, mask, value) (SMC_WR_PMCTRL(base, (SMC_RD_PMCTRL(base) & ~(mask)) | (value)))
#define SMC_SET_PMCTRL(base, value) (BME_OR8(&SMC_PMCTRL_REG(base), (uint8_t)(value)))
#define SMC_CLR_PMCTRL(base, value) (BME_AND8(&SMC_PMCTRL_REG(base), (uint8_t)(~(value))))
#define SMC_TOG_PMCTRL(base, value) (BME_XOR8(&SMC_PMCTRL_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual SMC_PMCTRL bitfields
 */

/*!
 * @name Register SMC_PMCTRL, field STOPM[2:0] (RW)
 *
 * When written, controls entry into the selected stop mode when Sleep-Now or
 * Sleep-On-Exit mode is entered with SLEEPDEEP=1 . Writes to this field are
 * blocked if the protection level has not been enabled using the PMPROT register.
 * After any system reset, this field is cleared by hardware on any successful write
 * to the PMPROT register. When set to VLLSx, the VLLSM field in the STOPCTRL
 * register is used to further select the particular VLLS submode which will be
 * entered. When set to STOP, the PSTOPO bits in the STOPCTRL register can be used to
 * select a Partial Stop mode if desired.
 *
 * Values:
 * - 0b000 - Normal Stop (STOP)
 * - 0b001 - Reserved
 * - 0b010 - Very-Low-Power Stop (VLPS)
 * - 0b011 - Reserved
 * - 0b100 - Very-Low-Leakage Stop (VLLSx)
 * - 0b101 - Reserved
 * - 0b110 - Reseved
 * - 0b111 - Reserved
 */
/*@{*/
/*! @brief Read current value of the SMC_PMCTRL_STOPM field. */
#define SMC_RD_PMCTRL_STOPM(base) ((SMC_PMCTRL_REG(base) & SMC_PMCTRL_STOPM_MASK) >> SMC_PMCTRL_STOPM_SHIFT)
#define SMC_BRD_PMCTRL_STOPM(base) (BME_UBFX8(&SMC_PMCTRL_REG(base), SMC_PMCTRL_STOPM_SHIFT, SMC_PMCTRL_STOPM_WIDTH))

/*! @brief Set the STOPM field to a new value. */
#define SMC_WR_PMCTRL_STOPM(base, value) (SMC_RMW_PMCTRL(base, SMC_PMCTRL_STOPM_MASK, SMC_PMCTRL_STOPM(value)))
#define SMC_BWR_PMCTRL_STOPM(base, value) (BME_BFI8(&SMC_PMCTRL_REG(base), ((uint8_t)(value) << SMC_PMCTRL_STOPM_SHIFT), SMC_PMCTRL_STOPM_SHIFT, SMC_PMCTRL_STOPM_WIDTH))
/*@}*/

/*!
 * @name Register SMC_PMCTRL, field STOPA[3] (RO)
 *
 * When set, this read-only status bit indicates an interrupt or reset occured
 * during the previous stop mode entry sequence, preventing the system from
 * entering that mode. This field is cleared by hardware at the beginning of any stop
 * mode entry sequence and is set if the sequence was aborted.
 *
 * Values:
 * - 0b0 - The previous stop mode entry was successsful.
 * - 0b1 - The previous stop mode entry was aborted.
 */
/*@{*/
/*! @brief Read current value of the SMC_PMCTRL_STOPA field. */
#define SMC_RD_PMCTRL_STOPA(base) ((SMC_PMCTRL_REG(base) & SMC_PMCTRL_STOPA_MASK) >> SMC_PMCTRL_STOPA_SHIFT)
#define SMC_BRD_PMCTRL_STOPA(base) (BME_UBFX8(&SMC_PMCTRL_REG(base), SMC_PMCTRL_STOPA_SHIFT, SMC_PMCTRL_STOPA_WIDTH))
/*@}*/

/*!
 * @name Register SMC_PMCTRL, field RUNM[6:5] (RW)
 *
 * When written, causes entry into the selected run mode. Writes to this field
 * are blocked if the protection level has not been enabled using the PMPROT
 * register. RUNM may be set to VLPR only when PMSTAT=RUN. After being written to
 * VLPR, RUNM should not be written back to RUN until PMSTAT=VLPR.
 *
 * Values:
 * - 0b00 - Normal Run mode (RUN)
 * - 0b01 - Reserved
 * - 0b10 - Very-Low-Power Run mode (VLPR)
 * - 0b11 - Reserved
 */
/*@{*/
/*! @brief Read current value of the SMC_PMCTRL_RUNM field. */
#define SMC_RD_PMCTRL_RUNM(base) ((SMC_PMCTRL_REG(base) & SMC_PMCTRL_RUNM_MASK) >> SMC_PMCTRL_RUNM_SHIFT)
#define SMC_BRD_PMCTRL_RUNM(base) (BME_UBFX8(&SMC_PMCTRL_REG(base), SMC_PMCTRL_RUNM_SHIFT, SMC_PMCTRL_RUNM_WIDTH))

/*! @brief Set the RUNM field to a new value. */
#define SMC_WR_PMCTRL_RUNM(base, value) (SMC_RMW_PMCTRL(base, SMC_PMCTRL_RUNM_MASK, SMC_PMCTRL_RUNM(value)))
#define SMC_BWR_PMCTRL_RUNM(base, value) (BME_BFI8(&SMC_PMCTRL_REG(base), ((uint8_t)(value) << SMC_PMCTRL_RUNM_SHIFT), SMC_PMCTRL_RUNM_SHIFT, SMC_PMCTRL_RUNM_WIDTH))
/*@}*/

/*******************************************************************************
 * SMC_STOPCTRL - Stop Control Register
 ******************************************************************************/

/*!
 * @brief SMC_STOPCTRL - Stop Control Register (RW)
 *
 * Reset value: 0x03U
 *
 * The STOPCTRL register provides various control bits allowing the user to fine
 * tune power consumption during the stop mode selected by the STOPM field. This
 * register is reset on Chip POR not VLLS and by reset types that trigger Chip
 * POR not VLLS. It is unaffected by reset types that do not trigger Chip POR not
 * VLLS. See the Reset section details for more information.
 */
/*!
 * @name Constants and macros for entire SMC_STOPCTRL register
 */
/*@{*/
#define SMC_RD_STOPCTRL(base)    (SMC_STOPCTRL_REG(base))
#define SMC_WR_STOPCTRL(base, value) (SMC_STOPCTRL_REG(base) = (value))
#define SMC_RMW_STOPCTRL(base, mask, value) (SMC_WR_STOPCTRL(base, (SMC_RD_STOPCTRL(base) & ~(mask)) | (value)))
#define SMC_SET_STOPCTRL(base, value) (BME_OR8(&SMC_STOPCTRL_REG(base), (uint8_t)(value)))
#define SMC_CLR_STOPCTRL(base, value) (BME_AND8(&SMC_STOPCTRL_REG(base), (uint8_t)(~(value))))
#define SMC_TOG_STOPCTRL(base, value) (BME_XOR8(&SMC_STOPCTRL_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual SMC_STOPCTRL bitfields
 */

/*!
 * @name Register SMC_STOPCTRL, field VLLSM[2:0] (RW)
 *
 * This field controls which VLLS sub-mode to enter if STOPM = VLLSx.
 *
 * Values:
 * - 0b000 - VLLS0
 * - 0b001 - VLLS1
 * - 0b010 - VLLS2
 * - 0b011 - VLLS3
 * - 0b100 - Reserved
 * - 0b101 - Reserved
 * - 0b110 - Reserved
 * - 0b111 - Reserved
 */
/*@{*/
/*! @brief Read current value of the SMC_STOPCTRL_VLLSM field. */
#define SMC_RD_STOPCTRL_VLLSM(base) ((SMC_STOPCTRL_REG(base) & SMC_STOPCTRL_VLLSM_MASK) >> SMC_STOPCTRL_VLLSM_SHIFT)
#define SMC_BRD_STOPCTRL_VLLSM(base) (BME_UBFX8(&SMC_STOPCTRL_REG(base), SMC_STOPCTRL_VLLSM_SHIFT, SMC_STOPCTRL_VLLSM_WIDTH))

/*! @brief Set the VLLSM field to a new value. */
#define SMC_WR_STOPCTRL_VLLSM(base, value) (SMC_RMW_STOPCTRL(base, SMC_STOPCTRL_VLLSM_MASK, SMC_STOPCTRL_VLLSM(value)))
#define SMC_BWR_STOPCTRL_VLLSM(base, value) (BME_BFI8(&SMC_STOPCTRL_REG(base), ((uint8_t)(value) << SMC_STOPCTRL_VLLSM_SHIFT), SMC_STOPCTRL_VLLSM_SHIFT, SMC_STOPCTRL_VLLSM_WIDTH))
/*@}*/

/*!
 * @name Register SMC_STOPCTRL, field PORPO[5] (RW)
 *
 * This bit controls whether the POR detect circuit is enabled in VLLS0 mode.
 *
 * Values:
 * - 0b0 - POR detect circuit is enabled in VLLS0
 * - 0b1 - POR detect circuit is disabled in VLLS0
 */
/*@{*/
/*! @brief Read current value of the SMC_STOPCTRL_PORPO field. */
#define SMC_RD_STOPCTRL_PORPO(base) ((SMC_STOPCTRL_REG(base) & SMC_STOPCTRL_PORPO_MASK) >> SMC_STOPCTRL_PORPO_SHIFT)
#define SMC_BRD_STOPCTRL_PORPO(base) (BME_UBFX8(&SMC_STOPCTRL_REG(base), SMC_STOPCTRL_PORPO_SHIFT, SMC_STOPCTRL_PORPO_WIDTH))

/*! @brief Set the PORPO field to a new value. */
#define SMC_WR_STOPCTRL_PORPO(base, value) (SMC_RMW_STOPCTRL(base, SMC_STOPCTRL_PORPO_MASK, SMC_STOPCTRL_PORPO(value)))
#define SMC_BWR_STOPCTRL_PORPO(base, value) (BME_BFI8(&SMC_STOPCTRL_REG(base), ((uint8_t)(value) << SMC_STOPCTRL_PORPO_SHIFT), SMC_STOPCTRL_PORPO_SHIFT, SMC_STOPCTRL_PORPO_WIDTH))
/*@}*/

/*!
 * @name Register SMC_STOPCTRL, field PSTOPO[7:6] (RW)
 *
 * These bits control whether a Partial Stop mode is entered when STOPM=STOP.
 * When entering a Partial Stop mode from RUN (or VLPR) mode, the PMC, MCG and
 * flash remain fully powered, allowing the device to wakeup almost instantaneously
 * at the expense of higher power consumption. In PSTOP2, only system clocks are
 * gated allowing peripherals running on bus clock to remain fully functional. In
 * PSTOP1, both system and bus clocks are gated.
 *
 * Values:
 * - 0b00 - STOP - Normal Stop mode
 * - 0b01 - PSTOP1 - Partial Stop with both system and bus clocks disabled
 * - 0b10 - PSTOP2 - Partial Stop with system clock disabled and bus clock
 *     enabled
 * - 0b11 - Reserved
 */
/*@{*/
/*! @brief Read current value of the SMC_STOPCTRL_PSTOPO field. */
#define SMC_RD_STOPCTRL_PSTOPO(base) ((SMC_STOPCTRL_REG(base) & SMC_STOPCTRL_PSTOPO_MASK) >> SMC_STOPCTRL_PSTOPO_SHIFT)
#define SMC_BRD_STOPCTRL_PSTOPO(base) (BME_UBFX8(&SMC_STOPCTRL_REG(base), SMC_STOPCTRL_PSTOPO_SHIFT, SMC_STOPCTRL_PSTOPO_WIDTH))

/*! @brief Set the PSTOPO field to a new value. */
#define SMC_WR_STOPCTRL_PSTOPO(base, value) (SMC_RMW_STOPCTRL(base, SMC_STOPCTRL_PSTOPO_MASK, SMC_STOPCTRL_PSTOPO(value)))
#define SMC_BWR_STOPCTRL_PSTOPO(base, value) (BME_BFI8(&SMC_STOPCTRL_REG(base), ((uint8_t)(value) << SMC_STOPCTRL_PSTOPO_SHIFT), SMC_STOPCTRL_PSTOPO_SHIFT, SMC_STOPCTRL_PSTOPO_WIDTH))
/*@}*/

/*******************************************************************************
 * SMC_PMSTAT - Power Mode Status register
 ******************************************************************************/

/*!
 * @brief SMC_PMSTAT - Power Mode Status register (RO)
 *
 * Reset value: 0x04U
 *
 * PMSTAT is a read-only, one-hot register which indicates the current power
 * mode of the system. This register is reset on Chip POR not VLLS and by reset
 * types that trigger Chip POR not VLLS. It is unaffected by reset types that do not
 * trigger Chip POR not VLLS. See the Reset section details for more information.
 */
/*!
 * @name Constants and macros for entire SMC_PMSTAT register
 */
/*@{*/
#define SMC_RD_PMSTAT(base)      (SMC_PMSTAT_REG(base))
/*@}*/

/*
 * MKM34Z7 SPI
 *
 * Serial Peripheral Interface
 *
 * Registers defined in this header file:
 * - SPI_S - SPI Status Register
 * - SPI_BR - SPI Baud Rate Register
 * - SPI_C2 - SPI Control Register 2
 * - SPI_C1 - SPI Control Register 1
 * - SPI_ML - SPI Match Register low
 * - SPI_MH - SPI match register high
 * - SPI_DL - SPI Data Register low
 * - SPI_DH - SPI data register high
 * - SPI_CI - SPI clear interrupt register
 * - SPI_C3 - SPI control register 3
 */

#define SPI_INSTANCE_COUNT (2U) /*!< Number of instances of the SPI module. */
#define SPI0_IDX (0U) /*!< Instance number for SPI0. */
#define SPI1_IDX (1U) /*!< Instance number for SPI1. */

/*******************************************************************************
 * SPI_S - SPI Status Register
 ******************************************************************************/

/*!
 * @brief SPI_S - SPI Status Register (RW)
 *
 * Reset value: 0x20U
 *
 * This register contains read-only status bits. When the FIFO is not supported
 * or not enabled (FIFOMODE is not present or is 0): Bits 3 through 0 are not
 * implemented and always read 0. When the FIFO is supported and enabled (FIFOMODE
 * is 1): This register has four flags that provide mechanisms to support an
 * 8-byte FIFO mode: RNFULLF, TNEARF, TXFULLF, and RFIFOEF. When the SPI is in 8-byte
 * FIFO mode, the function of SPRF and SPTEF differs slightly from their function
 * in the normal buffered modes, mainly regarding how these flags are cleared by
 * the amount available in the transmit and receive FIFOs. The RNFULLF and
 * TNEAREF help improve the efficiency of FIFO operation when transfering large
 * amounts of data. These flags provide a "watermark" feature of the FIFOs to allow
 * continuous transmissions of data when running at high speed. The RNFULLF can
 * generate an interrupt if the RNFULLIEN bit in the C3 register is set, which allows
 * the CPU to start emptying the receive FIFO without delaying the reception of
 * subsequent bytes. The user can also determine if all data in the receive FIFO
 * has been read by monitoring the RFIFOEF. The TNEAREF can generate an interrupt
 * if the TNEARIEN bit in the C3 register is set, which allows the CPU to start
 * filling the transmit FIFO before it is empty and thus to prevent breaks in SPI
 * transmission. At an initial POR, the values of TNEAREF and RFIFOEF are 0.
 * However, the status (S) register and both TX and RX FIFOs are reset due to a
 * change of SPIMODE, FIFOMODE or SPE. If this type of reset occurs and FIFOMODE is
 * 0, TNEAREF and RFIFOEF continue to reset to 0. If this type of reset occurs and
 * FIFOMODE is 1, TNEAREF and RFIFOEF reset to 1.
 */
/*!
 * @name Constants and macros for entire SPI_S register
 */
/*@{*/
#define SPI_RD_S(base)           (SPI_S_REG(base))
#define SPI_WR_S(base, value)    (SPI_S_REG(base) = (value))
#define SPI_RMW_S(base, mask, value) (SPI_WR_S(base, (SPI_RD_S(base) & ~(mask)) | (value)))
#define SPI_SET_S(base, value)   (BME_OR8(&SPI_S_REG(base), (uint8_t)(value)))
#define SPI_CLR_S(base, value)   (BME_AND8(&SPI_S_REG(base), (uint8_t)(~(value))))
#define SPI_TOG_S(base, value)   (BME_XOR8(&SPI_S_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual SPI_S bitfields
 */

/*!
 * @name Register SPI_S, field RFIFOEF[0] (RO)
 *
 * This bit indicates the status of the read FIFO when FIFOMODE is enabled. If
 * FIFOMODE is not enabled, ignore this bit. When FIFOMODE and DMA are both
 * enabled, the inverted RXIFOEF is used to trigger a DMA transfer. So when the receive
 * FIFO is not empty, the DMA request is active, and remains active until the
 * FIFO is empty. At an initial POR, the values of TNEAREF and RFIFOEF are 0.
 * However, the status (S) register and both TX and RX FIFOs are reset due to a change
 * of SPIMODE, FIFOMODE or SPE. If this type of reset occurs and FIFOMODE is 0,
 * TNEAREF and RFIFOEF continue to reset to 0. If this type of reset occurs and
 * FIFOMODE is 1, TNEAREF and RFIFOEF reset to 1.
 *
 * Values:
 * - 0b0 - Read FIFO has data. Reads of the DH:DL registers in 16-bit mode or
 *     the DL register in 8-bit mode will empty the read FIFO.
 * - 0b1 - Read FIFO is empty.
 */
/*@{*/
/*! @brief Read current value of the SPI_S_RFIFOEF field. */
#define SPI_RD_S_RFIFOEF(base) ((SPI_S_REG(base) & SPI_S_RFIFOEF_MASK) >> SPI_S_RFIFOEF_SHIFT)
#define SPI_BRD_S_RFIFOEF(base) (BME_UBFX8(&SPI_S_REG(base), SPI_S_RFIFOEF_SHIFT, SPI_S_RFIFOEF_WIDTH))
/*@}*/

/*!
 * @name Register SPI_S, field TXFULLF[1] (RO)
 *
 * This bit indicates the status of the transmit FIFO when FIFOMODE is enabled.
 * This flag is set when there are 8 bytes in the transmit FIFO. If FIFOMODE is
 * not enabled, ignore this bit. When FIFOMODE and DMA are both enabled, the
 * inverted TXFULLF is used to trigger a DMA transfer. So when the transmit FIFO is
 * not full, the DMA request is active, and remains active until the FIFO is full.
 *
 * Values:
 * - 0b0 - Transmit FIFO has less than 8 bytes
 * - 0b1 - Transmit FIFO has 8 bytes of data
 */
/*@{*/
/*! @brief Read current value of the SPI_S_TXFULLF field. */
#define SPI_RD_S_TXFULLF(base) ((SPI_S_REG(base) & SPI_S_TXFULLF_MASK) >> SPI_S_TXFULLF_SHIFT)
#define SPI_BRD_S_TXFULLF(base) (BME_UBFX8(&SPI_S_REG(base), SPI_S_TXFULLF_SHIFT, SPI_S_TXFULLF_WIDTH))
/*@}*/

/*!
 * @name Register SPI_S, field TNEAREF[2] (RO)
 *
 * This flag is set when only one 16-bit word or two 8-bit bytes of data remain
 * in the transmit FIFO, provided C3[TNEAREF_MARK] is 0, or when only two 16-bit
 * words or four 8-bit bytes of data remain in the transmit FIFO, provided
 * C3[TNEAREF_MARK] is 1. If FIFOMODE is not enabled, ignore this bit. At an initial
 * POR, the values of TNEAREF and RFIFOEF are 0. However, the status (S) register
 * and both TX and RX FIFOs are reset due to a change of SPIMODE, FIFOMODE or SPE.
 * If this type of reset occurs and FIFOMODE is 0, TNEAREF and RFIFOEF continue
 * to reset to 0. If this type of reset occurs and FIFOMODE is 1, TNEAREF and
 * RFIFOEF reset to 1.
 *
 * Values:
 * - 0b0 - Transmit FIFO has more than 16 bits (when C3[TNEAREF_MARK] is 0) or
 *     more than 32 bits (when C3[TNEAREF_MARK] is 1) remaining to transmit
 * - 0b1 - Transmit FIFO has an amount of data equal to or less than 16 bits
 *     (when C3[TNEAREF_MARK] is 0) or 32 bits (when C3[TNEAREF_MARK] is 1)
 *     remaining to transmit
 */
/*@{*/
/*! @brief Read current value of the SPI_S_TNEAREF field. */
#define SPI_RD_S_TNEAREF(base) ((SPI_S_REG(base) & SPI_S_TNEAREF_MASK) >> SPI_S_TNEAREF_SHIFT)
#define SPI_BRD_S_TNEAREF(base) (BME_UBFX8(&SPI_S_REG(base), SPI_S_TNEAREF_SHIFT, SPI_S_TNEAREF_WIDTH))
/*@}*/

/*!
 * @name Register SPI_S, field RNFULLF[3] (RO)
 *
 * This flag is set when more than three 16-bit words or six 8-bit bytes of data
 * remain in the receive FIFO, provided C3[RNFULLF_MARK] is 0, or when more than
 * two 16-bit words or four 8-bit bytes of data remain in the receive FIFO,
 * provided C3[RNFULLF_MARK] is 1. It has no function if FIFOMODE is not present or
 * is 0.
 *
 * Values:
 * - 0b0 - Receive FIFO has received less than 48 bits (when C3[RNFULLF_MARK] is
 *     0) or less than 32 bits (when C3[RNFULLF_MARK] is 1)
 * - 0b1 - Receive FIFO has received data of an amount equal to or greater than
 *     48 bits (when C3[RNFULLF_MARK] is 0) or 32 bits (when C3[RNFULLF_MARK] is
 *     1)
 */
/*@{*/
/*! @brief Read current value of the SPI_S_RNFULLF field. */
#define SPI_RD_S_RNFULLF(base) ((SPI_S_REG(base) & SPI_S_RNFULLF_MASK) >> SPI_S_RNFULLF_SHIFT)
#define SPI_BRD_S_RNFULLF(base) (BME_UBFX8(&SPI_S_REG(base), SPI_S_RNFULLF_SHIFT, SPI_S_RNFULLF_WIDTH))
/*@}*/

/*!
 * @name Register SPI_S, field MODF[4] (RO)
 *
 * MODF is set if the SPI is configured as a master and the slave select input
 * goes low, indicating some other SPI device is also configured as a master. The
 * SS pin acts as a mode fault error input only when C1[MSTR] is 1, C2[MODFEN] is
 * 1, and C1[SSOE] is 0; otherwise, MODF will never be set. MODF is cleared by
 * reading MODF while it is 1 and then writing to the SPI Control Register 1 (C1).
 *
 * Values:
 * - 0b0 - No mode fault error
 * - 0b1 - Mode fault error detected
 */
/*@{*/
/*! @brief Read current value of the SPI_S_MODF field. */
#define SPI_RD_S_MODF(base)  ((SPI_S_REG(base) & SPI_S_MODF_MASK) >> SPI_S_MODF_SHIFT)
#define SPI_BRD_S_MODF(base) (BME_UBFX8(&SPI_S_REG(base), SPI_S_MODF_SHIFT, SPI_S_MODF_WIDTH))
/*@}*/

/*!
 * @name Register SPI_S, field SPTEF[5] (RO)
 *
 * When the FIFO is not supported or not enabled (FIFOMODE is not present or is
 * 0): This bit is set when the transmit data buffer is empty. When the transmit
 * DMA request is disabled (TXDMAE is 0), SPTEF is cleared by reading the S
 * register with SPTEF set and then writing a data value to the transmit buffer at
 * DH:DL. The S register must be read with SPTEF set to 1 before writing data to the
 * DH:DL register; otherwise, the DH:DL write is ignored. When the transmit DMA
 * request is enabled (TXDMAE is 1), SPTEF is automatically cleared when the DMA
 * transfer for the transmit DMA request is completed (TX DMA Done is asserted).
 * SPTEF is automatically set when all data from the transmit buffer transfers
 * into the transmit shift register. For an idle SPI, data written to DH:DL is
 * transferred to the shifter almost immediately so that SPTEF is set within two bus
 * cycles, allowing a second set of data to be queued into the transmit buffer.
 * After completion of the transfer of the data in the shift register, the queued
 * data from the transmit buffer automatically moves to the shifter, and SPTEF is
 * set to indicate that room exists for new data in the transmit buffer. If no
 * new data is waiting in the transmit buffer, SPTEF simply remains set and no
 * data moves from the buffer to the shifter. When the FIFO is not supported or not
 * enabled (FIFOMODE is not present or is 0): If a transfer does not stop, the
 * last data that was transmitted is sent out again. When the FIFO is supported and
 * enabled (FIFOMODE is 1): This bit provides the status of the FIFO rather than
 * an 8-bit or a 16-bit buffer. This bit is set when the transmit FIFO is empty.
 * When the transmit DMA request is disabled (TXDMAE is 0), SPTEF is cleared by
 * writing a data value to the transmit FIFO at DH:DL. When the transmit DMA
 * request is enabled (TXDMAE is 1), SPTEF is automatically cleared when the DMA
 * transfer for the transmit DMA request is completed (TX DMA Done is asserted).
 * SPTEF is automatically set when all data from the transmit FIFO transfers into the
 * transmit shift register. For an idle SPI, data written to the DH:DL register
 * is transferred to the shifter almost immediately, so that SPTEF is set within
 * two bus cycles. A second write of data to the DH:DL register clears this SPTEF
 * flag. After completion of the transfer of the data in the shift register, the
 * queued data from the transmit FIFO automatically moves to the shifter, and
 * SPTEF will be set only when all data written to the transmit FIFO has been
 * transfered to the shifter. If no new data is waiting in the transmit FIFO, SPTEF
 * simply remains set and no data moves from the buffer to the shifter.
 *
 * Values:
 * - 0b0 - SPI transmit buffer not empty (when FIFOMODE is not present or is 0)
 *     or SPI FIFO not empty (when FIFOMODE is 1)
 * - 0b1 - SPI transmit buffer empty (when FIFOMODE is not present or is 0) or
 *     SPI FIFO empty (when FIFOMODE is 1)
 */
/*@{*/
/*! @brief Read current value of the SPI_S_SPTEF field. */
#define SPI_RD_S_SPTEF(base) ((SPI_S_REG(base) & SPI_S_SPTEF_MASK) >> SPI_S_SPTEF_SHIFT)
#define SPI_BRD_S_SPTEF(base) (BME_UBFX8(&SPI_S_REG(base), SPI_S_SPTEF_SHIFT, SPI_S_SPTEF_WIDTH))
/*@}*/

/*!
 * @name Register SPI_S, field SPMF[6] (W1C)
 *
 * SPMF is set after SPRF is 1 when the value in the receive data buffer matches
 * the value in the MH:ML registers. To clear the flag, read SPMF when it is set
 * and then write a 1 to it.
 *
 * Values:
 * - 0b0 - Value in the receive data buffer does not match the value in the
 *     MH:ML registers
 * - 0b1 - Value in the receive data buffer matches the value in the MH:ML
 *     registers
 */
/*@{*/
/*! @brief Read current value of the SPI_S_SPMF field. */
#define SPI_RD_S_SPMF(base)  ((SPI_S_REG(base) & SPI_S_SPMF_MASK) >> SPI_S_SPMF_SHIFT)
#define SPI_BRD_S_SPMF(base) (BME_UBFX8(&SPI_S_REG(base), SPI_S_SPMF_SHIFT, SPI_S_SPMF_WIDTH))

/*! @brief Set the SPMF field to a new value. */
#define SPI_WR_S_SPMF(base, value) (SPI_RMW_S(base, SPI_S_SPMF_MASK, SPI_S_SPMF(value)))
#define SPI_BWR_S_SPMF(base, value) (BME_BFI8(&SPI_S_REG(base), ((uint8_t)(value) << SPI_S_SPMF_SHIFT), SPI_S_SPMF_SHIFT, SPI_S_SPMF_WIDTH))
/*@}*/

/*!
 * @name Register SPI_S, field SPRF[7] (RO)
 *
 * When the FIFO is not supported or not enabled (FIFOMODE is not present or is
 * 0): SPRF is set at the completion of an SPI transfer to indicate that received
 * data may be read from the SPI data (DH:DL) register. When the receive DMA
 * request is disabled (RXDMAE is 0), SPRF is cleared by reading SPRF while it is
 * set and then reading the SPI data register. When the receive DMA request is
 * enabled (RXDMAE is 1), SPRF is automatically cleared when the DMA transfer for the
 * receive DMA request is completed (RX DMA Done is asserted). When FIFOMODE is
 * 1: This bit indicates the status of the read FIFO when FIFOMODE is enabled.
 * The SPRF is set when the read FIFO has received 64 bits (4 words or 8 bytes) of
 * data from the shifter and there have been no CPU reads of the SPI data (DH:DL)
 * register. When the receive DMA request is disabled (RXDMAE is 0), SPRF is
 * cleared by reading the SPI data register, resulting in the FIFO no longer being
 * full, assuming another SPI message is not received. When the receive DMA
 * request is enabled (RXDMAE is 1), SPRF is automatically cleared when the first DMA
 * transfer for the receive DMA request is completed (RX DMA Done is asserted).
 *
 * Values:
 * - 0b0 - No data available in the receive data buffer (when FIFOMODE is not
 *     present or is 0) or Read FIFO is not full (when FIFOMODE is 1)
 * - 0b1 - Data available in the receive data buffer (when FIFOMODE is not
 *     present or is 0) or Read FIFO is full (when FIFOMODE is 1)
 */
/*@{*/
/*! @brief Read current value of the SPI_S_SPRF field. */
#define SPI_RD_S_SPRF(base)  ((SPI_S_REG(base) & SPI_S_SPRF_MASK) >> SPI_S_SPRF_SHIFT)
#define SPI_BRD_S_SPRF(base) (BME_UBFX8(&SPI_S_REG(base), SPI_S_SPRF_SHIFT, SPI_S_SPRF_WIDTH))
/*@}*/

/*******************************************************************************
 * SPI_BR - SPI Baud Rate Register
 ******************************************************************************/

/*!
 * @brief SPI_BR - SPI Baud Rate Register (RW)
 *
 * Reset value: 0x00U
 *
 * Use this register to set the prescaler and bit rate divisor for an SPI
 * master. This register may be read or written at any time.
 */
/*!
 * @name Constants and macros for entire SPI_BR register
 */
/*@{*/
#define SPI_RD_BR(base)          (SPI_BR_REG(base))
#define SPI_WR_BR(base, value)   (SPI_BR_REG(base) = (value))
#define SPI_RMW_BR(base, mask, value) (SPI_WR_BR(base, (SPI_RD_BR(base) & ~(mask)) | (value)))
#define SPI_SET_BR(base, value)  (BME_OR8(&SPI_BR_REG(base), (uint8_t)(value)))
#define SPI_CLR_BR(base, value)  (BME_AND8(&SPI_BR_REG(base), (uint8_t)(~(value))))
#define SPI_TOG_BR(base, value)  (BME_XOR8(&SPI_BR_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual SPI_BR bitfields
 */

/*!
 * @name Register SPI_BR, field SPR[3:0] (RW)
 *
 * This 4-bit field selects one of nine divisors for the SPI baud rate divider.
 * The input to this divider comes from the SPI baud rate prescaler. Refer to the
 * description of "SPI Baud Rate Generation" for details.
 *
 * Values:
 * - 0b0000 - Baud rate divisor is 2.
 * - 0b0001 - Baud rate divisor is 4.
 * - 0b0010 - Baud rate divisor is 8.
 * - 0b0011 - Baud rate divisor is 16.
 * - 0b0100 - Baud rate divisor is 32.
 * - 0b0101 - Baud rate divisor is 64.
 * - 0b0110 - Baud rate divisor is 128.
 * - 0b0111 - Baud rate divisor is 256.
 * - 0b1000 - Baud rate divisor is 512.
 */
/*@{*/
/*! @brief Read current value of the SPI_BR_SPR field. */
#define SPI_RD_BR_SPR(base)  ((SPI_BR_REG(base) & SPI_BR_SPR_MASK) >> SPI_BR_SPR_SHIFT)
#define SPI_BRD_BR_SPR(base) (BME_UBFX8(&SPI_BR_REG(base), SPI_BR_SPR_SHIFT, SPI_BR_SPR_WIDTH))

/*! @brief Set the SPR field to a new value. */
#define SPI_WR_BR_SPR(base, value) (SPI_RMW_BR(base, SPI_BR_SPR_MASK, SPI_BR_SPR(value)))
#define SPI_BWR_BR_SPR(base, value) (BME_BFI8(&SPI_BR_REG(base), ((uint8_t)(value) << SPI_BR_SPR_SHIFT), SPI_BR_SPR_SHIFT, SPI_BR_SPR_WIDTH))
/*@}*/

/*!
 * @name Register SPI_BR, field SPPR[6:4] (RW)
 *
 * This 3-bit field selects one of eight divisors for the SPI baud rate
 * prescaler. The input to this prescaler is the SPI module clock. The output of this
 * prescaler drives the input of the SPI baud rate divider. Refer to the description
 * of "SPI Baud Rate Generation" for details.
 *
 * Values:
 * - 0b000 - Baud rate prescaler divisor is 1.
 * - 0b001 - Baud rate prescaler divisor is 2.
 * - 0b010 - Baud rate prescaler divisor is 3.
 * - 0b011 - Baud rate prescaler divisor is 4.
 * - 0b100 - Baud rate prescaler divisor is 5.
 * - 0b101 - Baud rate prescaler divisor is 6.
 * - 0b110 - Baud rate prescaler divisor is 7.
 * - 0b111 - Baud rate prescaler divisor is 8.
 */
/*@{*/
/*! @brief Read current value of the SPI_BR_SPPR field. */
#define SPI_RD_BR_SPPR(base) ((SPI_BR_REG(base) & SPI_BR_SPPR_MASK) >> SPI_BR_SPPR_SHIFT)
#define SPI_BRD_BR_SPPR(base) (BME_UBFX8(&SPI_BR_REG(base), SPI_BR_SPPR_SHIFT, SPI_BR_SPPR_WIDTH))

/*! @brief Set the SPPR field to a new value. */
#define SPI_WR_BR_SPPR(base, value) (SPI_RMW_BR(base, SPI_BR_SPPR_MASK, SPI_BR_SPPR(value)))
#define SPI_BWR_BR_SPPR(base, value) (BME_BFI8(&SPI_BR_REG(base), ((uint8_t)(value) << SPI_BR_SPPR_SHIFT), SPI_BR_SPPR_SHIFT, SPI_BR_SPPR_WIDTH))
/*@}*/

/*******************************************************************************
 * SPI_C2 - SPI Control Register 2
 ******************************************************************************/

/*!
 * @brief SPI_C2 - SPI Control Register 2 (RW)
 *
 * Reset value: 0x00U
 *
 * This read/write register is used to control optional features of the SPI
 * system.
 */
/*!
 * @name Constants and macros for entire SPI_C2 register
 */
/*@{*/
#define SPI_RD_C2(base)          (SPI_C2_REG(base))
#define SPI_WR_C2(base, value)   (SPI_C2_REG(base) = (value))
#define SPI_RMW_C2(base, mask, value) (SPI_WR_C2(base, (SPI_RD_C2(base) & ~(mask)) | (value)))
#define SPI_SET_C2(base, value)  (BME_OR8(&SPI_C2_REG(base), (uint8_t)(value)))
#define SPI_CLR_C2(base, value)  (BME_AND8(&SPI_C2_REG(base), (uint8_t)(~(value))))
#define SPI_TOG_C2(base, value)  (BME_XOR8(&SPI_C2_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual SPI_C2 bitfields
 */

/*!
 * @name Register SPI_C2, field SPC0[0] (RW)
 *
 * Enables bidirectional pin configurations.
 *
 * Values:
 * - 0b0 - SPI uses separate pins for data input and data output (pin mode is
 *     normal). In master mode of operation: MISO is master in and MOSI is master
 *     out. In slave mode of operation: MISO is slave out and MOSI is slave in.
 * - 0b1 - SPI configured for single-wire bidirectional operation (pin mode is
 *     bidirectional). In master mode of operation: MISO is not used by SPI; MOSI
 *     is master in when BIDIROE is 0 or master I/O when BIDIROE is 1. In slave
 *     mode of operation: MISO is slave in when BIDIROE is 0 or slave I/O when
 *     BIDIROE is 1; MOSI is not used by SPI.
 */
/*@{*/
/*! @brief Read current value of the SPI_C2_SPC0 field. */
#define SPI_RD_C2_SPC0(base) ((SPI_C2_REG(base) & SPI_C2_SPC0_MASK) >> SPI_C2_SPC0_SHIFT)
#define SPI_BRD_C2_SPC0(base) (BME_UBFX8(&SPI_C2_REG(base), SPI_C2_SPC0_SHIFT, SPI_C2_SPC0_WIDTH))

/*! @brief Set the SPC0 field to a new value. */
#define SPI_WR_C2_SPC0(base, value) (SPI_RMW_C2(base, SPI_C2_SPC0_MASK, SPI_C2_SPC0(value)))
#define SPI_BWR_C2_SPC0(base, value) (BME_BFI8(&SPI_C2_REG(base), ((uint8_t)(value) << SPI_C2_SPC0_SHIFT), SPI_C2_SPC0_SHIFT, SPI_C2_SPC0_WIDTH))
/*@}*/

/*!
 * @name Register SPI_C2, field SPISWAI[1] (RW)
 *
 * This bit is used for power conservation while the device is in Wait mode.
 *
 * Values:
 * - 0b0 - SPI clocks continue to operate in Wait mode.
 * - 0b1 - SPI clocks stop when the MCU enters Wait mode.
 */
/*@{*/
/*! @brief Read current value of the SPI_C2_SPISWAI field. */
#define SPI_RD_C2_SPISWAI(base) ((SPI_C2_REG(base) & SPI_C2_SPISWAI_MASK) >> SPI_C2_SPISWAI_SHIFT)
#define SPI_BRD_C2_SPISWAI(base) (BME_UBFX8(&SPI_C2_REG(base), SPI_C2_SPISWAI_SHIFT, SPI_C2_SPISWAI_WIDTH))

/*! @brief Set the SPISWAI field to a new value. */
#define SPI_WR_C2_SPISWAI(base, value) (SPI_RMW_C2(base, SPI_C2_SPISWAI_MASK, SPI_C2_SPISWAI(value)))
#define SPI_BWR_C2_SPISWAI(base, value) (BME_BFI8(&SPI_C2_REG(base), ((uint8_t)(value) << SPI_C2_SPISWAI_SHIFT), SPI_C2_SPISWAI_SHIFT, SPI_C2_SPISWAI_WIDTH))
/*@}*/

/*!
 * @name Register SPI_C2, field RXDMAE[2] (RW)
 *
 * This is the enable bit for a receive DMA request. When this bit is set to 1,
 * a receive DMA request is asserted when both SPRF and SPE are set, and the
 * interrupt from SPRF is disabled.
 *
 * Values:
 * - 0b0 - DMA request for receive is disabled and interrupt from SPRF is allowed
 * - 0b1 - DMA request for receive is enabled and interrupt from SPRF is disabled
 */
/*@{*/
/*! @brief Read current value of the SPI_C2_RXDMAE field. */
#define SPI_RD_C2_RXDMAE(base) ((SPI_C2_REG(base) & SPI_C2_RXDMAE_MASK) >> SPI_C2_RXDMAE_SHIFT)
#define SPI_BRD_C2_RXDMAE(base) (BME_UBFX8(&SPI_C2_REG(base), SPI_C2_RXDMAE_SHIFT, SPI_C2_RXDMAE_WIDTH))

/*! @brief Set the RXDMAE field to a new value. */
#define SPI_WR_C2_RXDMAE(base, value) (SPI_RMW_C2(base, SPI_C2_RXDMAE_MASK, SPI_C2_RXDMAE(value)))
#define SPI_BWR_C2_RXDMAE(base, value) (BME_BFI8(&SPI_C2_REG(base), ((uint8_t)(value) << SPI_C2_RXDMAE_SHIFT), SPI_C2_RXDMAE_SHIFT, SPI_C2_RXDMAE_WIDTH))
/*@}*/

/*!
 * @name Register SPI_C2, field BIDIROE[3] (RW)
 *
 * When bidirectional mode is enabled because SPI pin control 0 (SPC0) is set to
 * 1, BIDIROE determines whether the SPI data output driver is enabled to the
 * single bidirectional SPI I/O pin. Depending on whether the SPI is configured as
 * a master or a slave, it uses the MOSI (MOMI) or MISO (SISO) pin, respectively,
 * as the single SPI data I/O pin. When SPC0 is 0, BIDIROE has no meaning or
 * effect.
 *
 * Values:
 * - 0b0 - Output driver disabled so SPI data I/O pin acts as an input
 * - 0b1 - SPI I/O pin enabled as an output
 */
/*@{*/
/*! @brief Read current value of the SPI_C2_BIDIROE field. */
#define SPI_RD_C2_BIDIROE(base) ((SPI_C2_REG(base) & SPI_C2_BIDIROE_MASK) >> SPI_C2_BIDIROE_SHIFT)
#define SPI_BRD_C2_BIDIROE(base) (BME_UBFX8(&SPI_C2_REG(base), SPI_C2_BIDIROE_SHIFT, SPI_C2_BIDIROE_WIDTH))

/*! @brief Set the BIDIROE field to a new value. */
#define SPI_WR_C2_BIDIROE(base, value) (SPI_RMW_C2(base, SPI_C2_BIDIROE_MASK, SPI_C2_BIDIROE(value)))
#define SPI_BWR_C2_BIDIROE(base, value) (BME_BFI8(&SPI_C2_REG(base), ((uint8_t)(value) << SPI_C2_BIDIROE_SHIFT), SPI_C2_BIDIROE_SHIFT, SPI_C2_BIDIROE_WIDTH))
/*@}*/

/*!
 * @name Register SPI_C2, field MODFEN[4] (RW)
 *
 * When the SPI is configured for slave mode, this bit has no meaning or effect.
 * (The SS pin is the slave select input.) In master mode, this bit determines
 * how the SS pin is used. For details, refer to the description of the SSOE bit
 * in the C1 register.
 *
 * Values:
 * - 0b0 - Mode fault function disabled, master SS pin reverts to
 *     general-purpose I/O not controlled by SPI
 * - 0b1 - Mode fault function enabled, master SS pin acts as the mode fault
 *     input or the slave select output
 */
/*@{*/
/*! @brief Read current value of the SPI_C2_MODFEN field. */
#define SPI_RD_C2_MODFEN(base) ((SPI_C2_REG(base) & SPI_C2_MODFEN_MASK) >> SPI_C2_MODFEN_SHIFT)
#define SPI_BRD_C2_MODFEN(base) (BME_UBFX8(&SPI_C2_REG(base), SPI_C2_MODFEN_SHIFT, SPI_C2_MODFEN_WIDTH))

/*! @brief Set the MODFEN field to a new value. */
#define SPI_WR_C2_MODFEN(base, value) (SPI_RMW_C2(base, SPI_C2_MODFEN_MASK, SPI_C2_MODFEN(value)))
#define SPI_BWR_C2_MODFEN(base, value) (BME_BFI8(&SPI_C2_REG(base), ((uint8_t)(value) << SPI_C2_MODFEN_SHIFT), SPI_C2_MODFEN_SHIFT, SPI_C2_MODFEN_WIDTH))
/*@}*/

/*!
 * @name Register SPI_C2, field TXDMAE[5] (RW)
 *
 * This bit enables a transmit DMA request. When this bit is set to 1, a
 * transmit DMA request is asserted when both SPTEF and SPE are set, and the interrupt
 * from SPTEF is disabled.
 *
 * Values:
 * - 0b0 - DMA request for transmit is disabled and interrupt from SPTEF is
 *     allowed
 * - 0b1 - DMA request for transmit is enabled and interrupt from SPTEF is
 *     disabled
 */
/*@{*/
/*! @brief Read current value of the SPI_C2_TXDMAE field. */
#define SPI_RD_C2_TXDMAE(base) ((SPI_C2_REG(base) & SPI_C2_TXDMAE_MASK) >> SPI_C2_TXDMAE_SHIFT)
#define SPI_BRD_C2_TXDMAE(base) (BME_UBFX8(&SPI_C2_REG(base), SPI_C2_TXDMAE_SHIFT, SPI_C2_TXDMAE_WIDTH))

/*! @brief Set the TXDMAE field to a new value. */
#define SPI_WR_C2_TXDMAE(base, value) (SPI_RMW_C2(base, SPI_C2_TXDMAE_MASK, SPI_C2_TXDMAE(value)))
#define SPI_BWR_C2_TXDMAE(base, value) (BME_BFI8(&SPI_C2_REG(base), ((uint8_t)(value) << SPI_C2_TXDMAE_SHIFT), SPI_C2_TXDMAE_SHIFT, SPI_C2_TXDMAE_WIDTH))
/*@}*/

/*!
 * @name Register SPI_C2, field SPIMODE[6] (RW)
 *
 * This bit allows the user to select either an 8-bit or 16-bit SPI data
 * transmission length. In master mode, a change of this bit aborts a transmission in
 * progress, forces the SPI system into an idle state, and resets all status bits
 * in the S register. Refer to the description of "Data Transmission Length" for
 * details.
 *
 * Values:
 * - 0b0 - 8-bit SPI shift register, match register, and buffers
 * - 0b1 - 16-bit SPI shift register, match register, and buffers
 */
/*@{*/
/*! @brief Read current value of the SPI_C2_SPIMODE field. */
#define SPI_RD_C2_SPIMODE(base) ((SPI_C2_REG(base) & SPI_C2_SPIMODE_MASK) >> SPI_C2_SPIMODE_SHIFT)
#define SPI_BRD_C2_SPIMODE(base) (BME_UBFX8(&SPI_C2_REG(base), SPI_C2_SPIMODE_SHIFT, SPI_C2_SPIMODE_WIDTH))

/*! @brief Set the SPIMODE field to a new value. */
#define SPI_WR_C2_SPIMODE(base, value) (SPI_RMW_C2(base, SPI_C2_SPIMODE_MASK, SPI_C2_SPIMODE(value)))
#define SPI_BWR_C2_SPIMODE(base, value) (BME_BFI8(&SPI_C2_REG(base), ((uint8_t)(value) << SPI_C2_SPIMODE_SHIFT), SPI_C2_SPIMODE_SHIFT, SPI_C2_SPIMODE_WIDTH))
/*@}*/

/*!
 * @name Register SPI_C2, field SPMIE[7] (RW)
 *
 * This is the interrupt enable bit for the SPI receive data buffer hardware
 * match (SPMF) function.
 *
 * Values:
 * - 0b0 - Interrupts from SPMF inhibited (use polling)
 * - 0b1 - When SPMF is 1, requests a hardware interrupt
 */
/*@{*/
/*! @brief Read current value of the SPI_C2_SPMIE field. */
#define SPI_RD_C2_SPMIE(base) ((SPI_C2_REG(base) & SPI_C2_SPMIE_MASK) >> SPI_C2_SPMIE_SHIFT)
#define SPI_BRD_C2_SPMIE(base) (BME_UBFX8(&SPI_C2_REG(base), SPI_C2_SPMIE_SHIFT, SPI_C2_SPMIE_WIDTH))

/*! @brief Set the SPMIE field to a new value. */
#define SPI_WR_C2_SPMIE(base, value) (SPI_RMW_C2(base, SPI_C2_SPMIE_MASK, SPI_C2_SPMIE(value)))
#define SPI_BWR_C2_SPMIE(base, value) (BME_BFI8(&SPI_C2_REG(base), ((uint8_t)(value) << SPI_C2_SPMIE_SHIFT), SPI_C2_SPMIE_SHIFT, SPI_C2_SPMIE_WIDTH))
/*@}*/

/*******************************************************************************
 * SPI_C1 - SPI Control Register 1
 ******************************************************************************/

/*!
 * @brief SPI_C1 - SPI Control Register 1 (RW)
 *
 * Reset value: 0x04U
 *
 * This read/write register includes the SPI enable control, interrupt enables,
 * and configuration options.
 */
/*!
 * @name Constants and macros for entire SPI_C1 register
 */
/*@{*/
#define SPI_RD_C1(base)          (SPI_C1_REG(base))
#define SPI_WR_C1(base, value)   (SPI_C1_REG(base) = (value))
#define SPI_RMW_C1(base, mask, value) (SPI_WR_C1(base, (SPI_RD_C1(base) & ~(mask)) | (value)))
#define SPI_SET_C1(base, value)  (BME_OR8(&SPI_C1_REG(base), (uint8_t)(value)))
#define SPI_CLR_C1(base, value)  (BME_AND8(&SPI_C1_REG(base), (uint8_t)(~(value))))
#define SPI_TOG_C1(base, value)  (BME_XOR8(&SPI_C1_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual SPI_C1 bitfields
 */

/*!
 * @name Register SPI_C1, field LSBFE[0] (RW)
 *
 * This bit does not affect the position of the MSB and LSB in the data
 * register. Reads and writes of the data register always have the MSB in bit 7 (or bit
 * 15 in 16-bit mode).
 *
 * Values:
 * - 0b0 - SPI serial data transfers start with the most significant bit.
 * - 0b1 - SPI serial data transfers start with the least significant bit.
 */
/*@{*/
/*! @brief Read current value of the SPI_C1_LSBFE field. */
#define SPI_RD_C1_LSBFE(base) ((SPI_C1_REG(base) & SPI_C1_LSBFE_MASK) >> SPI_C1_LSBFE_SHIFT)
#define SPI_BRD_C1_LSBFE(base) (BME_UBFX8(&SPI_C1_REG(base), SPI_C1_LSBFE_SHIFT, SPI_C1_LSBFE_WIDTH))

/*! @brief Set the LSBFE field to a new value. */
#define SPI_WR_C1_LSBFE(base, value) (SPI_RMW_C1(base, SPI_C1_LSBFE_MASK, SPI_C1_LSBFE(value)))
#define SPI_BWR_C1_LSBFE(base, value) (BME_BFI8(&SPI_C1_REG(base), ((uint8_t)(value) << SPI_C1_LSBFE_SHIFT), SPI_C1_LSBFE_SHIFT, SPI_C1_LSBFE_WIDTH))
/*@}*/

/*!
 * @name Register SPI_C1, field SSOE[1] (RW)
 *
 * This bit is used in combination with the Mode Fault Enable (MODFEN) field in
 * the C2 register and the Master/Slave (MSTR) control bit to determine the
 * function of the SS pin.
 *
 * Values:
 * - 0b0 - When C2[MODFEN] is 0: In master mode, SS pin function is
 *     general-purpose I/O (not SPI). In slave mode, SS pin function is slave select input.
 *     When C2[MODFEN] is 1: In master mode, SS pin function is SS input for mode
 *     fault. In slave mode, SS pin function is slave select input.
 * - 0b1 - When C2[MODFEN] is 0: In master mode, SS pin function is
 *     general-purpose I/O (not SPI). In slave mode, SS pin function is slave select input.
 *     When C2[MODFEN] is 1: In master mode, SS pin function is automatic SS
 *     output. In slave mode: SS pin function is slave select input.
 */
/*@{*/
/*! @brief Read current value of the SPI_C1_SSOE field. */
#define SPI_RD_C1_SSOE(base) ((SPI_C1_REG(base) & SPI_C1_SSOE_MASK) >> SPI_C1_SSOE_SHIFT)
#define SPI_BRD_C1_SSOE(base) (BME_UBFX8(&SPI_C1_REG(base), SPI_C1_SSOE_SHIFT, SPI_C1_SSOE_WIDTH))

/*! @brief Set the SSOE field to a new value. */
#define SPI_WR_C1_SSOE(base, value) (SPI_RMW_C1(base, SPI_C1_SSOE_MASK, SPI_C1_SSOE(value)))
#define SPI_BWR_C1_SSOE(base, value) (BME_BFI8(&SPI_C1_REG(base), ((uint8_t)(value) << SPI_C1_SSOE_SHIFT), SPI_C1_SSOE_SHIFT, SPI_C1_SSOE_WIDTH))
/*@}*/

/*!
 * @name Register SPI_C1, field CPHA[2] (RW)
 *
 * Selects one of two clock formats for different kinds of synchronous serial
 * peripheral devices. Refer to the description of "SPI Clock Formats" for details.
 *
 * Values:
 * - 0b0 - First edge on SPSCK occurs at the middle of the first cycle of a data
 *     transfer.
 * - 0b1 - First edge on SPSCK occurs at the start of the first cycle of a data
 *     transfer.
 */
/*@{*/
/*! @brief Read current value of the SPI_C1_CPHA field. */
#define SPI_RD_C1_CPHA(base) ((SPI_C1_REG(base) & SPI_C1_CPHA_MASK) >> SPI_C1_CPHA_SHIFT)
#define SPI_BRD_C1_CPHA(base) (BME_UBFX8(&SPI_C1_REG(base), SPI_C1_CPHA_SHIFT, SPI_C1_CPHA_WIDTH))

/*! @brief Set the CPHA field to a new value. */
#define SPI_WR_C1_CPHA(base, value) (SPI_RMW_C1(base, SPI_C1_CPHA_MASK, SPI_C1_CPHA(value)))
#define SPI_BWR_C1_CPHA(base, value) (BME_BFI8(&SPI_C1_REG(base), ((uint8_t)(value) << SPI_C1_CPHA_SHIFT), SPI_C1_CPHA_SHIFT, SPI_C1_CPHA_WIDTH))
/*@}*/

/*!
 * @name Register SPI_C1, field CPOL[3] (RW)
 *
 * Selects an inverted or non-inverted SPI clock. To transmit data between SPI
 * modules, the SPI modules must have identical CPOL values. This bit effectively
 * places an inverter in series with the clock signal either from a master SPI
 * device or to a slave SPI device. Refer to the description of "SPI Clock Formats"
 * for details.
 *
 * Values:
 * - 0b0 - Active-high SPI clock (idles low)
 * - 0b1 - Active-low SPI clock (idles high)
 */
/*@{*/
/*! @brief Read current value of the SPI_C1_CPOL field. */
#define SPI_RD_C1_CPOL(base) ((SPI_C1_REG(base) & SPI_C1_CPOL_MASK) >> SPI_C1_CPOL_SHIFT)
#define SPI_BRD_C1_CPOL(base) (BME_UBFX8(&SPI_C1_REG(base), SPI_C1_CPOL_SHIFT, SPI_C1_CPOL_WIDTH))

/*! @brief Set the CPOL field to a new value. */
#define SPI_WR_C1_CPOL(base, value) (SPI_RMW_C1(base, SPI_C1_CPOL_MASK, SPI_C1_CPOL(value)))
#define SPI_BWR_C1_CPOL(base, value) (BME_BFI8(&SPI_C1_REG(base), ((uint8_t)(value) << SPI_C1_CPOL_SHIFT), SPI_C1_CPOL_SHIFT, SPI_C1_CPOL_WIDTH))
/*@}*/

/*!
 * @name Register SPI_C1, field MSTR[4] (RW)
 *
 * Selects master or slave mode operation.
 *
 * Values:
 * - 0b0 - SPI module configured as a slave SPI device
 * - 0b1 - SPI module configured as a master SPI device
 */
/*@{*/
/*! @brief Read current value of the SPI_C1_MSTR field. */
#define SPI_RD_C1_MSTR(base) ((SPI_C1_REG(base) & SPI_C1_MSTR_MASK) >> SPI_C1_MSTR_SHIFT)
#define SPI_BRD_C1_MSTR(base) (BME_UBFX8(&SPI_C1_REG(base), SPI_C1_MSTR_SHIFT, SPI_C1_MSTR_WIDTH))

/*! @brief Set the MSTR field to a new value. */
#define SPI_WR_C1_MSTR(base, value) (SPI_RMW_C1(base, SPI_C1_MSTR_MASK, SPI_C1_MSTR(value)))
#define SPI_BWR_C1_MSTR(base, value) (BME_BFI8(&SPI_C1_REG(base), ((uint8_t)(value) << SPI_C1_MSTR_SHIFT), SPI_C1_MSTR_SHIFT, SPI_C1_MSTR_WIDTH))
/*@}*/

/*!
 * @name Register SPI_C1, field SPTIE[5] (RW)
 *
 * When the FIFO is not supported or not enabled (FIFOMODE is not present or is
 * 0): This is the interrupt enable bit for SPI transmit buffer empty (SPTEF). An
 * interrupt occurs when the SPI transmit buffer is empty (SPTEF is set). When
 * the FIFO is supported and enabled (FIFOMODE is 1): This is the interrupt enable
 * bit for SPI transmit FIFO empty (SPTEF). An interrupt occurs when the SPI
 * transmit FIFO is empty (SPTEF is set).
 *
 * Values:
 * - 0b0 - Interrupts from SPTEF inhibited (use polling)
 * - 0b1 - When SPTEF is 1, hardware interrupt requested
 */
/*@{*/
/*! @brief Read current value of the SPI_C1_SPTIE field. */
#define SPI_RD_C1_SPTIE(base) ((SPI_C1_REG(base) & SPI_C1_SPTIE_MASK) >> SPI_C1_SPTIE_SHIFT)
#define SPI_BRD_C1_SPTIE(base) (BME_UBFX8(&SPI_C1_REG(base), SPI_C1_SPTIE_SHIFT, SPI_C1_SPTIE_WIDTH))

/*! @brief Set the SPTIE field to a new value. */
#define SPI_WR_C1_SPTIE(base, value) (SPI_RMW_C1(base, SPI_C1_SPTIE_MASK, SPI_C1_SPTIE(value)))
#define SPI_BWR_C1_SPTIE(base, value) (BME_BFI8(&SPI_C1_REG(base), ((uint8_t)(value) << SPI_C1_SPTIE_SHIFT), SPI_C1_SPTIE_SHIFT, SPI_C1_SPTIE_WIDTH))
/*@}*/

/*!
 * @name Register SPI_C1, field SPE[6] (RW)
 *
 * Enables the SPI system and dedicates the SPI port pins to SPI system
 * functions. If SPE is cleared, the SPI is disabled and forced into an idle state, and
 * all status bits in the S register are reset.
 *
 * Values:
 * - 0b0 - SPI system inactive
 * - 0b1 - SPI system enabled
 */
/*@{*/
/*! @brief Read current value of the SPI_C1_SPE field. */
#define SPI_RD_C1_SPE(base)  ((SPI_C1_REG(base) & SPI_C1_SPE_MASK) >> SPI_C1_SPE_SHIFT)
#define SPI_BRD_C1_SPE(base) (BME_UBFX8(&SPI_C1_REG(base), SPI_C1_SPE_SHIFT, SPI_C1_SPE_WIDTH))

/*! @brief Set the SPE field to a new value. */
#define SPI_WR_C1_SPE(base, value) (SPI_RMW_C1(base, SPI_C1_SPE_MASK, SPI_C1_SPE(value)))
#define SPI_BWR_C1_SPE(base, value) (BME_BFI8(&SPI_C1_REG(base), ((uint8_t)(value) << SPI_C1_SPE_SHIFT), SPI_C1_SPE_SHIFT, SPI_C1_SPE_WIDTH))
/*@}*/

/*!
 * @name Register SPI_C1, field SPIE[7] (RW)
 *
 * When the FIFO is not supported or not enabled (FIFOMODE is not present or is
 * 0): Enables the interrupt for SPI receive buffer full (SPRF) and mode fault
 * (MODF) events. When the FIFO is supported and enabled (FIFOMODE is 1): This bit
 * enables the SPI to interrupt the CPU when the receive FIFO is full. An
 * interrupt occurs when the SPRF bit is set or the MODF bit is set.
 *
 * Values:
 * - 0b0 - Interrupts from SPRF and MODF are inhibited-use polling (when
 *     FIFOMODE is not present or is 0) or Read FIFO Full Interrupts are disabled (when
 *     FIFOMODE is 1)
 * - 0b1 - Request a hardware interrupt when SPRF or MODF is 1 (when FIFOMODE is
 *     not present or is 0) or Read FIFO Full Interrupts are enabled (when
 *     FIFOMODE is 1)
 */
/*@{*/
/*! @brief Read current value of the SPI_C1_SPIE field. */
#define SPI_RD_C1_SPIE(base) ((SPI_C1_REG(base) & SPI_C1_SPIE_MASK) >> SPI_C1_SPIE_SHIFT)
#define SPI_BRD_C1_SPIE(base) (BME_UBFX8(&SPI_C1_REG(base), SPI_C1_SPIE_SHIFT, SPI_C1_SPIE_WIDTH))

/*! @brief Set the SPIE field to a new value. */
#define SPI_WR_C1_SPIE(base, value) (SPI_RMW_C1(base, SPI_C1_SPIE_MASK, SPI_C1_SPIE(value)))
#define SPI_BWR_C1_SPIE(base, value) (BME_BFI8(&SPI_C1_REG(base), ((uint8_t)(value) << SPI_C1_SPIE_SHIFT), SPI_C1_SPIE_SHIFT, SPI_C1_SPIE_WIDTH))
/*@}*/

/*******************************************************************************
 * SPI_ML - SPI Match Register low
 ******************************************************************************/

/*!
 * @brief SPI_ML - SPI Match Register low (RW)
 *
 * Reset value: 0x00U
 *
 * This register, together with the MH register, contains the hardware compare
 * value. When the value received in the SPI receive data buffer equals this
 * hardware compare value, the SPI Match Flag in the S register (S[SPMF]) sets. In
 * 8-bit mode, only the ML register is available. Reads of the MH register return
 * all zeros. Writes to the MH register are ignored. In 16-bit mode, reading either
 * byte (the MH or ML register) latches the contents of both bytes into a buffer
 * where they remain latched until the other byte is read. Writing to either
 * byte (the MH or ML register) latches the value into a buffer. When both bytes
 * have been written, they are transferred as a coherent value into the SPI match
 * registers.
 */
/*!
 * @name Constants and macros for entire SPI_ML register
 */
/*@{*/
#define SPI_RD_ML(base)          (SPI_ML_REG(base))
#define SPI_WR_ML(base, value)   (SPI_ML_REG(base) = (value))
#define SPI_RMW_ML(base, mask, value) (SPI_WR_ML(base, (SPI_RD_ML(base) & ~(mask)) | (value)))
#define SPI_SET_ML(base, value)  (BME_OR8(&SPI_ML_REG(base), (uint8_t)(value)))
#define SPI_CLR_ML(base, value)  (BME_AND8(&SPI_ML_REG(base), (uint8_t)(~(value))))
#define SPI_TOG_ML(base, value)  (BME_XOR8(&SPI_ML_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * SPI_MH - SPI match register high
 ******************************************************************************/

/*!
 * @brief SPI_MH - SPI match register high (RW)
 *
 * Reset value: 0x00U
 *
 * Refer to the description of the ML register.
 */
/*!
 * @name Constants and macros for entire SPI_MH register
 */
/*@{*/
#define SPI_RD_MH(base)          (SPI_MH_REG(base))
#define SPI_WR_MH(base, value)   (SPI_MH_REG(base) = (value))
#define SPI_RMW_MH(base, mask, value) (SPI_WR_MH(base, (SPI_RD_MH(base) & ~(mask)) | (value)))
#define SPI_SET_MH(base, value)  (BME_OR8(&SPI_MH_REG(base), (uint8_t)(value)))
#define SPI_CLR_MH(base, value)  (BME_AND8(&SPI_MH_REG(base), (uint8_t)(~(value))))
#define SPI_TOG_MH(base, value)  (BME_XOR8(&SPI_MH_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * SPI_DL - SPI Data Register low
 ******************************************************************************/

/*!
 * @brief SPI_DL - SPI Data Register low (RW)
 *
 * Reset value: 0x00U
 *
 * This register, together with the DH register, is both the input and output
 * register for SPI data. A write to the registers writes to the transmit data
 * buffer, allowing data to be queued and transmitted. When the SPI is configured as
 * a master, data queued in the transmit data buffer is transmitted immediately
 * after the previous transmission has completed. The SPTEF bit in the S register
 * indicates when the transmit data buffer is ready to accept new data. When the
 * transmit DMA request is disabled (TXDMAE is 0): The S register must be read
 * when S[SPTEF] is set before writing to the SPI data registers; otherwise, the
 * write is ignored. When the transmit DMA request is enabled (TXDMAE is 1) when
 * S[SPTEF] is set, the SPI data registers can be written automatically by DMA
 * without reading the S register first. Data may be read from the SPI data registers
 * any time after S[SPRF] is set and before another transfer is finished.
 * Failure to read the data out of the receive data buffer before a new transfer ends
 * causes a receive overrun condition, and the data from the new transfer is lost.
 * The new data is lost because the receive buffer still held the previous
 * character and was not ready to accept the new data. There is no indication for a
 * receive overrun condition, so the application system designer must ensure that
 * previous data has been read from the receive buffer before a new transfer is
 * initiated. In 8-bit mode, only the DL register is available. Reads of the DH
 * register return all zeros. Writes to the DH register are ignored. In 16-bit mode,
 * reading either byte (the DH or DL register) latches the contents of both
 * bytes into a buffer where they remain latched until the other byte is read.
 * Writing to either byte (the DH or DL register) latches the value into a buffer. When
 * both bytes have been written, they are transferred as a coherent 16-bit value
 * into the transmit data buffer.
 */
/*!
 * @name Constants and macros for entire SPI_DL register
 */
/*@{*/
#define SPI_RD_DL(base)          (SPI_DL_REG(base))
#define SPI_WR_DL(base, value)   (SPI_DL_REG(base) = (value))
#define SPI_RMW_DL(base, mask, value) (SPI_WR_DL(base, (SPI_RD_DL(base) & ~(mask)) | (value)))
#define SPI_SET_DL(base, value)  (BME_OR8(&SPI_DL_REG(base), (uint8_t)(value)))
#define SPI_CLR_DL(base, value)  (BME_AND8(&SPI_DL_REG(base), (uint8_t)(~(value))))
#define SPI_TOG_DL(base, value)  (BME_XOR8(&SPI_DL_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * SPI_DH - SPI data register high
 ******************************************************************************/

/*!
 * @brief SPI_DH - SPI data register high (RW)
 *
 * Reset value: 0x00U
 *
 * Refer to the description of the DL register.
 */
/*!
 * @name Constants and macros for entire SPI_DH register
 */
/*@{*/
#define SPI_RD_DH(base)          (SPI_DH_REG(base))
#define SPI_WR_DH(base, value)   (SPI_DH_REG(base) = (value))
#define SPI_RMW_DH(base, mask, value) (SPI_WR_DH(base, (SPI_RD_DH(base) & ~(mask)) | (value)))
#define SPI_SET_DH(base, value)  (BME_OR8(&SPI_DH_REG(base), (uint8_t)(value)))
#define SPI_CLR_DH(base, value)  (BME_AND8(&SPI_DH_REG(base), (uint8_t)(~(value))))
#define SPI_TOG_DH(base, value)  (BME_XOR8(&SPI_DH_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * SPI_CI - SPI clear interrupt register
 ******************************************************************************/

/*!
 * @brief SPI_CI - SPI clear interrupt register (RW)
 *
 * Reset value: 0x00U
 *
 * This register applies only for an instance of the SPI module that supports
 * the FIFO feature. The register has four bits dedicated to clearing the
 * interrupts. Writing 1 to these bits clears the corresponding interrupts if the INTCLR
 * bit in the C3 register is 1. Reading these bits always returns 0. This register
 * also has two read-only bits to indicate the transmit FIFO and receive FIFO
 * overrun conditions. When the receive FIFO is full and data is received, RXFOF is
 * set. Similarily, when the transmit FIFO is full and a write to the data
 * register occurs, TXFOF is set. These flags are cleared when the CI register is read
 * while the flags are set. The register has two more read-only bits to indicate
 * the error flags. These flags are set when, due to some spurious reason,
 * entries in the FIFO total more than 64 bits of data. At this point, all the flags
 * in the status register are reset, and entries in the FIFO are flushed with the
 * corresponding error flags set. These flags are cleared when the CI register is
 * read while the flags are set.
 */
/*!
 * @name Constants and macros for entire SPI_CI register
 */
/*@{*/
#define SPI_RD_CI(base)          (SPI_CI_REG(base))
#define SPI_WR_CI(base, value)   (SPI_CI_REG(base) = (value))
#define SPI_RMW_CI(base, mask, value) (SPI_WR_CI(base, (SPI_RD_CI(base) & ~(mask)) | (value)))
#define SPI_SET_CI(base, value)  (BME_OR8(&SPI_CI_REG(base), (uint8_t)(value)))
#define SPI_CLR_CI(base, value)  (BME_AND8(&SPI_CI_REG(base), (uint8_t)(~(value))))
#define SPI_TOG_CI(base, value)  (BME_XOR8(&SPI_CI_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual SPI_CI bitfields
 */

/*!
 * @name Register SPI_CI, field SPRFCI[0] (WORZ)
 *
 * Writing 1 to this bit clears the SPRF interrupt provided that C3[3] is set.
 */
/*@{*/
/*! @brief Set the SPRFCI field to a new value. */
#define SPI_WR_CI_SPRFCI(base, value) (SPI_RMW_CI(base, SPI_CI_SPRFCI_MASK, SPI_CI_SPRFCI(value)))
#define SPI_BWR_CI_SPRFCI(base, value) (BME_BFI8(&SPI_CI_REG(base), ((uint8_t)(value) << SPI_CI_SPRFCI_SHIFT), SPI_CI_SPRFCI_SHIFT, SPI_CI_SPRFCI_WIDTH))
/*@}*/

/*!
 * @name Register SPI_CI, field SPTEFCI[1] (WORZ)
 *
 * Writing 1 to this bit clears the SPTEF interrupt provided that C3[3] is set.
 */
/*@{*/
/*! @brief Set the SPTEFCI field to a new value. */
#define SPI_WR_CI_SPTEFCI(base, value) (SPI_RMW_CI(base, SPI_CI_SPTEFCI_MASK, SPI_CI_SPTEFCI(value)))
#define SPI_BWR_CI_SPTEFCI(base, value) (BME_BFI8(&SPI_CI_REG(base), ((uint8_t)(value) << SPI_CI_SPTEFCI_SHIFT), SPI_CI_SPTEFCI_SHIFT, SPI_CI_SPTEFCI_WIDTH))
/*@}*/

/*!
 * @name Register SPI_CI, field RNFULLFCI[2] (WORZ)
 *
 * Writing 1 to this bit clears the RNFULLF interrupt provided that C3[3] is set.
 */
/*@{*/
/*! @brief Set the RNFULLFCI field to a new value. */
#define SPI_WR_CI_RNFULLFCI(base, value) (SPI_RMW_CI(base, SPI_CI_RNFULLFCI_MASK, SPI_CI_RNFULLFCI(value)))
#define SPI_BWR_CI_RNFULLFCI(base, value) (BME_BFI8(&SPI_CI_REG(base), ((uint8_t)(value) << SPI_CI_RNFULLFCI_SHIFT), SPI_CI_RNFULLFCI_SHIFT, SPI_CI_RNFULLFCI_WIDTH))
/*@}*/

/*!
 * @name Register SPI_CI, field TNEAREFCI[3] (WORZ)
 *
 * Writing 1 to this bit clears the TNEAREF interrupt provided that C3[3] is set.
 */
/*@{*/
/*! @brief Set the TNEAREFCI field to a new value. */
#define SPI_WR_CI_TNEAREFCI(base, value) (SPI_RMW_CI(base, SPI_CI_TNEAREFCI_MASK, SPI_CI_TNEAREFCI(value)))
#define SPI_BWR_CI_TNEAREFCI(base, value) (BME_BFI8(&SPI_CI_REG(base), ((uint8_t)(value) << SPI_CI_TNEAREFCI_SHIFT), SPI_CI_TNEAREFCI_SHIFT, SPI_CI_TNEAREFCI_WIDTH))
/*@}*/

/*!
 * @name Register SPI_CI, field RXFOF[4] (RO)
 *
 * This flag indicates that a receive FIFO overflow condition has occurred.
 *
 * Values:
 * - 0b0 - Receive FIFO overflow condition has not occurred
 * - 0b1 - Receive FIFO overflow condition occurred
 */
/*@{*/
/*! @brief Read current value of the SPI_CI_RXFOF field. */
#define SPI_RD_CI_RXFOF(base) ((SPI_CI_REG(base) & SPI_CI_RXFOF_MASK) >> SPI_CI_RXFOF_SHIFT)
#define SPI_BRD_CI_RXFOF(base) (BME_UBFX8(&SPI_CI_REG(base), SPI_CI_RXFOF_SHIFT, SPI_CI_RXFOF_WIDTH))
/*@}*/

/*!
 * @name Register SPI_CI, field TXFOF[5] (RO)
 *
 * This flag indicates that a transmit FIFO overflow condition has occurred.
 *
 * Values:
 * - 0b0 - Transmit FIFO overflow condition has not occurred
 * - 0b1 - Transmit FIFO overflow condition occurred
 */
/*@{*/
/*! @brief Read current value of the SPI_CI_TXFOF field. */
#define SPI_RD_CI_TXFOF(base) ((SPI_CI_REG(base) & SPI_CI_TXFOF_MASK) >> SPI_CI_TXFOF_SHIFT)
#define SPI_BRD_CI_TXFOF(base) (BME_UBFX8(&SPI_CI_REG(base), SPI_CI_TXFOF_SHIFT, SPI_CI_TXFOF_WIDTH))
/*@}*/

/*!
 * @name Register SPI_CI, field RXFERR[6] (RO)
 *
 * This flag indicates that a receive FIFO error occurred because entries in the
 * FIFO total more than 64 bits of data.
 *
 * Values:
 * - 0b0 - No receive FIFO error occurred
 * - 0b1 - A receive FIFO error occurred
 */
/*@{*/
/*! @brief Read current value of the SPI_CI_RXFERR field. */
#define SPI_RD_CI_RXFERR(base) ((SPI_CI_REG(base) & SPI_CI_RXFERR_MASK) >> SPI_CI_RXFERR_SHIFT)
#define SPI_BRD_CI_RXFERR(base) (BME_UBFX8(&SPI_CI_REG(base), SPI_CI_RXFERR_SHIFT, SPI_CI_RXFERR_WIDTH))
/*@}*/

/*!
 * @name Register SPI_CI, field TXFERR[7] (RO)
 *
 * This flag indicates that a transmit FIFO error occurred because entries in
 * the FIFO total more than 64 bits of data.
 *
 * Values:
 * - 0b0 - No transmit FIFO error occurred
 * - 0b1 - A transmit FIFO error occurred
 */
/*@{*/
/*! @brief Read current value of the SPI_CI_TXFERR field. */
#define SPI_RD_CI_TXFERR(base) ((SPI_CI_REG(base) & SPI_CI_TXFERR_MASK) >> SPI_CI_TXFERR_SHIFT)
#define SPI_BRD_CI_TXFERR(base) (BME_UBFX8(&SPI_CI_REG(base), SPI_CI_TXFERR_SHIFT, SPI_CI_TXFERR_WIDTH))
/*@}*/

/*******************************************************************************
 * SPI_C3 - SPI control register 3
 ******************************************************************************/

/*!
 * @brief SPI_C3 - SPI control register 3 (RW)
 *
 * Reset value: 0x00U
 *
 * This register introduces a 64-bit FIFO function on both transmit and receive
 * buffers. It applies only for an instance of the SPI module that supports the
 * FIFO feature. FIFO mode is enabled by setting the FIFOMODE bit to 1. A write to
 * this register occurs only when it sets the FIFOMODE bit to 1. Using this FIFO
 * feature allows the SPI to provide high speed transfers of large amounts of
 * data without consuming large amounts of the CPU bandwidth. Enabling this FIFO
 * function affects the behavior of some of the read/write buffer flags in the S
 * register as follows: When the receive FIFO has data in it, S[RFIFOEF] is 0. As a
 * result: If C2[RXDMAE] is 1, RFIFOEF_b generates a receive DMA request. The
 * DMA request remains active until RFIFOEF is set to 1, indicating the receive
 * buffer is empty. If C2[RXDMAE] is 0 and C1[SPIE] is 1, SPRF interrupts the CPU.
 * When the transmit FIFO is not full, S[TXFULLF] is 0. As a result: If C2[TXDMAE]
 * is 1, TXFULLF_b generates a transmit DMA request. The DMA request remains
 * active until TXFULLF is set to 1, indicating the transmit FIFO is full. If
 * C2[TXDMAE] is 0 and C1[SPTIE] is 1, SPTEF interrupts the CPU. Two interrupt enable
 * bits, TNEARIEN and RNFULLIEN, provide CPU interrupts based on the "watermark"
 * feature of the TNEARF and RNFULLF flags of the S register.
 */
/*!
 * @name Constants and macros for entire SPI_C3 register
 */
/*@{*/
#define SPI_RD_C3(base)          (SPI_C3_REG(base))
#define SPI_WR_C3(base, value)   (SPI_C3_REG(base) = (value))
#define SPI_RMW_C3(base, mask, value) (SPI_WR_C3(base, (SPI_RD_C3(base) & ~(mask)) | (value)))
#define SPI_SET_C3(base, value)  (BME_OR8(&SPI_C3_REG(base), (uint8_t)(value)))
#define SPI_CLR_C3(base, value)  (BME_AND8(&SPI_C3_REG(base), (uint8_t)(~(value))))
#define SPI_TOG_C3(base, value)  (BME_XOR8(&SPI_C3_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual SPI_C3 bitfields
 */

/*!
 * @name Register SPI_C3, field FIFOMODE[0] (RW)
 *
 * This bit enables the SPI to use a 64-bit FIFO (8 bytes or four 16-bit words)
 * for both transmit and receive buffers.
 *
 * Values:
 * - 0b0 - FIFO mode disabled
 * - 0b1 - FIFO mode enabled
 */
/*@{*/
/*! @brief Read current value of the SPI_C3_FIFOMODE field. */
#define SPI_RD_C3_FIFOMODE(base) ((SPI_C3_REG(base) & SPI_C3_FIFOMODE_MASK) >> SPI_C3_FIFOMODE_SHIFT)
#define SPI_BRD_C3_FIFOMODE(base) (BME_UBFX8(&SPI_C3_REG(base), SPI_C3_FIFOMODE_SHIFT, SPI_C3_FIFOMODE_WIDTH))

/*! @brief Set the FIFOMODE field to a new value. */
#define SPI_WR_C3_FIFOMODE(base, value) (SPI_RMW_C3(base, SPI_C3_FIFOMODE_MASK, SPI_C3_FIFOMODE(value)))
#define SPI_BWR_C3_FIFOMODE(base, value) (BME_BFI8(&SPI_C3_REG(base), ((uint8_t)(value) << SPI_C3_FIFOMODE_SHIFT), SPI_C3_FIFOMODE_SHIFT, SPI_C3_FIFOMODE_WIDTH))
/*@}*/

/*!
 * @name Register SPI_C3, field RNFULLIEN[1] (RW)
 *
 * Writing 1 to this bit enables the SPI to interrupt the CPU when the RNFULLF
 * flag is set. This bit is ignored and has no function if the FIFOMODE bit is 0.
 *
 * Values:
 * - 0b0 - No interrupt upon RNFULLF being set
 * - 0b1 - Enable interrupts upon RNFULLF being set
 */
/*@{*/
/*! @brief Read current value of the SPI_C3_RNFULLIEN field. */
#define SPI_RD_C3_RNFULLIEN(base) ((SPI_C3_REG(base) & SPI_C3_RNFULLIEN_MASK) >> SPI_C3_RNFULLIEN_SHIFT)
#define SPI_BRD_C3_RNFULLIEN(base) (BME_UBFX8(&SPI_C3_REG(base), SPI_C3_RNFULLIEN_SHIFT, SPI_C3_RNFULLIEN_WIDTH))

/*! @brief Set the RNFULLIEN field to a new value. */
#define SPI_WR_C3_RNFULLIEN(base, value) (SPI_RMW_C3(base, SPI_C3_RNFULLIEN_MASK, SPI_C3_RNFULLIEN(value)))
#define SPI_BWR_C3_RNFULLIEN(base, value) (BME_BFI8(&SPI_C3_REG(base), ((uint8_t)(value) << SPI_C3_RNFULLIEN_SHIFT), SPI_C3_RNFULLIEN_SHIFT, SPI_C3_RNFULLIEN_WIDTH))
/*@}*/

/*!
 * @name Register SPI_C3, field TNEARIEN[2] (RW)
 *
 * Writing 1 to this bit enables the SPI to interrupt the CPU when the TNEAREF
 * flag is set. This bit is ignored and has no function if the FIFOMODE bit is 0.
 *
 * Values:
 * - 0b0 - No interrupt upon TNEAREF being set
 * - 0b1 - Enable interrupts upon TNEAREF being set
 */
/*@{*/
/*! @brief Read current value of the SPI_C3_TNEARIEN field. */
#define SPI_RD_C3_TNEARIEN(base) ((SPI_C3_REG(base) & SPI_C3_TNEARIEN_MASK) >> SPI_C3_TNEARIEN_SHIFT)
#define SPI_BRD_C3_TNEARIEN(base) (BME_UBFX8(&SPI_C3_REG(base), SPI_C3_TNEARIEN_SHIFT, SPI_C3_TNEARIEN_WIDTH))

/*! @brief Set the TNEARIEN field to a new value. */
#define SPI_WR_C3_TNEARIEN(base, value) (SPI_RMW_C3(base, SPI_C3_TNEARIEN_MASK, SPI_C3_TNEARIEN(value)))
#define SPI_BWR_C3_TNEARIEN(base, value) (BME_BFI8(&SPI_C3_REG(base), ((uint8_t)(value) << SPI_C3_TNEARIEN_SHIFT), SPI_C3_TNEARIEN_SHIFT, SPI_C3_TNEARIEN_WIDTH))
/*@}*/

/*!
 * @name Register SPI_C3, field INTCLR[3] (RW)
 *
 * This bit selects the mechanism by which the SPRF, SPTEF, TNEAREF, and RNFULLF
 * interrupts are cleared.
 *
 * Values:
 * - 0b0 - These interrupts are cleared when the corresponding flags are cleared
 *     depending on the state of the FIFOs
 * - 0b1 - These interrupts are cleared by writing the corresponding bits in the
 *     CI register
 */
/*@{*/
/*! @brief Read current value of the SPI_C3_INTCLR field. */
#define SPI_RD_C3_INTCLR(base) ((SPI_C3_REG(base) & SPI_C3_INTCLR_MASK) >> SPI_C3_INTCLR_SHIFT)
#define SPI_BRD_C3_INTCLR(base) (BME_UBFX8(&SPI_C3_REG(base), SPI_C3_INTCLR_SHIFT, SPI_C3_INTCLR_WIDTH))

/*! @brief Set the INTCLR field to a new value. */
#define SPI_WR_C3_INTCLR(base, value) (SPI_RMW_C3(base, SPI_C3_INTCLR_MASK, SPI_C3_INTCLR(value)))
#define SPI_BWR_C3_INTCLR(base, value) (BME_BFI8(&SPI_C3_REG(base), ((uint8_t)(value) << SPI_C3_INTCLR_SHIFT), SPI_C3_INTCLR_SHIFT, SPI_C3_INTCLR_WIDTH))
/*@}*/

/*!
 * @name Register SPI_C3, field RNFULLF_MARK[4] (RW)
 *
 * This bit selects the mark after which the RNFULLF flag is asserted.
 *
 * Values:
 * - 0b0 - RNFULLF is set when the receive FIFO has 48 bits or more
 * - 0b1 - RNFULLF is set when the receive FIFO has 32 bits or more
 */
/*@{*/
/*! @brief Read current value of the SPI_C3_RNFULLF_MARK field. */
#define SPI_RD_C3_RNFULLF_MARK(base) ((SPI_C3_REG(base) & SPI_C3_RNFULLF_MARK_MASK) >> SPI_C3_RNFULLF_MARK_SHIFT)
#define SPI_BRD_C3_RNFULLF_MARK(base) (BME_UBFX8(&SPI_C3_REG(base), SPI_C3_RNFULLF_MARK_SHIFT, SPI_C3_RNFULLF_MARK_WIDTH))

/*! @brief Set the RNFULLF_MARK field to a new value. */
#define SPI_WR_C3_RNFULLF_MARK(base, value) (SPI_RMW_C3(base, SPI_C3_RNFULLF_MARK_MASK, SPI_C3_RNFULLF_MARK(value)))
#define SPI_BWR_C3_RNFULLF_MARK(base, value) (BME_BFI8(&SPI_C3_REG(base), ((uint8_t)(value) << SPI_C3_RNFULLF_MARK_SHIFT), SPI_C3_RNFULLF_MARK_SHIFT, SPI_C3_RNFULLF_MARK_WIDTH))
/*@}*/

/*!
 * @name Register SPI_C3, field TNEAREF_MARK[5] (RW)
 *
 * This bit selects the mark after which the TNEAREF flag is asserted.
 *
 * Values:
 * - 0b0 - TNEAREF is set when the transmit FIFO has 16 bits or less
 * - 0b1 - TNEAREF is set when the transmit FIFO has 32 bits or less
 */
/*@{*/
/*! @brief Read current value of the SPI_C3_TNEAREF_MARK field. */
#define SPI_RD_C3_TNEAREF_MARK(base) ((SPI_C3_REG(base) & SPI_C3_TNEAREF_MARK_MASK) >> SPI_C3_TNEAREF_MARK_SHIFT)
#define SPI_BRD_C3_TNEAREF_MARK(base) (BME_UBFX8(&SPI_C3_REG(base), SPI_C3_TNEAREF_MARK_SHIFT, SPI_C3_TNEAREF_MARK_WIDTH))

/*! @brief Set the TNEAREF_MARK field to a new value. */
#define SPI_WR_C3_TNEAREF_MARK(base, value) (SPI_RMW_C3(base, SPI_C3_TNEAREF_MARK_MASK, SPI_C3_TNEAREF_MARK(value)))
#define SPI_BWR_C3_TNEAREF_MARK(base, value) (BME_BFI8(&SPI_C3_REG(base), ((uint8_t)(value) << SPI_C3_TNEAREF_MARK_SHIFT), SPI_C3_TNEAREF_MARK_SHIFT, SPI_C3_TNEAREF_MARK_WIDTH))
/*@}*/

/*
 * MKM34Z7 TMR
 *
 * Quad Timer
 *
 * Registers defined in this header file:
 * - TMR_COMP1 - Timer Channel Compare Register 1
 * - TMR_COMP2 - Timer Channel Compare Register 2
 * - TMR_CAPT - Timer Channel Capture Register
 * - TMR_LOAD - Timer Channel Load Register
 * - TMR_HOLD - Timer Channel Hold Register
 * - TMR_CNTR - Timer Channel Counter Register
 * - TMR_CTRL - Timer Channel Control Register
 * - TMR_SCTRL - Timer Channel Status and Control Register
 * - TMR_CMPLD1 - Timer Channel Comparator Load Register 1
 * - TMR_CMPLD2 - Timer Channel Comparator Load Register 2
 * - TMR_CSCTRL - Timer Channel Comparator Status and Control Register
 * - TMR_FILT - Timer Channel Input Filter Register
 * - TMR_ENBL - Timer Channel Enable Register
 */

#define TMR_INSTANCE_COUNT (4U) /*!< Number of instances of the TMR module. */
#define TMR0_IDX (0U) /*!< Instance number for TMR0. */
#define TMR1_IDX (1U) /*!< Instance number for TMR1. */
#define TMR2_IDX (2U) /*!< Instance number for TMR2. */
#define TMR3_IDX (3U) /*!< Instance number for TMR3. */

/*******************************************************************************
 * TMR_COMP1 - Timer Channel Compare Register 1
 ******************************************************************************/

/*!
 * @brief TMR_COMP1 - Timer Channel Compare Register 1 (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire TMR_COMP1 register
 */
/*@{*/
#define TMR_RD_COMP1(base)       (TMR_COMP1_REG(base))
#define TMR_WR_COMP1(base, value) (TMR_COMP1_REG(base) = (value))
#define TMR_RMW_COMP1(base, mask, value) (TMR_WR_COMP1(base, (TMR_RD_COMP1(base) & ~(mask)) | (value)))
#define TMR_SET_COMP1(base, value) (BME_OR16(&TMR_COMP1_REG(base), (uint16_t)(value)))
#define TMR_CLR_COMP1(base, value) (BME_AND16(&TMR_COMP1_REG(base), (uint16_t)(~(value))))
#define TMR_TOG_COMP1(base, value) (BME_XOR16(&TMR_COMP1_REG(base), (uint16_t)(value)))
/*@}*/

/*******************************************************************************
 * TMR_COMP2 - Timer Channel Compare Register 2
 ******************************************************************************/

/*!
 * @brief TMR_COMP2 - Timer Channel Compare Register 2 (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire TMR_COMP2 register
 */
/*@{*/
#define TMR_RD_COMP2(base)       (TMR_COMP2_REG(base))
#define TMR_WR_COMP2(base, value) (TMR_COMP2_REG(base) = (value))
#define TMR_RMW_COMP2(base, mask, value) (TMR_WR_COMP2(base, (TMR_RD_COMP2(base) & ~(mask)) | (value)))
#define TMR_SET_COMP2(base, value) (BME_OR16(&TMR_COMP2_REG(base), (uint16_t)(value)))
#define TMR_CLR_COMP2(base, value) (BME_AND16(&TMR_COMP2_REG(base), (uint16_t)(~(value))))
#define TMR_TOG_COMP2(base, value) (BME_XOR16(&TMR_COMP2_REG(base), (uint16_t)(value)))
/*@}*/

/*******************************************************************************
 * TMR_CAPT - Timer Channel Capture Register
 ******************************************************************************/

/*!
 * @brief TMR_CAPT - Timer Channel Capture Register (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire TMR_CAPT register
 */
/*@{*/
#define TMR_RD_CAPT(base)        (TMR_CAPT_REG(base))
#define TMR_WR_CAPT(base, value) (TMR_CAPT_REG(base) = (value))
#define TMR_RMW_CAPT(base, mask, value) (TMR_WR_CAPT(base, (TMR_RD_CAPT(base) & ~(mask)) | (value)))
#define TMR_SET_CAPT(base, value) (BME_OR16(&TMR_CAPT_REG(base), (uint16_t)(value)))
#define TMR_CLR_CAPT(base, value) (BME_AND16(&TMR_CAPT_REG(base), (uint16_t)(~(value))))
#define TMR_TOG_CAPT(base, value) (BME_XOR16(&TMR_CAPT_REG(base), (uint16_t)(value)))
/*@}*/

/*******************************************************************************
 * TMR_LOAD - Timer Channel Load Register
 ******************************************************************************/

/*!
 * @brief TMR_LOAD - Timer Channel Load Register (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire TMR_LOAD register
 */
/*@{*/
#define TMR_RD_LOAD(base)        (TMR_LOAD_REG(base))
#define TMR_WR_LOAD(base, value) (TMR_LOAD_REG(base) = (value))
#define TMR_RMW_LOAD(base, mask, value) (TMR_WR_LOAD(base, (TMR_RD_LOAD(base) & ~(mask)) | (value)))
#define TMR_SET_LOAD(base, value) (BME_OR16(&TMR_LOAD_REG(base), (uint16_t)(value)))
#define TMR_CLR_LOAD(base, value) (BME_AND16(&TMR_LOAD_REG(base), (uint16_t)(~(value))))
#define TMR_TOG_LOAD(base, value) (BME_XOR16(&TMR_LOAD_REG(base), (uint16_t)(value)))
/*@}*/

/*******************************************************************************
 * TMR_HOLD - Timer Channel Hold Register
 ******************************************************************************/

/*!
 * @brief TMR_HOLD - Timer Channel Hold Register (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire TMR_HOLD register
 */
/*@{*/
#define TMR_RD_HOLD(base)        (TMR_HOLD_REG(base))
#define TMR_WR_HOLD(base, value) (TMR_HOLD_REG(base) = (value))
#define TMR_RMW_HOLD(base, mask, value) (TMR_WR_HOLD(base, (TMR_RD_HOLD(base) & ~(mask)) | (value)))
#define TMR_SET_HOLD(base, value) (BME_OR16(&TMR_HOLD_REG(base), (uint16_t)(value)))
#define TMR_CLR_HOLD(base, value) (BME_AND16(&TMR_HOLD_REG(base), (uint16_t)(~(value))))
#define TMR_TOG_HOLD(base, value) (BME_XOR16(&TMR_HOLD_REG(base), (uint16_t)(value)))
/*@}*/

/*******************************************************************************
 * TMR_CNTR - Timer Channel Counter Register
 ******************************************************************************/

/*!
 * @brief TMR_CNTR - Timer Channel Counter Register (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire TMR_CNTR register
 */
/*@{*/
#define TMR_RD_CNTR(base)        (TMR_CNTR_REG(base))
#define TMR_WR_CNTR(base, value) (TMR_CNTR_REG(base) = (value))
#define TMR_RMW_CNTR(base, mask, value) (TMR_WR_CNTR(base, (TMR_RD_CNTR(base) & ~(mask)) | (value)))
#define TMR_SET_CNTR(base, value) (BME_OR16(&TMR_CNTR_REG(base), (uint16_t)(value)))
#define TMR_CLR_CNTR(base, value) (BME_AND16(&TMR_CNTR_REG(base), (uint16_t)(~(value))))
#define TMR_TOG_CNTR(base, value) (BME_XOR16(&TMR_CNTR_REG(base), (uint16_t)(value)))
/*@}*/

/*******************************************************************************
 * TMR_CTRL - Timer Channel Control Register
 ******************************************************************************/

/*!
 * @brief TMR_CTRL - Timer Channel Control Register (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire TMR_CTRL register
 */
/*@{*/
#define TMR_RD_CTRL(base)        (TMR_CTRL_REG(base))
#define TMR_WR_CTRL(base, value) (TMR_CTRL_REG(base) = (value))
#define TMR_RMW_CTRL(base, mask, value) (TMR_WR_CTRL(base, (TMR_RD_CTRL(base) & ~(mask)) | (value)))
#define TMR_SET_CTRL(base, value) (BME_OR16(&TMR_CTRL_REG(base), (uint16_t)(value)))
#define TMR_CLR_CTRL(base, value) (BME_AND16(&TMR_CTRL_REG(base), (uint16_t)(~(value))))
#define TMR_TOG_CTRL(base, value) (BME_XOR16(&TMR_CTRL_REG(base), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual TMR_CTRL bitfields
 */

/*!
 * @name Register TMR_CTRL, field OUTMODE[2:0] (RW)
 *
 * These bits determine the mode of operation for the OFLAG output signal.
 *
 * Values:
 * - 0b000 - Asserted while counter is active
 * - 0b001 - Clear OFLAG output on successful compare
 * - 0b010 - Set OFLAG output on successful compare
 * - 0b011 - Toggle OFLAG output on successful compare
 * - 0b100 - Toggle OFLAG output using alternating compare registers
 * - 0b101 - Set on compare, cleared on secondary source input edge
 * - 0b110 - Set on compare, cleared on counter rollover
 * - 0b111 - Enable gated clock output while counter is active
 */
/*@{*/
/*! @brief Read current value of the TMR_CTRL_OUTMODE field. */
#define TMR_RD_CTRL_OUTMODE(base) ((TMR_CTRL_REG(base) & TMR_CTRL_OUTMODE_MASK) >> TMR_CTRL_OUTMODE_SHIFT)
#define TMR_BRD_CTRL_OUTMODE(base) (BME_UBFX16(&TMR_CTRL_REG(base), TMR_CTRL_OUTMODE_SHIFT, TMR_CTRL_OUTMODE_WIDTH))

/*! @brief Set the OUTMODE field to a new value. */
#define TMR_WR_CTRL_OUTMODE(base, value) (TMR_RMW_CTRL(base, TMR_CTRL_OUTMODE_MASK, TMR_CTRL_OUTMODE(value)))
#define TMR_BWR_CTRL_OUTMODE(base, value) (BME_BFI16(&TMR_CTRL_REG(base), ((uint16_t)(value) << TMR_CTRL_OUTMODE_SHIFT), TMR_CTRL_OUTMODE_SHIFT, TMR_CTRL_OUTMODE_WIDTH))
/*@}*/

/*!
 * @name Register TMR_CTRL, field COINIT[3] (RW)
 *
 * This bit enables another counter/timer within the module to force the
 * re-initialization of this counter/timer when it has an active compare event.
 *
 * Values:
 * - 0b0 - Co-channel counter/timers cannot force a re-initialization of this
 *     counter/timer
 * - 0b1 - Co-channel counter/timers may force a re-initialization of this
 *     counter/timer
 */
/*@{*/
/*! @brief Read current value of the TMR_CTRL_COINIT field. */
#define TMR_RD_CTRL_COINIT(base) ((TMR_CTRL_REG(base) & TMR_CTRL_COINIT_MASK) >> TMR_CTRL_COINIT_SHIFT)
#define TMR_BRD_CTRL_COINIT(base) (BME_UBFX16(&TMR_CTRL_REG(base), TMR_CTRL_COINIT_SHIFT, TMR_CTRL_COINIT_WIDTH))

/*! @brief Set the COINIT field to a new value. */
#define TMR_WR_CTRL_COINIT(base, value) (TMR_RMW_CTRL(base, TMR_CTRL_COINIT_MASK, TMR_CTRL_COINIT(value)))
#define TMR_BWR_CTRL_COINIT(base, value) (BME_BFI16(&TMR_CTRL_REG(base), ((uint16_t)(value) << TMR_CTRL_COINIT_SHIFT), TMR_CTRL_COINIT_SHIFT, TMR_CTRL_COINIT_WIDTH))
/*@}*/

/*!
 * @name Register TMR_CTRL, field DIR[4] (RW)
 *
 * This bit selects either the normal count direction up, or the reverse
 * direction, down.
 *
 * Values:
 * - 0b0 - Count up.
 * - 0b1 - Count down.
 */
/*@{*/
/*! @brief Read current value of the TMR_CTRL_DIR field. */
#define TMR_RD_CTRL_DIR(base) ((TMR_CTRL_REG(base) & TMR_CTRL_DIR_MASK) >> TMR_CTRL_DIR_SHIFT)
#define TMR_BRD_CTRL_DIR(base) (BME_UBFX16(&TMR_CTRL_REG(base), TMR_CTRL_DIR_SHIFT, TMR_CTRL_DIR_WIDTH))

/*! @brief Set the DIR field to a new value. */
#define TMR_WR_CTRL_DIR(base, value) (TMR_RMW_CTRL(base, TMR_CTRL_DIR_MASK, TMR_CTRL_DIR(value)))
#define TMR_BWR_CTRL_DIR(base, value) (BME_BFI16(&TMR_CTRL_REG(base), ((uint16_t)(value) << TMR_CTRL_DIR_SHIFT), TMR_CTRL_DIR_SHIFT, TMR_CTRL_DIR_WIDTH))
/*@}*/

/*!
 * @name Register TMR_CTRL, field LENGTH[5] (RW)
 *
 * This bit determines whether the counter: counts to the compare value and then
 * re-initializes itself to the value specified in the LOAD (or CMPLD2)
 * register, or continues counting past the compare value to the binary roll over.
 *
 * Values:
 * - 0b0 - Count until roll over at $FFFF and continue from $0000.
 * - 0b1 - Count until compare, then re-initialize. If counting up, a successful
 *     compare occurs when the counter reaches a COMP1 value. If counting down,
 *     a successful compare occurs when the counter reaches a COMP2 value. When
 *     output mode $4 is used, alternating values of COMP1 and COMP2 are used to
 *     generate successful comparisons. For example, the counter counts until a
 *     COMP1 value is reached, re-initializes, counts until COMP2 value is reached,
 *     re-initializes, counts until COMP1 value is reached, and so on.
 */
/*@{*/
/*! @brief Read current value of the TMR_CTRL_LENGTH field. */
#define TMR_RD_CTRL_LENGTH(base) ((TMR_CTRL_REG(base) & TMR_CTRL_LENGTH_MASK) >> TMR_CTRL_LENGTH_SHIFT)
#define TMR_BRD_CTRL_LENGTH(base) (BME_UBFX16(&TMR_CTRL_REG(base), TMR_CTRL_LENGTH_SHIFT, TMR_CTRL_LENGTH_WIDTH))

/*! @brief Set the LENGTH field to a new value. */
#define TMR_WR_CTRL_LENGTH(base, value) (TMR_RMW_CTRL(base, TMR_CTRL_LENGTH_MASK, TMR_CTRL_LENGTH(value)))
#define TMR_BWR_CTRL_LENGTH(base, value) (BME_BFI16(&TMR_CTRL_REG(base), ((uint16_t)(value) << TMR_CTRL_LENGTH_SHIFT), TMR_CTRL_LENGTH_SHIFT, TMR_CTRL_LENGTH_WIDTH))
/*@}*/

/*!
 * @name Register TMR_CTRL, field ONCE[6] (RW)
 *
 * This bit selects continuous or one shot counting mode.
 *
 * Values:
 * - 0b0 - Count repeatedly.
 * - 0b1 - Count until compare and then stop. If counting up, a successful
 *     compare occurs when the counter reaches a COMP1 value. If counting down, a
 *     successful compare occurs when the counter reaches a COMP2 value. When output
 *     mode $4 is used, the counter re-initializes after reaching the COMP1
 *     value, continues to count to the COMP2 value, and then stops.
 */
/*@{*/
/*! @brief Read current value of the TMR_CTRL_ONCE field. */
#define TMR_RD_CTRL_ONCE(base) ((TMR_CTRL_REG(base) & TMR_CTRL_ONCE_MASK) >> TMR_CTRL_ONCE_SHIFT)
#define TMR_BRD_CTRL_ONCE(base) (BME_UBFX16(&TMR_CTRL_REG(base), TMR_CTRL_ONCE_SHIFT, TMR_CTRL_ONCE_WIDTH))

/*! @brief Set the ONCE field to a new value. */
#define TMR_WR_CTRL_ONCE(base, value) (TMR_RMW_CTRL(base, TMR_CTRL_ONCE_MASK, TMR_CTRL_ONCE(value)))
#define TMR_BWR_CTRL_ONCE(base, value) (BME_BFI16(&TMR_CTRL_REG(base), ((uint16_t)(value) << TMR_CTRL_ONCE_SHIFT), TMR_CTRL_ONCE_SHIFT, TMR_CTRL_ONCE_WIDTH))
/*@}*/

/*!
 * @name Register TMR_CTRL, field SCS[8:7] (RW)
 *
 * These bits identify the external input pin to be used as a count command or
 * timer command. The selected input can trigger the timer to capture the current
 * value of CNTR . The selected input can also be used to specify the count
 * direction. The selected signal can also be used as a fault input when CSCTRL[FAULT]
 * is set. The polarity of the signal can be inverted by SCTRL[IPS].
 *
 * Values:
 * - 0b00 - Counter 0 input pin
 * - 0b01 - Counter 1 input pin
 * - 0b10 - Counter 2 input pin
 * - 0b11 - Counter 3 input pin
 */
/*@{*/
/*! @brief Read current value of the TMR_CTRL_SCS field. */
#define TMR_RD_CTRL_SCS(base) ((TMR_CTRL_REG(base) & TMR_CTRL_SCS_MASK) >> TMR_CTRL_SCS_SHIFT)
#define TMR_BRD_CTRL_SCS(base) (BME_UBFX16(&TMR_CTRL_REG(base), TMR_CTRL_SCS_SHIFT, TMR_CTRL_SCS_WIDTH))

/*! @brief Set the SCS field to a new value. */
#define TMR_WR_CTRL_SCS(base, value) (TMR_RMW_CTRL(base, TMR_CTRL_SCS_MASK, TMR_CTRL_SCS(value)))
#define TMR_BWR_CTRL_SCS(base, value) (BME_BFI16(&TMR_CTRL_REG(base), ((uint16_t)(value) << TMR_CTRL_SCS_SHIFT), TMR_CTRL_SCS_SHIFT, TMR_CTRL_SCS_WIDTH))
/*@}*/

/*!
 * @name Register TMR_CTRL, field PCS[12:9] (RW)
 *
 * These bits select the primary count source. A timer selecting its own output
 * for input is not a legal choice. The result is no counting.
 *
 * Values:
 * - 0b0000 - Counter 0 input pin
 * - 0b0001 - Counter 1 input pin
 * - 0b0010 - Counter 2 input pin
 * - 0b0011 - Counter 3 input pin
 * - 0b0100 - Counter 0 output
 * - 0b0101 - Counter 1 output
 * - 0b0110 - Counter 2 output
 * - 0b0111 - Counter 3 output
 * - 0b1000 - IP bus clock divide by 1 prescaler
 * - 0b1001 - IP bus clock divide by 2 prescaler
 * - 0b1010 - IP bus clock divide by 4 prescaler
 * - 0b1011 - IP bus clock divide by 8 prescaler
 * - 0b1100 - IP bus clock divide by 16 prescaler
 * - 0b1101 - IP bus clock divide by 32 prescaler
 * - 0b1110 - IP bus clock divide by 64 prescaler
 * - 0b1111 - IP bus clock divide by 128 prescaler
 */
/*@{*/
/*! @brief Read current value of the TMR_CTRL_PCS field. */
#define TMR_RD_CTRL_PCS(base) ((TMR_CTRL_REG(base) & TMR_CTRL_PCS_MASK) >> TMR_CTRL_PCS_SHIFT)
#define TMR_BRD_CTRL_PCS(base) (BME_UBFX16(&TMR_CTRL_REG(base), TMR_CTRL_PCS_SHIFT, TMR_CTRL_PCS_WIDTH))

/*! @brief Set the PCS field to a new value. */
#define TMR_WR_CTRL_PCS(base, value) (TMR_RMW_CTRL(base, TMR_CTRL_PCS_MASK, TMR_CTRL_PCS(value)))
#define TMR_BWR_CTRL_PCS(base, value) (BME_BFI16(&TMR_CTRL_REG(base), ((uint16_t)(value) << TMR_CTRL_PCS_SHIFT), TMR_CTRL_PCS_SHIFT, TMR_CTRL_PCS_WIDTH))
/*@}*/

/*!
 * @name Register TMR_CTRL, field CM[15:13] (RW)
 *
 * These bits control the basic counting and behavior of the counter.
 *
 * Values:
 * - 0b000 - No operation
 * - 0b001 - Count rising edges of primary sourceRising edges are counted only
 *     when SCTRL[IPS] = 0. Falling edges are counted when SCTRL[IPS] = 1. If the
 *     primary count source is IP bus clock divide by 1, only rising edges are
 *     counted regardless of the value of SCTRL[IPS].
 * - 0b010 - Count rising and falling edges of primary sourceIP bus clock divide
 *     by 1 cannot be used as a primary count source in edge count mode.
 * - 0b011 - Count rising edges of primary source while secondary input high
 *     active
 * - 0b100 - Quadrature count mode, uses primary and secondary sources
 * - 0b101 - Count rising edges of primary source; secondary source specifies
 *     directionRising edges are counted only when SCTRL[IPS] = 0. Falling edges
 *     are counted when SCTRL[IPS] = 1.
 * - 0b110 - Edge of secondary source triggers primary count until compare
 * - 0b111 - Cascaded counter mode (up/down)The primary count source must be set
 *     to one of the counter outputs.
 */
/*@{*/
/*! @brief Read current value of the TMR_CTRL_CM field. */
#define TMR_RD_CTRL_CM(base) ((TMR_CTRL_REG(base) & TMR_CTRL_CM_MASK) >> TMR_CTRL_CM_SHIFT)
#define TMR_BRD_CTRL_CM(base) (BME_UBFX16(&TMR_CTRL_REG(base), TMR_CTRL_CM_SHIFT, TMR_CTRL_CM_WIDTH))

/*! @brief Set the CM field to a new value. */
#define TMR_WR_CTRL_CM(base, value) (TMR_RMW_CTRL(base, TMR_CTRL_CM_MASK, TMR_CTRL_CM(value)))
#define TMR_BWR_CTRL_CM(base, value) (BME_BFI16(&TMR_CTRL_REG(base), ((uint16_t)(value) << TMR_CTRL_CM_SHIFT), TMR_CTRL_CM_SHIFT, TMR_CTRL_CM_WIDTH))
/*@}*/

/*******************************************************************************
 * TMR_SCTRL - Timer Channel Status and Control Register
 ******************************************************************************/

/*!
 * @brief TMR_SCTRL - Timer Channel Status and Control Register (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire TMR_SCTRL register
 */
/*@{*/
#define TMR_RD_SCTRL(base)       (TMR_SCTRL_REG(base))
#define TMR_WR_SCTRL(base, value) (TMR_SCTRL_REG(base) = (value))
#define TMR_RMW_SCTRL(base, mask, value) (TMR_WR_SCTRL(base, (TMR_RD_SCTRL(base) & ~(mask)) | (value)))
#define TMR_SET_SCTRL(base, value) (BME_OR16(&TMR_SCTRL_REG(base), (uint16_t)(value)))
#define TMR_CLR_SCTRL(base, value) (BME_AND16(&TMR_SCTRL_REG(base), (uint16_t)(~(value))))
#define TMR_TOG_SCTRL(base, value) (BME_XOR16(&TMR_SCTRL_REG(base), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual TMR_SCTRL bitfields
 */

/*!
 * @name Register TMR_SCTRL, field OEN[0] (RW)
 *
 * This bit determines the direction of the external pin.
 *
 * Values:
 * - 0b0 - The external pin is configured as an input.
 * - 0b1 - The OFLAG output signal is driven on the external pin. Other timer
 *     groups using this external pin as their input see the driven value. The
 *     polarity of the signal is determined by OPS.
 */
/*@{*/
/*! @brief Read current value of the TMR_SCTRL_OEN field. */
#define TMR_RD_SCTRL_OEN(base) ((TMR_SCTRL_REG(base) & TMR_SCTRL_OEN_MASK) >> TMR_SCTRL_OEN_SHIFT)
#define TMR_BRD_SCTRL_OEN(base) (BME_UBFX16(&TMR_SCTRL_REG(base), TMR_SCTRL_OEN_SHIFT, TMR_SCTRL_OEN_WIDTH))

/*! @brief Set the OEN field to a new value. */
#define TMR_WR_SCTRL_OEN(base, value) (TMR_RMW_SCTRL(base, TMR_SCTRL_OEN_MASK, TMR_SCTRL_OEN(value)))
#define TMR_BWR_SCTRL_OEN(base, value) (BME_BFI16(&TMR_SCTRL_REG(base), ((uint16_t)(value) << TMR_SCTRL_OEN_SHIFT), TMR_SCTRL_OEN_SHIFT, TMR_SCTRL_OEN_WIDTH))
/*@}*/

/*!
 * @name Register TMR_SCTRL, field OPS[1] (RW)
 *
 * This bit determines the polarity of the OFLAG output signal.
 *
 * Values:
 * - 0b0 - True polarity.
 * - 0b1 - Inverted polarity.
 */
/*@{*/
/*! @brief Read current value of the TMR_SCTRL_OPS field. */
#define TMR_RD_SCTRL_OPS(base) ((TMR_SCTRL_REG(base) & TMR_SCTRL_OPS_MASK) >> TMR_SCTRL_OPS_SHIFT)
#define TMR_BRD_SCTRL_OPS(base) (BME_UBFX16(&TMR_SCTRL_REG(base), TMR_SCTRL_OPS_SHIFT, TMR_SCTRL_OPS_WIDTH))

/*! @brief Set the OPS field to a new value. */
#define TMR_WR_SCTRL_OPS(base, value) (TMR_RMW_SCTRL(base, TMR_SCTRL_OPS_MASK, TMR_SCTRL_OPS(value)))
#define TMR_BWR_SCTRL_OPS(base, value) (BME_BFI16(&TMR_SCTRL_REG(base), ((uint16_t)(value) << TMR_SCTRL_OPS_SHIFT), TMR_SCTRL_OPS_SHIFT, TMR_SCTRL_OPS_WIDTH))
/*@}*/

/*!
 * @name Register TMR_SCTRL, field FORCE[2] (WORZ)
 *
 * This write only bit forces the current value of VAL to be written to the
 * OFLAG output. This bit always reads as a zero. VAL and FORCE can be written
 * simultaneously in a single write operation. Write to FORCE only if the counter is
 * disabled. Setting this bit while the counter is enabled may yield unpredictable
 * results.
 */
/*@{*/
/*! @brief Set the FORCE field to a new value. */
#define TMR_WR_SCTRL_FORCE(base, value) (TMR_RMW_SCTRL(base, TMR_SCTRL_FORCE_MASK, TMR_SCTRL_FORCE(value)))
#define TMR_BWR_SCTRL_FORCE(base, value) (BME_BFI16(&TMR_SCTRL_REG(base), ((uint16_t)(value) << TMR_SCTRL_FORCE_SHIFT), TMR_SCTRL_FORCE_SHIFT, TMR_SCTRL_FORCE_WIDTH))
/*@}*/

/*!
 * @name Register TMR_SCTRL, field VAL[3] (RW)
 *
 * This bit determines the value of the OFLAG output signal when software
 * triggers a FORCE command.
 */
/*@{*/
/*! @brief Read current value of the TMR_SCTRL_VAL field. */
#define TMR_RD_SCTRL_VAL(base) ((TMR_SCTRL_REG(base) & TMR_SCTRL_VAL_MASK) >> TMR_SCTRL_VAL_SHIFT)
#define TMR_BRD_SCTRL_VAL(base) (BME_UBFX16(&TMR_SCTRL_REG(base), TMR_SCTRL_VAL_SHIFT, TMR_SCTRL_VAL_WIDTH))

/*! @brief Set the VAL field to a new value. */
#define TMR_WR_SCTRL_VAL(base, value) (TMR_RMW_SCTRL(base, TMR_SCTRL_VAL_MASK, TMR_SCTRL_VAL(value)))
#define TMR_BWR_SCTRL_VAL(base, value) (BME_BFI16(&TMR_SCTRL_REG(base), ((uint16_t)(value) << TMR_SCTRL_VAL_SHIFT), TMR_SCTRL_VAL_SHIFT, TMR_SCTRL_VAL_WIDTH))
/*@}*/

/*!
 * @name Register TMR_SCTRL, field EEOF[4] (RW)
 *
 * This bit (when set) enables the compare from another counter/timer within the
 * same module to force the state of this counter's OFLAG output signal.
 */
/*@{*/
/*! @brief Read current value of the TMR_SCTRL_EEOF field. */
#define TMR_RD_SCTRL_EEOF(base) ((TMR_SCTRL_REG(base) & TMR_SCTRL_EEOF_MASK) >> TMR_SCTRL_EEOF_SHIFT)
#define TMR_BRD_SCTRL_EEOF(base) (BME_UBFX16(&TMR_SCTRL_REG(base), TMR_SCTRL_EEOF_SHIFT, TMR_SCTRL_EEOF_WIDTH))

/*! @brief Set the EEOF field to a new value. */
#define TMR_WR_SCTRL_EEOF(base, value) (TMR_RMW_SCTRL(base, TMR_SCTRL_EEOF_MASK, TMR_SCTRL_EEOF(value)))
#define TMR_BWR_SCTRL_EEOF(base, value) (BME_BFI16(&TMR_SCTRL_REG(base), ((uint16_t)(value) << TMR_SCTRL_EEOF_SHIFT), TMR_SCTRL_EEOF_SHIFT, TMR_SCTRL_EEOF_WIDTH))
/*@}*/

/*!
 * @name Register TMR_SCTRL, field MSTR[5] (RW)
 *
 * This bit (when set) enables the compare function's output to be broadcasted
 * to the other counters/timers in the module. This signal then can be used to
 * re-initialize the other counters and/or force their OFLAG signal outputs.
 */
/*@{*/
/*! @brief Read current value of the TMR_SCTRL_MSTR field. */
#define TMR_RD_SCTRL_MSTR(base) ((TMR_SCTRL_REG(base) & TMR_SCTRL_MSTR_MASK) >> TMR_SCTRL_MSTR_SHIFT)
#define TMR_BRD_SCTRL_MSTR(base) (BME_UBFX16(&TMR_SCTRL_REG(base), TMR_SCTRL_MSTR_SHIFT, TMR_SCTRL_MSTR_WIDTH))

/*! @brief Set the MSTR field to a new value. */
#define TMR_WR_SCTRL_MSTR(base, value) (TMR_RMW_SCTRL(base, TMR_SCTRL_MSTR_MASK, TMR_SCTRL_MSTR(value)))
#define TMR_BWR_SCTRL_MSTR(base, value) (BME_BFI16(&TMR_SCTRL_REG(base), ((uint16_t)(value) << TMR_SCTRL_MSTR_SHIFT), TMR_SCTRL_MSTR_SHIFT, TMR_SCTRL_MSTR_WIDTH))
/*@}*/

/*!
 * @name Register TMR_SCTRL, field CAPTURE_MODE[7:6] (RW)
 *
 * These bits specify the operation of the capture register as well as the
 * operation of the input edge flag. The input source is the secondary count source.
 *
 * Values:
 * - 0b00 - Capture function is disabled
 * - 0b01 - Load capture register on rising edge (when IPS=0) or falling edge
 *     (when IPS=1) of input
 * - 0b10 - Load capture register on falling edge (when IPS=0) or rising edge
 *     (when IPS=1) of input
 * - 0b11 - Load capture register on both edges of input
 */
/*@{*/
/*! @brief Read current value of the TMR_SCTRL_CAPTURE_MODE field. */
#define TMR_RD_SCTRL_CAPTURE_MODE(base) ((TMR_SCTRL_REG(base) & TMR_SCTRL_CAPTURE_MODE_MASK) >> TMR_SCTRL_CAPTURE_MODE_SHIFT)
#define TMR_BRD_SCTRL_CAPTURE_MODE(base) (BME_UBFX16(&TMR_SCTRL_REG(base), TMR_SCTRL_CAPTURE_MODE_SHIFT, TMR_SCTRL_CAPTURE_MODE_WIDTH))

/*! @brief Set the CAPTURE_MODE field to a new value. */
#define TMR_WR_SCTRL_CAPTURE_MODE(base, value) (TMR_RMW_SCTRL(base, TMR_SCTRL_CAPTURE_MODE_MASK, TMR_SCTRL_CAPTURE_MODE(value)))
#define TMR_BWR_SCTRL_CAPTURE_MODE(base, value) (BME_BFI16(&TMR_SCTRL_REG(base), ((uint16_t)(value) << TMR_SCTRL_CAPTURE_MODE_SHIFT), TMR_SCTRL_CAPTURE_MODE_SHIFT, TMR_SCTRL_CAPTURE_MODE_WIDTH))
/*@}*/

/*!
 * @name Register TMR_SCTRL, field INPUT[8] (RO)
 *
 * This read-only bit reflects the current state of the external input pin
 * selected via the secondary count source after application of IPS and filtering.
 */
/*@{*/
/*! @brief Read current value of the TMR_SCTRL_INPUT field. */
#define TMR_RD_SCTRL_INPUT(base) ((TMR_SCTRL_REG(base) & TMR_SCTRL_INPUT_MASK) >> TMR_SCTRL_INPUT_SHIFT)
#define TMR_BRD_SCTRL_INPUT(base) (BME_UBFX16(&TMR_SCTRL_REG(base), TMR_SCTRL_INPUT_SHIFT, TMR_SCTRL_INPUT_WIDTH))
/*@}*/

/*!
 * @name Register TMR_SCTRL, field IPS[9] (RW)
 *
 * This bit (when set) inverts the input signal polarity.
 */
/*@{*/
/*! @brief Read current value of the TMR_SCTRL_IPS field. */
#define TMR_RD_SCTRL_IPS(base) ((TMR_SCTRL_REG(base) & TMR_SCTRL_IPS_MASK) >> TMR_SCTRL_IPS_SHIFT)
#define TMR_BRD_SCTRL_IPS(base) (BME_UBFX16(&TMR_SCTRL_REG(base), TMR_SCTRL_IPS_SHIFT, TMR_SCTRL_IPS_WIDTH))

/*! @brief Set the IPS field to a new value. */
#define TMR_WR_SCTRL_IPS(base, value) (TMR_RMW_SCTRL(base, TMR_SCTRL_IPS_MASK, TMR_SCTRL_IPS(value)))
#define TMR_BWR_SCTRL_IPS(base, value) (BME_BFI16(&TMR_SCTRL_REG(base), ((uint16_t)(value) << TMR_SCTRL_IPS_SHIFT), TMR_SCTRL_IPS_SHIFT, TMR_SCTRL_IPS_WIDTH))
/*@}*/

/*!
 * @name Register TMR_SCTRL, field IEFIE[10] (RW)
 *
 * This bit (when set) enables interrupts when IEF is set.
 */
/*@{*/
/*! @brief Read current value of the TMR_SCTRL_IEFIE field. */
#define TMR_RD_SCTRL_IEFIE(base) ((TMR_SCTRL_REG(base) & TMR_SCTRL_IEFIE_MASK) >> TMR_SCTRL_IEFIE_SHIFT)
#define TMR_BRD_SCTRL_IEFIE(base) (BME_UBFX16(&TMR_SCTRL_REG(base), TMR_SCTRL_IEFIE_SHIFT, TMR_SCTRL_IEFIE_WIDTH))

/*! @brief Set the IEFIE field to a new value. */
#define TMR_WR_SCTRL_IEFIE(base, value) (TMR_RMW_SCTRL(base, TMR_SCTRL_IEFIE_MASK, TMR_SCTRL_IEFIE(value)))
#define TMR_BWR_SCTRL_IEFIE(base, value) (BME_BFI16(&TMR_SCTRL_REG(base), ((uint16_t)(value) << TMR_SCTRL_IEFIE_SHIFT), TMR_SCTRL_IEFIE_SHIFT, TMR_SCTRL_IEFIE_WIDTH))
/*@}*/

/*!
 * @name Register TMR_SCTRL, field IEF[11] (RW)
 *
 * This bit is set when CAPTMODE is enabled and a proper input transition occurs
 * (on an input selected as a secondary count source) while the count mode does
 * not equal 000. This bit is cleared by writing a zero to this bit position.
 * Setting the input polarity select bit (IPS) changes the edge to be detected.
 * Also, the control register's secondary count source determines which external
 * input pin is monitored by the detection circuitry.
 */
/*@{*/
/*! @brief Read current value of the TMR_SCTRL_IEF field. */
#define TMR_RD_SCTRL_IEF(base) ((TMR_SCTRL_REG(base) & TMR_SCTRL_IEF_MASK) >> TMR_SCTRL_IEF_SHIFT)
#define TMR_BRD_SCTRL_IEF(base) (BME_UBFX16(&TMR_SCTRL_REG(base), TMR_SCTRL_IEF_SHIFT, TMR_SCTRL_IEF_WIDTH))

/*! @brief Set the IEF field to a new value. */
#define TMR_WR_SCTRL_IEF(base, value) (TMR_RMW_SCTRL(base, TMR_SCTRL_IEF_MASK, TMR_SCTRL_IEF(value)))
#define TMR_BWR_SCTRL_IEF(base, value) (BME_BFI16(&TMR_SCTRL_REG(base), ((uint16_t)(value) << TMR_SCTRL_IEF_SHIFT), TMR_SCTRL_IEF_SHIFT, TMR_SCTRL_IEF_WIDTH))
/*@}*/

/*!
 * @name Register TMR_SCTRL, field TOFIE[12] (RW)
 *
 * This bit (when set) enables interrupts when TOF is set.
 */
/*@{*/
/*! @brief Read current value of the TMR_SCTRL_TOFIE field. */
#define TMR_RD_SCTRL_TOFIE(base) ((TMR_SCTRL_REG(base) & TMR_SCTRL_TOFIE_MASK) >> TMR_SCTRL_TOFIE_SHIFT)
#define TMR_BRD_SCTRL_TOFIE(base) (BME_UBFX16(&TMR_SCTRL_REG(base), TMR_SCTRL_TOFIE_SHIFT, TMR_SCTRL_TOFIE_WIDTH))

/*! @brief Set the TOFIE field to a new value. */
#define TMR_WR_SCTRL_TOFIE(base, value) (TMR_RMW_SCTRL(base, TMR_SCTRL_TOFIE_MASK, TMR_SCTRL_TOFIE(value)))
#define TMR_BWR_SCTRL_TOFIE(base, value) (BME_BFI16(&TMR_SCTRL_REG(base), ((uint16_t)(value) << TMR_SCTRL_TOFIE_SHIFT), TMR_SCTRL_TOFIE_SHIFT, TMR_SCTRL_TOFIE_WIDTH))
/*@}*/

/*!
 * @name Register TMR_SCTRL, field TOF[13] (RW)
 *
 * This bit is set when the counter rolls over its maximum value $FFFF or $0000
 * (depending on count direction). This bit is cleared by writing a zero to this
 * bit location.
 */
/*@{*/
/*! @brief Read current value of the TMR_SCTRL_TOF field. */
#define TMR_RD_SCTRL_TOF(base) ((TMR_SCTRL_REG(base) & TMR_SCTRL_TOF_MASK) >> TMR_SCTRL_TOF_SHIFT)
#define TMR_BRD_SCTRL_TOF(base) (BME_UBFX16(&TMR_SCTRL_REG(base), TMR_SCTRL_TOF_SHIFT, TMR_SCTRL_TOF_WIDTH))

/*! @brief Set the TOF field to a new value. */
#define TMR_WR_SCTRL_TOF(base, value) (TMR_RMW_SCTRL(base, TMR_SCTRL_TOF_MASK, TMR_SCTRL_TOF(value)))
#define TMR_BWR_SCTRL_TOF(base, value) (BME_BFI16(&TMR_SCTRL_REG(base), ((uint16_t)(value) << TMR_SCTRL_TOF_SHIFT), TMR_SCTRL_TOF_SHIFT, TMR_SCTRL_TOF_WIDTH))
/*@}*/

/*!
 * @name Register TMR_SCTRL, field TCFIE[14] (RW)
 *
 * This bit (when set) enables interrupts when TCF is set.
 */
/*@{*/
/*! @brief Read current value of the TMR_SCTRL_TCFIE field. */
#define TMR_RD_SCTRL_TCFIE(base) ((TMR_SCTRL_REG(base) & TMR_SCTRL_TCFIE_MASK) >> TMR_SCTRL_TCFIE_SHIFT)
#define TMR_BRD_SCTRL_TCFIE(base) (BME_UBFX16(&TMR_SCTRL_REG(base), TMR_SCTRL_TCFIE_SHIFT, TMR_SCTRL_TCFIE_WIDTH))

/*! @brief Set the TCFIE field to a new value. */
#define TMR_WR_SCTRL_TCFIE(base, value) (TMR_RMW_SCTRL(base, TMR_SCTRL_TCFIE_MASK, TMR_SCTRL_TCFIE(value)))
#define TMR_BWR_SCTRL_TCFIE(base, value) (BME_BFI16(&TMR_SCTRL_REG(base), ((uint16_t)(value) << TMR_SCTRL_TCFIE_SHIFT), TMR_SCTRL_TCFIE_SHIFT, TMR_SCTRL_TCFIE_WIDTH))
/*@}*/

/*!
 * @name Register TMR_SCTRL, field TCF[15] (RW)
 *
 * This bit is set when a successful compare occurs. This bit is cleared by
 * writing a zero to this bit location.
 */
/*@{*/
/*! @brief Read current value of the TMR_SCTRL_TCF field. */
#define TMR_RD_SCTRL_TCF(base) ((TMR_SCTRL_REG(base) & TMR_SCTRL_TCF_MASK) >> TMR_SCTRL_TCF_SHIFT)
#define TMR_BRD_SCTRL_TCF(base) (BME_UBFX16(&TMR_SCTRL_REG(base), TMR_SCTRL_TCF_SHIFT, TMR_SCTRL_TCF_WIDTH))

/*! @brief Set the TCF field to a new value. */
#define TMR_WR_SCTRL_TCF(base, value) (TMR_RMW_SCTRL(base, TMR_SCTRL_TCF_MASK, TMR_SCTRL_TCF(value)))
#define TMR_BWR_SCTRL_TCF(base, value) (BME_BFI16(&TMR_SCTRL_REG(base), ((uint16_t)(value) << TMR_SCTRL_TCF_SHIFT), TMR_SCTRL_TCF_SHIFT, TMR_SCTRL_TCF_WIDTH))
/*@}*/

/*******************************************************************************
 * TMR_CMPLD1 - Timer Channel Comparator Load Register 1
 ******************************************************************************/

/*!
 * @brief TMR_CMPLD1 - Timer Channel Comparator Load Register 1 (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire TMR_CMPLD1 register
 */
/*@{*/
#define TMR_RD_CMPLD1(base)      (TMR_CMPLD1_REG(base))
#define TMR_WR_CMPLD1(base, value) (TMR_CMPLD1_REG(base) = (value))
#define TMR_RMW_CMPLD1(base, mask, value) (TMR_WR_CMPLD1(base, (TMR_RD_CMPLD1(base) & ~(mask)) | (value)))
#define TMR_SET_CMPLD1(base, value) (BME_OR16(&TMR_CMPLD1_REG(base), (uint16_t)(value)))
#define TMR_CLR_CMPLD1(base, value) (BME_AND16(&TMR_CMPLD1_REG(base), (uint16_t)(~(value))))
#define TMR_TOG_CMPLD1(base, value) (BME_XOR16(&TMR_CMPLD1_REG(base), (uint16_t)(value)))
/*@}*/

/*******************************************************************************
 * TMR_CMPLD2 - Timer Channel Comparator Load Register 2
 ******************************************************************************/

/*!
 * @brief TMR_CMPLD2 - Timer Channel Comparator Load Register 2 (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire TMR_CMPLD2 register
 */
/*@{*/
#define TMR_RD_CMPLD2(base)      (TMR_CMPLD2_REG(base))
#define TMR_WR_CMPLD2(base, value) (TMR_CMPLD2_REG(base) = (value))
#define TMR_RMW_CMPLD2(base, mask, value) (TMR_WR_CMPLD2(base, (TMR_RD_CMPLD2(base) & ~(mask)) | (value)))
#define TMR_SET_CMPLD2(base, value) (BME_OR16(&TMR_CMPLD2_REG(base), (uint16_t)(value)))
#define TMR_CLR_CMPLD2(base, value) (BME_AND16(&TMR_CMPLD2_REG(base), (uint16_t)(~(value))))
#define TMR_TOG_CMPLD2(base, value) (BME_XOR16(&TMR_CMPLD2_REG(base), (uint16_t)(value)))
/*@}*/

/*******************************************************************************
 * TMR_CSCTRL - Timer Channel Comparator Status and Control Register
 ******************************************************************************/

/*!
 * @brief TMR_CSCTRL - Timer Channel Comparator Status and Control Register (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire TMR_CSCTRL register
 */
/*@{*/
#define TMR_RD_CSCTRL(base)      (TMR_CSCTRL_REG(base))
#define TMR_WR_CSCTRL(base, value) (TMR_CSCTRL_REG(base) = (value))
#define TMR_RMW_CSCTRL(base, mask, value) (TMR_WR_CSCTRL(base, (TMR_RD_CSCTRL(base) & ~(mask)) | (value)))
#define TMR_SET_CSCTRL(base, value) (BME_OR16(&TMR_CSCTRL_REG(base), (uint16_t)(value)))
#define TMR_CLR_CSCTRL(base, value) (BME_AND16(&TMR_CSCTRL_REG(base), (uint16_t)(~(value))))
#define TMR_TOG_CSCTRL(base, value) (BME_XOR16(&TMR_CSCTRL_REG(base), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual TMR_CSCTRL bitfields
 */

/*!
 * @name Register TMR_CSCTRL, field CL1[1:0] (RW)
 *
 * These bits control when COMP1 is preloaded with the value from CMPLD1.
 *
 * Values:
 * - 0b00 - Never preload
 * - 0b01 - Load upon successful compare with the value in COMP1
 * - 0b10 - Load upon successful compare with the value in COMP2
 * - 0b11 - Reserved
 */
/*@{*/
/*! @brief Read current value of the TMR_CSCTRL_CL1 field. */
#define TMR_RD_CSCTRL_CL1(base) ((TMR_CSCTRL_REG(base) & TMR_CSCTRL_CL1_MASK) >> TMR_CSCTRL_CL1_SHIFT)
#define TMR_BRD_CSCTRL_CL1(base) (BME_UBFX16(&TMR_CSCTRL_REG(base), TMR_CSCTRL_CL1_SHIFT, TMR_CSCTRL_CL1_WIDTH))

/*! @brief Set the CL1 field to a new value. */
#define TMR_WR_CSCTRL_CL1(base, value) (TMR_RMW_CSCTRL(base, TMR_CSCTRL_CL1_MASK, TMR_CSCTRL_CL1(value)))
#define TMR_BWR_CSCTRL_CL1(base, value) (BME_BFI16(&TMR_CSCTRL_REG(base), ((uint16_t)(value) << TMR_CSCTRL_CL1_SHIFT), TMR_CSCTRL_CL1_SHIFT, TMR_CSCTRL_CL1_WIDTH))
/*@}*/

/*!
 * @name Register TMR_CSCTRL, field CL2[3:2] (RW)
 *
 * These bits control when COMP2 is preloaded with the value from CMPLD2.
 *
 * Values:
 * - 0b00 - Never preload
 * - 0b01 - Load upon successful compare with the value in COMP1
 * - 0b10 - Load upon successful compare with the value in COMP2
 * - 0b11 - Reserved
 */
/*@{*/
/*! @brief Read current value of the TMR_CSCTRL_CL2 field. */
#define TMR_RD_CSCTRL_CL2(base) ((TMR_CSCTRL_REG(base) & TMR_CSCTRL_CL2_MASK) >> TMR_CSCTRL_CL2_SHIFT)
#define TMR_BRD_CSCTRL_CL2(base) (BME_UBFX16(&TMR_CSCTRL_REG(base), TMR_CSCTRL_CL2_SHIFT, TMR_CSCTRL_CL2_WIDTH))

/*! @brief Set the CL2 field to a new value. */
#define TMR_WR_CSCTRL_CL2(base, value) (TMR_RMW_CSCTRL(base, TMR_CSCTRL_CL2_MASK, TMR_CSCTRL_CL2(value)))
#define TMR_BWR_CSCTRL_CL2(base, value) (BME_BFI16(&TMR_CSCTRL_REG(base), ((uint16_t)(value) << TMR_CSCTRL_CL2_SHIFT), TMR_CSCTRL_CL2_SHIFT, TMR_CSCTRL_CL2_WIDTH))
/*@}*/

/*!
 * @name Register TMR_CSCTRL, field TCF1[4] (RW)
 *
 * When set, this bit indicates a successful comparison of the timer and the the
 * COMP1 register has occurred. This bit is sticky, and will remain set until
 * explicitly cleared by writing a zero to this bit location.
 */
/*@{*/
/*! @brief Read current value of the TMR_CSCTRL_TCF1 field. */
#define TMR_RD_CSCTRL_TCF1(base) ((TMR_CSCTRL_REG(base) & TMR_CSCTRL_TCF1_MASK) >> TMR_CSCTRL_TCF1_SHIFT)
#define TMR_BRD_CSCTRL_TCF1(base) (BME_UBFX16(&TMR_CSCTRL_REG(base), TMR_CSCTRL_TCF1_SHIFT, TMR_CSCTRL_TCF1_WIDTH))

/*! @brief Set the TCF1 field to a new value. */
#define TMR_WR_CSCTRL_TCF1(base, value) (TMR_RMW_CSCTRL(base, TMR_CSCTRL_TCF1_MASK, TMR_CSCTRL_TCF1(value)))
#define TMR_BWR_CSCTRL_TCF1(base, value) (BME_BFI16(&TMR_CSCTRL_REG(base), ((uint16_t)(value) << TMR_CSCTRL_TCF1_SHIFT), TMR_CSCTRL_TCF1_SHIFT, TMR_CSCTRL_TCF1_WIDTH))
/*@}*/

/*!
 * @name Register TMR_CSCTRL, field TCF2[5] (RW)
 *
 * When set, this bit indicates a successful comparison of the timer and the the
 * COMP2 register has occurred. This bit is sticky, and will remain set until
 * explicitly cleared by writing a zero to this bit location.
 */
/*@{*/
/*! @brief Read current value of the TMR_CSCTRL_TCF2 field. */
#define TMR_RD_CSCTRL_TCF2(base) ((TMR_CSCTRL_REG(base) & TMR_CSCTRL_TCF2_MASK) >> TMR_CSCTRL_TCF2_SHIFT)
#define TMR_BRD_CSCTRL_TCF2(base) (BME_UBFX16(&TMR_CSCTRL_REG(base), TMR_CSCTRL_TCF2_SHIFT, TMR_CSCTRL_TCF2_WIDTH))

/*! @brief Set the TCF2 field to a new value. */
#define TMR_WR_CSCTRL_TCF2(base, value) (TMR_RMW_CSCTRL(base, TMR_CSCTRL_TCF2_MASK, TMR_CSCTRL_TCF2(value)))
#define TMR_BWR_CSCTRL_TCF2(base, value) (BME_BFI16(&TMR_CSCTRL_REG(base), ((uint16_t)(value) << TMR_CSCTRL_TCF2_SHIFT), TMR_CSCTRL_TCF2_SHIFT, TMR_CSCTRL_TCF2_WIDTH))
/*@}*/

/*!
 * @name Register TMR_CSCTRL, field TCF1EN[6] (RW)
 *
 * An interrupt is issued when both this bit and TCF1 are set.
 */
/*@{*/
/*! @brief Read current value of the TMR_CSCTRL_TCF1EN field. */
#define TMR_RD_CSCTRL_TCF1EN(base) ((TMR_CSCTRL_REG(base) & TMR_CSCTRL_TCF1EN_MASK) >> TMR_CSCTRL_TCF1EN_SHIFT)
#define TMR_BRD_CSCTRL_TCF1EN(base) (BME_UBFX16(&TMR_CSCTRL_REG(base), TMR_CSCTRL_TCF1EN_SHIFT, TMR_CSCTRL_TCF1EN_WIDTH))

/*! @brief Set the TCF1EN field to a new value. */
#define TMR_WR_CSCTRL_TCF1EN(base, value) (TMR_RMW_CSCTRL(base, TMR_CSCTRL_TCF1EN_MASK, TMR_CSCTRL_TCF1EN(value)))
#define TMR_BWR_CSCTRL_TCF1EN(base, value) (BME_BFI16(&TMR_CSCTRL_REG(base), ((uint16_t)(value) << TMR_CSCTRL_TCF1EN_SHIFT), TMR_CSCTRL_TCF1EN_SHIFT, TMR_CSCTRL_TCF1EN_WIDTH))
/*@}*/

/*!
 * @name Register TMR_CSCTRL, field TCF2EN[7] (RW)
 *
 * An interrupt is issued when both this bit and TCF2 are set.
 */
/*@{*/
/*! @brief Read current value of the TMR_CSCTRL_TCF2EN field. */
#define TMR_RD_CSCTRL_TCF2EN(base) ((TMR_CSCTRL_REG(base) & TMR_CSCTRL_TCF2EN_MASK) >> TMR_CSCTRL_TCF2EN_SHIFT)
#define TMR_BRD_CSCTRL_TCF2EN(base) (BME_UBFX16(&TMR_CSCTRL_REG(base), TMR_CSCTRL_TCF2EN_SHIFT, TMR_CSCTRL_TCF2EN_WIDTH))

/*! @brief Set the TCF2EN field to a new value. */
#define TMR_WR_CSCTRL_TCF2EN(base, value) (TMR_RMW_CSCTRL(base, TMR_CSCTRL_TCF2EN_MASK, TMR_CSCTRL_TCF2EN(value)))
#define TMR_BWR_CSCTRL_TCF2EN(base, value) (BME_BFI16(&TMR_CSCTRL_REG(base), ((uint16_t)(value) << TMR_CSCTRL_TCF2EN_SHIFT), TMR_CSCTRL_TCF2EN_SHIFT, TMR_CSCTRL_TCF2EN_WIDTH))
/*@}*/

/*!
 * @name Register TMR_CSCTRL, field OFLAG[8] (RO)
 *
 * This read only bit shows the state of the Timer's internal OFLAG signal prior
 * to consideration of polarity or debug mode.
 */
/*@{*/
/*! @brief Read current value of the TMR_CSCTRL_OFLAG field. */
#define TMR_RD_CSCTRL_OFLAG(base) ((TMR_CSCTRL_REG(base) & TMR_CSCTRL_OFLAG_MASK) >> TMR_CSCTRL_OFLAG_SHIFT)
#define TMR_BRD_CSCTRL_OFLAG(base) (BME_UBFX16(&TMR_CSCTRL_REG(base), TMR_CSCTRL_OFLAG_SHIFT, TMR_CSCTRL_OFLAG_WIDTH))
/*@}*/

/*!
 * @name Register TMR_CSCTRL, field UP[9] (RO)
 *
 * This read-only bit is used during quadrature count mode, CTRL[CM] = 100, to
 * read the direction of the last count. CTRL[DIR] reverses the sense of this bit.
 *
 * Values:
 * - 0b0 - The last count was in the DOWN direction.
 * - 0b1 - The last count was in the UP direction.
 */
/*@{*/
/*! @brief Read current value of the TMR_CSCTRL_UP field. */
#define TMR_RD_CSCTRL_UP(base) ((TMR_CSCTRL_REG(base) & TMR_CSCTRL_UP_MASK) >> TMR_CSCTRL_UP_SHIFT)
#define TMR_BRD_CSCTRL_UP(base) (BME_UBFX16(&TMR_CSCTRL_REG(base), TMR_CSCTRL_UP_SHIFT, TMR_CSCTRL_UP_WIDTH))
/*@}*/

/*!
 * @name Register TMR_CSCTRL, field TCI[10] (RW)
 *
 * This bit is used during triggered count mode, CTRL[CM] = 110, to enable the
 * counter to be re-initialized when a second trigger occurs while the counter is
 * still counting. Normally, the second trigger causes the counting to stop/pause
 * until a third trigger occurs. With this bit set, a second trigger event
 * causes the counter to re-initialize and continue counting.
 *
 * Values:
 * - 0b0 - Stop counter upon receiving a second trigger event while still
 *     counting from the first trigger event.
 * - 0b1 - Reload the counter upon receiving a second trigger event while still
 *     counting from the first trigger event.
 */
/*@{*/
/*! @brief Read current value of the TMR_CSCTRL_TCI field. */
#define TMR_RD_CSCTRL_TCI(base) ((TMR_CSCTRL_REG(base) & TMR_CSCTRL_TCI_MASK) >> TMR_CSCTRL_TCI_SHIFT)
#define TMR_BRD_CSCTRL_TCI(base) (BME_UBFX16(&TMR_CSCTRL_REG(base), TMR_CSCTRL_TCI_SHIFT, TMR_CSCTRL_TCI_WIDTH))

/*! @brief Set the TCI field to a new value. */
#define TMR_WR_CSCTRL_TCI(base, value) (TMR_RMW_CSCTRL(base, TMR_CSCTRL_TCI_MASK, TMR_CSCTRL_TCI(value)))
#define TMR_BWR_CSCTRL_TCI(base, value) (BME_BFI16(&TMR_CSCTRL_REG(base), ((uint16_t)(value) << TMR_CSCTRL_TCI_SHIFT), TMR_CSCTRL_TCI_SHIFT, TMR_CSCTRL_TCI_WIDTH))
/*@}*/

/*!
 * @name Register TMR_CSCTRL, field ROC[11] (RW)
 *
 * This bit enables the capture function to cause the counter to be reloaded
 * from the LOAD register.
 *
 * Values:
 * - 0b0 - Do not reload the counter on a capture event.
 * - 0b1 - Reload the counter on a capture event.
 */
/*@{*/
/*! @brief Read current value of the TMR_CSCTRL_ROC field. */
#define TMR_RD_CSCTRL_ROC(base) ((TMR_CSCTRL_REG(base) & TMR_CSCTRL_ROC_MASK) >> TMR_CSCTRL_ROC_SHIFT)
#define TMR_BRD_CSCTRL_ROC(base) (BME_UBFX16(&TMR_CSCTRL_REG(base), TMR_CSCTRL_ROC_SHIFT, TMR_CSCTRL_ROC_WIDTH))

/*! @brief Set the ROC field to a new value. */
#define TMR_WR_CSCTRL_ROC(base, value) (TMR_RMW_CSCTRL(base, TMR_CSCTRL_ROC_MASK, TMR_CSCTRL_ROC(value)))
#define TMR_BWR_CSCTRL_ROC(base, value) (BME_BFI16(&TMR_CSCTRL_REG(base), ((uint16_t)(value) << TMR_CSCTRL_ROC_SHIFT), TMR_CSCTRL_ROC_SHIFT, TMR_CSCTRL_ROC_WIDTH))
/*@}*/

/*!
 * @name Register TMR_CSCTRL, field ALT_LOAD[12] (RW)
 *
 * This bit allows for an alternative method for loading the counter during
 * modulo counting. Normally, the counter can be loaded only with the value from the
 * LOAD register. When this bit is set, the counter is loaded from the LOAD
 * register when counting up and a match with COMP1 occurs, or the counter is loaded
 * from the CMPLD2 register when counting down and a match with COMP2 occurs.
 *
 * Values:
 * - 0b0 - Counter can be re-initialized only with the LOAD register.
 * - 0b1 - Counter can be re-initialized with the LOAD or CMPLD2 registers
 *     depending on count direction.
 */
/*@{*/
/*! @brief Read current value of the TMR_CSCTRL_ALT_LOAD field. */
#define TMR_RD_CSCTRL_ALT_LOAD(base) ((TMR_CSCTRL_REG(base) & TMR_CSCTRL_ALT_LOAD_MASK) >> TMR_CSCTRL_ALT_LOAD_SHIFT)
#define TMR_BRD_CSCTRL_ALT_LOAD(base) (BME_UBFX16(&TMR_CSCTRL_REG(base), TMR_CSCTRL_ALT_LOAD_SHIFT, TMR_CSCTRL_ALT_LOAD_WIDTH))

/*! @brief Set the ALT_LOAD field to a new value. */
#define TMR_WR_CSCTRL_ALT_LOAD(base, value) (TMR_RMW_CSCTRL(base, TMR_CSCTRL_ALT_LOAD_MASK, TMR_CSCTRL_ALT_LOAD(value)))
#define TMR_BWR_CSCTRL_ALT_LOAD(base, value) (BME_BFI16(&TMR_CSCTRL_REG(base), ((uint16_t)(value) << TMR_CSCTRL_ALT_LOAD_SHIFT), TMR_CSCTRL_ALT_LOAD_SHIFT, TMR_CSCTRL_ALT_LOAD_WIDTH))
/*@}*/

/*!
 * @name Register TMR_CSCTRL, field FAULT[13] (RW)
 *
 * The selected secondary input acts as a fault signal so that the timer OFLAG
 * is cleared when the secondary input is set. When the secondary input is used in
 * this mode, there is no resynchronization of the input so that there is a
 * combinational path to clear the OFLAG. Fault inputs less than two clock periods
 * wide will not be latched. Latched faults will be cleared the next time that the
 * counter logic sets the OFLAG.
 *
 * Values:
 * - 0b0 - Fault function disabled.
 * - 0b1 - Fault function enabled.
 */
/*@{*/
/*! @brief Read current value of the TMR_CSCTRL_FAULT field. */
#define TMR_RD_CSCTRL_FAULT(base) ((TMR_CSCTRL_REG(base) & TMR_CSCTRL_FAULT_MASK) >> TMR_CSCTRL_FAULT_SHIFT)
#define TMR_BRD_CSCTRL_FAULT(base) (BME_UBFX16(&TMR_CSCTRL_REG(base), TMR_CSCTRL_FAULT_SHIFT, TMR_CSCTRL_FAULT_WIDTH))

/*! @brief Set the FAULT field to a new value. */
#define TMR_WR_CSCTRL_FAULT(base, value) (TMR_RMW_CSCTRL(base, TMR_CSCTRL_FAULT_MASK, TMR_CSCTRL_FAULT(value)))
#define TMR_BWR_CSCTRL_FAULT(base, value) (BME_BFI16(&TMR_CSCTRL_REG(base), ((uint16_t)(value) << TMR_CSCTRL_FAULT_SHIFT), TMR_CSCTRL_FAULT_SHIFT, TMR_CSCTRL_FAULT_WIDTH))
/*@}*/

/*!
 * @name Register TMR_CSCTRL, field DBG_EN[15:14] (RW)
 *
 * These bits allow the TMR module to perform certain actions in response to the
 * chip entering debug mode.
 *
 * Values:
 * - 0b00 - Continue with normal operation during debug mode. (default)
 * - 0b01 - Halt TMR counter during debug mode.
 * - 0b10 - Force TMR output to logic 0 (prior to consideration of SCTRL[OPS]).
 * - 0b11 - Both halt counter and force output to 0 during debug mode.
 */
/*@{*/
/*! @brief Read current value of the TMR_CSCTRL_DBG_EN field. */
#define TMR_RD_CSCTRL_DBG_EN(base) ((TMR_CSCTRL_REG(base) & TMR_CSCTRL_DBG_EN_MASK) >> TMR_CSCTRL_DBG_EN_SHIFT)
#define TMR_BRD_CSCTRL_DBG_EN(base) (BME_UBFX16(&TMR_CSCTRL_REG(base), TMR_CSCTRL_DBG_EN_SHIFT, TMR_CSCTRL_DBG_EN_WIDTH))

/*! @brief Set the DBG_EN field to a new value. */
#define TMR_WR_CSCTRL_DBG_EN(base, value) (TMR_RMW_CSCTRL(base, TMR_CSCTRL_DBG_EN_MASK, TMR_CSCTRL_DBG_EN(value)))
#define TMR_BWR_CSCTRL_DBG_EN(base, value) (BME_BFI16(&TMR_CSCTRL_REG(base), ((uint16_t)(value) << TMR_CSCTRL_DBG_EN_SHIFT), TMR_CSCTRL_DBG_EN_SHIFT, TMR_CSCTRL_DBG_EN_WIDTH))
/*@}*/

/*******************************************************************************
 * TMR_FILT - Timer Channel Input Filter Register
 ******************************************************************************/

/*!
 * @brief TMR_FILT - Timer Channel Input Filter Register (RW)
 *
 * Reset value: 0x0000U
 *
 * The FILT register programs the values for the filtering of the corresponding
 * input without regard for the fact that any timer channel can use the input as
 * a count source. Input filter considerations: Set the FILT_PER value such that
 * the sampling period is larger than the period of the expected noise. In this
 * way, a noise spike will corrupt only one sample. Choose the FILT_CNT value to
 * reduce the probability that noisy samples cause an incorrect transition to be
 * recognized. The probability of an incorrect transistion is defined as the
 * probability of an incorrect sample raised to the power of (FILT_CNT + 3). The
 * values of FILT_PER and FILT_CNT must also be balanced against the desire for
 * minimal latency in recognizing input transitions. Turning on the input filter
 * (setting FILT_PER to a non-zero value) introduces a latency of (((FILT_CNT + 3) x
 * FILT_PER) + 2) IP bus clock periods.
 */
/*!
 * @name Constants and macros for entire TMR_FILT register
 */
/*@{*/
#define TMR_RD_FILT(base)        (TMR_FILT_REG(base))
#define TMR_WR_FILT(base, value) (TMR_FILT_REG(base) = (value))
#define TMR_RMW_FILT(base, mask, value) (TMR_WR_FILT(base, (TMR_RD_FILT(base) & ~(mask)) | (value)))
#define TMR_SET_FILT(base, value) (BME_OR16(&TMR_FILT_REG(base), (uint16_t)(value)))
#define TMR_CLR_FILT(base, value) (BME_AND16(&TMR_FILT_REG(base), (uint16_t)(~(value))))
#define TMR_TOG_FILT(base, value) (BME_XOR16(&TMR_FILT_REG(base), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual TMR_FILT bitfields
 */

/*!
 * @name Register TMR_FILT, field FILT_PER[7:0] (RW)
 *
 * These bits represent the sampling period (in IP bus clock cycles) of the TMR
 * input signals. Each input is sampled multiple times at the rate specified by
 * this field. If FILT_PER is 0x00 (default), then the input filter is bypassed.
 * The value of FILT_PER affects the input latency. When changing values for
 * FILT_PER from one non-zero value to another non-zero value, write a value of zero
 * first to clear the filter.
 */
/*@{*/
/*! @brief Read current value of the TMR_FILT_FILT_PER field. */
#define TMR_RD_FILT_FILT_PER(base) ((TMR_FILT_REG(base) & TMR_FILT_FILT_PER_MASK) >> TMR_FILT_FILT_PER_SHIFT)
#define TMR_BRD_FILT_FILT_PER(base) (BME_UBFX16(&TMR_FILT_REG(base), TMR_FILT_FILT_PER_SHIFT, TMR_FILT_FILT_PER_WIDTH))

/*! @brief Set the FILT_PER field to a new value. */
#define TMR_WR_FILT_FILT_PER(base, value) (TMR_RMW_FILT(base, TMR_FILT_FILT_PER_MASK, TMR_FILT_FILT_PER(value)))
#define TMR_BWR_FILT_FILT_PER(base, value) (BME_BFI16(&TMR_FILT_REG(base), ((uint16_t)(value) << TMR_FILT_FILT_PER_SHIFT), TMR_FILT_FILT_PER_SHIFT, TMR_FILT_FILT_PER_WIDTH))
/*@}*/

/*!
 * @name Register TMR_FILT, field FILT_CNT[10:8] (RW)
 *
 * These bits represent the number of consecutive samples that must agree prior
 * to the input filter accepting an input transition. A value of 0x0 represents 3
 * samples. A value of 0x7 represents 10 samples. The value of FILT_CNT affects
 * the input latency.
 */
/*@{*/
/*! @brief Read current value of the TMR_FILT_FILT_CNT field. */
#define TMR_RD_FILT_FILT_CNT(base) ((TMR_FILT_REG(base) & TMR_FILT_FILT_CNT_MASK) >> TMR_FILT_FILT_CNT_SHIFT)
#define TMR_BRD_FILT_FILT_CNT(base) (BME_UBFX16(&TMR_FILT_REG(base), TMR_FILT_FILT_CNT_SHIFT, TMR_FILT_FILT_CNT_WIDTH))

/*! @brief Set the FILT_CNT field to a new value. */
#define TMR_WR_FILT_FILT_CNT(base, value) (TMR_RMW_FILT(base, TMR_FILT_FILT_CNT_MASK, TMR_FILT_FILT_CNT(value)))
#define TMR_BWR_FILT_FILT_CNT(base, value) (BME_BFI16(&TMR_FILT_REG(base), ((uint16_t)(value) << TMR_FILT_FILT_CNT_SHIFT), TMR_FILT_FILT_CNT_SHIFT, TMR_FILT_FILT_CNT_WIDTH))
/*@}*/

/*******************************************************************************
 * TMR_ENBL - Timer Channel Enable Register
 ******************************************************************************/

/*!
 * @brief TMR_ENBL - Timer Channel Enable Register (RW)
 *
 * Reset value: 0x000FU
 */
/*!
 * @name Constants and macros for entire TMR_ENBL register
 */
/*@{*/
#define TMR_RD_ENBL(base)        (TMR_ENBL_REG(base))
#define TMR_WR_ENBL(base, value) (TMR_ENBL_REG(base) = (value))
#define TMR_RMW_ENBL(base, mask, value) (TMR_WR_ENBL(base, (TMR_RD_ENBL(base) & ~(mask)) | (value)))
#define TMR_SET_ENBL(base, value) (BME_OR16(&TMR_ENBL_REG(base), (uint16_t)(value)))
#define TMR_CLR_ENBL(base, value) (BME_AND16(&TMR_ENBL_REG(base), (uint16_t)(~(value))))
#define TMR_TOG_ENBL(base, value) (BME_XOR16(&TMR_ENBL_REG(base), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual TMR_ENBL bitfields
 */

/*!
 * @name Register TMR_ENBL, field ENBL[3:0] (RW)
 *
 * These bits enable the prescaler (if it is being used) and counter in each
 * channel. Multiple ENBL bits can be set at the same time to synchronize the start
 * of separate counters. If an ENBL bit is set, then the corresponding channel
 * starts its counter as soon as the CTRL[CM] field has a value other than 0. When
 * an ENBL bit is clear, the corresponding counter maintains its current value.
 *
 * Values:
 * - 0b0000 - Timer channel is disabled.
 * - 0b0001 - Timer channel is enabled. (default)
 */
/*@{*/
/*! @brief Read current value of the TMR_ENBL_ENBL field. */
#define TMR_RD_ENBL_ENBL(base) ((TMR_ENBL_REG(base) & TMR_ENBL_ENBL_MASK) >> TMR_ENBL_ENBL_SHIFT)
#define TMR_BRD_ENBL_ENBL(base) (BME_UBFX16(&TMR_ENBL_REG(base), TMR_ENBL_ENBL_SHIFT, TMR_ENBL_ENBL_WIDTH))

/*! @brief Set the ENBL field to a new value. */
#define TMR_WR_ENBL_ENBL(base, value) (TMR_RMW_ENBL(base, TMR_ENBL_ENBL_MASK, TMR_ENBL_ENBL(value)))
#define TMR_BWR_ENBL_ENBL(base, value) (BME_BFI16(&TMR_ENBL_REG(base), ((uint16_t)(value) << TMR_ENBL_ENBL_SHIFT), TMR_ENBL_ENBL_SHIFT, TMR_ENBL_ENBL_WIDTH))
/*@}*/

/*
 * MKM34Z7 UART
 *
 * Serial Communication Interface
 *
 * Registers defined in this header file:
 * - UART_BDH - UART Baud Rate Registers: High
 * - UART_BDL - UART Baud Rate Registers: Low
 * - UART_C1 - UART Control Register 1
 * - UART_C2 - UART Control Register 2
 * - UART_S1 - UART Status Register 1
 * - UART_S2 - UART Status Register 2
 * - UART_C3 - UART Control Register 3
 * - UART_D - UART Data Register
 * - UART_MA1 - UART Match Address Registers 1
 * - UART_MA2 - UART Match Address Registers 2
 * - UART_C4 - UART Control Register 4
 * - UART_C5 - UART Control Register 5
 * - UART_ED - UART Extended Data Register
 * - UART_MODEM - UART Modem Register
 * - UART_PFIFO - UART FIFO Parameters
 * - UART_CFIFO - UART FIFO Control Register
 * - UART_SFIFO - UART FIFO Status Register
 * - UART_TWFIFO - UART FIFO Transmit Watermark
 * - UART_TCFIFO - UART FIFO Transmit Count
 * - UART_RWFIFO - UART FIFO Receive Watermark
 * - UART_RCFIFO - UART FIFO Receive Count
 * - UART_C7816 - UART 7816 Control Register
 * - UART_IE7816 - UART 7816 Interrupt Enable Register
 * - UART_IS7816 - UART 7816 Interrupt Status Register
 * - UART_WP7816 - UART 7816 Wait Parameter Register
 * - UART_WN7816 - UART 7816 Wait N Register
 * - UART_WF7816 - UART 7816 Wait FD Register
 * - UART_ET7816 - UART 7816 Error Threshold Register
 * - UART_TL7816 - UART 7816 Transmit Length Register
 * - UART_AP7816A_T0 - UART 7816 ATR Duration Timer Register A
 * - UART_AP7816B_T0 - UART 7816 ATR Duration Timer Register B
 * - UART_WP7816A_T0 - UART 7816 Wait Parameter Register A
 * - UART_WP7816B_T0 - UART 7816 Wait Parameter Register B
 * - UART_WP7816A_T1 - UART 7816 Wait Parameter Register A
 * - UART_WP7816B_T1 - UART 7816 Wait Parameter Register B
 * - UART_WGP7816_T1 - UART 7816 Wait and Guard Parameter Register
 * - UART_WP7816C_T1 - UART 7816 Wait Parameter Register C
 */

#define UART_INSTANCE_COUNT (4U) /*!< Number of instances of the UART module. */
#define UART0_IDX (0U) /*!< Instance number for UART0. */
#define UART1_IDX (1U) /*!< Instance number for UART1. */
#define UART2_IDX (2U) /*!< Instance number for UART2. */
#define UART3_IDX (3U) /*!< Instance number for UART3. */

/*******************************************************************************
 * UART_BDH - UART Baud Rate Registers: High
 ******************************************************************************/

/*!
 * @brief UART_BDH - UART Baud Rate Registers: High (RW)
 *
 * Reset value: 0x00U
 *
 * This register, along with the BDL register, controls the prescale divisor for
 * UART baud rate generation. To update the 13-bit baud rate setting
 * (SBR[12:0]), first write to BDH to buffer the high half of the new value and then write
 * to BDL. The working value in BDH does not change until BDL is written. BDL is
 * reset to a nonzero value, but after reset, the baud rate generator remains
 * disabled until the first time the receiver or transmitter is enabled, that is,
 * when C2[RE] or C2[TE] is set.
 */
/*!
 * @name Constants and macros for entire UART_BDH register
 */
/*@{*/
#define UART_RD_BDH(base)        (UART_BDH_REG(base))
#define UART_WR_BDH(base, value) (UART_BDH_REG(base) = (value))
#define UART_RMW_BDH(base, mask, value) (UART_WR_BDH(base, (UART_RD_BDH(base) & ~(mask)) | (value)))
#define UART_SET_BDH(base, value) (BME_OR8(&UART_BDH_REG(base), (uint8_t)(value)))
#define UART_CLR_BDH(base, value) (BME_AND8(&UART_BDH_REG(base), (uint8_t)(~(value))))
#define UART_TOG_BDH(base, value) (BME_XOR8(&UART_BDH_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual UART_BDH bitfields
 */

/*!
 * @name Register UART_BDH, field SBR[4:0] (RW)
 *
 * The baud rate for the UART is determined by the 13 SBR fields. See Baud rate
 * generation for details. The baud rate generator is disabled until C2[TE] or
 * C2[RE] is set for the first time after reset.The baud rate generator is disabled
 * when SBR = 0. Writing to BDH has no effect without writing to BDL, because
 * writing to BDH puts the data in a temporary location until BDL is written.
 */
/*@{*/
/*! @brief Read current value of the UART_BDH_SBR field. */
#define UART_RD_BDH_SBR(base) ((UART_BDH_REG(base) & UART_BDH_SBR_MASK) >> UART_BDH_SBR_SHIFT)
#define UART_BRD_BDH_SBR(base) (BME_UBFX8(&UART_BDH_REG(base), UART_BDH_SBR_SHIFT, UART_BDH_SBR_WIDTH))

/*! @brief Set the SBR field to a new value. */
#define UART_WR_BDH_SBR(base, value) (UART_RMW_BDH(base, UART_BDH_SBR_MASK, UART_BDH_SBR(value)))
#define UART_BWR_BDH_SBR(base, value) (BME_BFI8(&UART_BDH_REG(base), ((uint8_t)(value) << UART_BDH_SBR_SHIFT), UART_BDH_SBR_SHIFT, UART_BDH_SBR_WIDTH))
/*@}*/

/*!
 * @name Register UART_BDH, field RXEDGIE[6] (RW)
 *
 * Enables the receive input active edge, RXEDGIF, to generate interrupt
 * requests.
 *
 * Values:
 * - 0b0 - Hardware interrupts from RXEDGIF disabled using polling.
 * - 0b1 - RXEDGIF interrupt request enabled.
 */
/*@{*/
/*! @brief Read current value of the UART_BDH_RXEDGIE field. */
#define UART_RD_BDH_RXEDGIE(base) ((UART_BDH_REG(base) & UART_BDH_RXEDGIE_MASK) >> UART_BDH_RXEDGIE_SHIFT)
#define UART_BRD_BDH_RXEDGIE(base) (BME_UBFX8(&UART_BDH_REG(base), UART_BDH_RXEDGIE_SHIFT, UART_BDH_RXEDGIE_WIDTH))

/*! @brief Set the RXEDGIE field to a new value. */
#define UART_WR_BDH_RXEDGIE(base, value) (UART_RMW_BDH(base, UART_BDH_RXEDGIE_MASK, UART_BDH_RXEDGIE(value)))
#define UART_BWR_BDH_RXEDGIE(base, value) (BME_BFI8(&UART_BDH_REG(base), ((uint8_t)(value) << UART_BDH_RXEDGIE_SHIFT), UART_BDH_RXEDGIE_SHIFT, UART_BDH_RXEDGIE_WIDTH))
/*@}*/

/*******************************************************************************
 * UART_BDL - UART Baud Rate Registers: Low
 ******************************************************************************/

/*!
 * @brief UART_BDL - UART Baud Rate Registers: Low (RW)
 *
 * Reset value: 0x04U
 *
 * This register, along with the BDH register, controls the prescale divisor for
 * UART baud rate generation. To update the 13-bit baud rate setting, SBR[12:0],
 * first write to BDH to buffer the high half of the new value and then write to
 * BDL. The working value in BDH does not change until BDL is written. BDL is
 * reset to a nonzero value, but after reset, the baud rate generator remains
 * disabled until the first time the receiver or transmitter is enabled, that is, when
 * C2[RE] or C2[TE] is set.
 */
/*!
 * @name Constants and macros for entire UART_BDL register
 */
/*@{*/
#define UART_RD_BDL(base)        (UART_BDL_REG(base))
#define UART_WR_BDL(base, value) (UART_BDL_REG(base) = (value))
#define UART_RMW_BDL(base, mask, value) (UART_WR_BDL(base, (UART_RD_BDL(base) & ~(mask)) | (value)))
#define UART_SET_BDL(base, value) (BME_OR8(&UART_BDL_REG(base), (uint8_t)(value)))
#define UART_CLR_BDL(base, value) (BME_AND8(&UART_BDL_REG(base), (uint8_t)(~(value))))
#define UART_TOG_BDL(base, value) (BME_XOR8(&UART_BDL_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * UART_C1 - UART Control Register 1
 ******************************************************************************/

/*!
 * @brief UART_C1 - UART Control Register 1 (RW)
 *
 * Reset value: 0x00U
 *
 * This read/write register controls various optional features of the UART
 * system.
 */
/*!
 * @name Constants and macros for entire UART_C1 register
 */
/*@{*/
#define UART_RD_C1(base)         (UART_C1_REG(base))
#define UART_WR_C1(base, value)  (UART_C1_REG(base) = (value))
#define UART_RMW_C1(base, mask, value) (UART_WR_C1(base, (UART_RD_C1(base) & ~(mask)) | (value)))
#define UART_SET_C1(base, value) (BME_OR8(&UART_C1_REG(base), (uint8_t)(value)))
#define UART_CLR_C1(base, value) (BME_AND8(&UART_C1_REG(base), (uint8_t)(~(value))))
#define UART_TOG_C1(base, value) (BME_XOR8(&UART_C1_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual UART_C1 bitfields
 */

/*!
 * @name Register UART_C1, field PT[0] (RW)
 *
 * Determines whether the UART generates and checks for even parity or odd
 * parity. With even parity, an even number of 1s clears the parity bit and an odd
 * number of 1s sets the parity bit. With odd parity, an odd number of 1s clears the
 * parity bit and an even number of 1s sets the parity bit. This field must be
 * cleared when C7816[ISO_7816E] is set/enabled.
 *
 * Values:
 * - 0b0 - Even parity.
 * - 0b1 - Odd parity.
 */
/*@{*/
/*! @brief Read current value of the UART_C1_PT field. */
#define UART_RD_C1_PT(base)  ((UART_C1_REG(base) & UART_C1_PT_MASK) >> UART_C1_PT_SHIFT)
#define UART_BRD_C1_PT(base) (BME_UBFX8(&UART_C1_REG(base), UART_C1_PT_SHIFT, UART_C1_PT_WIDTH))

/*! @brief Set the PT field to a new value. */
#define UART_WR_C1_PT(base, value) (UART_RMW_C1(base, UART_C1_PT_MASK, UART_C1_PT(value)))
#define UART_BWR_C1_PT(base, value) (BME_BFI8(&UART_C1_REG(base), ((uint8_t)(value) << UART_C1_PT_SHIFT), UART_C1_PT_SHIFT, UART_C1_PT_WIDTH))
/*@}*/

/*!
 * @name Register UART_C1, field PE[1] (RW)
 *
 * Enables the parity function. When parity is enabled, parity function inserts
 * a parity bit in the bit position immediately preceding the stop bit. This
 * field must be set when C7816[ISO_7816E] is set/enabled.
 *
 * Values:
 * - 0b0 - Parity function disabled.
 * - 0b1 - Parity function enabled.
 */
/*@{*/
/*! @brief Read current value of the UART_C1_PE field. */
#define UART_RD_C1_PE(base)  ((UART_C1_REG(base) & UART_C1_PE_MASK) >> UART_C1_PE_SHIFT)
#define UART_BRD_C1_PE(base) (BME_UBFX8(&UART_C1_REG(base), UART_C1_PE_SHIFT, UART_C1_PE_WIDTH))

/*! @brief Set the PE field to a new value. */
#define UART_WR_C1_PE(base, value) (UART_RMW_C1(base, UART_C1_PE_MASK, UART_C1_PE(value)))
#define UART_BWR_C1_PE(base, value) (BME_BFI8(&UART_C1_REG(base), ((uint8_t)(value) << UART_C1_PE_SHIFT), UART_C1_PE_SHIFT, UART_C1_PE_WIDTH))
/*@}*/

/*!
 * @name Register UART_C1, field ILT[2] (RW)
 *
 * Determines when the receiver starts counting logic 1s as idle character bits.
 * The count begins either after a valid start bit or after the stop bit. If the
 * count begins after the start bit, then a string of logic 1s preceding the
 * stop bit can cause false recognition of an idle character. Beginning the count
 * after the stop bit avoids false idle character recognition, but requires
 * properly synchronized transmissions. In case the UART is programmed with ILT = 1, a
 * logic of 1'b0 is automatically shifted after a received stop bit, therefore
 * resetting the idle count. In case the UART is programmed for IDLE line wakeup
 * (RWU = 1 and WAKE = 0), ILT has no effect on when the receiver starts counting
 * logic 1s as idle character bits. In idle line wakeup, an idle character is
 * recognized at anytime the receiver sees 10, 11, or 12 1s depending on the M, PE,
 * and C4[M10] fields.
 *
 * Values:
 * - 0b0 - Idle character bit count starts after start bit.
 * - 0b1 - Idle character bit count starts after stop bit.
 */
/*@{*/
/*! @brief Read current value of the UART_C1_ILT field. */
#define UART_RD_C1_ILT(base) ((UART_C1_REG(base) & UART_C1_ILT_MASK) >> UART_C1_ILT_SHIFT)
#define UART_BRD_C1_ILT(base) (BME_UBFX8(&UART_C1_REG(base), UART_C1_ILT_SHIFT, UART_C1_ILT_WIDTH))

/*! @brief Set the ILT field to a new value. */
#define UART_WR_C1_ILT(base, value) (UART_RMW_C1(base, UART_C1_ILT_MASK, UART_C1_ILT(value)))
#define UART_BWR_C1_ILT(base, value) (BME_BFI8(&UART_C1_REG(base), ((uint8_t)(value) << UART_C1_ILT_SHIFT), UART_C1_ILT_SHIFT, UART_C1_ILT_WIDTH))
/*@}*/

/*!
 * @name Register UART_C1, field WAKE[3] (RW)
 *
 * Determines which condition wakes the UART: Address mark in the most
 * significant bit position of a received data character, or An idle condition on the
 * receive pin input signal.
 *
 * Values:
 * - 0b0 - Idle line wakeup.
 * - 0b1 - Address mark wakeup.
 */
/*@{*/
/*! @brief Read current value of the UART_C1_WAKE field. */
#define UART_RD_C1_WAKE(base) ((UART_C1_REG(base) & UART_C1_WAKE_MASK) >> UART_C1_WAKE_SHIFT)
#define UART_BRD_C1_WAKE(base) (BME_UBFX8(&UART_C1_REG(base), UART_C1_WAKE_SHIFT, UART_C1_WAKE_WIDTH))

/*! @brief Set the WAKE field to a new value. */
#define UART_WR_C1_WAKE(base, value) (UART_RMW_C1(base, UART_C1_WAKE_MASK, UART_C1_WAKE(value)))
#define UART_BWR_C1_WAKE(base, value) (BME_BFI8(&UART_C1_REG(base), ((uint8_t)(value) << UART_C1_WAKE_SHIFT), UART_C1_WAKE_SHIFT, UART_C1_WAKE_WIDTH))
/*@}*/

/*!
 * @name Register UART_C1, field M[4] (RW)
 *
 * This field must be set when C7816[ISO_7816E] is set/enabled.
 *
 * Values:
 * - 0b0 - Normal-start + 8 data bits (MSB/LSB first as determined by MSBF) +
 *     stop.
 * - 0b1 - Use-start + 9 data bits (MSB/LSB first as determined by MSBF) + stop.
 */
/*@{*/
/*! @brief Read current value of the UART_C1_M field. */
#define UART_RD_C1_M(base)   ((UART_C1_REG(base) & UART_C1_M_MASK) >> UART_C1_M_SHIFT)
#define UART_BRD_C1_M(base)  (BME_UBFX8(&UART_C1_REG(base), UART_C1_M_SHIFT, UART_C1_M_WIDTH))

/*! @brief Set the M field to a new value. */
#define UART_WR_C1_M(base, value) (UART_RMW_C1(base, UART_C1_M_MASK, UART_C1_M(value)))
#define UART_BWR_C1_M(base, value) (BME_BFI8(&UART_C1_REG(base), ((uint8_t)(value) << UART_C1_M_SHIFT), UART_C1_M_SHIFT, UART_C1_M_WIDTH))
/*@}*/

/*!
 * @name Register UART_C1, field RSRC[5] (RW)
 *
 * This field has no meaning or effect unless the LOOPS field is set. When LOOPS
 * is set, the RSRC field determines the source for the receiver shift register
 * input.
 *
 * Values:
 * - 0b0 - Selects internal loop back mode. The receiver input is internally
 *     connected to transmitter output.
 * - 0b1 - Single wire UART mode where the receiver input is connected to the
 *     transmit pin input signal.
 */
/*@{*/
/*! @brief Read current value of the UART_C1_RSRC field. */
#define UART_RD_C1_RSRC(base) ((UART_C1_REG(base) & UART_C1_RSRC_MASK) >> UART_C1_RSRC_SHIFT)
#define UART_BRD_C1_RSRC(base) (BME_UBFX8(&UART_C1_REG(base), UART_C1_RSRC_SHIFT, UART_C1_RSRC_WIDTH))

/*! @brief Set the RSRC field to a new value. */
#define UART_WR_C1_RSRC(base, value) (UART_RMW_C1(base, UART_C1_RSRC_MASK, UART_C1_RSRC(value)))
#define UART_BWR_C1_RSRC(base, value) (BME_BFI8(&UART_C1_REG(base), ((uint8_t)(value) << UART_C1_RSRC_SHIFT), UART_C1_RSRC_SHIFT, UART_C1_RSRC_WIDTH))
/*@}*/

/*!
 * @name Register UART_C1, field LOOPS[7] (RW)
 *
 * When LOOPS is set, the RxD pin is disconnected from the UART and the
 * transmitter output is internally connected to the receiver input. The transmitter and
 * the receiver must be enabled to use the loop function.
 *
 * Values:
 * - 0b0 - Normal operation.
 * - 0b1 - Loop mode where transmitter output is internally connected to
 *     receiver input. The receiver input is determined by RSRC.
 */
/*@{*/
/*! @brief Read current value of the UART_C1_LOOPS field. */
#define UART_RD_C1_LOOPS(base) ((UART_C1_REG(base) & UART_C1_LOOPS_MASK) >> UART_C1_LOOPS_SHIFT)
#define UART_BRD_C1_LOOPS(base) (BME_UBFX8(&UART_C1_REG(base), UART_C1_LOOPS_SHIFT, UART_C1_LOOPS_WIDTH))

/*! @brief Set the LOOPS field to a new value. */
#define UART_WR_C1_LOOPS(base, value) (UART_RMW_C1(base, UART_C1_LOOPS_MASK, UART_C1_LOOPS(value)))
#define UART_BWR_C1_LOOPS(base, value) (BME_BFI8(&UART_C1_REG(base), ((uint8_t)(value) << UART_C1_LOOPS_SHIFT), UART_C1_LOOPS_SHIFT, UART_C1_LOOPS_WIDTH))
/*@}*/

/*******************************************************************************
 * UART_C2 - UART Control Register 2
 ******************************************************************************/

/*!
 * @brief UART_C2 - UART Control Register 2 (RW)
 *
 * Reset value: 0x00U
 *
 * This register can be read or written at any time.
 */
/*!
 * @name Constants and macros for entire UART_C2 register
 */
/*@{*/
#define UART_RD_C2(base)         (UART_C2_REG(base))
#define UART_WR_C2(base, value)  (UART_C2_REG(base) = (value))
#define UART_RMW_C2(base, mask, value) (UART_WR_C2(base, (UART_RD_C2(base) & ~(mask)) | (value)))
#define UART_SET_C2(base, value) (BME_OR8(&UART_C2_REG(base), (uint8_t)(value)))
#define UART_CLR_C2(base, value) (BME_AND8(&UART_C2_REG(base), (uint8_t)(~(value))))
#define UART_TOG_C2(base, value) (BME_XOR8(&UART_C2_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual UART_C2 bitfields
 */

/*!
 * @name Register UART_C2, field SBK[0] (RW)
 *
 * Toggling SBK sends one break character from the following: See Transmitting
 * break characters for the number of logic 0s for the different configurations.
 * Toggling implies clearing the SBK field before the break character has finished
 * transmitting. As long as SBK is set, the transmitter continues to send
 * complete break characters (10, 11, or 12 bits, or 13 or 14 bits). Ensure that C2[TE]
 * is asserted atleast 1 clock before assertion of this bit. 10, 11, or 12 logic
 * 0s if S2[BRK13] is cleared 13 or 14 logic 0s if S2[BRK13] is set. This field
 * must be cleared when C7816[ISO_7816E] is set.
 *
 * Values:
 * - 0b0 - Normal transmitter operation.
 * - 0b1 - Queue break characters to be sent.
 */
/*@{*/
/*! @brief Read current value of the UART_C2_SBK field. */
#define UART_RD_C2_SBK(base) ((UART_C2_REG(base) & UART_C2_SBK_MASK) >> UART_C2_SBK_SHIFT)
#define UART_BRD_C2_SBK(base) (BME_UBFX8(&UART_C2_REG(base), UART_C2_SBK_SHIFT, UART_C2_SBK_WIDTH))

/*! @brief Set the SBK field to a new value. */
#define UART_WR_C2_SBK(base, value) (UART_RMW_C2(base, UART_C2_SBK_MASK, UART_C2_SBK(value)))
#define UART_BWR_C2_SBK(base, value) (BME_BFI8(&UART_C2_REG(base), ((uint8_t)(value) << UART_C2_SBK_SHIFT), UART_C2_SBK_SHIFT, UART_C2_SBK_WIDTH))
/*@}*/

/*!
 * @name Register UART_C2, field RWU[1] (RW)
 *
 * This field can be set to place the UART receiver in a standby state. RWU
 * automatically clears when an RWU event occurs, that is, an IDLE event when
 * C1[WAKE] is clear or an address match when C1[WAKE] is set. This field must be
 * cleared when C7816[ISO_7816E] is set. RWU must be set only with C1[WAKE] = 0 (wakeup
 * on idle) if the channel is currently not idle. This can be determined by
 * S2[RAF]. If the flag is set to wake up an IDLE event and the channel is already
 * idle, it is possible that the UART will discard data. This is because the data
 * must be received after an IDLE is detected before IDLE is allowed to reasserted.
 *
 * Values:
 * - 0b0 - Normal operation.
 * - 0b1 - RWU enables the wakeup function and inhibits further receiver
 *     interrupt requests. Normally, hardware wakes the receiver by automatically
 *     clearing RWU.
 */
/*@{*/
/*! @brief Read current value of the UART_C2_RWU field. */
#define UART_RD_C2_RWU(base) ((UART_C2_REG(base) & UART_C2_RWU_MASK) >> UART_C2_RWU_SHIFT)
#define UART_BRD_C2_RWU(base) (BME_UBFX8(&UART_C2_REG(base), UART_C2_RWU_SHIFT, UART_C2_RWU_WIDTH))

/*! @brief Set the RWU field to a new value. */
#define UART_WR_C2_RWU(base, value) (UART_RMW_C2(base, UART_C2_RWU_MASK, UART_C2_RWU(value)))
#define UART_BWR_C2_RWU(base, value) (BME_BFI8(&UART_C2_REG(base), ((uint8_t)(value) << UART_C2_RWU_SHIFT), UART_C2_RWU_SHIFT, UART_C2_RWU_WIDTH))
/*@}*/

/*!
 * @name Register UART_C2, field RE[2] (RW)
 *
 * Enables the UART receiver.
 *
 * Values:
 * - 0b0 - Receiver off.
 * - 0b1 - Receiver on.
 */
/*@{*/
/*! @brief Read current value of the UART_C2_RE field. */
#define UART_RD_C2_RE(base)  ((UART_C2_REG(base) & UART_C2_RE_MASK) >> UART_C2_RE_SHIFT)
#define UART_BRD_C2_RE(base) (BME_UBFX8(&UART_C2_REG(base), UART_C2_RE_SHIFT, UART_C2_RE_WIDTH))

/*! @brief Set the RE field to a new value. */
#define UART_WR_C2_RE(base, value) (UART_RMW_C2(base, UART_C2_RE_MASK, UART_C2_RE(value)))
#define UART_BWR_C2_RE(base, value) (BME_BFI8(&UART_C2_REG(base), ((uint8_t)(value) << UART_C2_RE_SHIFT), UART_C2_RE_SHIFT, UART_C2_RE_WIDTH))
/*@}*/

/*!
 * @name Register UART_C2, field TE[3] (RW)
 *
 * Enables the UART transmitter. TE can be used to queue an idle preamble by
 * clearing and then setting TE. When C7816[ISO_7816E] is set/enabled and
 * C7816[TTYPE] = 1, this field is automatically cleared after the requested block has been
 * transmitted. This condition is detected when TL7816[TLEN] = 0 and four
 * additional characters are transmitted.
 *
 * Values:
 * - 0b0 - Transmitter off.
 * - 0b1 - Transmitter on.
 */
/*@{*/
/*! @brief Read current value of the UART_C2_TE field. */
#define UART_RD_C2_TE(base)  ((UART_C2_REG(base) & UART_C2_TE_MASK) >> UART_C2_TE_SHIFT)
#define UART_BRD_C2_TE(base) (BME_UBFX8(&UART_C2_REG(base), UART_C2_TE_SHIFT, UART_C2_TE_WIDTH))

/*! @brief Set the TE field to a new value. */
#define UART_WR_C2_TE(base, value) (UART_RMW_C2(base, UART_C2_TE_MASK, UART_C2_TE(value)))
#define UART_BWR_C2_TE(base, value) (BME_BFI8(&UART_C2_REG(base), ((uint8_t)(value) << UART_C2_TE_SHIFT), UART_C2_TE_SHIFT, UART_C2_TE_WIDTH))
/*@}*/

/*!
 * @name Register UART_C2, field ILIE[4] (RW)
 *
 * Enables the idle line flag, S1[IDLE], to generate interrupt requestsor DMA
 * transfer requests based on the state of C5[ILDMAS].
 *
 * Values:
 * - 0b0 - IDLE interrupt requests disabled. and DMA transfer
 * - 0b1 - IDLE interrupt requests enabled. or DMA transfer
 */
/*@{*/
/*! @brief Read current value of the UART_C2_ILIE field. */
#define UART_RD_C2_ILIE(base) ((UART_C2_REG(base) & UART_C2_ILIE_MASK) >> UART_C2_ILIE_SHIFT)
#define UART_BRD_C2_ILIE(base) (BME_UBFX8(&UART_C2_REG(base), UART_C2_ILIE_SHIFT, UART_C2_ILIE_WIDTH))

/*! @brief Set the ILIE field to a new value. */
#define UART_WR_C2_ILIE(base, value) (UART_RMW_C2(base, UART_C2_ILIE_MASK, UART_C2_ILIE(value)))
#define UART_BWR_C2_ILIE(base, value) (BME_BFI8(&UART_C2_REG(base), ((uint8_t)(value) << UART_C2_ILIE_SHIFT), UART_C2_ILIE_SHIFT, UART_C2_ILIE_WIDTH))
/*@}*/

/*!
 * @name Register UART_C2, field RIE[5] (RW)
 *
 * Enables S1[RDRF] to generate interrupt requests or DMA transfer requests,
 * based on the state of C5[RDMAS].
 *
 * Values:
 * - 0b0 - RDRF interrupt and DMA transfer requests disabled.
 * - 0b1 - RDRF interrupt or DMA transfer requests enabled.
 */
/*@{*/
/*! @brief Read current value of the UART_C2_RIE field. */
#define UART_RD_C2_RIE(base) ((UART_C2_REG(base) & UART_C2_RIE_MASK) >> UART_C2_RIE_SHIFT)
#define UART_BRD_C2_RIE(base) (BME_UBFX8(&UART_C2_REG(base), UART_C2_RIE_SHIFT, UART_C2_RIE_WIDTH))

/*! @brief Set the RIE field to a new value. */
#define UART_WR_C2_RIE(base, value) (UART_RMW_C2(base, UART_C2_RIE_MASK, UART_C2_RIE(value)))
#define UART_BWR_C2_RIE(base, value) (BME_BFI8(&UART_C2_REG(base), ((uint8_t)(value) << UART_C2_RIE_SHIFT), UART_C2_RIE_SHIFT, UART_C2_RIE_WIDTH))
/*@}*/

/*!
 * @name Register UART_C2, field TCIE[6] (RW)
 *
 * Enables the transmission complete flag, S1[TC], to generate interrupt
 * requests .
 *
 * Values:
 * - 0b0 - TC interrupt requests disabled.
 * - 0b1 - TC interrupt requests enabled.
 */
/*@{*/
/*! @brief Read current value of the UART_C2_TCIE field. */
#define UART_RD_C2_TCIE(base) ((UART_C2_REG(base) & UART_C2_TCIE_MASK) >> UART_C2_TCIE_SHIFT)
#define UART_BRD_C2_TCIE(base) (BME_UBFX8(&UART_C2_REG(base), UART_C2_TCIE_SHIFT, UART_C2_TCIE_WIDTH))

/*! @brief Set the TCIE field to a new value. */
#define UART_WR_C2_TCIE(base, value) (UART_RMW_C2(base, UART_C2_TCIE_MASK, UART_C2_TCIE(value)))
#define UART_BWR_C2_TCIE(base, value) (BME_BFI8(&UART_C2_REG(base), ((uint8_t)(value) << UART_C2_TCIE_SHIFT), UART_C2_TCIE_SHIFT, UART_C2_TCIE_WIDTH))
/*@}*/

/*!
 * @name Register UART_C2, field TIE[7] (RW)
 *
 * Enables S1[TDRE] to generate interrupt requests or DMA transfer requests,
 * based on the state of C5[TDMAS]. If C2[TIE] and C5[TDMAS] are both set, then TCIE
 * must be cleared, and D[D] must not be written unless servicing a DMA request.
 *
 * Values:
 * - 0b0 - TDRE interrupt and DMA transfer requests disabled.
 * - 0b1 - TDRE interrupt or DMA transfer requests enabled.
 */
/*@{*/
/*! @brief Read current value of the UART_C2_TIE field. */
#define UART_RD_C2_TIE(base) ((UART_C2_REG(base) & UART_C2_TIE_MASK) >> UART_C2_TIE_SHIFT)
#define UART_BRD_C2_TIE(base) (BME_UBFX8(&UART_C2_REG(base), UART_C2_TIE_SHIFT, UART_C2_TIE_WIDTH))

/*! @brief Set the TIE field to a new value. */
#define UART_WR_C2_TIE(base, value) (UART_RMW_C2(base, UART_C2_TIE_MASK, UART_C2_TIE(value)))
#define UART_BWR_C2_TIE(base, value) (BME_BFI8(&UART_C2_REG(base), ((uint8_t)(value) << UART_C2_TIE_SHIFT), UART_C2_TIE_SHIFT, UART_C2_TIE_WIDTH))
/*@}*/

/*******************************************************************************
 * UART_S1 - UART Status Register 1
 ******************************************************************************/

/*!
 * @brief UART_S1 - UART Status Register 1 (RO)
 *
 * Reset value: 0xC0U
 *
 * The S1 register provides inputs to the MCU for generation of UART interrupts
 * or DMA requests. This register can also be polled by the MCU to check the
 * status of its fields. To clear a flag, the status register should be read followed
 * by a read or write to D register, depending on the interrupt flag type. Other
 * instructions can be executed between the two steps as long the handling of
 * I/O is not compromised, but the order of operations is important for flag
 * clearing. When a flag is configured to trigger a DMA request, assertion of the
 * associated DMA done signal from the DMA controller clears the flag. If the
 * condition that results in the assertion of the flag, interrupt, or DMA request is not
 * resolved prior to clearing the flag, the flag, and interrupt/DMA request,
 * reasserts. For example, if the DMA or interrupt service routine fails to write
 * sufficient data to the transmit buffer to raise it above the watermark level, the
 * flag reasserts and generates another interrupt or DMA request. Reading an
 * empty data register to clear one of the flags of the S1 register causes the FIFO
 * pointers to become misaligned. A receive FIFO flush reinitializes the
 * pointers. A better way to prevent this situation is to always leave one byte in FIFO
 * and this byte will be read eventually in clearing the flag bit.
 */
/*!
 * @name Constants and macros for entire UART_S1 register
 */
/*@{*/
#define UART_RD_S1(base)         (UART_S1_REG(base))
/*@}*/

/*
 * Constants & macros for individual UART_S1 bitfields
 */

/*!
 * @name Register UART_S1, field PF[0] (RO)
 *
 * PF is set when PE is set and the parity of the received data does not match
 * its parity bit. The PF is not set in the case of an overrun condition. When PF
 * is set, it indicates only that a dataword was received with parity error since
 * the last time it was cleared. There is no guarantee that the first dataword
 * read from the receive buffer has a parity error or that there is only one
 * dataword in the buffer that was received with a parity error, unless the receive
 * buffer has a depth of one. To clear PF, read S1 and then read D. Within the
 * receive buffer structure the received dataword is tagged if it is received with a
 * parity error. This information is available by reading the ED register prior
 * to reading the D register.
 *
 * Values:
 * - 0b0 - No parity error detected since the last time this flag was cleared.
 *     If the receive buffer has a depth greater than 1, then there may be data in
 *     the receive buffer what was received with a parity error.
 * - 0b1 - At least one dataword was received with a parity error since the last
 *     time this flag was cleared.
 */
/*@{*/
/*! @brief Read current value of the UART_S1_PF field. */
#define UART_RD_S1_PF(base)  ((UART_S1_REG(base) & UART_S1_PF_MASK) >> UART_S1_PF_SHIFT)
#define UART_BRD_S1_PF(base) (BME_UBFX8(&UART_S1_REG(base), UART_S1_PF_SHIFT, UART_S1_PF_WIDTH))
/*@}*/

/*!
 * @name Register UART_S1, field FE[1] (RO)
 *
 * FE is set when a logic 0 is accepted as the stop bit. FE does not set in the
 * case of an overrun. FE inhibits further data reception until it is cleared. To
 * clear FE, read S1 with FE set and then read D. The last data in the receive
 * buffer represents the data that was received with the frame error enabled.
 * Framing errors are not supported when 7816E is set/enabled. However, if this flag
 * is set, data is still not received in 7816 mode.
 *
 * Values:
 * - 0b0 - No framing error detected.
 * - 0b1 - Framing error.
 */
/*@{*/
/*! @brief Read current value of the UART_S1_FE field. */
#define UART_RD_S1_FE(base)  ((UART_S1_REG(base) & UART_S1_FE_MASK) >> UART_S1_FE_SHIFT)
#define UART_BRD_S1_FE(base) (BME_UBFX8(&UART_S1_REG(base), UART_S1_FE_SHIFT, UART_S1_FE_WIDTH))
/*@}*/

/*!
 * @name Register UART_S1, field NF[2] (RO)
 *
 * NF is set when the UART detects noise on the receiver input. NF does not
 * become set in the case of an overrun. When NF is set, it indicates only that a
 * dataword has been received with noise since the last time it was cleared. There
 * is no guarantee that the first dataword read from the receive buffer has noise
 * or that there is only one dataword in the buffer that was received with noise
 * unless the receive buffer has a depth of one. To clear NF, read S1 and then
 * read D.
 *
 * Values:
 * - 0b0 - No noise detected since the last time this flag was cleared. If the
 *     receive buffer has a depth greater than 1 then there may be data in the
 *     receiver buffer that was received with noise.
 * - 0b1 - At least one dataword was received with noise detected since the last
 *     time the flag was cleared.
 */
/*@{*/
/*! @brief Read current value of the UART_S1_NF field. */
#define UART_RD_S1_NF(base)  ((UART_S1_REG(base) & UART_S1_NF_MASK) >> UART_S1_NF_SHIFT)
#define UART_BRD_S1_NF(base) (BME_UBFX8(&UART_S1_REG(base), UART_S1_NF_SHIFT, UART_S1_NF_WIDTH))
/*@}*/

/*!
 * @name Register UART_S1, field OR[3] (RO)
 *
 * OR is set when software fails to prevent the receive data register from
 * overflowing with data. The OR bit is set immediately after the stop bit has been
 * completely received for the dataword that overflows the buffer and all the other
 * error flags (FE, NF, and PF) are prevented from setting. The data in the
 * shift register is lost, but the data already in the UART data registers is not
 * affected. If the OR flag is set, no data is stored in the data buffer even if
 * sufficient room exists. Additionally, while the OR flag is set, the RDRF and IDLE
 * flags are blocked from asserting, that is, transition from an inactive to an
 * active state. To clear OR, read S1 when OR is set and then read D. See
 * functional description for more details regarding the operation of the OR bit. In
 * 7816 mode, it is possible to configure a NACK to be returned by programing
 * C7816[ONACK].
 *
 * Values:
 * - 0b0 - No overrun has occurred since the last time the flag was cleared.
 * - 0b1 - Overrun has occurred or the overrun flag has not been cleared since
 *     the last overrun occured.
 */
/*@{*/
/*! @brief Read current value of the UART_S1_OR field. */
#define UART_RD_S1_OR(base)  ((UART_S1_REG(base) & UART_S1_OR_MASK) >> UART_S1_OR_SHIFT)
#define UART_BRD_S1_OR(base) (BME_UBFX8(&UART_S1_REG(base), UART_S1_OR_SHIFT, UART_S1_OR_WIDTH))
/*@}*/

/*!
 * @name Register UART_S1, field IDLE[4] (RO)
 *
 * After the IDLE flag is cleared, a frame must be received (although not
 * necessarily stored in the data buffer, for example if C2[RWU] is set). To clear
 * IDLE, read UART status S1 with IDLE set and then read D. IDLE is set when either
 * of the following appear on the receiver input: 10 consecutive logic 1s if C1[M]
 * = 0 11 consecutive logic 1s if C1[M] = 1 and C4[M10] = 0 12 consecutive logic
 * 1s if C1[M] = 1, C4[M10] = 1, and C1[PE] = 1 Idle detection is not supported
 * when 7816E is set/enabled and hence this flag is ignored. When RWU is set and
 * WAKE is cleared, an idle line condition sets the IDLE flag if RWUID is set,
 * else the IDLE flag does not become set.
 *
 * Values:
 * - 0b0 - Receiver input is either active now or has never become active since
 *     the IDLE flag was last cleared.
 * - 0b1 - Receiver input has become idle or the flag has not been cleared since
 *     it last asserted.
 */
/*@{*/
/*! @brief Read current value of the UART_S1_IDLE field. */
#define UART_RD_S1_IDLE(base) ((UART_S1_REG(base) & UART_S1_IDLE_MASK) >> UART_S1_IDLE_SHIFT)
#define UART_BRD_S1_IDLE(base) (BME_UBFX8(&UART_S1_REG(base), UART_S1_IDLE_SHIFT, UART_S1_IDLE_WIDTH))
/*@}*/

/*!
 * @name Register UART_S1, field RDRF[5] (RO)
 *
 * RDRF is set when the number of datawords in the receive buffer is equal to or
 * more than the number indicated by RWFIFO[RXWATER]. A dataword that is in the
 * process of being received is not included in the count. To clear RDRF, read S1
 * when RDRF is set and then read D. For more efficient interrupt and DMA
 * operation, read all data except the final value from the buffer, using D/C3[T8]/ED.
 * Then read S1 and the final data value, resulting in the clearing of the RDRF
 * flag. Even if RDRF is set, data will continue to be received until an overrun
 * condition occurs.
 *
 * Values:
 * - 0b0 - The number of datawords in the receive buffer is less than the number
 *     indicated by RXWATER.
 * - 0b1 - The number of datawords in the receive buffer is equal to or greater
 *     than the number indicated by RXWATER at some point in time since this flag
 *     was last cleared.
 */
/*@{*/
/*! @brief Read current value of the UART_S1_RDRF field. */
#define UART_RD_S1_RDRF(base) ((UART_S1_REG(base) & UART_S1_RDRF_MASK) >> UART_S1_RDRF_SHIFT)
#define UART_BRD_S1_RDRF(base) (BME_UBFX8(&UART_S1_REG(base), UART_S1_RDRF_SHIFT, UART_S1_RDRF_WIDTH))
/*@}*/

/*!
 * @name Register UART_S1, field TC[6] (RO)
 *
 * TC is set when the transmit buffer is empty and no data, preamble, or break
 * character is being transmitted. When TC is set, the transmit data output signal
 * becomes idle (logic 1). TC is cleared by reading S1 with TC set and then
 * doing one of the following: When C7816[ISO_7816E] is set/enabled, this field is
 * set after any NACK signal has been received, but prior to any corresponding
 * guard times expiring. Writing to D to transmit new data. Queuing a preamble by
 * clearing and then setting C2[TE]. Queuing a break character by writing 1 to SBK
 * in C2.
 *
 * Values:
 * - 0b0 - Transmitter active (sending data, a preamble, or a break).
 * - 0b1 - Transmitter idle (transmission activity complete).
 */
/*@{*/
/*! @brief Read current value of the UART_S1_TC field. */
#define UART_RD_S1_TC(base)  ((UART_S1_REG(base) & UART_S1_TC_MASK) >> UART_S1_TC_SHIFT)
#define UART_BRD_S1_TC(base) (BME_UBFX8(&UART_S1_REG(base), UART_S1_TC_SHIFT, UART_S1_TC_WIDTH))
/*@}*/

/*!
 * @name Register UART_S1, field TDRE[7] (RO)
 *
 * TDRE will set when the number of datawords in the transmit buffer (D and
 * C3[T8])is equal to or less than the number indicated by TWFIFO[TXWATER]. A
 * character that is in the process of being transmitted is not included in the count.
 * To clear TDRE, read S1 when TDRE is set and then write to the UART data
 * register (D). For more efficient interrupt servicing, all data except the final value
 * to be written to the buffer must be written to D/C3[T8]. Then S1 can be read
 * before writing the final data value, resulting in the clearing of the TRDE
 * flag. This is more efficient because the TDRE reasserts until the watermark has
 * been exceeded. So, attempting to clear the TDRE with every write will be
 * ineffective until sufficient data has been written.
 *
 * Values:
 * - 0b0 - The amount of data in the transmit buffer is greater than the value
 *     indicated by TWFIFO[TXWATER].
 * - 0b1 - The amount of data in the transmit buffer is less than or equal to
 *     the value indicated by TWFIFO[TXWATER] at some point in time since the flag
 *     has been cleared.
 */
/*@{*/
/*! @brief Read current value of the UART_S1_TDRE field. */
#define UART_RD_S1_TDRE(base) ((UART_S1_REG(base) & UART_S1_TDRE_MASK) >> UART_S1_TDRE_SHIFT)
#define UART_BRD_S1_TDRE(base) (BME_UBFX8(&UART_S1_REG(base), UART_S1_TDRE_SHIFT, UART_S1_TDRE_WIDTH))
/*@}*/

/*******************************************************************************
 * UART_S2 - UART Status Register 2
 ******************************************************************************/

/*!
 * @brief UART_S2 - UART Status Register 2 (RW)
 *
 * Reset value: 0x00U
 *
 * The S2 register provides inputs to the MCU for generation of UART interrupts
 * or DMA requests. Also, this register can be polled by the MCU to check the
 * status of these bits. This register can be read or written at any time, with the
 * exception of the MSBF and RXINV bits, which should be changed by the user only
 * between transmit and receive packets.
 */
/*!
 * @name Constants and macros for entire UART_S2 register
 */
/*@{*/
#define UART_RD_S2(base)         (UART_S2_REG(base))
#define UART_WR_S2(base, value)  (UART_S2_REG(base) = (value))
#define UART_RMW_S2(base, mask, value) (UART_WR_S2(base, (UART_RD_S2(base) & ~(mask)) | (value)))
#define UART_SET_S2(base, value) (BME_OR8(&UART_S2_REG(base), (uint8_t)(value)))
#define UART_CLR_S2(base, value) (BME_AND8(&UART_S2_REG(base), (uint8_t)(~(value))))
#define UART_TOG_S2(base, value) (BME_XOR8(&UART_S2_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual UART_S2 bitfields
 */

/*!
 * @name Register UART_S2, field RAF[0] (RO)
 *
 * RAF is set when the UART receiver detects a logic 0 during the RT1 time
 * period of the start bit search. RAF is cleared when the receiver detects an idle
 * character when C7816[ISO7816E] is cleared/disabled. When C7816[ISO7816E] is
 * enabled, the RAF is cleared if the C7816[TTYPE] = 0 expires or the C7816[TTYPE] =
 * 1 expires.In case C7816[ISO7816E] is set and C7816[TTYPE] = 0, it is possible
 * to configure the guard time to 12. However, if a NACK is required to be
 * transmitted, the data transfer actually takes 13 ETU with the 13th ETU slot being a
 * inactive buffer. Therefore, in this situation, the RAF may deassert one ETU
 * prior to actually being inactive.
 *
 * Values:
 * - 0b0 - UART receiver idle/inactive waiting for a start bit.
 * - 0b1 - UART receiver active, RxD input not idle.
 */
/*@{*/
/*! @brief Read current value of the UART_S2_RAF field. */
#define UART_RD_S2_RAF(base) ((UART_S2_REG(base) & UART_S2_RAF_MASK) >> UART_S2_RAF_SHIFT)
#define UART_BRD_S2_RAF(base) (BME_UBFX8(&UART_S2_REG(base), UART_S2_RAF_SHIFT, UART_S2_RAF_WIDTH))
/*@}*/

/*!
 * @name Register UART_S2, field BRK13[2] (RW)
 *
 * Determines whether the transmit break character is 10, 11, or 12 bits long,
 * or 13 or 14 bits long. See for the length of the break character for the
 * different configurations. The detection of a framing error is not affected by this
 * field. Transmitting break characters
 *
 * Values:
 * - 0b0 - Break character is 10, 11, or 12 bits long.
 * - 0b1 - Break character is 13 or 14 bits long.
 */
/*@{*/
/*! @brief Read current value of the UART_S2_BRK13 field. */
#define UART_RD_S2_BRK13(base) ((UART_S2_REG(base) & UART_S2_BRK13_MASK) >> UART_S2_BRK13_SHIFT)
#define UART_BRD_S2_BRK13(base) (BME_UBFX8(&UART_S2_REG(base), UART_S2_BRK13_SHIFT, UART_S2_BRK13_WIDTH))

/*! @brief Set the BRK13 field to a new value. */
#define UART_WR_S2_BRK13(base, value) (UART_RMW_S2(base, (UART_S2_BRK13_MASK | UART_S2_RXEDGIF_MASK), UART_S2_BRK13(value)))
#define UART_BWR_S2_BRK13(base, value) (BME_BFI8(&UART_S2_REG(base), ((uint8_t)(value) << UART_S2_BRK13_SHIFT), UART_S2_BRK13_SHIFT, UART_S2_BRK13_WIDTH))
/*@}*/

/*!
 * @name Register UART_S2, field RWUID[3] (RW)
 *
 * When RWU is set and WAKE is cleared, this field controls whether the idle
 * character that wakes the receiver sets S1[IDLE]. This field must be cleared when
 * C7816[ISO7816E] is set/enabled.
 *
 * Values:
 * - 0b0 - S1[IDLE] is not set upon detection of an idle character.
 * - 0b1 - S1[IDLE] is set upon detection of an idle character.
 */
/*@{*/
/*! @brief Read current value of the UART_S2_RWUID field. */
#define UART_RD_S2_RWUID(base) ((UART_S2_REG(base) & UART_S2_RWUID_MASK) >> UART_S2_RWUID_SHIFT)
#define UART_BRD_S2_RWUID(base) (BME_UBFX8(&UART_S2_REG(base), UART_S2_RWUID_SHIFT, UART_S2_RWUID_WIDTH))

/*! @brief Set the RWUID field to a new value. */
#define UART_WR_S2_RWUID(base, value) (UART_RMW_S2(base, (UART_S2_RWUID_MASK | UART_S2_RXEDGIF_MASK), UART_S2_RWUID(value)))
#define UART_BWR_S2_RWUID(base, value) (BME_BFI8(&UART_S2_REG(base), ((uint8_t)(value) << UART_S2_RWUID_SHIFT), UART_S2_RWUID_SHIFT, UART_S2_RWUID_WIDTH))
/*@}*/

/*!
 * @name Register UART_S2, field RXINV[4] (RW)
 *
 * Setting this field reverses the polarity of the received data input. In NRZ
 * format, a one is represented by a mark and a zero is represented by a space for
 * normal polarity, and the opposite for inverted polarity. This field is
 * automatically set when C7816[INIT] and C7816[ISO7816E] are enabled and an initial
 * character is detected in T = 0 protocol mode. Setting RXINV inverts the RxD
 * input for data bits, start and stop bits, break, and idle. When C7816[ISO7816E] is
 * set/enabled, only the data bits and the parity bit are inverted.
 *
 * Values:
 * - 0b0 - Receive data is not inverted.
 * - 0b1 - Receive data is inverted.
 */
/*@{*/
/*! @brief Read current value of the UART_S2_RXINV field. */
#define UART_RD_S2_RXINV(base) ((UART_S2_REG(base) & UART_S2_RXINV_MASK) >> UART_S2_RXINV_SHIFT)
#define UART_BRD_S2_RXINV(base) (BME_UBFX8(&UART_S2_REG(base), UART_S2_RXINV_SHIFT, UART_S2_RXINV_WIDTH))

/*! @brief Set the RXINV field to a new value. */
#define UART_WR_S2_RXINV(base, value) (UART_RMW_S2(base, (UART_S2_RXINV_MASK | UART_S2_RXEDGIF_MASK), UART_S2_RXINV(value)))
#define UART_BWR_S2_RXINV(base, value) (BME_BFI8(&UART_S2_REG(base), ((uint8_t)(value) << UART_S2_RXINV_SHIFT), UART_S2_RXINV_SHIFT, UART_S2_RXINV_WIDTH))
/*@}*/

/*!
 * @name Register UART_S2, field MSBF[5] (RW)
 *
 * Setting this field reverses the order of the bits that are transmitted and
 * received on the wire. This field does not affect the polarity of the bits, the
 * location of the parity bit, or the location of the start or stop bits. This
 * field is automatically set when C7816[INIT] and C7816[ISO7816E] are enabled and
 * an initial character is detected in T = 0 protocol mode.
 *
 * Values:
 * - 0b0 - LSB (bit0) is the first bit that is transmitted following the start
 *     bit. Further, the first bit received after the start bit is identified as
 *     bit0.
 * - 0b1 - MSB (bit8, bit7 or bit6) is the first bit that is transmitted
 *     following the start bit, depending on the setting of C1[M] and C1[PE]. Further,
 *     the first bit received after the start bit is identified as bit8, bit7, or
 *     bit6, depending on the setting of C1[M] and C1[PE].
 */
/*@{*/
/*! @brief Read current value of the UART_S2_MSBF field. */
#define UART_RD_S2_MSBF(base) ((UART_S2_REG(base) & UART_S2_MSBF_MASK) >> UART_S2_MSBF_SHIFT)
#define UART_BRD_S2_MSBF(base) (BME_UBFX8(&UART_S2_REG(base), UART_S2_MSBF_SHIFT, UART_S2_MSBF_WIDTH))

/*! @brief Set the MSBF field to a new value. */
#define UART_WR_S2_MSBF(base, value) (UART_RMW_S2(base, (UART_S2_MSBF_MASK | UART_S2_RXEDGIF_MASK), UART_S2_MSBF(value)))
#define UART_BWR_S2_MSBF(base, value) (BME_BFI8(&UART_S2_REG(base), ((uint8_t)(value) << UART_S2_MSBF_SHIFT), UART_S2_MSBF_SHIFT, UART_S2_MSBF_WIDTH))
/*@}*/

/*!
 * @name Register UART_S2, field RXEDGIF[6] (W1C)
 *
 * RXEDGIF is set when an active edge occurs on the RxD pin. The active edge is
 * falling if RXINV = 0, and rising if RXINV=1. RXEDGIF is cleared by writing a 1
 * to it. See for additional details. RXEDGIF description The active edge is
 * detected only in two wire mode and on receiving data coming from the RxD pin.
 *
 * Values:
 * - 0b0 - No active edge on the receive pin has occurred.
 * - 0b1 - An active edge on the receive pin has occurred.
 */
/*@{*/
/*! @brief Read current value of the UART_S2_RXEDGIF field. */
#define UART_RD_S2_RXEDGIF(base) ((UART_S2_REG(base) & UART_S2_RXEDGIF_MASK) >> UART_S2_RXEDGIF_SHIFT)
#define UART_BRD_S2_RXEDGIF(base) (BME_UBFX8(&UART_S2_REG(base), UART_S2_RXEDGIF_SHIFT, UART_S2_RXEDGIF_WIDTH))

/*! @brief Set the RXEDGIF field to a new value. */
#define UART_WR_S2_RXEDGIF(base, value) (UART_RMW_S2(base, UART_S2_RXEDGIF_MASK, UART_S2_RXEDGIF(value)))
#define UART_BWR_S2_RXEDGIF(base, value) (BME_BFI8(&UART_S2_REG(base), ((uint8_t)(value) << UART_S2_RXEDGIF_SHIFT), UART_S2_RXEDGIF_SHIFT, UART_S2_RXEDGIF_WIDTH))
/*@}*/

/*******************************************************************************
 * UART_C3 - UART Control Register 3
 ******************************************************************************/

/*!
 * @brief UART_C3 - UART Control Register 3 (RW)
 *
 * Reset value: 0x00U
 *
 * Writing R8 does not have any effect. TXDIR and TXINV can be changed only
 * between transmit and receive packets.
 */
/*!
 * @name Constants and macros for entire UART_C3 register
 */
/*@{*/
#define UART_RD_C3(base)         (UART_C3_REG(base))
#define UART_WR_C3(base, value)  (UART_C3_REG(base) = (value))
#define UART_RMW_C3(base, mask, value) (UART_WR_C3(base, (UART_RD_C3(base) & ~(mask)) | (value)))
#define UART_SET_C3(base, value) (BME_OR8(&UART_C3_REG(base), (uint8_t)(value)))
#define UART_CLR_C3(base, value) (BME_AND8(&UART_C3_REG(base), (uint8_t)(~(value))))
#define UART_TOG_C3(base, value) (BME_XOR8(&UART_C3_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual UART_C3 bitfields
 */

/*!
 * @name Register UART_C3, field PEIE[0] (RW)
 *
 * Enables the parity error flag, S1[PF], to generate interrupt requests.
 *
 * Values:
 * - 0b0 - PF interrupt requests are disabled.
 * - 0b1 - PF interrupt requests are enabled.
 */
/*@{*/
/*! @brief Read current value of the UART_C3_PEIE field. */
#define UART_RD_C3_PEIE(base) ((UART_C3_REG(base) & UART_C3_PEIE_MASK) >> UART_C3_PEIE_SHIFT)
#define UART_BRD_C3_PEIE(base) (BME_UBFX8(&UART_C3_REG(base), UART_C3_PEIE_SHIFT, UART_C3_PEIE_WIDTH))

/*! @brief Set the PEIE field to a new value. */
#define UART_WR_C3_PEIE(base, value) (UART_RMW_C3(base, UART_C3_PEIE_MASK, UART_C3_PEIE(value)))
#define UART_BWR_C3_PEIE(base, value) (BME_BFI8(&UART_C3_REG(base), ((uint8_t)(value) << UART_C3_PEIE_SHIFT), UART_C3_PEIE_SHIFT, UART_C3_PEIE_WIDTH))
/*@}*/

/*!
 * @name Register UART_C3, field FEIE[1] (RW)
 *
 * Enables the framing error flag, S1[FE], to generate interrupt requests.
 *
 * Values:
 * - 0b0 - FE interrupt requests are disabled.
 * - 0b1 - FE interrupt requests are enabled.
 */
/*@{*/
/*! @brief Read current value of the UART_C3_FEIE field. */
#define UART_RD_C3_FEIE(base) ((UART_C3_REG(base) & UART_C3_FEIE_MASK) >> UART_C3_FEIE_SHIFT)
#define UART_BRD_C3_FEIE(base) (BME_UBFX8(&UART_C3_REG(base), UART_C3_FEIE_SHIFT, UART_C3_FEIE_WIDTH))

/*! @brief Set the FEIE field to a new value. */
#define UART_WR_C3_FEIE(base, value) (UART_RMW_C3(base, UART_C3_FEIE_MASK, UART_C3_FEIE(value)))
#define UART_BWR_C3_FEIE(base, value) (BME_BFI8(&UART_C3_REG(base), ((uint8_t)(value) << UART_C3_FEIE_SHIFT), UART_C3_FEIE_SHIFT, UART_C3_FEIE_WIDTH))
/*@}*/

/*!
 * @name Register UART_C3, field NEIE[2] (RW)
 *
 * Enables the noise flag, S1[NF], to generate interrupt requests.
 *
 * Values:
 * - 0b0 - NF interrupt requests are disabled.
 * - 0b1 - NF interrupt requests are enabled.
 */
/*@{*/
/*! @brief Read current value of the UART_C3_NEIE field. */
#define UART_RD_C3_NEIE(base) ((UART_C3_REG(base) & UART_C3_NEIE_MASK) >> UART_C3_NEIE_SHIFT)
#define UART_BRD_C3_NEIE(base) (BME_UBFX8(&UART_C3_REG(base), UART_C3_NEIE_SHIFT, UART_C3_NEIE_WIDTH))

/*! @brief Set the NEIE field to a new value. */
#define UART_WR_C3_NEIE(base, value) (UART_RMW_C3(base, UART_C3_NEIE_MASK, UART_C3_NEIE(value)))
#define UART_BWR_C3_NEIE(base, value) (BME_BFI8(&UART_C3_REG(base), ((uint8_t)(value) << UART_C3_NEIE_SHIFT), UART_C3_NEIE_SHIFT, UART_C3_NEIE_WIDTH))
/*@}*/

/*!
 * @name Register UART_C3, field ORIE[3] (RW)
 *
 * Enables the overrun error flag, S1[OR], to generate interrupt requests.
 *
 * Values:
 * - 0b0 - OR interrupts are disabled.
 * - 0b1 - OR interrupt requests are enabled.
 */
/*@{*/
/*! @brief Read current value of the UART_C3_ORIE field. */
#define UART_RD_C3_ORIE(base) ((UART_C3_REG(base) & UART_C3_ORIE_MASK) >> UART_C3_ORIE_SHIFT)
#define UART_BRD_C3_ORIE(base) (BME_UBFX8(&UART_C3_REG(base), UART_C3_ORIE_SHIFT, UART_C3_ORIE_WIDTH))

/*! @brief Set the ORIE field to a new value. */
#define UART_WR_C3_ORIE(base, value) (UART_RMW_C3(base, UART_C3_ORIE_MASK, UART_C3_ORIE(value)))
#define UART_BWR_C3_ORIE(base, value) (BME_BFI8(&UART_C3_REG(base), ((uint8_t)(value) << UART_C3_ORIE_SHIFT), UART_C3_ORIE_SHIFT, UART_C3_ORIE_WIDTH))
/*@}*/

/*!
 * @name Register UART_C3, field TXINV[4] (RW)
 *
 * Setting this field reverses the polarity of the transmitted data output. In
 * NRZ format, a one is represented by a mark and a zero is represented by a space
 * for normal polarity, and the opposite for inverted polarity. This field is
 * automatically set when C7816[INIT] and C7816[ISO7816E] are enabled and an
 * initial character is detected in T = 0 protocol mode. Setting TXINV inverts all
 * transmitted values, including idle, break, start, and stop bits. In loop mode, if
 * TXINV is set, the receiver gets the transmit inversion bit when RXINV is
 * disabled. When C7816[ISO7816E] is set/enabled then only the transmitted data bits
 * and parity bit are inverted.
 *
 * Values:
 * - 0b0 - Transmit data is not inverted.
 * - 0b1 - Transmit data is inverted.
 */
/*@{*/
/*! @brief Read current value of the UART_C3_TXINV field. */
#define UART_RD_C3_TXINV(base) ((UART_C3_REG(base) & UART_C3_TXINV_MASK) >> UART_C3_TXINV_SHIFT)
#define UART_BRD_C3_TXINV(base) (BME_UBFX8(&UART_C3_REG(base), UART_C3_TXINV_SHIFT, UART_C3_TXINV_WIDTH))

/*! @brief Set the TXINV field to a new value. */
#define UART_WR_C3_TXINV(base, value) (UART_RMW_C3(base, UART_C3_TXINV_MASK, UART_C3_TXINV(value)))
#define UART_BWR_C3_TXINV(base, value) (BME_BFI8(&UART_C3_REG(base), ((uint8_t)(value) << UART_C3_TXINV_SHIFT), UART_C3_TXINV_SHIFT, UART_C3_TXINV_WIDTH))
/*@}*/

/*!
 * @name Register UART_C3, field TXDIR[5] (RW)
 *
 * Determines whether the TXD pin is used as an input or output in the
 * single-wire mode of operation. This field is relevant only to the single wire mode.
 * When C7816[ISO7816E] is set/enabled and C7816[TTYPE] = 1, this field is
 * automatically cleared after the requested block is transmitted. This condition is
 * detected when TL7816[TLEN] = 0 and 4 additional characters are transmitted.
 * Additionally, if C7816[ISO7816E] is set/enabled and C7816[TTYPE] = 0 and a NACK is
 * being transmitted, the hardware automatically overrides this field as needed. In
 * this situation, TXDIR does not reflect the temporary state associated with
 * the NACK.
 *
 * Values:
 * - 0b0 - TXD pin is an input in single wire mode.
 * - 0b1 - TXD pin is an output in single wire mode.
 */
/*@{*/
/*! @brief Read current value of the UART_C3_TXDIR field. */
#define UART_RD_C3_TXDIR(base) ((UART_C3_REG(base) & UART_C3_TXDIR_MASK) >> UART_C3_TXDIR_SHIFT)
#define UART_BRD_C3_TXDIR(base) (BME_UBFX8(&UART_C3_REG(base), UART_C3_TXDIR_SHIFT, UART_C3_TXDIR_WIDTH))

/*! @brief Set the TXDIR field to a new value. */
#define UART_WR_C3_TXDIR(base, value) (UART_RMW_C3(base, UART_C3_TXDIR_MASK, UART_C3_TXDIR(value)))
#define UART_BWR_C3_TXDIR(base, value) (BME_BFI8(&UART_C3_REG(base), ((uint8_t)(value) << UART_C3_TXDIR_SHIFT), UART_C3_TXDIR_SHIFT, UART_C3_TXDIR_WIDTH))
/*@}*/

/*!
 * @name Register UART_C3, field T8[6] (RW)
 *
 * T8 is the ninth data bit transmitted when the UART is configured for 9-bit
 * data format, that is, if C1[M] = 1 or C4[M10] = 1. If the value of T8 is the
 * same as in the previous transmission, T8 does not have to be rewritten. The same
 * value is transmitted until T8 is rewritten. To correctly transmit the 9th bit,
 * write UARTx_C3[T8] to the desired value, then write the UARTx_D register with
 * the remaining data.
 */
/*@{*/
/*! @brief Read current value of the UART_C3_T8 field. */
#define UART_RD_C3_T8(base)  ((UART_C3_REG(base) & UART_C3_T8_MASK) >> UART_C3_T8_SHIFT)
#define UART_BRD_C3_T8(base) (BME_UBFX8(&UART_C3_REG(base), UART_C3_T8_SHIFT, UART_C3_T8_WIDTH))

/*! @brief Set the T8 field to a new value. */
#define UART_WR_C3_T8(base, value) (UART_RMW_C3(base, UART_C3_T8_MASK, UART_C3_T8(value)))
#define UART_BWR_C3_T8(base, value) (BME_BFI8(&UART_C3_REG(base), ((uint8_t)(value) << UART_C3_T8_SHIFT), UART_C3_T8_SHIFT, UART_C3_T8_WIDTH))
/*@}*/

/*!
 * @name Register UART_C3, field R8[7] (RO)
 *
 * R8 is the ninth data bit received when the UART is configured for 9-bit data
 * format, that is, if C1[M] = 1 or C4[M10] = 1. The R8 value corresponds to the
 * current data value in the UARTx_D register. To read the 9th bit, read the
 * value of UARTx_C3[R8], then read the UARTx_D register.
 */
/*@{*/
/*! @brief Read current value of the UART_C3_R8 field. */
#define UART_RD_C3_R8(base)  ((UART_C3_REG(base) & UART_C3_R8_MASK) >> UART_C3_R8_SHIFT)
#define UART_BRD_C3_R8(base) (BME_UBFX8(&UART_C3_REG(base), UART_C3_R8_SHIFT, UART_C3_R8_WIDTH))
/*@}*/

/*******************************************************************************
 * UART_D - UART Data Register
 ******************************************************************************/

/*!
 * @brief UART_D - UART Data Register (RW)
 *
 * Reset value: 0x00U
 *
 * This register is actually two separate registers. Reads return the contents
 * of the read-only receive data register and writes go to the write-only transmit
 * data register. In 8-bit or 9-bit data format, only UART data register (D)
 * needs to be accessed to clear the S1[RDRF] bit (assuming receiver buffer level is
 * less than RWFIFO[RXWATER]). The C3 register needs to be read, prior to the D
 * register, only if the ninth bit of data needs to be captured. Similarly, the
 * ED register needs to be read, prior to the D register, only if the additional
 * flag data for the dataword needs to be captured. In the normal 8-bit mode (M
 * bit cleared) if the parity is enabled, you get seven data bits and one parity
 * bit. That one parity bit is loaded into the D register. So, for the data bits,
 * mask off the parity bit from the value you read out of this register. When
 * transmitting in 9-bit data format and using 8-bit write instructions, write first
 * to transmit bit 8 in UART control register 3 (C3[T8]), then D. A write to
 * C3[T8] stores the data in a temporary register. If D register is written first,
 * and then the new data on data bus is stored in D, the temporary value written by
 * the last write to C3[T8] gets stored in the C3[T8] register.
 */
/*!
 * @name Constants and macros for entire UART_D register
 */
/*@{*/
#define UART_RD_D(base)          (UART_D_REG(base))
#define UART_WR_D(base, value)   (UART_D_REG(base) = (value))
#define UART_RMW_D(base, mask, value) (UART_WR_D(base, (UART_RD_D(base) & ~(mask)) | (value)))
#define UART_SET_D(base, value)  (BME_OR8(&UART_D_REG(base), (uint8_t)(value)))
#define UART_CLR_D(base, value)  (BME_AND8(&UART_D_REG(base), (uint8_t)(~(value))))
#define UART_TOG_D(base, value)  (BME_XOR8(&UART_D_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * UART_MA1 - UART Match Address Registers 1
 ******************************************************************************/

/*!
 * @brief UART_MA1 - UART Match Address Registers 1 (RW)
 *
 * Reset value: 0x00U
 *
 * The MA1 and MA2 registers are compared to input data addresses when the most
 * significant bit is set and the associated C4[MAEN] field is set. If a match
 * occurs, the following data is transferred to the data register. If a match
 * fails, the following data is discarded. These registers can be read and written at
 * anytime.
 */
/*!
 * @name Constants and macros for entire UART_MA1 register
 */
/*@{*/
#define UART_RD_MA1(base)        (UART_MA1_REG(base))
#define UART_WR_MA1(base, value) (UART_MA1_REG(base) = (value))
#define UART_RMW_MA1(base, mask, value) (UART_WR_MA1(base, (UART_RD_MA1(base) & ~(mask)) | (value)))
#define UART_SET_MA1(base, value) (BME_OR8(&UART_MA1_REG(base), (uint8_t)(value)))
#define UART_CLR_MA1(base, value) (BME_AND8(&UART_MA1_REG(base), (uint8_t)(~(value))))
#define UART_TOG_MA1(base, value) (BME_XOR8(&UART_MA1_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * UART_MA2 - UART Match Address Registers 2
 ******************************************************************************/

/*!
 * @brief UART_MA2 - UART Match Address Registers 2 (RW)
 *
 * Reset value: 0x00U
 *
 * These registers can be read and written at anytime. The MA1 and MA2 registers
 * are compared to input data addresses when the most significant bit is set and
 * the associated C4[MAEN] field is set. If a match occurs, the following data
 * is transferred to the data register. If a match fails, the following data is
 * discarded.
 */
/*!
 * @name Constants and macros for entire UART_MA2 register
 */
/*@{*/
#define UART_RD_MA2(base)        (UART_MA2_REG(base))
#define UART_WR_MA2(base, value) (UART_MA2_REG(base) = (value))
#define UART_RMW_MA2(base, mask, value) (UART_WR_MA2(base, (UART_RD_MA2(base) & ~(mask)) | (value)))
#define UART_SET_MA2(base, value) (BME_OR8(&UART_MA2_REG(base), (uint8_t)(value)))
#define UART_CLR_MA2(base, value) (BME_AND8(&UART_MA2_REG(base), (uint8_t)(~(value))))
#define UART_TOG_MA2(base, value) (BME_XOR8(&UART_MA2_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * UART_C4 - UART Control Register 4
 ******************************************************************************/

/*!
 * @brief UART_C4 - UART Control Register 4 (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire UART_C4 register
 */
/*@{*/
#define UART_RD_C4(base)         (UART_C4_REG(base))
#define UART_WR_C4(base, value)  (UART_C4_REG(base) = (value))
#define UART_RMW_C4(base, mask, value) (UART_WR_C4(base, (UART_RD_C4(base) & ~(mask)) | (value)))
#define UART_SET_C4(base, value) (BME_OR8(&UART_C4_REG(base), (uint8_t)(value)))
#define UART_CLR_C4(base, value) (BME_AND8(&UART_C4_REG(base), (uint8_t)(~(value))))
#define UART_TOG_C4(base, value) (BME_XOR8(&UART_C4_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual UART_C4 bitfields
 */

/*!
 * @name Register UART_C4, field BRFA[4:0] (RW)
 *
 * This bit field is used to add more timing resolution to the average baud
 * frequency, in increments of 1/32. See Baud rate generation for more information.
 */
/*@{*/
/*! @brief Read current value of the UART_C4_BRFA field. */
#define UART_RD_C4_BRFA(base) ((UART_C4_REG(base) & UART_C4_BRFA_MASK) >> UART_C4_BRFA_SHIFT)
#define UART_BRD_C4_BRFA(base) (BME_UBFX8(&UART_C4_REG(base), UART_C4_BRFA_SHIFT, UART_C4_BRFA_WIDTH))

/*! @brief Set the BRFA field to a new value. */
#define UART_WR_C4_BRFA(base, value) (UART_RMW_C4(base, UART_C4_BRFA_MASK, UART_C4_BRFA(value)))
#define UART_BWR_C4_BRFA(base, value) (BME_BFI8(&UART_C4_REG(base), ((uint8_t)(value) << UART_C4_BRFA_SHIFT), UART_C4_BRFA_SHIFT, UART_C4_BRFA_WIDTH))
/*@}*/

/*!
 * @name Register UART_C4, field M10[5] (RW)
 *
 * Causes a tenth, non-memory mapped bit to be part of the serial transmission.
 * This tenth bit is generated and interpreted as a parity bit. If M10 is set,
 * then both C1[M] and C1[PE] must also be set. This field must be cleared when
 * C7816[ISO7816E] is set/enabled. See Data format (non ISO-7816) for more
 * information.
 *
 * Values:
 * - 0b0 - The parity bit is the ninth bit in the serial transmission.
 * - 0b1 - The parity bit is the tenth bit in the serial transmission.
 */
/*@{*/
/*! @brief Read current value of the UART_C4_M10 field. */
#define UART_RD_C4_M10(base) ((UART_C4_REG(base) & UART_C4_M10_MASK) >> UART_C4_M10_SHIFT)
#define UART_BRD_C4_M10(base) (BME_UBFX8(&UART_C4_REG(base), UART_C4_M10_SHIFT, UART_C4_M10_WIDTH))

/*! @brief Set the M10 field to a new value. */
#define UART_WR_C4_M10(base, value) (UART_RMW_C4(base, UART_C4_M10_MASK, UART_C4_M10(value)))
#define UART_BWR_C4_M10(base, value) (BME_BFI8(&UART_C4_REG(base), ((uint8_t)(value) << UART_C4_M10_SHIFT), UART_C4_M10_SHIFT, UART_C4_M10_WIDTH))
/*@}*/

/*!
 * @name Register UART_C4, field MAEN2[6] (RW)
 *
 * See Match address operation for more information.
 *
 * Values:
 * - 0b0 - All data received is transferred to the data buffer if MAEN1 is
 *     cleared.
 * - 0b1 - All data received with the most significant bit cleared, is
 *     discarded. All data received with the most significant bit set, is compared with
 *     contents of MA2 register. If no match occurs, the data is discarded. If a
 *     match occurs, data is transferred to the data buffer. This field must be
 *     cleared when C7816[ISO7816E] is set/enabled.
 */
/*@{*/
/*! @brief Read current value of the UART_C4_MAEN2 field. */
#define UART_RD_C4_MAEN2(base) ((UART_C4_REG(base) & UART_C4_MAEN2_MASK) >> UART_C4_MAEN2_SHIFT)
#define UART_BRD_C4_MAEN2(base) (BME_UBFX8(&UART_C4_REG(base), UART_C4_MAEN2_SHIFT, UART_C4_MAEN2_WIDTH))

/*! @brief Set the MAEN2 field to a new value. */
#define UART_WR_C4_MAEN2(base, value) (UART_RMW_C4(base, UART_C4_MAEN2_MASK, UART_C4_MAEN2(value)))
#define UART_BWR_C4_MAEN2(base, value) (BME_BFI8(&UART_C4_REG(base), ((uint8_t)(value) << UART_C4_MAEN2_SHIFT), UART_C4_MAEN2_SHIFT, UART_C4_MAEN2_WIDTH))
/*@}*/

/*!
 * @name Register UART_C4, field MAEN1[7] (RW)
 *
 * See Match address operation for more information.
 *
 * Values:
 * - 0b0 - All data received is transferred to the data buffer if MAEN2 is
 *     cleared.
 * - 0b1 - All data received with the most significant bit cleared, is
 *     discarded. All data received with the most significant bit set, is compared with
 *     contents of MA1 register. If no match occurs, the data is discarded. If
 *     match occurs, data is transferred to the data buffer. This field must be
 *     cleared when C7816[ISO7816E] is set/enabled.
 */
/*@{*/
/*! @brief Read current value of the UART_C4_MAEN1 field. */
#define UART_RD_C4_MAEN1(base) ((UART_C4_REG(base) & UART_C4_MAEN1_MASK) >> UART_C4_MAEN1_SHIFT)
#define UART_BRD_C4_MAEN1(base) (BME_UBFX8(&UART_C4_REG(base), UART_C4_MAEN1_SHIFT, UART_C4_MAEN1_WIDTH))

/*! @brief Set the MAEN1 field to a new value. */
#define UART_WR_C4_MAEN1(base, value) (UART_RMW_C4(base, UART_C4_MAEN1_MASK, UART_C4_MAEN1(value)))
#define UART_BWR_C4_MAEN1(base, value) (BME_BFI8(&UART_C4_REG(base), ((uint8_t)(value) << UART_C4_MAEN1_SHIFT), UART_C4_MAEN1_SHIFT, UART_C4_MAEN1_WIDTH))
/*@}*/

/*******************************************************************************
 * UART_C5 - UART Control Register 5
 ******************************************************************************/

/*!
 * @brief UART_C5 - UART Control Register 5 (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire UART_C5 register
 */
/*@{*/
#define UART_RD_C5(base)         (UART_C5_REG(base))
#define UART_WR_C5(base, value)  (UART_C5_REG(base) = (value))
#define UART_RMW_C5(base, mask, value) (UART_WR_C5(base, (UART_RD_C5(base) & ~(mask)) | (value)))
#define UART_SET_C5(base, value) (BME_OR8(&UART_C5_REG(base), (uint8_t)(value)))
#define UART_CLR_C5(base, value) (BME_AND8(&UART_C5_REG(base), (uint8_t)(~(value))))
#define UART_TOG_C5(base, value) (BME_XOR8(&UART_C5_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual UART_C5 bitfields
 */

/*!
 * @name Register UART_C5, field ILDMAS[4] (RW)
 *
 * Configures the idle line flag, S1[IDLE], to generate interrupt or DMA
 * requests if C2[ILIE] is set. If C2[ILIE] is cleared, and S1[IDLE] is set, the IDLE
 * DMA and IDLE interrupt request signals are not asserted, regardless of the state
 * of ILDMAS.
 *
 * Values:
 * - 0b0 - If C2[ILIE] and S1[IDLE] are set, the IDLE interrupt request signal
 *     is asserted to request an interrupt service.
 * - 0b1 - If C2[ILIE] and S1[IDLE] are set, the IDLE DMA request signal is
 *     asserted to request a DMA transfer.
 */
/*@{*/
/*! @brief Read current value of the UART_C5_ILDMAS field. */
#define UART_RD_C5_ILDMAS(base) ((UART_C5_REG(base) & UART_C5_ILDMAS_MASK) >> UART_C5_ILDMAS_SHIFT)
#define UART_BRD_C5_ILDMAS(base) (BME_UBFX8(&UART_C5_REG(base), UART_C5_ILDMAS_SHIFT, UART_C5_ILDMAS_WIDTH))

/*! @brief Set the ILDMAS field to a new value. */
#define UART_WR_C5_ILDMAS(base, value) (UART_RMW_C5(base, UART_C5_ILDMAS_MASK, UART_C5_ILDMAS(value)))
#define UART_BWR_C5_ILDMAS(base, value) (BME_BFI8(&UART_C5_REG(base), ((uint8_t)(value) << UART_C5_ILDMAS_SHIFT), UART_C5_ILDMAS_SHIFT, UART_C5_ILDMAS_WIDTH))
/*@}*/

/*!
 * @name Register UART_C5, field RDMAS[5] (RW)
 *
 * Configures the receiver data register full flag, S1[RDRF], to generate
 * interrupt or DMA requests if C2[RIE] is set. If C2[RIE] is cleared, and S1[RDRF] is
 * set, the RDRF DMA and RDFR interrupt request signals are not asserted,
 * regardless of the state of RDMAS.
 *
 * Values:
 * - 0b0 - If C2[RIE] and S1[RDRF] are set, the RDFR interrupt request signal is
 *     asserted to request an interrupt service.
 * - 0b1 - If C2[RIE] and S1[RDRF] are set, the RDRF DMA request signal is
 *     asserted to request a DMA transfer.
 */
/*@{*/
/*! @brief Read current value of the UART_C5_RDMAS field. */
#define UART_RD_C5_RDMAS(base) ((UART_C5_REG(base) & UART_C5_RDMAS_MASK) >> UART_C5_RDMAS_SHIFT)
#define UART_BRD_C5_RDMAS(base) (BME_UBFX8(&UART_C5_REG(base), UART_C5_RDMAS_SHIFT, UART_C5_RDMAS_WIDTH))

/*! @brief Set the RDMAS field to a new value. */
#define UART_WR_C5_RDMAS(base, value) (UART_RMW_C5(base, UART_C5_RDMAS_MASK, UART_C5_RDMAS(value)))
#define UART_BWR_C5_RDMAS(base, value) (BME_BFI8(&UART_C5_REG(base), ((uint8_t)(value) << UART_C5_RDMAS_SHIFT), UART_C5_RDMAS_SHIFT, UART_C5_RDMAS_WIDTH))
/*@}*/

/*!
 * @name Register UART_C5, field TDMAS[7] (RW)
 *
 * Configures the transmit data register empty flag, S1[TDRE], to generate
 * interrupt or DMA requests if C2[TIE] is set. If C2[TIE] is cleared, TDRE DMA and
 * TDRE interrupt request signals are not asserted when the TDRE flag is set,
 * regardless of the state of TDMAS. If C2[TIE] and TDMAS are both set, then C2[TCIE]
 * must be cleared, and D must not be written unless a DMA request is being
 * serviced.
 *
 * Values:
 * - 0b0 - If C2[TIE] is set and the S1[TDRE] flag is set, the TDRE interrupt
 *     request signal is asserted to request interrupt service.
 * - 0b1 - If C2[TIE] is set and the S1[TDRE] flag is set, the TDRE DMA request
 *     signal is asserted to request a DMA transfer.
 */
/*@{*/
/*! @brief Read current value of the UART_C5_TDMAS field. */
#define UART_RD_C5_TDMAS(base) ((UART_C5_REG(base) & UART_C5_TDMAS_MASK) >> UART_C5_TDMAS_SHIFT)
#define UART_BRD_C5_TDMAS(base) (BME_UBFX8(&UART_C5_REG(base), UART_C5_TDMAS_SHIFT, UART_C5_TDMAS_WIDTH))

/*! @brief Set the TDMAS field to a new value. */
#define UART_WR_C5_TDMAS(base, value) (UART_RMW_C5(base, UART_C5_TDMAS_MASK, UART_C5_TDMAS(value)))
#define UART_BWR_C5_TDMAS(base, value) (BME_BFI8(&UART_C5_REG(base), ((uint8_t)(value) << UART_C5_TDMAS_SHIFT), UART_C5_TDMAS_SHIFT, UART_C5_TDMAS_WIDTH))
/*@}*/

/*******************************************************************************
 * UART_ED - UART Extended Data Register
 ******************************************************************************/

/*!
 * @brief UART_ED - UART Extended Data Register (RO)
 *
 * Reset value: 0x00U
 *
 * This register contains additional information flags that are stored with a
 * received dataword. This register may be read at any time but contains valid data
 * only if there is a dataword in the receive FIFO. The data contained in this
 * register represents additional information regarding the conditions on which a
 * dataword was received. The importance of this data varies with the
 * application, and in some cases maybe completely optional. These fields automatically
 * update to reflect the conditions of the next dataword whenever D is read. If
 * S1[NF] and S1[PF] have not been set since the last time the receive buffer was
 * empty, the NOISY and PARITYE fields will be zero.
 */
/*!
 * @name Constants and macros for entire UART_ED register
 */
/*@{*/
#define UART_RD_ED(base)         (UART_ED_REG(base))
/*@}*/

/*
 * Constants & macros for individual UART_ED bitfields
 */

/*!
 * @name Register UART_ED, field PARITYE[6] (RO)
 *
 * The current received dataword contained in D and C3[R8] was received with a
 * parity error.
 *
 * Values:
 * - 0b0 - The dataword was received without a parity error.
 * - 0b1 - The dataword was received with a parity error.
 */
/*@{*/
/*! @brief Read current value of the UART_ED_PARITYE field. */
#define UART_RD_ED_PARITYE(base) ((UART_ED_REG(base) & UART_ED_PARITYE_MASK) >> UART_ED_PARITYE_SHIFT)
#define UART_BRD_ED_PARITYE(base) (BME_UBFX8(&UART_ED_REG(base), UART_ED_PARITYE_SHIFT, UART_ED_PARITYE_WIDTH))
/*@}*/

/*!
 * @name Register UART_ED, field NOISY[7] (RO)
 *
 * The current received dataword contained in D and C3[R8] was received with
 * noise.
 *
 * Values:
 * - 0b0 - The dataword was received without noise.
 * - 0b1 - The data was received with noise.
 */
/*@{*/
/*! @brief Read current value of the UART_ED_NOISY field. */
#define UART_RD_ED_NOISY(base) ((UART_ED_REG(base) & UART_ED_NOISY_MASK) >> UART_ED_NOISY_SHIFT)
#define UART_BRD_ED_NOISY(base) (BME_UBFX8(&UART_ED_REG(base), UART_ED_NOISY_SHIFT, UART_ED_NOISY_WIDTH))
/*@}*/

/*******************************************************************************
 * UART_MODEM - UART Modem Register
 ******************************************************************************/

/*!
 * @brief UART_MODEM - UART Modem Register (RW)
 *
 * Reset value: 0x00U
 *
 * The MODEM register controls options for setting the modem configuration.
 * RXRTSE, TXRTSPOL, TXRTSE, and TXCTSE must all be cleared when C7816[ISO7816EN] is
 * enabled. This will cause the RTS to deassert during ISO-7816 wait times. The
 * ISO-7816 protocol does not use the RTS and CTS signals.
 */
/*!
 * @name Constants and macros for entire UART_MODEM register
 */
/*@{*/
#define UART_RD_MODEM(base)      (UART_MODEM_REG(base))
#define UART_WR_MODEM(base, value) (UART_MODEM_REG(base) = (value))
#define UART_RMW_MODEM(base, mask, value) (UART_WR_MODEM(base, (UART_RD_MODEM(base) & ~(mask)) | (value)))
#define UART_SET_MODEM(base, value) (BME_OR8(&UART_MODEM_REG(base), (uint8_t)(value)))
#define UART_CLR_MODEM(base, value) (BME_AND8(&UART_MODEM_REG(base), (uint8_t)(~(value))))
#define UART_TOG_MODEM(base, value) (BME_XOR8(&UART_MODEM_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual UART_MODEM bitfields
 */

/*!
 * @name Register UART_MODEM, field TXCTSE[0] (RW)
 *
 * TXCTSE controls the operation of the transmitter. TXCTSE can be set
 * independently from the state of TXRTSE and RXRTSE.
 *
 * Values:
 * - 0b0 - CTS has no effect on the transmitter.
 * - 0b1 - Enables clear-to-send operation. The transmitter checks the state of
 *     CTS each time it is ready to send a character. If CTS is asserted, the
 *     character is sent. If CTS is deasserted, the signal TXD remains in the mark
 *     state and transmission is delayed until CTS is asserted. Changes in CTS as
 *     a character is being sent do not affect its transmission.
 */
/*@{*/
/*! @brief Read current value of the UART_MODEM_TXCTSE field. */
#define UART_RD_MODEM_TXCTSE(base) ((UART_MODEM_REG(base) & UART_MODEM_TXCTSE_MASK) >> UART_MODEM_TXCTSE_SHIFT)
#define UART_BRD_MODEM_TXCTSE(base) (BME_UBFX8(&UART_MODEM_REG(base), UART_MODEM_TXCTSE_SHIFT, UART_MODEM_TXCTSE_WIDTH))

/*! @brief Set the TXCTSE field to a new value. */
#define UART_WR_MODEM_TXCTSE(base, value) (UART_RMW_MODEM(base, UART_MODEM_TXCTSE_MASK, UART_MODEM_TXCTSE(value)))
#define UART_BWR_MODEM_TXCTSE(base, value) (BME_BFI8(&UART_MODEM_REG(base), ((uint8_t)(value) << UART_MODEM_TXCTSE_SHIFT), UART_MODEM_TXCTSE_SHIFT, UART_MODEM_TXCTSE_WIDTH))
/*@}*/

/*!
 * @name Register UART_MODEM, field TXRTSE[1] (RW)
 *
 * Controls RTS before and after a transmission.
 *
 * Values:
 * - 0b0 - The transmitter has no effect on RTS.
 * - 0b1 - When a character is placed into an empty transmitter data buffer ,
 *     RTS asserts one bit time before the start bit is transmitted. RTS deasserts
 *     one bit time after all characters in the transmitter data buffer and shift
 *     register are completely sent, including the last stop bit. (FIFO) (FIFO)
 */
/*@{*/
/*! @brief Read current value of the UART_MODEM_TXRTSE field. */
#define UART_RD_MODEM_TXRTSE(base) ((UART_MODEM_REG(base) & UART_MODEM_TXRTSE_MASK) >> UART_MODEM_TXRTSE_SHIFT)
#define UART_BRD_MODEM_TXRTSE(base) (BME_UBFX8(&UART_MODEM_REG(base), UART_MODEM_TXRTSE_SHIFT, UART_MODEM_TXRTSE_WIDTH))

/*! @brief Set the TXRTSE field to a new value. */
#define UART_WR_MODEM_TXRTSE(base, value) (UART_RMW_MODEM(base, UART_MODEM_TXRTSE_MASK, UART_MODEM_TXRTSE(value)))
#define UART_BWR_MODEM_TXRTSE(base, value) (BME_BFI8(&UART_MODEM_REG(base), ((uint8_t)(value) << UART_MODEM_TXRTSE_SHIFT), UART_MODEM_TXRTSE_SHIFT, UART_MODEM_TXRTSE_WIDTH))
/*@}*/

/*!
 * @name Register UART_MODEM, field TXRTSPOL[2] (RW)
 *
 * Controls the polarity of the transmitter RTS. TXRTSPOL does not affect the
 * polarity of the receiver RTS. RTS will remain negated in the active low state
 * unless TXRTSE is set.
 *
 * Values:
 * - 0b0 - Transmitter RTS is active low.
 * - 0b1 - Transmitter RTS is active high.
 */
/*@{*/
/*! @brief Read current value of the UART_MODEM_TXRTSPOL field. */
#define UART_RD_MODEM_TXRTSPOL(base) ((UART_MODEM_REG(base) & UART_MODEM_TXRTSPOL_MASK) >> UART_MODEM_TXRTSPOL_SHIFT)
#define UART_BRD_MODEM_TXRTSPOL(base) (BME_UBFX8(&UART_MODEM_REG(base), UART_MODEM_TXRTSPOL_SHIFT, UART_MODEM_TXRTSPOL_WIDTH))

/*! @brief Set the TXRTSPOL field to a new value. */
#define UART_WR_MODEM_TXRTSPOL(base, value) (UART_RMW_MODEM(base, UART_MODEM_TXRTSPOL_MASK, UART_MODEM_TXRTSPOL(value)))
#define UART_BWR_MODEM_TXRTSPOL(base, value) (BME_BFI8(&UART_MODEM_REG(base), ((uint8_t)(value) << UART_MODEM_TXRTSPOL_SHIFT), UART_MODEM_TXRTSPOL_SHIFT, UART_MODEM_TXRTSPOL_WIDTH))
/*@}*/

/*!
 * @name Register UART_MODEM, field RXRTSE[3] (RW)
 *
 * Allows the RTS output to control the CTS input of the transmitting device to
 * prevent receiver overrun. Do not set both RXRTSE and TXRTSE.
 *
 * Values:
 * - 0b0 - The receiver has no effect on RTS.
 * - 0b1 - RTS is deasserted if the number of characters in the receiver data
 *     register (FIFO) is equal to or greater than RWFIFO[RXWATER]. RTS is asserted
 *     when the number of characters in the receiver data register (FIFO) is
 *     less than RWFIFO[RXWATER]. See Hardware flow control
 */
/*@{*/
/*! @brief Read current value of the UART_MODEM_RXRTSE field. */
#define UART_RD_MODEM_RXRTSE(base) ((UART_MODEM_REG(base) & UART_MODEM_RXRTSE_MASK) >> UART_MODEM_RXRTSE_SHIFT)
#define UART_BRD_MODEM_RXRTSE(base) (BME_UBFX8(&UART_MODEM_REG(base), UART_MODEM_RXRTSE_SHIFT, UART_MODEM_RXRTSE_WIDTH))

/*! @brief Set the RXRTSE field to a new value. */
#define UART_WR_MODEM_RXRTSE(base, value) (UART_RMW_MODEM(base, UART_MODEM_RXRTSE_MASK, UART_MODEM_RXRTSE(value)))
#define UART_BWR_MODEM_RXRTSE(base, value) (BME_BFI8(&UART_MODEM_REG(base), ((uint8_t)(value) << UART_MODEM_RXRTSE_SHIFT), UART_MODEM_RXRTSE_SHIFT, UART_MODEM_RXRTSE_WIDTH))
/*@}*/

/*******************************************************************************
 * UART_PFIFO - UART FIFO Parameters
 ******************************************************************************/

/*!
 * @brief UART_PFIFO - UART FIFO Parameters (RW)
 *
 * Reset value: 0x00U
 *
 * This register provides the ability for the programmer to turn on and off FIFO
 * functionality. It also provides the size of the FIFO that has been
 * implemented. This register may be read at any time. This register must be written only
 * when C2[RE] and C2[TE] are cleared/not set and when the data buffer/FIFO is
 * empty.
 */
/*!
 * @name Constants and macros for entire UART_PFIFO register
 */
/*@{*/
#define UART_RD_PFIFO(base)      (UART_PFIFO_REG(base))
#define UART_WR_PFIFO(base, value) (UART_PFIFO_REG(base) = (value))
#define UART_RMW_PFIFO(base, mask, value) (UART_WR_PFIFO(base, (UART_RD_PFIFO(base) & ~(mask)) | (value)))
#define UART_SET_PFIFO(base, value) (BME_OR8(&UART_PFIFO_REG(base), (uint8_t)(value)))
#define UART_CLR_PFIFO(base, value) (BME_AND8(&UART_PFIFO_REG(base), (uint8_t)(~(value))))
#define UART_TOG_PFIFO(base, value) (BME_XOR8(&UART_PFIFO_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual UART_PFIFO bitfields
 */

/*!
 * @name Register UART_PFIFO, field RXFIFOSIZE[2:0] (RO)
 *
 * The maximum number of receive datawords that can be stored in the receive
 * buffer before an overrun occurs. This field is read only.
 *
 * Values:
 * - 0b000 - Receive FIFO/Buffer depth = 1 dataword.
 * - 0b001 - Receive FIFO/Buffer depth = 4 datawords.
 * - 0b010 - Receive FIFO/Buffer depth = 8 datawords.
 * - 0b011 - Receive FIFO/Buffer depth = 16 datawords.
 * - 0b100 - Receive FIFO/Buffer depth = 32 datawords.
 * - 0b101 - Receive FIFO/Buffer depth = 64 datawords.
 * - 0b110 - Receive FIFO/Buffer depth = 128 datawords.
 * - 0b111 - Reserved.
 */
/*@{*/
/*! @brief Read current value of the UART_PFIFO_RXFIFOSIZE field. */
#define UART_RD_PFIFO_RXFIFOSIZE(base) ((UART_PFIFO_REG(base) & UART_PFIFO_RXFIFOSIZE_MASK) >> UART_PFIFO_RXFIFOSIZE_SHIFT)
#define UART_BRD_PFIFO_RXFIFOSIZE(base) (BME_UBFX8(&UART_PFIFO_REG(base), UART_PFIFO_RXFIFOSIZE_SHIFT, UART_PFIFO_RXFIFOSIZE_WIDTH))
/*@}*/

/*!
 * @name Register UART_PFIFO, field RXFE[3] (RW)
 *
 * When this field is set, the built in FIFO structure for the receive buffer is
 * enabled. The size of the FIFO structure is indicated by the RXFIFOSIZE field.
 * If this field is not set, the receive buffer operates as a FIFO of depth one
 * dataword regardless of the value in RXFIFOSIZE. Both C2[TE] and C2[RE] must be
 * cleared prior to changing this field. Additionally, TXFLUSH and RXFLUSH
 * commands must be issued immediately after changing this field.
 *
 * Values:
 * - 0b0 - Receive FIFO is not enabled. Buffer is depth 1. (Legacy support)
 * - 0b1 - Receive FIFO is enabled. Buffer is depth indicted by RXFIFOSIZE.
 */
/*@{*/
/*! @brief Read current value of the UART_PFIFO_RXFE field. */
#define UART_RD_PFIFO_RXFE(base) ((UART_PFIFO_REG(base) & UART_PFIFO_RXFE_MASK) >> UART_PFIFO_RXFE_SHIFT)
#define UART_BRD_PFIFO_RXFE(base) (BME_UBFX8(&UART_PFIFO_REG(base), UART_PFIFO_RXFE_SHIFT, UART_PFIFO_RXFE_WIDTH))

/*! @brief Set the RXFE field to a new value. */
#define UART_WR_PFIFO_RXFE(base, value) (UART_RMW_PFIFO(base, UART_PFIFO_RXFE_MASK, UART_PFIFO_RXFE(value)))
#define UART_BWR_PFIFO_RXFE(base, value) (BME_BFI8(&UART_PFIFO_REG(base), ((uint8_t)(value) << UART_PFIFO_RXFE_SHIFT), UART_PFIFO_RXFE_SHIFT, UART_PFIFO_RXFE_WIDTH))
/*@}*/

/*!
 * @name Register UART_PFIFO, field TXFIFOSIZE[6:4] (RO)
 *
 * The maximum number of transmit datawords that can be stored in the transmit
 * buffer. This field is read only.
 *
 * Values:
 * - 0b000 - Transmit FIFO/Buffer depth = 1 dataword.
 * - 0b001 - Transmit FIFO/Buffer depth = 4 datawords.
 * - 0b010 - Transmit FIFO/Buffer depth = 8 datawords.
 * - 0b011 - Transmit FIFO/Buffer depth = 16 datawords.
 * - 0b100 - Transmit FIFO/Buffer depth = 32 datawords.
 * - 0b101 - Transmit FIFO/Buffer depth = 64 datawords.
 * - 0b110 - Transmit FIFO/Buffer depth = 128 datawords.
 * - 0b111 - Reserved.
 */
/*@{*/
/*! @brief Read current value of the UART_PFIFO_TXFIFOSIZE field. */
#define UART_RD_PFIFO_TXFIFOSIZE(base) ((UART_PFIFO_REG(base) & UART_PFIFO_TXFIFOSIZE_MASK) >> UART_PFIFO_TXFIFOSIZE_SHIFT)
#define UART_BRD_PFIFO_TXFIFOSIZE(base) (BME_UBFX8(&UART_PFIFO_REG(base), UART_PFIFO_TXFIFOSIZE_SHIFT, UART_PFIFO_TXFIFOSIZE_WIDTH))
/*@}*/

/*!
 * @name Register UART_PFIFO, field TXFE[7] (RW)
 *
 * When this field is set, the built in FIFO structure for the transmit buffer
 * is enabled. The size of the FIFO structure is indicated by TXFIFOSIZE. If this
 * field is not set, the transmit buffer operates as a FIFO of depth one dataword
 * regardless of the value in TXFIFOSIZE. Both C2[TE] and C2[RE] must be cleared
 * prior to changing this field. Additionally, TXFLUSH and RXFLUSH commands must
 * be issued immediately after changing this field.
 *
 * Values:
 * - 0b0 - Transmit FIFO is not enabled. Buffer is depth 1. (Legacy support).
 * - 0b1 - Transmit FIFO is enabled. Buffer is depth indicated by TXFIFOSIZE.
 */
/*@{*/
/*! @brief Read current value of the UART_PFIFO_TXFE field. */
#define UART_RD_PFIFO_TXFE(base) ((UART_PFIFO_REG(base) & UART_PFIFO_TXFE_MASK) >> UART_PFIFO_TXFE_SHIFT)
#define UART_BRD_PFIFO_TXFE(base) (BME_UBFX8(&UART_PFIFO_REG(base), UART_PFIFO_TXFE_SHIFT, UART_PFIFO_TXFE_WIDTH))

/*! @brief Set the TXFE field to a new value. */
#define UART_WR_PFIFO_TXFE(base, value) (UART_RMW_PFIFO(base, UART_PFIFO_TXFE_MASK, UART_PFIFO_TXFE(value)))
#define UART_BWR_PFIFO_TXFE(base, value) (BME_BFI8(&UART_PFIFO_REG(base), ((uint8_t)(value) << UART_PFIFO_TXFE_SHIFT), UART_PFIFO_TXFE_SHIFT, UART_PFIFO_TXFE_WIDTH))
/*@}*/

/*******************************************************************************
 * UART_CFIFO - UART FIFO Control Register
 ******************************************************************************/

/*!
 * @brief UART_CFIFO - UART FIFO Control Register (RW)
 *
 * Reset value: 0x00U
 *
 * This register provides the ability to program various control fields for FIFO
 * operation. This register may be read or written at any time. Note that
 * writing to TXFLUSH and RXFLUSH may result in data loss and requires careful action
 * to prevent unintended/unpredictable behavior. Therefore, it is recommended that
 * TE and RE be cleared prior to flushing the corresponding FIFO.
 */
/*!
 * @name Constants and macros for entire UART_CFIFO register
 */
/*@{*/
#define UART_RD_CFIFO(base)      (UART_CFIFO_REG(base))
#define UART_WR_CFIFO(base, value) (UART_CFIFO_REG(base) = (value))
#define UART_RMW_CFIFO(base, mask, value) (UART_WR_CFIFO(base, (UART_RD_CFIFO(base) & ~(mask)) | (value)))
#define UART_SET_CFIFO(base, value) (BME_OR8(&UART_CFIFO_REG(base), (uint8_t)(value)))
#define UART_CLR_CFIFO(base, value) (BME_AND8(&UART_CFIFO_REG(base), (uint8_t)(~(value))))
#define UART_TOG_CFIFO(base, value) (BME_XOR8(&UART_CFIFO_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual UART_CFIFO bitfields
 */

/*!
 * @name Register UART_CFIFO, field RXUFE[0] (RW)
 *
 * When this field is set, the RXUF flag generates an interrupt to the host.
 *
 * Values:
 * - 0b0 - RXUF flag does not generate an interrupt to the host.
 * - 0b1 - RXUF flag generates an interrupt to the host.
 */
/*@{*/
/*! @brief Read current value of the UART_CFIFO_RXUFE field. */
#define UART_RD_CFIFO_RXUFE(base) ((UART_CFIFO_REG(base) & UART_CFIFO_RXUFE_MASK) >> UART_CFIFO_RXUFE_SHIFT)
#define UART_BRD_CFIFO_RXUFE(base) (BME_UBFX8(&UART_CFIFO_REG(base), UART_CFIFO_RXUFE_SHIFT, UART_CFIFO_RXUFE_WIDTH))

/*! @brief Set the RXUFE field to a new value. */
#define UART_WR_CFIFO_RXUFE(base, value) (UART_RMW_CFIFO(base, UART_CFIFO_RXUFE_MASK, UART_CFIFO_RXUFE(value)))
#define UART_BWR_CFIFO_RXUFE(base, value) (BME_BFI8(&UART_CFIFO_REG(base), ((uint8_t)(value) << UART_CFIFO_RXUFE_SHIFT), UART_CFIFO_RXUFE_SHIFT, UART_CFIFO_RXUFE_WIDTH))
/*@}*/

/*!
 * @name Register UART_CFIFO, field TXOFE[1] (RW)
 *
 * When this field is set, the TXOF flag generates an interrupt to the host.
 *
 * Values:
 * - 0b0 - TXOF flag does not generate an interrupt to the host.
 * - 0b1 - TXOF flag generates an interrupt to the host.
 */
/*@{*/
/*! @brief Read current value of the UART_CFIFO_TXOFE field. */
#define UART_RD_CFIFO_TXOFE(base) ((UART_CFIFO_REG(base) & UART_CFIFO_TXOFE_MASK) >> UART_CFIFO_TXOFE_SHIFT)
#define UART_BRD_CFIFO_TXOFE(base) (BME_UBFX8(&UART_CFIFO_REG(base), UART_CFIFO_TXOFE_SHIFT, UART_CFIFO_TXOFE_WIDTH))

/*! @brief Set the TXOFE field to a new value. */
#define UART_WR_CFIFO_TXOFE(base, value) (UART_RMW_CFIFO(base, UART_CFIFO_TXOFE_MASK, UART_CFIFO_TXOFE(value)))
#define UART_BWR_CFIFO_TXOFE(base, value) (BME_BFI8(&UART_CFIFO_REG(base), ((uint8_t)(value) << UART_CFIFO_TXOFE_SHIFT), UART_CFIFO_TXOFE_SHIFT, UART_CFIFO_TXOFE_WIDTH))
/*@}*/

/*!
 * @name Register UART_CFIFO, field RXOFE[2] (RW)
 *
 * When this field is set, the RXOF flag generates an interrupt to the host.
 *
 * Values:
 * - 0b0 - RXOF flag does not generate an interrupt to the host.
 * - 0b1 - RXOF flag generates an interrupt to the host.
 */
/*@{*/
/*! @brief Read current value of the UART_CFIFO_RXOFE field. */
#define UART_RD_CFIFO_RXOFE(base) ((UART_CFIFO_REG(base) & UART_CFIFO_RXOFE_MASK) >> UART_CFIFO_RXOFE_SHIFT)
#define UART_BRD_CFIFO_RXOFE(base) (BME_UBFX8(&UART_CFIFO_REG(base), UART_CFIFO_RXOFE_SHIFT, UART_CFIFO_RXOFE_WIDTH))

/*! @brief Set the RXOFE field to a new value. */
#define UART_WR_CFIFO_RXOFE(base, value) (UART_RMW_CFIFO(base, UART_CFIFO_RXOFE_MASK, UART_CFIFO_RXOFE(value)))
#define UART_BWR_CFIFO_RXOFE(base, value) (BME_BFI8(&UART_CFIFO_REG(base), ((uint8_t)(value) << UART_CFIFO_RXOFE_SHIFT), UART_CFIFO_RXOFE_SHIFT, UART_CFIFO_RXOFE_WIDTH))
/*@}*/

/*!
 * @name Register UART_CFIFO, field RXFLUSH[6] (WORZ)
 *
 * Writing to this field causes all data that is stored in the receive
 * FIFO/buffer to be flushed. This does not affect data that is in the receive shift
 * register.
 *
 * Values:
 * - 0b0 - No flush operation occurs.
 * - 0b1 - All data in the receive FIFO/buffer is cleared out.
 */
/*@{*/
/*! @brief Set the RXFLUSH field to a new value. */
#define UART_WR_CFIFO_RXFLUSH(base, value) (UART_RMW_CFIFO(base, UART_CFIFO_RXFLUSH_MASK, UART_CFIFO_RXFLUSH(value)))
#define UART_BWR_CFIFO_RXFLUSH(base, value) (BME_BFI8(&UART_CFIFO_REG(base), ((uint8_t)(value) << UART_CFIFO_RXFLUSH_SHIFT), UART_CFIFO_RXFLUSH_SHIFT, UART_CFIFO_RXFLUSH_WIDTH))
/*@}*/

/*!
 * @name Register UART_CFIFO, field TXFLUSH[7] (WORZ)
 *
 * Writing to this field causes all data that is stored in the transmit
 * FIFO/buffer to be flushed. This does not affect data that is in the transmit shift
 * register.
 *
 * Values:
 * - 0b0 - No flush operation occurs.
 * - 0b1 - All data in the transmit FIFO/Buffer is cleared out.
 */
/*@{*/
/*! @brief Set the TXFLUSH field to a new value. */
#define UART_WR_CFIFO_TXFLUSH(base, value) (UART_RMW_CFIFO(base, UART_CFIFO_TXFLUSH_MASK, UART_CFIFO_TXFLUSH(value)))
#define UART_BWR_CFIFO_TXFLUSH(base, value) (BME_BFI8(&UART_CFIFO_REG(base), ((uint8_t)(value) << UART_CFIFO_TXFLUSH_SHIFT), UART_CFIFO_TXFLUSH_SHIFT, UART_CFIFO_TXFLUSH_WIDTH))
/*@}*/

/*******************************************************************************
 * UART_SFIFO - UART FIFO Status Register
 ******************************************************************************/

/*!
 * @brief UART_SFIFO - UART FIFO Status Register (RW)
 *
 * Reset value: 0xC0U
 *
 * This register provides status information regarding the transmit and receiver
 * buffers/FIFOs, including interrupt information. This register may be written
 * to or read at any time.
 */
/*!
 * @name Constants and macros for entire UART_SFIFO register
 */
/*@{*/
#define UART_RD_SFIFO(base)      (UART_SFIFO_REG(base))
#define UART_WR_SFIFO(base, value) (UART_SFIFO_REG(base) = (value))
#define UART_RMW_SFIFO(base, mask, value) (UART_WR_SFIFO(base, (UART_RD_SFIFO(base) & ~(mask)) | (value)))
#define UART_SET_SFIFO(base, value) (BME_OR8(&UART_SFIFO_REG(base), (uint8_t)(value)))
#define UART_CLR_SFIFO(base, value) (BME_AND8(&UART_SFIFO_REG(base), (uint8_t)(~(value))))
#define UART_TOG_SFIFO(base, value) (BME_XOR8(&UART_SFIFO_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual UART_SFIFO bitfields
 */

/*!
 * @name Register UART_SFIFO, field RXUF[0] (W1C)
 *
 * Indicates that more data has been read from the receive buffer than was
 * present. This field will assert regardless of the value of CFIFO[RXUFE]. However,
 * an interrupt will be issued to the host only if CFIFO[RXUFE] is set. This flag
 * is cleared by writing a 1.
 *
 * Values:
 * - 0b0 - No receive buffer underflow has occurred since the last time the flag
 *     was cleared.
 * - 0b1 - At least one receive buffer underflow has occurred since the last
 *     time the flag was cleared.
 */
/*@{*/
/*! @brief Read current value of the UART_SFIFO_RXUF field. */
#define UART_RD_SFIFO_RXUF(base) ((UART_SFIFO_REG(base) & UART_SFIFO_RXUF_MASK) >> UART_SFIFO_RXUF_SHIFT)
#define UART_BRD_SFIFO_RXUF(base) (BME_UBFX8(&UART_SFIFO_REG(base), UART_SFIFO_RXUF_SHIFT, UART_SFIFO_RXUF_WIDTH))

/*! @brief Set the RXUF field to a new value. */
#define UART_WR_SFIFO_RXUF(base, value) (UART_RMW_SFIFO(base, (UART_SFIFO_RXUF_MASK | UART_SFIFO_TXOF_MASK | UART_SFIFO_RXOF_MASK), UART_SFIFO_RXUF(value)))
#define UART_BWR_SFIFO_RXUF(base, value) (BME_BFI8(&UART_SFIFO_REG(base), ((uint8_t)(value) << UART_SFIFO_RXUF_SHIFT), UART_SFIFO_RXUF_SHIFT, UART_SFIFO_RXUF_WIDTH))
/*@}*/

/*!
 * @name Register UART_SFIFO, field TXOF[1] (W1C)
 *
 * Indicates that more data has been written to the transmit buffer than it can
 * hold. This field will assert regardless of the value of CFIFO[TXOFE]. However,
 * an interrupt will be issued to the host only if CFIFO[TXOFE] is set. This
 * flag is cleared by writing a 1.
 *
 * Values:
 * - 0b0 - No transmit buffer overflow has occurred since the last time the flag
 *     was cleared.
 * - 0b1 - At least one transmit buffer overflow has occurred since the last
 *     time the flag was cleared.
 */
/*@{*/
/*! @brief Read current value of the UART_SFIFO_TXOF field. */
#define UART_RD_SFIFO_TXOF(base) ((UART_SFIFO_REG(base) & UART_SFIFO_TXOF_MASK) >> UART_SFIFO_TXOF_SHIFT)
#define UART_BRD_SFIFO_TXOF(base) (BME_UBFX8(&UART_SFIFO_REG(base), UART_SFIFO_TXOF_SHIFT, UART_SFIFO_TXOF_WIDTH))

/*! @brief Set the TXOF field to a new value. */
#define UART_WR_SFIFO_TXOF(base, value) (UART_RMW_SFIFO(base, (UART_SFIFO_TXOF_MASK | UART_SFIFO_RXUF_MASK | UART_SFIFO_RXOF_MASK), UART_SFIFO_TXOF(value)))
#define UART_BWR_SFIFO_TXOF(base, value) (BME_BFI8(&UART_SFIFO_REG(base), ((uint8_t)(value) << UART_SFIFO_TXOF_SHIFT), UART_SFIFO_TXOF_SHIFT, UART_SFIFO_TXOF_WIDTH))
/*@}*/

/*!
 * @name Register UART_SFIFO, field RXOF[2] (W1C)
 *
 * Indicates that more data has been written to the receive buffer than it can
 * hold. This field will assert regardless of the value of CFIFO[RXOFE]. However,
 * an interrupt will be issued to the host only if CFIFO[RXOFE] is set. This flag
 * is cleared by writing a 1.
 *
 * Values:
 * - 0b0 - No receive buffer overflow has occurred since the last time the flag
 *     was cleared.
 * - 0b1 - At least one receive buffer overflow has occurred since the last time
 *     the flag was cleared.
 */
/*@{*/
/*! @brief Read current value of the UART_SFIFO_RXOF field. */
#define UART_RD_SFIFO_RXOF(base) ((UART_SFIFO_REG(base) & UART_SFIFO_RXOF_MASK) >> UART_SFIFO_RXOF_SHIFT)
#define UART_BRD_SFIFO_RXOF(base) (BME_UBFX8(&UART_SFIFO_REG(base), UART_SFIFO_RXOF_SHIFT, UART_SFIFO_RXOF_WIDTH))

/*! @brief Set the RXOF field to a new value. */
#define UART_WR_SFIFO_RXOF(base, value) (UART_RMW_SFIFO(base, (UART_SFIFO_RXOF_MASK | UART_SFIFO_RXUF_MASK | UART_SFIFO_TXOF_MASK), UART_SFIFO_RXOF(value)))
#define UART_BWR_SFIFO_RXOF(base, value) (BME_BFI8(&UART_SFIFO_REG(base), ((uint8_t)(value) << UART_SFIFO_RXOF_SHIFT), UART_SFIFO_RXOF_SHIFT, UART_SFIFO_RXOF_WIDTH))
/*@}*/

/*!
 * @name Register UART_SFIFO, field RXEMPT[6] (RO)
 *
 * Asserts when there is no data in the receive FIFO/Buffer. This field does not
 * take into account data that is in the receive shift register.
 *
 * Values:
 * - 0b0 - Receive buffer is not empty.
 * - 0b1 - Receive buffer is empty.
 */
/*@{*/
/*! @brief Read current value of the UART_SFIFO_RXEMPT field. */
#define UART_RD_SFIFO_RXEMPT(base) ((UART_SFIFO_REG(base) & UART_SFIFO_RXEMPT_MASK) >> UART_SFIFO_RXEMPT_SHIFT)
#define UART_BRD_SFIFO_RXEMPT(base) (BME_UBFX8(&UART_SFIFO_REG(base), UART_SFIFO_RXEMPT_SHIFT, UART_SFIFO_RXEMPT_WIDTH))
/*@}*/

/*!
 * @name Register UART_SFIFO, field TXEMPT[7] (RO)
 *
 * Asserts when there is no data in the Transmit FIFO/buffer. This field does
 * not take into account data that is in the transmit shift register.
 *
 * Values:
 * - 0b0 - Transmit buffer is not empty.
 * - 0b1 - Transmit buffer is empty.
 */
/*@{*/
/*! @brief Read current value of the UART_SFIFO_TXEMPT field. */
#define UART_RD_SFIFO_TXEMPT(base) ((UART_SFIFO_REG(base) & UART_SFIFO_TXEMPT_MASK) >> UART_SFIFO_TXEMPT_SHIFT)
#define UART_BRD_SFIFO_TXEMPT(base) (BME_UBFX8(&UART_SFIFO_REG(base), UART_SFIFO_TXEMPT_SHIFT, UART_SFIFO_TXEMPT_WIDTH))
/*@}*/

/*******************************************************************************
 * UART_TWFIFO - UART FIFO Transmit Watermark
 ******************************************************************************/

/*!
 * @brief UART_TWFIFO - UART FIFO Transmit Watermark (RW)
 *
 * Reset value: 0x00U
 *
 * This register provides the ability to set a programmable threshold for
 * notification of needing additional transmit data. This register may be read at any
 * time but must be written only when C2[TE] is not set. Changing the value of the
 * watermark will not clear the S1[TDRE] flag.
 */
/*!
 * @name Constants and macros for entire UART_TWFIFO register
 */
/*@{*/
#define UART_RD_TWFIFO(base)     (UART_TWFIFO_REG(base))
#define UART_WR_TWFIFO(base, value) (UART_TWFIFO_REG(base) = (value))
#define UART_RMW_TWFIFO(base, mask, value) (UART_WR_TWFIFO(base, (UART_RD_TWFIFO(base) & ~(mask)) | (value)))
#define UART_SET_TWFIFO(base, value) (BME_OR8(&UART_TWFIFO_REG(base), (uint8_t)(value)))
#define UART_CLR_TWFIFO(base, value) (BME_AND8(&UART_TWFIFO_REG(base), (uint8_t)(~(value))))
#define UART_TOG_TWFIFO(base, value) (BME_XOR8(&UART_TWFIFO_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * UART_TCFIFO - UART FIFO Transmit Count
 ******************************************************************************/

/*!
 * @brief UART_TCFIFO - UART FIFO Transmit Count (RO)
 *
 * Reset value: 0x00U
 *
 * This is a read only register that indicates how many datawords are currently
 * in the transmit buffer/FIFO. It may be read at any time.
 */
/*!
 * @name Constants and macros for entire UART_TCFIFO register
 */
/*@{*/
#define UART_RD_TCFIFO(base)     (UART_TCFIFO_REG(base))
/*@}*/

/*******************************************************************************
 * UART_RWFIFO - UART FIFO Receive Watermark
 ******************************************************************************/

/*!
 * @brief UART_RWFIFO - UART FIFO Receive Watermark (RW)
 *
 * Reset value: 0x01U
 *
 * This register provides the ability to set a programmable threshold for
 * notification of the need to remove data from the receiver FIFO/buffer. This register
 * may be read at any time but must be written only when C2[RE] is not asserted.
 * Changing the value in this register will not clear S1[RDRF].
 */
/*!
 * @name Constants and macros for entire UART_RWFIFO register
 */
/*@{*/
#define UART_RD_RWFIFO(base)     (UART_RWFIFO_REG(base))
#define UART_WR_RWFIFO(base, value) (UART_RWFIFO_REG(base) = (value))
#define UART_RMW_RWFIFO(base, mask, value) (UART_WR_RWFIFO(base, (UART_RD_RWFIFO(base) & ~(mask)) | (value)))
#define UART_SET_RWFIFO(base, value) (BME_OR8(&UART_RWFIFO_REG(base), (uint8_t)(value)))
#define UART_CLR_RWFIFO(base, value) (BME_AND8(&UART_RWFIFO_REG(base), (uint8_t)(~(value))))
#define UART_TOG_RWFIFO(base, value) (BME_XOR8(&UART_RWFIFO_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * UART_RCFIFO - UART FIFO Receive Count
 ******************************************************************************/

/*!
 * @brief UART_RCFIFO - UART FIFO Receive Count (RO)
 *
 * Reset value: 0x00U
 *
 * This is a read only register that indicates how many datawords are currently
 * in the receive FIFO/buffer. It may be read at any time.
 */
/*!
 * @name Constants and macros for entire UART_RCFIFO register
 */
/*@{*/
#define UART_RD_RCFIFO(base)     (UART_RCFIFO_REG(base))
/*@}*/

/*******************************************************************************
 * UART_C7816 - UART 7816 Control Register
 ******************************************************************************/

/*!
 * @brief UART_C7816 - UART 7816 Control Register (RW)
 *
 * Reset value: 0x00U
 *
 * The C7816 register is the primary control register for ISO-7816 specific
 * functionality. This register is specific to 7816 functionality and the values in
 * this register have no effect on UART operation and should be ignored if
 * ISO_7816E is not set/enabled. This register may be read at any time but values must
 * be changed only when ISO_7816E is not set.
 */
/*!
 * @name Constants and macros for entire UART_C7816 register
 */
/*@{*/
#define UART_RD_C7816(base)      (UART_C7816_REG(base))
#define UART_WR_C7816(base, value) (UART_C7816_REG(base) = (value))
#define UART_RMW_C7816(base, mask, value) (UART_WR_C7816(base, (UART_RD_C7816(base) & ~(mask)) | (value)))
#define UART_SET_C7816(base, value) (BME_OR8(&UART_C7816_REG(base), (uint8_t)(value)))
#define UART_CLR_C7816(base, value) (BME_AND8(&UART_C7816_REG(base), (uint8_t)(~(value))))
#define UART_TOG_C7816(base, value) (BME_XOR8(&UART_C7816_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual UART_C7816 bitfields
 */

/*!
 * @name Register UART_C7816, field ISO_7816E[0] (RW)
 *
 * Indicates that the UART is operating according to the ISO-7816 protocol. This
 * field must be modified only when no transmit or receive is occurring. If this
 * field is changed during a data transfer, the data being transmitted or
 * received may be transferred incorrectly.
 *
 * Values:
 * - 0b0 - ISO-7816 functionality is turned off/not enabled.
 * - 0b1 - ISO-7816 functionality is turned on/enabled.
 */
/*@{*/
/*! @brief Read current value of the UART_C7816_ISO_7816E field. */
#define UART_RD_C7816_ISO_7816E(base) ((UART_C7816_REG(base) & UART_C7816_ISO_7816E_MASK) >> UART_C7816_ISO_7816E_SHIFT)
#define UART_BRD_C7816_ISO_7816E(base) (BME_UBFX8(&UART_C7816_REG(base), UART_C7816_ISO_7816E_SHIFT, UART_C7816_ISO_7816E_WIDTH))

/*! @brief Set the ISO_7816E field to a new value. */
#define UART_WR_C7816_ISO_7816E(base, value) (UART_RMW_C7816(base, UART_C7816_ISO_7816E_MASK, UART_C7816_ISO_7816E(value)))
#define UART_BWR_C7816_ISO_7816E(base, value) (BME_BFI8(&UART_C7816_REG(base), ((uint8_t)(value) << UART_C7816_ISO_7816E_SHIFT), UART_C7816_ISO_7816E_SHIFT, UART_C7816_ISO_7816E_WIDTH))
/*@}*/

/*!
 * @name Register UART_C7816, field TTYPE[1] (RW)
 *
 * Indicates the transfer protocol being used. See ISO-7816 / smartcard support
 * for more details.
 *
 * Values:
 * - 0b0 - T = 0 per the ISO-7816 specification.
 * - 0b1 - T = 1 per the ISO-7816 specification.
 */
/*@{*/
/*! @brief Read current value of the UART_C7816_TTYPE field. */
#define UART_RD_C7816_TTYPE(base) ((UART_C7816_REG(base) & UART_C7816_TTYPE_MASK) >> UART_C7816_TTYPE_SHIFT)
#define UART_BRD_C7816_TTYPE(base) (BME_UBFX8(&UART_C7816_REG(base), UART_C7816_TTYPE_SHIFT, UART_C7816_TTYPE_WIDTH))

/*! @brief Set the TTYPE field to a new value. */
#define UART_WR_C7816_TTYPE(base, value) (UART_RMW_C7816(base, UART_C7816_TTYPE_MASK, UART_C7816_TTYPE(value)))
#define UART_BWR_C7816_TTYPE(base, value) (BME_BFI8(&UART_C7816_REG(base), ((uint8_t)(value) << UART_C7816_TTYPE_SHIFT), UART_C7816_TTYPE_SHIFT, UART_C7816_TTYPE_WIDTH))
/*@}*/

/*!
 * @name Register UART_C7816, field INIT[2] (RW)
 *
 * When this field is set, all received characters are searched for a valid
 * initial character. If an invalid initial character is identified, and ANACK is
 * set, a NACK is sent. All received data is discarded and error flags blocked
 * (S1[NF], S1[OR], S1[FE], S1[PF], IS7816[WT], IS7816[CWT], IS7816[BWT], IS7816[ADT],
 * IS7816[GTV]) until a valid initial character is detected. Upon detecting a
 * valid initial character, the configuration values S2[MSBF], C3[TXINV], and
 * S2[RXINV] are automatically updated to reflect the initial character that was
 * received. The actual INIT data value is not stored in the receive buffer.
 * Additionally, upon detection of a valid initial character, IS7816[INITD] is set and an
 * interrupt issued as programmed by IE7816[INITDE]. When a valid initial
 * character is detected, INIT is automatically cleared. This Initial Character Detect
 * feature is supported only in T = 0 protocol mode.
 *
 * Values:
 * - 0b0 - Normal operating mode. Receiver does not seek to identify initial
 *     character.
 * - 0b1 - Receiver searches for initial character.
 */
/*@{*/
/*! @brief Read current value of the UART_C7816_INIT field. */
#define UART_RD_C7816_INIT(base) ((UART_C7816_REG(base) & UART_C7816_INIT_MASK) >> UART_C7816_INIT_SHIFT)
#define UART_BRD_C7816_INIT(base) (BME_UBFX8(&UART_C7816_REG(base), UART_C7816_INIT_SHIFT, UART_C7816_INIT_WIDTH))

/*! @brief Set the INIT field to a new value. */
#define UART_WR_C7816_INIT(base, value) (UART_RMW_C7816(base, UART_C7816_INIT_MASK, UART_C7816_INIT(value)))
#define UART_BWR_C7816_INIT(base, value) (BME_BFI8(&UART_C7816_REG(base), ((uint8_t)(value) << UART_C7816_INIT_SHIFT), UART_C7816_INIT_SHIFT, UART_C7816_INIT_WIDTH))
/*@}*/

/*!
 * @name Register UART_C7816, field ANACK[3] (RW)
 *
 * When this field is set, the receiver automatically generates a NACK response
 * if a parity error occurs or if INIT is set and an invalid initial character is
 * detected. A NACK is generated only if TTYPE = 0. If ANACK is set, the UART
 * attempts to retransmit the data indefinitely. To stop retransmission attempts,
 * clear C2[TE] or ISO_7816E and do not set until S1[TC] sets C2[TE] again.
 *
 * Values:
 * - 0b0 - No NACK is automatically generated.
 * - 0b1 - A NACK is automatically generated if a parity error is detected or if
 *     an invalid initial character is detected.
 */
/*@{*/
/*! @brief Read current value of the UART_C7816_ANACK field. */
#define UART_RD_C7816_ANACK(base) ((UART_C7816_REG(base) & UART_C7816_ANACK_MASK) >> UART_C7816_ANACK_SHIFT)
#define UART_BRD_C7816_ANACK(base) (BME_UBFX8(&UART_C7816_REG(base), UART_C7816_ANACK_SHIFT, UART_C7816_ANACK_WIDTH))

/*! @brief Set the ANACK field to a new value. */
#define UART_WR_C7816_ANACK(base, value) (UART_RMW_C7816(base, UART_C7816_ANACK_MASK, UART_C7816_ANACK(value)))
#define UART_BWR_C7816_ANACK(base, value) (BME_BFI8(&UART_C7816_REG(base), ((uint8_t)(value) << UART_C7816_ANACK_SHIFT), UART_C7816_ANACK_SHIFT, UART_C7816_ANACK_WIDTH))
/*@}*/

/*!
 * @name Register UART_C7816, field ONACK[4] (RW)
 *
 * When this field is set, the receiver automatically generates a NACK response
 * if a receive buffer overrun occurs, as indicated by S1[OR]. In many systems,
 * this results in the transmitter resending the packet that overflowed until the
 * retransmit threshold for that transmitter is reached. A NACK is generated only
 * if TTYPE=0. This field operates independently of ANACK. See . Overrun NACK
 * considerations
 *
 * Values:
 * - 0b0 - The received data does not generate a NACK when the receipt of the
 *     data results in an overflow event.
 * - 0b1 - If the receiver buffer overflows, a NACK is automatically sent on a
 *     received character.
 */
/*@{*/
/*! @brief Read current value of the UART_C7816_ONACK field. */
#define UART_RD_C7816_ONACK(base) ((UART_C7816_REG(base) & UART_C7816_ONACK_MASK) >> UART_C7816_ONACK_SHIFT)
#define UART_BRD_C7816_ONACK(base) (BME_UBFX8(&UART_C7816_REG(base), UART_C7816_ONACK_SHIFT, UART_C7816_ONACK_WIDTH))

/*! @brief Set the ONACK field to a new value. */
#define UART_WR_C7816_ONACK(base, value) (UART_RMW_C7816(base, UART_C7816_ONACK_MASK, UART_C7816_ONACK(value)))
#define UART_BWR_C7816_ONACK(base, value) (BME_BFI8(&UART_C7816_REG(base), ((uint8_t)(value) << UART_C7816_ONACK_SHIFT), UART_C7816_ONACK_SHIFT, UART_C7816_ONACK_WIDTH))
/*@}*/

/*******************************************************************************
 * UART_IE7816 - UART 7816 Interrupt Enable Register
 ******************************************************************************/

/*!
 * @brief UART_IE7816 - UART 7816 Interrupt Enable Register (RW)
 *
 * Reset value: 0x00U
 *
 * The IE7816 register controls which flags result in an interrupt being issued.
 * This register is specific to 7816 functionality, the corresponding flags that
 * drive the interrupts are not asserted when 7816E is not set/enabled. However,
 * these flags may remain set if they are asserted while 7816E was set and not
 * subsequently cleared. This register may be read or written to at any time.
 */
/*!
 * @name Constants and macros for entire UART_IE7816 register
 */
/*@{*/
#define UART_RD_IE7816(base)     (UART_IE7816_REG(base))
#define UART_WR_IE7816(base, value) (UART_IE7816_REG(base) = (value))
#define UART_RMW_IE7816(base, mask, value) (UART_WR_IE7816(base, (UART_RD_IE7816(base) & ~(mask)) | (value)))
#define UART_SET_IE7816(base, value) (BME_OR8(&UART_IE7816_REG(base), (uint8_t)(value)))
#define UART_CLR_IE7816(base, value) (BME_AND8(&UART_IE7816_REG(base), (uint8_t)(~(value))))
#define UART_TOG_IE7816(base, value) (BME_XOR8(&UART_IE7816_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual UART_IE7816 bitfields
 */

/*!
 * @name Register UART_IE7816, field RXTE[0] (RW)
 *
 * Values:
 * - 0b0 - The assertion of IS7816[RXT] does not result in the generation of an
 *     interrupt.
 * - 0b1 - The assertion of IS7816[RXT] results in the generation of an
 *     interrupt.
 */
/*@{*/
/*! @brief Read current value of the UART_IE7816_RXTE field. */
#define UART_RD_IE7816_RXTE(base) ((UART_IE7816_REG(base) & UART_IE7816_RXTE_MASK) >> UART_IE7816_RXTE_SHIFT)
#define UART_BRD_IE7816_RXTE(base) (BME_UBFX8(&UART_IE7816_REG(base), UART_IE7816_RXTE_SHIFT, UART_IE7816_RXTE_WIDTH))

/*! @brief Set the RXTE field to a new value. */
#define UART_WR_IE7816_RXTE(base, value) (UART_RMW_IE7816(base, UART_IE7816_RXTE_MASK, UART_IE7816_RXTE(value)))
#define UART_BWR_IE7816_RXTE(base, value) (BME_BFI8(&UART_IE7816_REG(base), ((uint8_t)(value) << UART_IE7816_RXTE_SHIFT), UART_IE7816_RXTE_SHIFT, UART_IE7816_RXTE_WIDTH))
/*@}*/

/*!
 * @name Register UART_IE7816, field TXTE[1] (RW)
 *
 * Values:
 * - 0b0 - The assertion of IS7816[TXT] does not result in the generation of an
 *     interrupt.
 * - 0b1 - The assertion of IS7816[TXT] results in the generation of an
 *     interrupt.
 */
/*@{*/
/*! @brief Read current value of the UART_IE7816_TXTE field. */
#define UART_RD_IE7816_TXTE(base) ((UART_IE7816_REG(base) & UART_IE7816_TXTE_MASK) >> UART_IE7816_TXTE_SHIFT)
#define UART_BRD_IE7816_TXTE(base) (BME_UBFX8(&UART_IE7816_REG(base), UART_IE7816_TXTE_SHIFT, UART_IE7816_TXTE_WIDTH))

/*! @brief Set the TXTE field to a new value. */
#define UART_WR_IE7816_TXTE(base, value) (UART_RMW_IE7816(base, UART_IE7816_TXTE_MASK, UART_IE7816_TXTE(value)))
#define UART_BWR_IE7816_TXTE(base, value) (BME_BFI8(&UART_IE7816_REG(base), ((uint8_t)(value) << UART_IE7816_TXTE_SHIFT), UART_IE7816_TXTE_SHIFT, UART_IE7816_TXTE_WIDTH))
/*@}*/

/*!
 * @name Register UART_IE7816, field GTVE[2] (RW)
 *
 * Values:
 * - 0b0 - The assertion of IS7816[GTV] does not result in the generation of an
 *     interrupt.
 * - 0b1 - The assertion of IS7816[GTV] results in the generation of an
 *     interrupt.
 */
/*@{*/
/*! @brief Read current value of the UART_IE7816_GTVE field. */
#define UART_RD_IE7816_GTVE(base) ((UART_IE7816_REG(base) & UART_IE7816_GTVE_MASK) >> UART_IE7816_GTVE_SHIFT)
#define UART_BRD_IE7816_GTVE(base) (BME_UBFX8(&UART_IE7816_REG(base), UART_IE7816_GTVE_SHIFT, UART_IE7816_GTVE_WIDTH))

/*! @brief Set the GTVE field to a new value. */
#define UART_WR_IE7816_GTVE(base, value) (UART_RMW_IE7816(base, UART_IE7816_GTVE_MASK, UART_IE7816_GTVE(value)))
#define UART_BWR_IE7816_GTVE(base, value) (BME_BFI8(&UART_IE7816_REG(base), ((uint8_t)(value) << UART_IE7816_GTVE_SHIFT), UART_IE7816_GTVE_SHIFT, UART_IE7816_GTVE_WIDTH))
/*@}*/

/*!
 * @name Register UART_IE7816, field ADTE[3] (RW)
 *
 * Values:
 * - 0b0 - The assertion of IS7816[ADT] does not result in the generation of an
 *     interrupt.
 * - 0b1 - The assertion of IS7816[ADT] results in the generation of an
 *     interrupt.
 */
/*@{*/
/*! @brief Read current value of the UART_IE7816_ADTE field. */
#define UART_RD_IE7816_ADTE(base) ((UART_IE7816_REG(base) & UART_IE7816_ADTE_MASK) >> UART_IE7816_ADTE_SHIFT)
#define UART_BRD_IE7816_ADTE(base) (BME_UBFX8(&UART_IE7816_REG(base), UART_IE7816_ADTE_SHIFT, UART_IE7816_ADTE_WIDTH))

/*! @brief Set the ADTE field to a new value. */
#define UART_WR_IE7816_ADTE(base, value) (UART_RMW_IE7816(base, UART_IE7816_ADTE_MASK, UART_IE7816_ADTE(value)))
#define UART_BWR_IE7816_ADTE(base, value) (BME_BFI8(&UART_IE7816_REG(base), ((uint8_t)(value) << UART_IE7816_ADTE_SHIFT), UART_IE7816_ADTE_SHIFT, UART_IE7816_ADTE_WIDTH))
/*@}*/

/*!
 * @name Register UART_IE7816, field INITDE[4] (RW)
 *
 * Values:
 * - 0b0 - The assertion of IS7816[INITD] does not result in the generation of
 *     an interrupt.
 * - 0b1 - The assertion of IS7816[INITD] results in the generation of an
 *     interrupt.
 */
/*@{*/
/*! @brief Read current value of the UART_IE7816_INITDE field. */
#define UART_RD_IE7816_INITDE(base) ((UART_IE7816_REG(base) & UART_IE7816_INITDE_MASK) >> UART_IE7816_INITDE_SHIFT)
#define UART_BRD_IE7816_INITDE(base) (BME_UBFX8(&UART_IE7816_REG(base), UART_IE7816_INITDE_SHIFT, UART_IE7816_INITDE_WIDTH))

/*! @brief Set the INITDE field to a new value. */
#define UART_WR_IE7816_INITDE(base, value) (UART_RMW_IE7816(base, UART_IE7816_INITDE_MASK, UART_IE7816_INITDE(value)))
#define UART_BWR_IE7816_INITDE(base, value) (BME_BFI8(&UART_IE7816_REG(base), ((uint8_t)(value) << UART_IE7816_INITDE_SHIFT), UART_IE7816_INITDE_SHIFT, UART_IE7816_INITDE_WIDTH))
/*@}*/

/*!
 * @name Register UART_IE7816, field BWTE[5] (RW)
 *
 * Values:
 * - 0b0 - The assertion of IS7816[BWT] does not result in the generation of an
 *     interrupt.
 * - 0b1 - The assertion of IS7816[BWT] results in the generation of an
 *     interrupt.
 */
/*@{*/
/*! @brief Read current value of the UART_IE7816_BWTE field. */
#define UART_RD_IE7816_BWTE(base) ((UART_IE7816_REG(base) & UART_IE7816_BWTE_MASK) >> UART_IE7816_BWTE_SHIFT)
#define UART_BRD_IE7816_BWTE(base) (BME_UBFX8(&UART_IE7816_REG(base), UART_IE7816_BWTE_SHIFT, UART_IE7816_BWTE_WIDTH))

/*! @brief Set the BWTE field to a new value. */
#define UART_WR_IE7816_BWTE(base, value) (UART_RMW_IE7816(base, UART_IE7816_BWTE_MASK, UART_IE7816_BWTE(value)))
#define UART_BWR_IE7816_BWTE(base, value) (BME_BFI8(&UART_IE7816_REG(base), ((uint8_t)(value) << UART_IE7816_BWTE_SHIFT), UART_IE7816_BWTE_SHIFT, UART_IE7816_BWTE_WIDTH))
/*@}*/

/*!
 * @name Register UART_IE7816, field CWTE[6] (RW)
 *
 * Values:
 * - 0b0 - The assertion of IS7816[CWT] does not result in the generation of an
 *     interrupt.
 * - 0b1 - The assertion of IS7816[CWT] results in the generation of an
 *     interrupt.
 */
/*@{*/
/*! @brief Read current value of the UART_IE7816_CWTE field. */
#define UART_RD_IE7816_CWTE(base) ((UART_IE7816_REG(base) & UART_IE7816_CWTE_MASK) >> UART_IE7816_CWTE_SHIFT)
#define UART_BRD_IE7816_CWTE(base) (BME_UBFX8(&UART_IE7816_REG(base), UART_IE7816_CWTE_SHIFT, UART_IE7816_CWTE_WIDTH))

/*! @brief Set the CWTE field to a new value. */
#define UART_WR_IE7816_CWTE(base, value) (UART_RMW_IE7816(base, UART_IE7816_CWTE_MASK, UART_IE7816_CWTE(value)))
#define UART_BWR_IE7816_CWTE(base, value) (BME_BFI8(&UART_IE7816_REG(base), ((uint8_t)(value) << UART_IE7816_CWTE_SHIFT), UART_IE7816_CWTE_SHIFT, UART_IE7816_CWTE_WIDTH))
/*@}*/

/*!
 * @name Register UART_IE7816, field WTE[7] (RW)
 *
 * Values:
 * - 0b0 - The assertion of IS7816[WT] does not result in the generation of an
 *     interrupt.
 * - 0b1 - The assertion of IS7816[WT] results in the generation of an interrupt.
 */
/*@{*/
/*! @brief Read current value of the UART_IE7816_WTE field. */
#define UART_RD_IE7816_WTE(base) ((UART_IE7816_REG(base) & UART_IE7816_WTE_MASK) >> UART_IE7816_WTE_SHIFT)
#define UART_BRD_IE7816_WTE(base) (BME_UBFX8(&UART_IE7816_REG(base), UART_IE7816_WTE_SHIFT, UART_IE7816_WTE_WIDTH))

/*! @brief Set the WTE field to a new value. */
#define UART_WR_IE7816_WTE(base, value) (UART_RMW_IE7816(base, UART_IE7816_WTE_MASK, UART_IE7816_WTE(value)))
#define UART_BWR_IE7816_WTE(base, value) (BME_BFI8(&UART_IE7816_REG(base), ((uint8_t)(value) << UART_IE7816_WTE_SHIFT), UART_IE7816_WTE_SHIFT, UART_IE7816_WTE_WIDTH))
/*@}*/

/*******************************************************************************
 * UART_IS7816 - UART 7816 Interrupt Status Register
 ******************************************************************************/

/*!
 * @brief UART_IS7816 - UART 7816 Interrupt Status Register (W1C)
 *
 * Reset value: 0x00U
 *
 * The IS7816 register provides a mechanism to read and clear the interrupt
 * flags. All flags/interrupts are cleared by writing a 1 to the field location.
 * Writing a 0 has no effect. All bits are "sticky", meaning they indicate that only
 * the flag condition that occurred since the last time the bit was cleared, not
 * that the condition currently exists. The status flags are set regardless of
 * whether the corresponding field in the IE7816 is set or cleared. The IE7816
 * controls only if an interrupt is issued to the host processor. This register is
 * specific to 7816 functionality and the values in this register have no affect on
 * UART operation and should be ignored if 7816E is not set/enabled. This
 * register may be read or written at anytime.
 */
/*!
 * @name Constants and macros for entire UART_IS7816 register
 */
/*@{*/
#define UART_RD_IS7816(base)     (UART_IS7816_REG(base))
#define UART_WR_IS7816(base, value) (UART_IS7816_REG(base) = (value))
#define UART_RMW_IS7816(base, mask, value) (UART_WR_IS7816(base, (UART_RD_IS7816(base) & ~(mask)) | (value)))
#define UART_SET_IS7816(base, value) (BME_OR8(&UART_IS7816_REG(base), (uint8_t)(value)))
#define UART_CLR_IS7816(base, value) (BME_AND8(&UART_IS7816_REG(base), (uint8_t)(~(value))))
#define UART_TOG_IS7816(base, value) (BME_XOR8(&UART_IS7816_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual UART_IS7816 bitfields
 */

/*!
 * @name Register UART_IS7816, field RXT[0] (W1C)
 *
 * Indicates that there are more than ET7816[RXTHRESHOLD] consecutive NACKS
 * generated in response to parity errors on received data. This flag requires ANACK
 * to be set. Additionally, this flag asserts only when C7816[TTYPE] = 0.
 * Clearing this field also resets the counter keeping track of consecutive NACKS. The
 * UART will continue to attempt to receive data regardless of whether this flag
 * is set. If 7816E is cleared/disabled, RE is cleared/disabled, C7816[TTYPE] = 1,
 * or packet is received without needing to issue a NACK, the internal NACK
 * detection counter is cleared and the count restarts from zero on the next
 * transmitted NACK. This interrupt is cleared by writing 1.
 *
 * Values:
 * - 0b0 - The number of consecutive NACKS generated as a result of parity
 *     errors and buffer overruns is less than or equal to the value in
 *     ET7816[RXTHRESHOLD].
 * - 0b1 - The number of consecutive NACKS generated as a result of parity
 *     errors and buffer overruns is greater than the value in ET7816[RXTHRESHOLD].
 */
/*@{*/
/*! @brief Read current value of the UART_IS7816_RXT field. */
#define UART_RD_IS7816_RXT(base) ((UART_IS7816_REG(base) & UART_IS7816_RXT_MASK) >> UART_IS7816_RXT_SHIFT)
#define UART_BRD_IS7816_RXT(base) (BME_UBFX8(&UART_IS7816_REG(base), UART_IS7816_RXT_SHIFT, UART_IS7816_RXT_WIDTH))

/*! @brief Set the RXT field to a new value. */
#define UART_WR_IS7816_RXT(base, value) (UART_RMW_IS7816(base, (UART_IS7816_RXT_MASK | UART_IS7816_TXT_MASK | UART_IS7816_GTV_MASK | UART_IS7816_ADT_MASK | UART_IS7816_INITD_MASK | UART_IS7816_BWT_MASK | UART_IS7816_CWT_MASK | UART_IS7816_WT_MASK), UART_IS7816_RXT(value)))
#define UART_BWR_IS7816_RXT(base, value) (BME_BFI8(&UART_IS7816_REG(base), ((uint8_t)(value) << UART_IS7816_RXT_SHIFT), UART_IS7816_RXT_SHIFT, UART_IS7816_RXT_WIDTH))
/*@}*/

/*!
 * @name Register UART_IS7816, field TXT[1] (W1C)
 *
 * Indicates that the transmit NACK threshold has been exceeded as indicated by
 * ET7816[TXTHRESHOLD]. Regardless of whether this flag is set, the UART
 * continues to retransmit indefinitely. This flag asserts only when C7816[TTYPE] = 0. If
 * 7816E is cleared/disabled, ANACK is cleared/disabled, C2[TE] is
 * cleared/disabled, C7816[TTYPE] = 1, or packet is transferred without receiving a NACK, the
 * internal NACK detection counter is cleared and the count restarts from zero on
 * the next received NACK. This interrupt is cleared by writing 1.
 *
 * Values:
 * - 0b0 - The number of retries and corresponding NACKS does not exceed the
 *     value in ET7816[TXTHRESHOLD].
 * - 0b1 - The number of retries and corresponding NACKS exceeds the value in
 *     ET7816[TXTHRESHOLD].
 */
/*@{*/
/*! @brief Read current value of the UART_IS7816_TXT field. */
#define UART_RD_IS7816_TXT(base) ((UART_IS7816_REG(base) & UART_IS7816_TXT_MASK) >> UART_IS7816_TXT_SHIFT)
#define UART_BRD_IS7816_TXT(base) (BME_UBFX8(&UART_IS7816_REG(base), UART_IS7816_TXT_SHIFT, UART_IS7816_TXT_WIDTH))

/*! @brief Set the TXT field to a new value. */
#define UART_WR_IS7816_TXT(base, value) (UART_RMW_IS7816(base, (UART_IS7816_TXT_MASK | UART_IS7816_RXT_MASK | UART_IS7816_GTV_MASK | UART_IS7816_ADT_MASK | UART_IS7816_INITD_MASK | UART_IS7816_BWT_MASK | UART_IS7816_CWT_MASK | UART_IS7816_WT_MASK), UART_IS7816_TXT(value)))
#define UART_BWR_IS7816_TXT(base, value) (BME_BFI8(&UART_IS7816_REG(base), ((uint8_t)(value) << UART_IS7816_TXT_SHIFT), UART_IS7816_TXT_SHIFT, UART_IS7816_TXT_WIDTH))
/*@}*/

/*!
 * @name Register UART_IS7816, field GTV[2] (W1C)
 *
 * Indicates that one or more of the character guard time, block guard time, or
 * guard time are violated. This interrupt is cleared by writing 1.
 *
 * Values:
 * - 0b0 - A guard time (GT, CGT, or BGT) has not been violated.
 * - 0b1 - A guard time (GT, CGT, or BGT) has been violated.
 */
/*@{*/
/*! @brief Read current value of the UART_IS7816_GTV field. */
#define UART_RD_IS7816_GTV(base) ((UART_IS7816_REG(base) & UART_IS7816_GTV_MASK) >> UART_IS7816_GTV_SHIFT)
#define UART_BRD_IS7816_GTV(base) (BME_UBFX8(&UART_IS7816_REG(base), UART_IS7816_GTV_SHIFT, UART_IS7816_GTV_WIDTH))

/*! @brief Set the GTV field to a new value. */
#define UART_WR_IS7816_GTV(base, value) (UART_RMW_IS7816(base, (UART_IS7816_GTV_MASK | UART_IS7816_RXT_MASK | UART_IS7816_TXT_MASK | UART_IS7816_ADT_MASK | UART_IS7816_INITD_MASK | UART_IS7816_BWT_MASK | UART_IS7816_CWT_MASK | UART_IS7816_WT_MASK), UART_IS7816_GTV(value)))
#define UART_BWR_IS7816_GTV(base, value) (BME_BFI8(&UART_IS7816_REG(base), ((uint8_t)(value) << UART_IS7816_GTV_SHIFT), UART_IS7816_GTV_SHIFT, UART_IS7816_GTV_WIDTH))
/*@}*/

/*!
 * @name Register UART_IS7816, field ADT[3] (W1C)
 *
 * Indicates that the ATR duration time, the time between the leading edge of
 * the TS character being received and the leading edge of the next response
 * character, has exceeded the programmed value. This flag asserts only when
 * C7816[TTYPE] = 0. This interrupt is cleared by writing 1.
 *
 * Values:
 * - 0b0 - ATR Duration time (ADT) has not been violated.
 * - 0b1 - ATR Duration time (ADT) has been violated.
 */
/*@{*/
/*! @brief Read current value of the UART_IS7816_ADT field. */
#define UART_RD_IS7816_ADT(base) ((UART_IS7816_REG(base) & UART_IS7816_ADT_MASK) >> UART_IS7816_ADT_SHIFT)
#define UART_BRD_IS7816_ADT(base) (BME_UBFX8(&UART_IS7816_REG(base), UART_IS7816_ADT_SHIFT, UART_IS7816_ADT_WIDTH))

/*! @brief Set the ADT field to a new value. */
#define UART_WR_IS7816_ADT(base, value) (UART_RMW_IS7816(base, (UART_IS7816_ADT_MASK | UART_IS7816_RXT_MASK | UART_IS7816_TXT_MASK | UART_IS7816_GTV_MASK | UART_IS7816_INITD_MASK | UART_IS7816_BWT_MASK | UART_IS7816_CWT_MASK | UART_IS7816_WT_MASK), UART_IS7816_ADT(value)))
#define UART_BWR_IS7816_ADT(base, value) (BME_BFI8(&UART_IS7816_REG(base), ((uint8_t)(value) << UART_IS7816_ADT_SHIFT), UART_IS7816_ADT_SHIFT, UART_IS7816_ADT_WIDTH))
/*@}*/

/*!
 * @name Register UART_IS7816, field INITD[4] (W1C)
 *
 * Indicates that a valid initial character is received. This interrupt is
 * cleared by writing 1.
 *
 * Values:
 * - 0b0 - A valid initial character has not been received.
 * - 0b1 - A valid initial character has been received.
 */
/*@{*/
/*! @brief Read current value of the UART_IS7816_INITD field. */
#define UART_RD_IS7816_INITD(base) ((UART_IS7816_REG(base) & UART_IS7816_INITD_MASK) >> UART_IS7816_INITD_SHIFT)
#define UART_BRD_IS7816_INITD(base) (BME_UBFX8(&UART_IS7816_REG(base), UART_IS7816_INITD_SHIFT, UART_IS7816_INITD_WIDTH))

/*! @brief Set the INITD field to a new value. */
#define UART_WR_IS7816_INITD(base, value) (UART_RMW_IS7816(base, (UART_IS7816_INITD_MASK | UART_IS7816_RXT_MASK | UART_IS7816_TXT_MASK | UART_IS7816_GTV_MASK | UART_IS7816_ADT_MASK | UART_IS7816_BWT_MASK | UART_IS7816_CWT_MASK | UART_IS7816_WT_MASK), UART_IS7816_INITD(value)))
#define UART_BWR_IS7816_INITD(base, value) (BME_BFI8(&UART_IS7816_REG(base), ((uint8_t)(value) << UART_IS7816_INITD_SHIFT), UART_IS7816_INITD_SHIFT, UART_IS7816_INITD_WIDTH))
/*@}*/

/*!
 * @name Register UART_IS7816, field BWT[5] (W1C)
 *
 * Indicates that the block wait time, the time between the leading edge of
 * first received character of a block and the leading edge of the last character the
 * previously transmitted block, has exceeded the programmed value. This flag
 * asserts only when C7816[TTYPE] = 1.This interrupt is cleared by writing 1.
 *
 * Values:
 * - 0b0 - Block wait time (BWT) has not been violated.
 * - 0b1 - Block wait time (BWT) has been violated.
 */
/*@{*/
/*! @brief Read current value of the UART_IS7816_BWT field. */
#define UART_RD_IS7816_BWT(base) ((UART_IS7816_REG(base) & UART_IS7816_BWT_MASK) >> UART_IS7816_BWT_SHIFT)
#define UART_BRD_IS7816_BWT(base) (BME_UBFX8(&UART_IS7816_REG(base), UART_IS7816_BWT_SHIFT, UART_IS7816_BWT_WIDTH))

/*! @brief Set the BWT field to a new value. */
#define UART_WR_IS7816_BWT(base, value) (UART_RMW_IS7816(base, (UART_IS7816_BWT_MASK | UART_IS7816_RXT_MASK | UART_IS7816_TXT_MASK | UART_IS7816_GTV_MASK | UART_IS7816_ADT_MASK | UART_IS7816_INITD_MASK | UART_IS7816_CWT_MASK | UART_IS7816_WT_MASK), UART_IS7816_BWT(value)))
#define UART_BWR_IS7816_BWT(base, value) (BME_BFI8(&UART_IS7816_REG(base), ((uint8_t)(value) << UART_IS7816_BWT_SHIFT), UART_IS7816_BWT_SHIFT, UART_IS7816_BWT_WIDTH))
/*@}*/

/*!
 * @name Register UART_IS7816, field CWT[6] (W1C)
 *
 * Indicates that the character wait time, the time between the leading edges of
 * two consecutive characters in a block, has exceeded the programmed value.
 * This flag asserts only when C7816[TTYPE] = 1. This interrupt is cleared by
 * writing 1.
 *
 * Values:
 * - 0b0 - Character wait time (CWT) has not been violated.
 * - 0b1 - Character wait time (CWT) has been violated.
 */
/*@{*/
/*! @brief Read current value of the UART_IS7816_CWT field. */
#define UART_RD_IS7816_CWT(base) ((UART_IS7816_REG(base) & UART_IS7816_CWT_MASK) >> UART_IS7816_CWT_SHIFT)
#define UART_BRD_IS7816_CWT(base) (BME_UBFX8(&UART_IS7816_REG(base), UART_IS7816_CWT_SHIFT, UART_IS7816_CWT_WIDTH))

/*! @brief Set the CWT field to a new value. */
#define UART_WR_IS7816_CWT(base, value) (UART_RMW_IS7816(base, (UART_IS7816_CWT_MASK | UART_IS7816_RXT_MASK | UART_IS7816_TXT_MASK | UART_IS7816_GTV_MASK | UART_IS7816_ADT_MASK | UART_IS7816_INITD_MASK | UART_IS7816_BWT_MASK | UART_IS7816_WT_MASK), UART_IS7816_CWT(value)))
#define UART_BWR_IS7816_CWT(base, value) (BME_BFI8(&UART_IS7816_REG(base), ((uint8_t)(value) << UART_IS7816_CWT_SHIFT), UART_IS7816_CWT_SHIFT, UART_IS7816_CWT_WIDTH))
/*@}*/

/*!
 * @name Register UART_IS7816, field WT[7] (W1C)
 *
 * Indicates that the wait time, the time between the leading edge of a
 * character being transmitted and the leading edge of the next response character, has
 * exceeded the programmed value. This flag asserts only when C7816[TTYPE] = 0.
 * This interrupt is cleared by writing 1.
 *
 * Values:
 * - 0b0 - Wait time (WT) has not been violated.
 * - 0b1 - Wait time (WT) has been violated.
 */
/*@{*/
/*! @brief Read current value of the UART_IS7816_WT field. */
#define UART_RD_IS7816_WT(base) ((UART_IS7816_REG(base) & UART_IS7816_WT_MASK) >> UART_IS7816_WT_SHIFT)
#define UART_BRD_IS7816_WT(base) (BME_UBFX8(&UART_IS7816_REG(base), UART_IS7816_WT_SHIFT, UART_IS7816_WT_WIDTH))

/*! @brief Set the WT field to a new value. */
#define UART_WR_IS7816_WT(base, value) (UART_RMW_IS7816(base, (UART_IS7816_WT_MASK | UART_IS7816_RXT_MASK | UART_IS7816_TXT_MASK | UART_IS7816_GTV_MASK | UART_IS7816_ADT_MASK | UART_IS7816_INITD_MASK | UART_IS7816_BWT_MASK | UART_IS7816_CWT_MASK), UART_IS7816_WT(value)))
#define UART_BWR_IS7816_WT(base, value) (BME_BFI8(&UART_IS7816_REG(base), ((uint8_t)(value) << UART_IS7816_WT_SHIFT), UART_IS7816_WT_SHIFT, UART_IS7816_WT_WIDTH))
/*@}*/

/*******************************************************************************
 * UART_WP7816 - UART 7816 Wait Parameter Register
 ******************************************************************************/

/*!
 * @brief UART_WP7816 - UART 7816 Wait Parameter Register (RW)
 *
 * Reset value: 0x00U
 *
 * The WP7816 register contains the WTX variable used in the generation of the
 * block wait timer. This register may be read at any time. This register must be
 * written to only when C7816[ISO_7816E] is not set.
 */
/*!
 * @name Constants and macros for entire UART_WP7816 register
 */
/*@{*/
#define UART_RD_WP7816(base)     (UART_WP7816_REG(base))
#define UART_WR_WP7816(base, value) (UART_WP7816_REG(base) = (value))
#define UART_RMW_WP7816(base, mask, value) (UART_WR_WP7816(base, (UART_RD_WP7816(base) & ~(mask)) | (value)))
#define UART_SET_WP7816(base, value) (BME_OR8(&UART_WP7816_REG(base), (uint8_t)(value)))
#define UART_CLR_WP7816(base, value) (BME_AND8(&UART_WP7816_REG(base), (uint8_t)(~(value))))
#define UART_TOG_WP7816(base, value) (BME_XOR8(&UART_WP7816_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * UART_WN7816 - UART 7816 Wait N Register
 ******************************************************************************/

/*!
 * @brief UART_WN7816 - UART 7816 Wait N Register (RW)
 *
 * Reset value: 0x00U
 *
 * The WN7816 register contains a parameter that is used in the calculation of
 * the guard time counter. This register may be read at any time. This register
 * must be written to only when C7816[ISO_7816E] is not set.
 */
/*!
 * @name Constants and macros for entire UART_WN7816 register
 */
/*@{*/
#define UART_RD_WN7816(base)     (UART_WN7816_REG(base))
#define UART_WR_WN7816(base, value) (UART_WN7816_REG(base) = (value))
#define UART_RMW_WN7816(base, mask, value) (UART_WR_WN7816(base, (UART_RD_WN7816(base) & ~(mask)) | (value)))
#define UART_SET_WN7816(base, value) (BME_OR8(&UART_WN7816_REG(base), (uint8_t)(value)))
#define UART_CLR_WN7816(base, value) (BME_AND8(&UART_WN7816_REG(base), (uint8_t)(~(value))))
#define UART_TOG_WN7816(base, value) (BME_XOR8(&UART_WN7816_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * UART_WF7816 - UART 7816 Wait FD Register
 ******************************************************************************/

/*!
 * @brief UART_WF7816 - UART 7816 Wait FD Register (RW)
 *
 * Reset value: 0x01U
 *
 * The WF7816 contains parameters that are used in the generation of various
 * counters including GT, CGT, BGT, WT, and BWT. This register may be read at any
 * time. This register must be written to only when C7816[ISO_7816E] is not set.
 */
/*!
 * @name Constants and macros for entire UART_WF7816 register
 */
/*@{*/
#define UART_RD_WF7816(base)     (UART_WF7816_REG(base))
#define UART_WR_WF7816(base, value) (UART_WF7816_REG(base) = (value))
#define UART_RMW_WF7816(base, mask, value) (UART_WR_WF7816(base, (UART_RD_WF7816(base) & ~(mask)) | (value)))
#define UART_SET_WF7816(base, value) (BME_OR8(&UART_WF7816_REG(base), (uint8_t)(value)))
#define UART_CLR_WF7816(base, value) (BME_AND8(&UART_WF7816_REG(base), (uint8_t)(~(value))))
#define UART_TOG_WF7816(base, value) (BME_XOR8(&UART_WF7816_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * UART_ET7816 - UART 7816 Error Threshold Register
 ******************************************************************************/

/*!
 * @brief UART_ET7816 - UART 7816 Error Threshold Register (RW)
 *
 * Reset value: 0x00U
 *
 * The ET7816 register contains fields that determine the number of NACKs that
 * must be received or transmitted before the host processor is notified. This
 * register may be read at anytime. This register must be written to only when
 * C7816[ISO_7816E] is not set.
 */
/*!
 * @name Constants and macros for entire UART_ET7816 register
 */
/*@{*/
#define UART_RD_ET7816(base)     (UART_ET7816_REG(base))
#define UART_WR_ET7816(base, value) (UART_ET7816_REG(base) = (value))
#define UART_RMW_ET7816(base, mask, value) (UART_WR_ET7816(base, (UART_RD_ET7816(base) & ~(mask)) | (value)))
#define UART_SET_ET7816(base, value) (BME_OR8(&UART_ET7816_REG(base), (uint8_t)(value)))
#define UART_CLR_ET7816(base, value) (BME_AND8(&UART_ET7816_REG(base), (uint8_t)(~(value))))
#define UART_TOG_ET7816(base, value) (BME_XOR8(&UART_ET7816_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual UART_ET7816 bitfields
 */

/*!
 * @name Register UART_ET7816, field RXTHRESHOLD[3:0] (RW)
 *
 * The value written to this field indicates the maximum number of consecutive
 * NACKs generated as a result of a parity error or receiver buffer overruns
 * before the host processor is notified. After the counter exceeds that value in the
 * field, the IS7816[RXT] is asserted. This field is meaningful only when
 * C7816[TTYPE] = 0. The value read from this field represents the number of consecutive
 * NACKs that have been transmitted since the last successful reception. This
 * counter saturates at 4'hF and does not wrap around. Regardless of the number of
 * NACKs sent, the UART continues to receive valid packets indefinitely. For
 * additional information, see IS7816[RXT] field description.
 */
/*@{*/
/*! @brief Read current value of the UART_ET7816_RXTHRESHOLD field. */
#define UART_RD_ET7816_RXTHRESHOLD(base) ((UART_ET7816_REG(base) & UART_ET7816_RXTHRESHOLD_MASK) >> UART_ET7816_RXTHRESHOLD_SHIFT)
#define UART_BRD_ET7816_RXTHRESHOLD(base) (BME_UBFX8(&UART_ET7816_REG(base), UART_ET7816_RXTHRESHOLD_SHIFT, UART_ET7816_RXTHRESHOLD_WIDTH))

/*! @brief Set the RXTHRESHOLD field to a new value. */
#define UART_WR_ET7816_RXTHRESHOLD(base, value) (UART_RMW_ET7816(base, UART_ET7816_RXTHRESHOLD_MASK, UART_ET7816_RXTHRESHOLD(value)))
#define UART_BWR_ET7816_RXTHRESHOLD(base, value) (BME_BFI8(&UART_ET7816_REG(base), ((uint8_t)(value) << UART_ET7816_RXTHRESHOLD_SHIFT), UART_ET7816_RXTHRESHOLD_SHIFT, UART_ET7816_RXTHRESHOLD_WIDTH))
/*@}*/

/*!
 * @name Register UART_ET7816, field TXTHRESHOLD[7:4] (RW)
 *
 * The value written to this field indicates the maximum number of failed
 * attempts (NACKs) a transmitted character can have before the host processor is
 * notified. This field is meaningful only when C7816[TTYPE] = 0 and C7816[ANACK] = 1.
 * The value read from this field represents the number of consecutive NACKs
 * that have been received since the last successful transmission. This counter
 * saturates at 4'hF and does not wrap around. Regardless of how many NACKs that are
 * received, the UART continues to retransmit indefinitely. This flag only
 * asserts when C7816[TTYPE] = 0. For additional information see the IS7816[TXT] field
 * description.
 *
 * Values:
 * - 0b0000 - TXT asserts on the first NACK that is received.
 * - 0b0001 - TXT asserts on the second NACK that is received.
 */
/*@{*/
/*! @brief Read current value of the UART_ET7816_TXTHRESHOLD field. */
#define UART_RD_ET7816_TXTHRESHOLD(base) ((UART_ET7816_REG(base) & UART_ET7816_TXTHRESHOLD_MASK) >> UART_ET7816_TXTHRESHOLD_SHIFT)
#define UART_BRD_ET7816_TXTHRESHOLD(base) (BME_UBFX8(&UART_ET7816_REG(base), UART_ET7816_TXTHRESHOLD_SHIFT, UART_ET7816_TXTHRESHOLD_WIDTH))

/*! @brief Set the TXTHRESHOLD field to a new value. */
#define UART_WR_ET7816_TXTHRESHOLD(base, value) (UART_RMW_ET7816(base, UART_ET7816_TXTHRESHOLD_MASK, UART_ET7816_TXTHRESHOLD(value)))
#define UART_BWR_ET7816_TXTHRESHOLD(base, value) (BME_BFI8(&UART_ET7816_REG(base), ((uint8_t)(value) << UART_ET7816_TXTHRESHOLD_SHIFT), UART_ET7816_TXTHRESHOLD_SHIFT, UART_ET7816_TXTHRESHOLD_WIDTH))
/*@}*/

/*******************************************************************************
 * UART_TL7816 - UART 7816 Transmit Length Register
 ******************************************************************************/

/*!
 * @brief UART_TL7816 - UART 7816 Transmit Length Register (RW)
 *
 * Reset value: 0x00U
 *
 * The TL7816 register is used to indicate the number of characters contained in
 * the block being transmitted. This register is used only when C7816[TTYPE] =
 * 1. This register may be read at anytime. This register must be written only
 * when C2[TE] is not enabled.
 */
/*!
 * @name Constants and macros for entire UART_TL7816 register
 */
/*@{*/
#define UART_RD_TL7816(base)     (UART_TL7816_REG(base))
#define UART_WR_TL7816(base, value) (UART_TL7816_REG(base) = (value))
#define UART_RMW_TL7816(base, mask, value) (UART_WR_TL7816(base, (UART_RD_TL7816(base) & ~(mask)) | (value)))
#define UART_SET_TL7816(base, value) (BME_OR8(&UART_TL7816_REG(base), (uint8_t)(value)))
#define UART_CLR_TL7816(base, value) (BME_AND8(&UART_TL7816_REG(base), (uint8_t)(~(value))))
#define UART_TOG_TL7816(base, value) (BME_XOR8(&UART_TL7816_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * UART_AP7816A_T0 - UART 7816 ATR Duration Timer Register A
 ******************************************************************************/

/*!
 * @brief UART_AP7816A_T0 - UART 7816 ATR Duration Timer Register A (RW)
 *
 * Reset value: 0x00U
 *
 * The AP7816A_T0 register contains variables used in the generation of the ATR
 * Duration Timer. This register may be read at any time. This register must be
 * written to only when C7816[ISO_7816E] is not set, except when writing 0 to
 * clear the ADT Counter. The ADT Counter starts counting on detection of the
 * complete TS Character. It must be noted that by this time, exactly 10 ETUs have
 * elapsed since the start bit of the TS character. The user must take this into
 * account while programming this register.
 */
/*!
 * @name Constants and macros for entire UART_AP7816A_T0 register
 */
/*@{*/
#define UART_RD_AP7816A_T0(base) (UART_AP7816A_T0_REG(base))
#define UART_WR_AP7816A_T0(base, value) (UART_AP7816A_T0_REG(base) = (value))
#define UART_RMW_AP7816A_T0(base, mask, value) (UART_WR_AP7816A_T0(base, (UART_RD_AP7816A_T0(base) & ~(mask)) | (value)))
#define UART_SET_AP7816A_T0(base, value) (BME_OR8(&UART_AP7816A_T0_REG(base), (uint8_t)(value)))
#define UART_CLR_AP7816A_T0(base, value) (BME_AND8(&UART_AP7816A_T0_REG(base), (uint8_t)(~(value))))
#define UART_TOG_AP7816A_T0(base, value) (BME_XOR8(&UART_AP7816A_T0_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * UART_AP7816B_T0 - UART 7816 ATR Duration Timer Register B
 ******************************************************************************/

/*!
 * @brief UART_AP7816B_T0 - UART 7816 ATR Duration Timer Register B (RW)
 *
 * Reset value: 0x00U
 *
 * The AP7816B_T0 register contains variables used in the generation of the ATR
 * Duration Timer. This register may be read at any time. This register must be
 * written to only when C7816[ISO_7816E] is not set, except when writing 0 to
 * clear the ADT Counter. The ADT Counter starts counting on detection of the
 * complete TS Character. It must be noted that by this time, exactly 10 ETUs have
 * elapsed since the start bit of the TS character. The user must take this into
 * account while programming this register.
 */
/*!
 * @name Constants and macros for entire UART_AP7816B_T0 register
 */
/*@{*/
#define UART_RD_AP7816B_T0(base) (UART_AP7816B_T0_REG(base))
#define UART_WR_AP7816B_T0(base, value) (UART_AP7816B_T0_REG(base) = (value))
#define UART_RMW_AP7816B_T0(base, mask, value) (UART_WR_AP7816B_T0(base, (UART_RD_AP7816B_T0(base) & ~(mask)) | (value)))
#define UART_SET_AP7816B_T0(base, value) (BME_OR8(&UART_AP7816B_T0_REG(base), (uint8_t)(value)))
#define UART_CLR_AP7816B_T0(base, value) (BME_AND8(&UART_AP7816B_T0_REG(base), (uint8_t)(~(value))))
#define UART_TOG_AP7816B_T0(base, value) (BME_XOR8(&UART_AP7816B_T0_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * UART_WP7816A_T0 - UART 7816 Wait Parameter Register A
 ******************************************************************************/

/*!
 * @brief UART_WP7816A_T0 - UART 7816 Wait Parameter Register A (RW)
 *
 * Reset value: 0x00U
 *
 * The WP7816A_T0 register contains constants used in the generation of various
 * wait time counters. To save register space, this register is used differently
 * when C7816[TTYPE] = 0 and C7816[TTYPE] = 1. This register may be read at any
 * time. This register must be written to only when C7816[ISO_7816E] is not set.
 */
/*!
 * @name Constants and macros for entire UART_WP7816A_T0 register
 */
/*@{*/
#define UART_RD_WP7816A_T0(base) (UART_WP7816A_T0_REG(base))
#define UART_WR_WP7816A_T0(base, value) (UART_WP7816A_T0_REG(base) = (value))
#define UART_RMW_WP7816A_T0(base, mask, value) (UART_WR_WP7816A_T0(base, (UART_RD_WP7816A_T0(base) & ~(mask)) | (value)))
#define UART_SET_WP7816A_T0(base, value) (BME_OR8(&UART_WP7816A_T0_REG(base), (uint8_t)(value)))
#define UART_CLR_WP7816A_T0(base, value) (BME_AND8(&UART_WP7816A_T0_REG(base), (uint8_t)(~(value))))
#define UART_TOG_WP7816A_T0(base, value) (BME_XOR8(&UART_WP7816A_T0_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * UART_WP7816A_T1 - UART 7816 Wait Parameter Register A
 ******************************************************************************/

/*!
 * @brief UART_WP7816A_T1 - UART 7816 Wait Parameter Register A (RW)
 *
 * Reset value: 0x00U
 *
 * The WP7816A_T1 register contains constants used in the generation of various
 * wait time counters. To save register space, this register is used differently
 * when C7816[TTYPE] = 0 and C7816[TTYPE] = 1. This register may be read at any
 * time. This register must be written to only when C7816[ISO_7816E] is not set.
 */
/*!
 * @name Constants and macros for entire UART_WP7816A_T1 register
 */
/*@{*/
#define UART_RD_WP7816A_T1(base) (UART_WP7816A_T1_REG(base))
#define UART_WR_WP7816A_T1(base, value) (UART_WP7816A_T1_REG(base) = (value))
#define UART_RMW_WP7816A_T1(base, mask, value) (UART_WR_WP7816A_T1(base, (UART_RD_WP7816A_T1(base) & ~(mask)) | (value)))
#define UART_SET_WP7816A_T1(base, value) (BME_OR8(&UART_WP7816A_T1_REG(base), (uint8_t)(value)))
#define UART_CLR_WP7816A_T1(base, value) (BME_AND8(&UART_WP7816A_T1_REG(base), (uint8_t)(~(value))))
#define UART_TOG_WP7816A_T1(base, value) (BME_XOR8(&UART_WP7816A_T1_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * UART_WP7816B_T0 - UART 7816 Wait Parameter Register B
 ******************************************************************************/

/*!
 * @brief UART_WP7816B_T0 - UART 7816 Wait Parameter Register B (RW)
 *
 * Reset value: 0x14U
 *
 * The WP7816B_T0 register contains constants used in the generation of various
 * wait time counters. To save register space, this register is used differently
 * when C7816[TTYPE] = 0 and C7816[TTYPE] = 1. This register may be read at any
 * time. This register must be written to only when C7816[ISO_7816E] is not set.
 */
/*!
 * @name Constants and macros for entire UART_WP7816B_T0 register
 */
/*@{*/
#define UART_RD_WP7816B_T0(base) (UART_WP7816B_T0_REG(base))
#define UART_WR_WP7816B_T0(base, value) (UART_WP7816B_T0_REG(base) = (value))
#define UART_RMW_WP7816B_T0(base, mask, value) (UART_WR_WP7816B_T0(base, (UART_RD_WP7816B_T0(base) & ~(mask)) | (value)))
#define UART_SET_WP7816B_T0(base, value) (BME_OR8(&UART_WP7816B_T0_REG(base), (uint8_t)(value)))
#define UART_CLR_WP7816B_T0(base, value) (BME_AND8(&UART_WP7816B_T0_REG(base), (uint8_t)(~(value))))
#define UART_TOG_WP7816B_T0(base, value) (BME_XOR8(&UART_WP7816B_T0_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * UART_WP7816B_T1 - UART 7816 Wait Parameter Register B
 ******************************************************************************/

/*!
 * @brief UART_WP7816B_T1 - UART 7816 Wait Parameter Register B (RW)
 *
 * Reset value: 0x14U
 *
 * The WP7816B_T1 register contains constants used in the generation of various
 * wait time counters. To save register space, this register is used differently
 * when C7816[TTYPE] = 0 and C7816[TTYPE] = 1. This register may be read at any
 * time. This register must be written to only when C7816[ISO_7816E] is not set.
 */
/*!
 * @name Constants and macros for entire UART_WP7816B_T1 register
 */
/*@{*/
#define UART_RD_WP7816B_T1(base) (UART_WP7816B_T1_REG(base))
#define UART_WR_WP7816B_T1(base, value) (UART_WP7816B_T1_REG(base) = (value))
#define UART_RMW_WP7816B_T1(base, mask, value) (UART_WR_WP7816B_T1(base, (UART_RD_WP7816B_T1(base) & ~(mask)) | (value)))
#define UART_SET_WP7816B_T1(base, value) (BME_OR8(&UART_WP7816B_T1_REG(base), (uint8_t)(value)))
#define UART_CLR_WP7816B_T1(base, value) (BME_AND8(&UART_WP7816B_T1_REG(base), (uint8_t)(~(value))))
#define UART_TOG_WP7816B_T1(base, value) (BME_XOR8(&UART_WP7816B_T1_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * UART_WGP7816_T1 - UART 7816 Wait and Guard Parameter Register
 ******************************************************************************/

/*!
 * @brief UART_WGP7816_T1 - UART 7816 Wait and Guard Parameter Register (RW)
 *
 * Reset value: 0x06U
 *
 * The WGP7816_T1 register contains constants used in the generation of various
 * wait and guard timer counters. This register may be read at any time. This
 * register must be written to only when C7816[ISO_7816E] is not set.
 */
/*!
 * @name Constants and macros for entire UART_WGP7816_T1 register
 */
/*@{*/
#define UART_RD_WGP7816_T1(base) (UART_WGP7816_T1_REG(base))
#define UART_WR_WGP7816_T1(base, value) (UART_WGP7816_T1_REG(base) = (value))
#define UART_RMW_WGP7816_T1(base, mask, value) (UART_WR_WGP7816_T1(base, (UART_RD_WGP7816_T1(base) & ~(mask)) | (value)))
#define UART_SET_WGP7816_T1(base, value) (BME_OR8(&UART_WGP7816_T1_REG(base), (uint8_t)(value)))
#define UART_CLR_WGP7816_T1(base, value) (BME_AND8(&UART_WGP7816_T1_REG(base), (uint8_t)(~(value))))
#define UART_TOG_WGP7816_T1(base, value) (BME_XOR8(&UART_WGP7816_T1_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual UART_WGP7816_T1 bitfields
 */

/*!
 * @name Register UART_WGP7816_T1, field BGI[3:0] (RW)
 *
 * Used to calculate the value used for the BGT counter. It represent a value
 * between 0 and 15. This value is used only when C7816[TTYPE] = 1. See Wait time
 * and guard time parameters .
 */
/*@{*/
/*! @brief Read current value of the UART_WGP7816_T1_BGI field. */
#define UART_RD_WGP7816_T1_BGI(base) ((UART_WGP7816_T1_REG(base) & UART_WGP7816_T1_BGI_MASK) >> UART_WGP7816_T1_BGI_SHIFT)
#define UART_BRD_WGP7816_T1_BGI(base) (BME_UBFX8(&UART_WGP7816_T1_REG(base), UART_WGP7816_T1_BGI_SHIFT, UART_WGP7816_T1_BGI_WIDTH))

/*! @brief Set the BGI field to a new value. */
#define UART_WR_WGP7816_T1_BGI(base, value) (UART_RMW_WGP7816_T1(base, UART_WGP7816_T1_BGI_MASK, UART_WGP7816_T1_BGI(value)))
#define UART_BWR_WGP7816_T1_BGI(base, value) (BME_BFI8(&UART_WGP7816_T1_REG(base), ((uint8_t)(value) << UART_WGP7816_T1_BGI_SHIFT), UART_WGP7816_T1_BGI_SHIFT, UART_WGP7816_T1_BGI_WIDTH))
/*@}*/

/*!
 * @name Register UART_WGP7816_T1, field CWI1[7:4] (RW)
 *
 * Used to calculate the value used for the CWT counter. It represents a value
 * between 0 and 15. This value is used only when C7816[TTYPE] = 1. See Wait time
 * and guard time parameters .
 */
/*@{*/
/*! @brief Read current value of the UART_WGP7816_T1_CWI1 field. */
#define UART_RD_WGP7816_T1_CWI1(base) ((UART_WGP7816_T1_REG(base) & UART_WGP7816_T1_CWI1_MASK) >> UART_WGP7816_T1_CWI1_SHIFT)
#define UART_BRD_WGP7816_T1_CWI1(base) (BME_UBFX8(&UART_WGP7816_T1_REG(base), UART_WGP7816_T1_CWI1_SHIFT, UART_WGP7816_T1_CWI1_WIDTH))

/*! @brief Set the CWI1 field to a new value. */
#define UART_WR_WGP7816_T1_CWI1(base, value) (UART_RMW_WGP7816_T1(base, UART_WGP7816_T1_CWI1_MASK, UART_WGP7816_T1_CWI1(value)))
#define UART_BWR_WGP7816_T1_CWI1(base, value) (BME_BFI8(&UART_WGP7816_T1_REG(base), ((uint8_t)(value) << UART_WGP7816_T1_CWI1_SHIFT), UART_WGP7816_T1_CWI1_SHIFT, UART_WGP7816_T1_CWI1_WIDTH))
/*@}*/

/*******************************************************************************
 * UART_WP7816C_T1 - UART 7816 Wait Parameter Register C
 ******************************************************************************/

/*!
 * @brief UART_WP7816C_T1 - UART 7816 Wait Parameter Register C (RW)
 *
 * Reset value: 0x0BU
 *
 * The WP7816C_T1 register contains constants used in the generation of various
 * wait timer counters. This register may be read at any time. This register must
 * be written to only when C7816[ISO_7816E] is not set.
 */
/*!
 * @name Constants and macros for entire UART_WP7816C_T1 register
 */
/*@{*/
#define UART_RD_WP7816C_T1(base) (UART_WP7816C_T1_REG(base))
#define UART_WR_WP7816C_T1(base, value) (UART_WP7816C_T1_REG(base) = (value))
#define UART_RMW_WP7816C_T1(base, mask, value) (UART_WR_WP7816C_T1(base, (UART_RD_WP7816C_T1(base) & ~(mask)) | (value)))
#define UART_SET_WP7816C_T1(base, value) (BME_OR8(&UART_WP7816C_T1_REG(base), (uint8_t)(value)))
#define UART_CLR_WP7816C_T1(base, value) (BME_AND8(&UART_WP7816C_T1_REG(base), (uint8_t)(~(value))))
#define UART_TOG_WP7816C_T1(base, value) (BME_XOR8(&UART_WP7816C_T1_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual UART_WP7816C_T1 bitfields
 */

/*!
 * @name Register UART_WP7816C_T1, field CWI2[4:0] (RW)
 *
 * Used to calculate the value used for the CWT counter. It represents a value
 * between 0 and 31. This value is used only when C7816[TTYPE] = 1. See Wait time
 * and guard time parameters .
 */
/*@{*/
/*! @brief Read current value of the UART_WP7816C_T1_CWI2 field. */
#define UART_RD_WP7816C_T1_CWI2(base) ((UART_WP7816C_T1_REG(base) & UART_WP7816C_T1_CWI2_MASK) >> UART_WP7816C_T1_CWI2_SHIFT)
#define UART_BRD_WP7816C_T1_CWI2(base) (BME_UBFX8(&UART_WP7816C_T1_REG(base), UART_WP7816C_T1_CWI2_SHIFT, UART_WP7816C_T1_CWI2_WIDTH))

/*! @brief Set the CWI2 field to a new value. */
#define UART_WR_WP7816C_T1_CWI2(base, value) (UART_RMW_WP7816C_T1(base, UART_WP7816C_T1_CWI2_MASK, UART_WP7816C_T1_CWI2(value)))
#define UART_BWR_WP7816C_T1_CWI2(base, value) (BME_BFI8(&UART_WP7816C_T1_REG(base), ((uint8_t)(value) << UART_WP7816C_T1_CWI2_SHIFT), UART_WP7816C_T1_CWI2_SHIFT, UART_WP7816C_T1_CWI2_WIDTH))
/*@}*/

/*
 * MKM34Z7 VREF
 *
 * Voltage Reference
 *
 * Registers defined in this header file:
 * - VREF_VREFH_TRM - VREF Trim Register
 * - VREF_VREFH_SC - VREF Status and Control Register
 * - VREF_VREFL_TRM - VREFL TRIM Register
 */

#define VREF_INSTANCE_COUNT (1U) /*!< Number of instances of the VREF module. */
#define VREF_IDX (0U) /*!< Instance number for VREF. */

/*******************************************************************************
 * VREF_VREFH_TRM - VREF Trim Register
 ******************************************************************************/

/*!
 * @brief VREF_VREFH_TRM - VREF Trim Register (RW)
 *
 * Reset value: 0x00U
 *
 * This register contains bits that contain the trim data for the Voltage
 * Reference.
 */
/*!
 * @name Constants and macros for entire VREF_VREFH_TRM register
 */
/*@{*/
#define VREF_RD_VREFH_TRM(base)  (VREF_VREFH_TRM_REG(base))
#define VREF_WR_VREFH_TRM(base, value) (VREF_VREFH_TRM_REG(base) = (value))
#define VREF_RMW_VREFH_TRM(base, mask, value) (VREF_WR_VREFH_TRM(base, (VREF_RD_VREFH_TRM(base) & ~(mask)) | (value)))
#define VREF_SET_VREFH_TRM(base, value) (BME_OR8(&VREF_VREFH_TRM_REG(base), (uint8_t)(value)))
#define VREF_CLR_VREFH_TRM(base, value) (BME_AND8(&VREF_VREFH_TRM_REG(base), (uint8_t)(~(value))))
#define VREF_TOG_VREFH_TRM(base, value) (BME_XOR8(&VREF_VREFH_TRM_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual VREF_VREFH_TRM bitfields
 */

/*!
 * @name Register VREF_VREFH_TRM, field TRIM[5:0] (RW)
 *
 * These bits change the resulting VREF by approximately +/- 0.5 mV for each
 * step. Min = minimum and max = maximum voltage reference output. For minimum and
 * maximum voltage reference output values, refer to the Data Sheet for this chip.
 *
 * Values:
 * - 0b000000 - Min
 * - 0b111111 - Max
 */
/*@{*/
/*! @brief Read current value of the VREF_VREFH_TRM_TRIM field. */
#define VREF_RD_VREFH_TRM_TRIM(base) ((VREF_VREFH_TRM_REG(base) & VREF_VREFH_TRM_TRIM_MASK) >> VREF_VREFH_TRM_TRIM_SHIFT)
#define VREF_BRD_VREFH_TRM_TRIM(base) (BME_UBFX8(&VREF_VREFH_TRM_REG(base), VREF_VREFH_TRM_TRIM_SHIFT, VREF_VREFH_TRM_TRIM_WIDTH))

/*! @brief Set the TRIM field to a new value. */
#define VREF_WR_VREFH_TRM_TRIM(base, value) (VREF_RMW_VREFH_TRM(base, VREF_VREFH_TRM_TRIM_MASK, VREF_VREFH_TRM_TRIM(value)))
#define VREF_BWR_VREFH_TRM_TRIM(base, value) (BME_BFI8(&VREF_VREFH_TRM_REG(base), ((uint8_t)(value) << VREF_VREFH_TRM_TRIM_SHIFT), VREF_VREFH_TRM_TRIM_SHIFT, VREF_VREFH_TRM_TRIM_WIDTH))
/*@}*/

/*!
 * @name Register VREF_VREFH_TRM, field CHOPEN[6] (RW)
 *
 * This bit is set during factory trimming of the VREF voltage. This bit should
 * be written to 1 to achieve the performance stated in the data sheet.
 *
 * Values:
 * - 0b0 - Chop oscillator is disabled.
 * - 0b1 - Chop oscillator is enabled.
 */
/*@{*/
/*! @brief Read current value of the VREF_VREFH_TRM_CHOPEN field. */
#define VREF_RD_VREFH_TRM_CHOPEN(base) ((VREF_VREFH_TRM_REG(base) & VREF_VREFH_TRM_CHOPEN_MASK) >> VREF_VREFH_TRM_CHOPEN_SHIFT)
#define VREF_BRD_VREFH_TRM_CHOPEN(base) (BME_UBFX8(&VREF_VREFH_TRM_REG(base), VREF_VREFH_TRM_CHOPEN_SHIFT, VREF_VREFH_TRM_CHOPEN_WIDTH))

/*! @brief Set the CHOPEN field to a new value. */
#define VREF_WR_VREFH_TRM_CHOPEN(base, value) (VREF_RMW_VREFH_TRM(base, VREF_VREFH_TRM_CHOPEN_MASK, VREF_VREFH_TRM_CHOPEN(value)))
#define VREF_BWR_VREFH_TRM_CHOPEN(base, value) (BME_BFI8(&VREF_VREFH_TRM_REG(base), ((uint8_t)(value) << VREF_VREFH_TRM_CHOPEN_SHIFT), VREF_VREFH_TRM_CHOPEN_SHIFT, VREF_VREFH_TRM_CHOPEN_WIDTH))
/*@}*/

/*******************************************************************************
 * VREF_VREFH_SC - VREF Status and Control Register
 ******************************************************************************/

/*!
 * @brief VREF_VREFH_SC - VREF Status and Control Register (RW)
 *
 * Reset value: 0x00U
 *
 * This register contains the control bits used to enable the internal voltage
 * reference and to select the buffer mode to be used.
 */
/*!
 * @name Constants and macros for entire VREF_VREFH_SC register
 */
/*@{*/
#define VREF_RD_VREFH_SC(base)   (VREF_VREFH_SC_REG(base))
#define VREF_WR_VREFH_SC(base, value) (VREF_VREFH_SC_REG(base) = (value))
#define VREF_RMW_VREFH_SC(base, mask, value) (VREF_WR_VREFH_SC(base, (VREF_RD_VREFH_SC(base) & ~(mask)) | (value)))
#define VREF_SET_VREFH_SC(base, value) (BME_OR8(&VREF_VREFH_SC_REG(base), (uint8_t)(value)))
#define VREF_CLR_VREFH_SC(base, value) (BME_AND8(&VREF_VREFH_SC_REG(base), (uint8_t)(~(value))))
#define VREF_TOG_VREFH_SC(base, value) (BME_XOR8(&VREF_VREFH_SC_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual VREF_VREFH_SC bitfields
 */

/*!
 * @name Register VREF_VREFH_SC, field MODE_LV[1:0] (RW)
 *
 * These bits select the buffer modes for the Voltage Reference module.
 *
 * Values:
 * - 0b00 - Bandgap on only, for stabilization and startup
 * - 0b01 - High power buffer mode enabled
 * - 0b10 - Low-power buffer mode enabled
 * - 0b11 - Reserved
 */
/*@{*/
/*! @brief Read current value of the VREF_VREFH_SC_MODE_LV field. */
#define VREF_RD_VREFH_SC_MODE_LV(base) ((VREF_VREFH_SC_REG(base) & VREF_VREFH_SC_MODE_LV_MASK) >> VREF_VREFH_SC_MODE_LV_SHIFT)
#define VREF_BRD_VREFH_SC_MODE_LV(base) (BME_UBFX8(&VREF_VREFH_SC_REG(base), VREF_VREFH_SC_MODE_LV_SHIFT, VREF_VREFH_SC_MODE_LV_WIDTH))

/*! @brief Set the MODE_LV field to a new value. */
#define VREF_WR_VREFH_SC_MODE_LV(base, value) (VREF_RMW_VREFH_SC(base, VREF_VREFH_SC_MODE_LV_MASK, VREF_VREFH_SC_MODE_LV(value)))
#define VREF_BWR_VREFH_SC_MODE_LV(base, value) (BME_BFI8(&VREF_VREFH_SC_REG(base), ((uint8_t)(value) << VREF_VREFH_SC_MODE_LV_SHIFT), VREF_VREFH_SC_MODE_LV_SHIFT, VREF_VREFH_SC_MODE_LV_WIDTH))
/*@}*/

/*!
 * @name Register VREF_VREFH_SC, field VREFST[2] (RO)
 *
 * This bit indicates that the bandgap reference within the Voltage Reference
 * module has completed its startup and stabilization.
 *
 * Values:
 * - 0b0 - The module is disabled or not stable.
 * - 0b1 - The module is stable.
 */
/*@{*/
/*! @brief Read current value of the VREF_VREFH_SC_VREFST field. */
#define VREF_RD_VREFH_SC_VREFST(base) ((VREF_VREFH_SC_REG(base) & VREF_VREFH_SC_VREFST_MASK) >> VREF_VREFH_SC_VREFST_SHIFT)
#define VREF_BRD_VREFH_SC_VREFST(base) (BME_UBFX8(&VREF_VREFH_SC_REG(base), VREF_VREFH_SC_VREFST_SHIFT, VREF_VREFH_SC_VREFST_WIDTH))
/*@}*/

/*!
 * @name Register VREF_VREFH_SC, field ICOMPEN[5] (RW)
 *
 * This bit is set during factory trimming of the VREF voltage. This bit should
 * be written to 1 to achieve the performance stated in the data sheet.
 *
 * Values:
 * - 0b0 - Disabled
 * - 0b1 - Enabled
 */
/*@{*/
/*! @brief Read current value of the VREF_VREFH_SC_ICOMPEN field. */
#define VREF_RD_VREFH_SC_ICOMPEN(base) ((VREF_VREFH_SC_REG(base) & VREF_VREFH_SC_ICOMPEN_MASK) >> VREF_VREFH_SC_ICOMPEN_SHIFT)
#define VREF_BRD_VREFH_SC_ICOMPEN(base) (BME_UBFX8(&VREF_VREFH_SC_REG(base), VREF_VREFH_SC_ICOMPEN_SHIFT, VREF_VREFH_SC_ICOMPEN_WIDTH))

/*! @brief Set the ICOMPEN field to a new value. */
#define VREF_WR_VREFH_SC_ICOMPEN(base, value) (VREF_RMW_VREFH_SC(base, VREF_VREFH_SC_ICOMPEN_MASK, VREF_VREFH_SC_ICOMPEN(value)))
#define VREF_BWR_VREFH_SC_ICOMPEN(base, value) (BME_BFI8(&VREF_VREFH_SC_REG(base), ((uint8_t)(value) << VREF_VREFH_SC_ICOMPEN_SHIFT), VREF_VREFH_SC_ICOMPEN_SHIFT, VREF_VREFH_SC_ICOMPEN_WIDTH))
/*@}*/

/*!
 * @name Register VREF_VREFH_SC, field REGEN[6] (RW)
 *
 * This bit is used to enable the internal 1.75 V regulator to produce a
 * constant internal voltage supply in order to reduce the sensitivity to external
 * supply noise and variation. If it is desired to keep the regulator enabled in very
 * low power modes, refer to the Chip Configuration chapter for a description on
 * how this can be achieved. This bit is set during factory trimming of the VREF
 * voltage. This bit should be written to 1 to achieve the performance stated in
 * the data sheet.
 *
 * Values:
 * - 0b0 - Internal 1.75 V regulator is disabled.
 * - 0b1 - Internal 1.75 V regulator is enabled.
 */
/*@{*/
/*! @brief Read current value of the VREF_VREFH_SC_REGEN field. */
#define VREF_RD_VREFH_SC_REGEN(base) ((VREF_VREFH_SC_REG(base) & VREF_VREFH_SC_REGEN_MASK) >> VREF_VREFH_SC_REGEN_SHIFT)
#define VREF_BRD_VREFH_SC_REGEN(base) (BME_UBFX8(&VREF_VREFH_SC_REG(base), VREF_VREFH_SC_REGEN_SHIFT, VREF_VREFH_SC_REGEN_WIDTH))

/*! @brief Set the REGEN field to a new value. */
#define VREF_WR_VREFH_SC_REGEN(base, value) (VREF_RMW_VREFH_SC(base, VREF_VREFH_SC_REGEN_MASK, VREF_VREFH_SC_REGEN(value)))
#define VREF_BWR_VREFH_SC_REGEN(base, value) (BME_BFI8(&VREF_VREFH_SC_REG(base), ((uint8_t)(value) << VREF_VREFH_SC_REGEN_SHIFT), VREF_VREFH_SC_REGEN_SHIFT, VREF_VREFH_SC_REGEN_WIDTH))
/*@}*/

/*!
 * @name Register VREF_VREFH_SC, field VREFEN[7] (RW)
 *
 * This bit is used to enable the bandgap reference within the Voltage Reference
 * module. After the VREF is enabled, turning off the clock to the VREF module
 * via the corresponding clock gate register will not disable the VREF. VREF must
 * be disabled via this VREFEN bit.
 *
 * Values:
 * - 0b0 - The module is disabled.
 * - 0b1 - The module is enabled.
 */
/*@{*/
/*! @brief Read current value of the VREF_VREFH_SC_VREFEN field. */
#define VREF_RD_VREFH_SC_VREFEN(base) ((VREF_VREFH_SC_REG(base) & VREF_VREFH_SC_VREFEN_MASK) >> VREF_VREFH_SC_VREFEN_SHIFT)
#define VREF_BRD_VREFH_SC_VREFEN(base) (BME_UBFX8(&VREF_VREFH_SC_REG(base), VREF_VREFH_SC_VREFEN_SHIFT, VREF_VREFH_SC_VREFEN_WIDTH))

/*! @brief Set the VREFEN field to a new value. */
#define VREF_WR_VREFH_SC_VREFEN(base, value) (VREF_RMW_VREFH_SC(base, VREF_VREFH_SC_VREFEN_MASK, VREF_VREFH_SC_VREFEN(value)))
#define VREF_BWR_VREFH_SC_VREFEN(base, value) (BME_BFI8(&VREF_VREFH_SC_REG(base), ((uint8_t)(value) << VREF_VREFH_SC_VREFEN_SHIFT), VREF_VREFH_SC_VREFEN_SHIFT, VREF_VREFH_SC_VREFEN_WIDTH))
/*@}*/

/*******************************************************************************
 * VREF_VREFL_TRM - VREFL TRIM Register
 ******************************************************************************/

/*!
 * @brief VREF_VREFL_TRM - VREFL TRIM Register (RW)
 *
 * Reset value: 0x03U
 *
 * This register contains bits that contain enable and trim data for VREFL (0.4
 * V) reference. It also contains a bit to select between internal and external
 * 1.2 V reference.
 */
/*!
 * @name Constants and macros for entire VREF_VREFL_TRM register
 */
/*@{*/
#define VREF_RD_VREFL_TRM(base)  (VREF_VREFL_TRM_REG(base))
#define VREF_WR_VREFL_TRM(base, value) (VREF_VREFL_TRM_REG(base) = (value))
#define VREF_RMW_VREFL_TRM(base, mask, value) (VREF_WR_VREFL_TRM(base, (VREF_RD_VREFL_TRM(base) & ~(mask)) | (value)))
#define VREF_SET_VREFL_TRM(base, value) (BME_OR8(&VREF_VREFL_TRM_REG(base), (uint8_t)(value)))
#define VREF_CLR_VREFL_TRM(base, value) (BME_AND8(&VREF_VREFL_TRM_REG(base), (uint8_t)(~(value))))
#define VREF_TOG_VREFL_TRM(base, value) (BME_XOR8(&VREF_VREFL_TRM_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual VREF_VREFL_TRM bitfields
 */

/*!
 * @name Register VREF_VREFL_TRM, field VREFL_TRIM[2:0] (RW)
 *
 * These bits trim the VREFL reference voltage in steps of 10 mV. The mid
 * voltage of the trim range is 0.4 V at the trim value of 011. The values 111 and 110
 * are NOT valid/allowed. Value of VREFL_TRIM (default 011) is determined by IFR.
 */
/*@{*/
/*! @brief Read current value of the VREF_VREFL_TRM_VREFL_TRIM field. */
#define VREF_RD_VREFL_TRM_VREFL_TRIM(base) ((VREF_VREFL_TRM_REG(base) & VREF_VREFL_TRM_VREFL_TRIM_MASK) >> VREF_VREFL_TRM_VREFL_TRIM_SHIFT)
#define VREF_BRD_VREFL_TRM_VREFL_TRIM(base) (BME_UBFX8(&VREF_VREFL_TRM_REG(base), VREF_VREFL_TRM_VREFL_TRIM_SHIFT, VREF_VREFL_TRM_VREFL_TRIM_WIDTH))

/*! @brief Set the VREFL_TRIM field to a new value. */
#define VREF_WR_VREFL_TRM_VREFL_TRIM(base, value) (VREF_RMW_VREFL_TRM(base, VREF_VREFL_TRM_VREFL_TRIM_MASK, VREF_VREFL_TRM_VREFL_TRIM(value)))
#define VREF_BWR_VREFL_TRM_VREFL_TRIM(base, value) (BME_BFI8(&VREF_VREFL_TRM_REG(base), ((uint8_t)(value) << VREF_VREFL_TRM_VREFL_TRIM_SHIFT), VREF_VREFL_TRM_VREFL_TRIM_SHIFT, VREF_VREFL_TRM_VREFL_TRIM_WIDTH))
/*@}*/

/*!
 * @name Register VREF_VREFL_TRM, field VREFL_EN[3] (RW)
 *
 * This bit enables the VREFL (0.4 V) reference buffer.
 *
 * Values:
 * - 0b0 - Disable
 * - 0b1 - Enable
 */
/*@{*/
/*! @brief Read current value of the VREF_VREFL_TRM_VREFL_EN field. */
#define VREF_RD_VREFL_TRM_VREFL_EN(base) ((VREF_VREFL_TRM_REG(base) & VREF_VREFL_TRM_VREFL_EN_MASK) >> VREF_VREFL_TRM_VREFL_EN_SHIFT)
#define VREF_BRD_VREFL_TRM_VREFL_EN(base) (BME_UBFX8(&VREF_VREFL_TRM_REG(base), VREF_VREFL_TRM_VREFL_EN_SHIFT, VREF_VREFL_TRM_VREFL_EN_WIDTH))

/*! @brief Set the VREFL_EN field to a new value. */
#define VREF_WR_VREFL_TRM_VREFL_EN(base, value) (VREF_RMW_VREFL_TRM(base, VREF_VREFL_TRM_VREFL_EN_MASK, VREF_VREFL_TRM_VREFL_EN(value)))
#define VREF_BWR_VREFL_TRM_VREFL_EN(base, value) (BME_BFI8(&VREF_VREFL_TRM_REG(base), ((uint8_t)(value) << VREF_VREFL_TRM_VREFL_EN_SHIFT), VREF_VREFL_TRM_VREFL_EN_SHIFT, VREF_VREFL_TRM_VREFL_EN_WIDTH))
/*@}*/

/*!
 * @name Register VREF_VREFL_TRM, field VREFL_SEL[4] (RW)
 *
 * This bit selects between internal and external 1.2 V reference.
 *
 * Values:
 * - 0b0 - Internal reference
 * - 0b1 - External reference
 */
/*@{*/
/*! @brief Read current value of the VREF_VREFL_TRM_VREFL_SEL field. */
#define VREF_RD_VREFL_TRM_VREFL_SEL(base) ((VREF_VREFL_TRM_REG(base) & VREF_VREFL_TRM_VREFL_SEL_MASK) >> VREF_VREFL_TRM_VREFL_SEL_SHIFT)
#define VREF_BRD_VREFL_TRM_VREFL_SEL(base) (BME_UBFX8(&VREF_VREFL_TRM_REG(base), VREF_VREFL_TRM_VREFL_SEL_SHIFT, VREF_VREFL_TRM_VREFL_SEL_WIDTH))

/*! @brief Set the VREFL_SEL field to a new value. */
#define VREF_WR_VREFL_TRM_VREFL_SEL(base, value) (VREF_RMW_VREFL_TRM(base, VREF_VREFL_TRM_VREFL_SEL_MASK, VREF_VREFL_TRM_VREFL_SEL(value)))
#define VREF_BWR_VREFL_TRM_VREFL_SEL(base, value) (BME_BFI8(&VREF_VREFL_TRM_REG(base), ((uint8_t)(value) << VREF_VREFL_TRM_VREFL_SEL_SHIFT), VREF_VREFL_TRM_VREFL_SEL_SHIFT, VREF_VREFL_TRM_VREFL_SEL_WIDTH))
/*@}*/

/*
 * MKM34Z7 WDOG
 *
 * Generation 2008 Watchdog Timer
 *
 * Registers defined in this header file:
 * - WDOG_STCTRLH - Watchdog Status and Control Register High
 * - WDOG_STCTRLL - Watchdog Status and Control Register Low
 * - WDOG_TOVALH - Watchdog Time-out Value Register High
 * - WDOG_TOVALL - Watchdog Time-out Value Register Low
 * - WDOG_WINH - Watchdog Window Register High
 * - WDOG_WINL - Watchdog Window Register Low
 * - WDOG_REFRESH - Watchdog Refresh register
 * - WDOG_UNLOCK - Watchdog Unlock register
 * - WDOG_TMROUTH - Watchdog Timer Output Register High
 * - WDOG_TMROUTL - Watchdog Timer Output Register Low
 * - WDOG_RSTCNT - Watchdog Reset Count register
 * - WDOG_PRESC - Watchdog Prescaler register
 */

#define WDOG_INSTANCE_COUNT (1U) /*!< Number of instances of the WDOG module. */
#define WDOG_IDX (0U) /*!< Instance number for WDOG. */

/*******************************************************************************
 * WDOG_STCTRLH - Watchdog Status and Control Register High
 ******************************************************************************/

/*!
 * @brief WDOG_STCTRLH - Watchdog Status and Control Register High (RW)
 *
 * Reset value: 0x0151U
 */
/*!
 * @name Constants and macros for entire WDOG_STCTRLH register
 */
/*@{*/
#define WDOG_RD_STCTRLH(base)    (WDOG_STCTRLH_REG(base))
#define WDOG_WR_STCTRLH(base, value) (WDOG_STCTRLH_REG(base) = (value))
#define WDOG_RMW_STCTRLH(base, mask, value) (WDOG_WR_STCTRLH(base, (WDOG_RD_STCTRLH(base) & ~(mask)) | (value)))
#define WDOG_SET_STCTRLH(base, value) (BME_OR16(&WDOG_STCTRLH_REG(base), (uint16_t)(value)))
#define WDOG_CLR_STCTRLH(base, value) (BME_AND16(&WDOG_STCTRLH_REG(base), (uint16_t)(~(value))))
#define WDOG_TOG_STCTRLH(base, value) (BME_XOR16(&WDOG_STCTRLH_REG(base), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual WDOG_STCTRLH bitfields
 */

/*!
 * @name Register WDOG_STCTRLH, field WDOGEN[0] (RW)
 *
 * Enables or disables the WDOG's operation. In the disabled state, the watchdog
 * timer is kept in the reset state, but the other exception conditions can
 * still trigger a reset/interrupt. A change in the value of this bit must be held
 * for more than one WDOG_CLK cycle for the WDOG to be enabled or disabled.
 *
 * Values:
 * - 0b0 - WDOG is disabled.
 * - 0b1 - WDOG is enabled.
 */
/*@{*/
/*! @brief Read current value of the WDOG_STCTRLH_WDOGEN field. */
#define WDOG_RD_STCTRLH_WDOGEN(base) ((WDOG_STCTRLH_REG(base) & WDOG_STCTRLH_WDOGEN_MASK) >> WDOG_STCTRLH_WDOGEN_SHIFT)
#define WDOG_BRD_STCTRLH_WDOGEN(base) (BME_UBFX16(&WDOG_STCTRLH_REG(base), WDOG_STCTRLH_WDOGEN_SHIFT, WDOG_STCTRLH_WDOGEN_WIDTH))

/*! @brief Set the WDOGEN field to a new value. */
#define WDOG_WR_STCTRLH_WDOGEN(base, value) (WDOG_RMW_STCTRLH(base, WDOG_STCTRLH_WDOGEN_MASK, WDOG_STCTRLH_WDOGEN(value)))
#define WDOG_BWR_STCTRLH_WDOGEN(base, value) (BME_BFI16(&WDOG_STCTRLH_REG(base), ((uint16_t)(value) << WDOG_STCTRLH_WDOGEN_SHIFT), WDOG_STCTRLH_WDOGEN_SHIFT, WDOG_STCTRLH_WDOGEN_WIDTH))
/*@}*/

/*!
 * @name Register WDOG_STCTRLH, field CLKSRC[1] (RW)
 *
 * Selects clock source for the WDOG timer and other internal timing operations.
 *
 * Values:
 * - 0b0 - WDOG clock sourced from LPO .
 * - 0b1 - WDOG clock sourced from alternate clock source.
 */
/*@{*/
/*! @brief Read current value of the WDOG_STCTRLH_CLKSRC field. */
#define WDOG_RD_STCTRLH_CLKSRC(base) ((WDOG_STCTRLH_REG(base) & WDOG_STCTRLH_CLKSRC_MASK) >> WDOG_STCTRLH_CLKSRC_SHIFT)
#define WDOG_BRD_STCTRLH_CLKSRC(base) (BME_UBFX16(&WDOG_STCTRLH_REG(base), WDOG_STCTRLH_CLKSRC_SHIFT, WDOG_STCTRLH_CLKSRC_WIDTH))

/*! @brief Set the CLKSRC field to a new value. */
#define WDOG_WR_STCTRLH_CLKSRC(base, value) (WDOG_RMW_STCTRLH(base, WDOG_STCTRLH_CLKSRC_MASK, WDOG_STCTRLH_CLKSRC(value)))
#define WDOG_BWR_STCTRLH_CLKSRC(base, value) (BME_BFI16(&WDOG_STCTRLH_REG(base), ((uint16_t)(value) << WDOG_STCTRLH_CLKSRC_SHIFT), WDOG_STCTRLH_CLKSRC_SHIFT, WDOG_STCTRLH_CLKSRC_WIDTH))
/*@}*/

/*!
 * @name Register WDOG_STCTRLH, field IRQRSTEN[2] (RW)
 *
 * Used to enable the debug breadcrumbs feature. A change in this bit is updated
 * immediately, as opposed to updating after WCT.
 *
 * Values:
 * - 0b0 - WDOG time-out generates reset only.
 * - 0b1 - WDOG time-out initially generates an interrupt. After WCT, it
 *     generates a reset.
 */
/*@{*/
/*! @brief Read current value of the WDOG_STCTRLH_IRQRSTEN field. */
#define WDOG_RD_STCTRLH_IRQRSTEN(base) ((WDOG_STCTRLH_REG(base) & WDOG_STCTRLH_IRQRSTEN_MASK) >> WDOG_STCTRLH_IRQRSTEN_SHIFT)
#define WDOG_BRD_STCTRLH_IRQRSTEN(base) (BME_UBFX16(&WDOG_STCTRLH_REG(base), WDOG_STCTRLH_IRQRSTEN_SHIFT, WDOG_STCTRLH_IRQRSTEN_WIDTH))

/*! @brief Set the IRQRSTEN field to a new value. */
#define WDOG_WR_STCTRLH_IRQRSTEN(base, value) (WDOG_RMW_STCTRLH(base, WDOG_STCTRLH_IRQRSTEN_MASK, WDOG_STCTRLH_IRQRSTEN(value)))
#define WDOG_BWR_STCTRLH_IRQRSTEN(base, value) (BME_BFI16(&WDOG_STCTRLH_REG(base), ((uint16_t)(value) << WDOG_STCTRLH_IRQRSTEN_SHIFT), WDOG_STCTRLH_IRQRSTEN_SHIFT, WDOG_STCTRLH_IRQRSTEN_WIDTH))
/*@}*/

/*!
 * @name Register WDOG_STCTRLH, field WINEN[3] (RW)
 *
 * Enables Windowing mode.
 *
 * Values:
 * - 0b0 - Windowing mode is disabled.
 * - 0b1 - Windowing mode is enabled.
 */
/*@{*/
/*! @brief Read current value of the WDOG_STCTRLH_WINEN field. */
#define WDOG_RD_STCTRLH_WINEN(base) ((WDOG_STCTRLH_REG(base) & WDOG_STCTRLH_WINEN_MASK) >> WDOG_STCTRLH_WINEN_SHIFT)
#define WDOG_BRD_STCTRLH_WINEN(base) (BME_UBFX16(&WDOG_STCTRLH_REG(base), WDOG_STCTRLH_WINEN_SHIFT, WDOG_STCTRLH_WINEN_WIDTH))

/*! @brief Set the WINEN field to a new value. */
#define WDOG_WR_STCTRLH_WINEN(base, value) (WDOG_RMW_STCTRLH(base, WDOG_STCTRLH_WINEN_MASK, WDOG_STCTRLH_WINEN(value)))
#define WDOG_BWR_STCTRLH_WINEN(base, value) (BME_BFI16(&WDOG_STCTRLH_REG(base), ((uint16_t)(value) << WDOG_STCTRLH_WINEN_SHIFT), WDOG_STCTRLH_WINEN_SHIFT, WDOG_STCTRLH_WINEN_WIDTH))
/*@}*/

/*!
 * @name Register WDOG_STCTRLH, field ALLOWUPDATE[4] (RW)
 *
 * Enables updates to watchdog write-once registers, after the reset-triggered
 * initial configuration window (WCT) closes, through unlock sequence.
 *
 * Values:
 * - 0b0 - No further updates allowed to WDOG write-once registers.
 * - 0b1 - WDOG write-once registers can be unlocked for updating.
 */
/*@{*/
/*! @brief Read current value of the WDOG_STCTRLH_ALLOWUPDATE field. */
#define WDOG_RD_STCTRLH_ALLOWUPDATE(base) ((WDOG_STCTRLH_REG(base) & WDOG_STCTRLH_ALLOWUPDATE_MASK) >> WDOG_STCTRLH_ALLOWUPDATE_SHIFT)
#define WDOG_BRD_STCTRLH_ALLOWUPDATE(base) (BME_UBFX16(&WDOG_STCTRLH_REG(base), WDOG_STCTRLH_ALLOWUPDATE_SHIFT, WDOG_STCTRLH_ALLOWUPDATE_WIDTH))

/*! @brief Set the ALLOWUPDATE field to a new value. */
#define WDOG_WR_STCTRLH_ALLOWUPDATE(base, value) (WDOG_RMW_STCTRLH(base, WDOG_STCTRLH_ALLOWUPDATE_MASK, WDOG_STCTRLH_ALLOWUPDATE(value)))
#define WDOG_BWR_STCTRLH_ALLOWUPDATE(base, value) (BME_BFI16(&WDOG_STCTRLH_REG(base), ((uint16_t)(value) << WDOG_STCTRLH_ALLOWUPDATE_SHIFT), WDOG_STCTRLH_ALLOWUPDATE_SHIFT, WDOG_STCTRLH_ALLOWUPDATE_WIDTH))
/*@}*/

/*!
 * @name Register WDOG_STCTRLH, field DBGEN[5] (RW)
 *
 * Enables or disables WDOG in Debug mode.
 *
 * Values:
 * - 0b0 - WDOG is disabled in CPU Debug mode.
 * - 0b1 - WDOG is enabled in CPU Debug mode.
 */
/*@{*/
/*! @brief Read current value of the WDOG_STCTRLH_DBGEN field. */
#define WDOG_RD_STCTRLH_DBGEN(base) ((WDOG_STCTRLH_REG(base) & WDOG_STCTRLH_DBGEN_MASK) >> WDOG_STCTRLH_DBGEN_SHIFT)
#define WDOG_BRD_STCTRLH_DBGEN(base) (BME_UBFX16(&WDOG_STCTRLH_REG(base), WDOG_STCTRLH_DBGEN_SHIFT, WDOG_STCTRLH_DBGEN_WIDTH))

/*! @brief Set the DBGEN field to a new value. */
#define WDOG_WR_STCTRLH_DBGEN(base, value) (WDOG_RMW_STCTRLH(base, WDOG_STCTRLH_DBGEN_MASK, WDOG_STCTRLH_DBGEN(value)))
#define WDOG_BWR_STCTRLH_DBGEN(base, value) (BME_BFI16(&WDOG_STCTRLH_REG(base), ((uint16_t)(value) << WDOG_STCTRLH_DBGEN_SHIFT), WDOG_STCTRLH_DBGEN_SHIFT, WDOG_STCTRLH_DBGEN_WIDTH))
/*@}*/

/*!
 * @name Register WDOG_STCTRLH, field STOPEN[6] (RW)
 *
 * Enables or disables WDOG in Stop mode.
 *
 * Values:
 * - 0b0 - WDOG is disabled in CPU Stop mode.
 * - 0b1 - WDOG is enabled in CPU Stop mode.
 */
/*@{*/
/*! @brief Read current value of the WDOG_STCTRLH_STOPEN field. */
#define WDOG_RD_STCTRLH_STOPEN(base) ((WDOG_STCTRLH_REG(base) & WDOG_STCTRLH_STOPEN_MASK) >> WDOG_STCTRLH_STOPEN_SHIFT)
#define WDOG_BRD_STCTRLH_STOPEN(base) (BME_UBFX16(&WDOG_STCTRLH_REG(base), WDOG_STCTRLH_STOPEN_SHIFT, WDOG_STCTRLH_STOPEN_WIDTH))

/*! @brief Set the STOPEN field to a new value. */
#define WDOG_WR_STCTRLH_STOPEN(base, value) (WDOG_RMW_STCTRLH(base, WDOG_STCTRLH_STOPEN_MASK, WDOG_STCTRLH_STOPEN(value)))
#define WDOG_BWR_STCTRLH_STOPEN(base, value) (BME_BFI16(&WDOG_STCTRLH_REG(base), ((uint16_t)(value) << WDOG_STCTRLH_STOPEN_SHIFT), WDOG_STCTRLH_STOPEN_SHIFT, WDOG_STCTRLH_STOPEN_WIDTH))
/*@}*/

/*!
 * @name Register WDOG_STCTRLH, field TESTWDOG[10] (RW)
 *
 * Puts the watchdog in the functional test mode. In this mode, the watchdog
 * timer and the associated compare and reset generation logic is tested for correct
 * operation. The clock for the timer is switched from the main watchdog clock
 * to the fast clock input for watchdog functional test. The TESTSEL bit selects
 * the test to be run.
 */
/*@{*/
/*! @brief Read current value of the WDOG_STCTRLH_TESTWDOG field. */
#define WDOG_RD_STCTRLH_TESTWDOG(base) ((WDOG_STCTRLH_REG(base) & WDOG_STCTRLH_TESTWDOG_MASK) >> WDOG_STCTRLH_TESTWDOG_SHIFT)
#define WDOG_BRD_STCTRLH_TESTWDOG(base) (BME_UBFX16(&WDOG_STCTRLH_REG(base), WDOG_STCTRLH_TESTWDOG_SHIFT, WDOG_STCTRLH_TESTWDOG_WIDTH))

/*! @brief Set the TESTWDOG field to a new value. */
#define WDOG_WR_STCTRLH_TESTWDOG(base, value) (WDOG_RMW_STCTRLH(base, WDOG_STCTRLH_TESTWDOG_MASK, WDOG_STCTRLH_TESTWDOG(value)))
#define WDOG_BWR_STCTRLH_TESTWDOG(base, value) (BME_BFI16(&WDOG_STCTRLH_REG(base), ((uint16_t)(value) << WDOG_STCTRLH_TESTWDOG_SHIFT), WDOG_STCTRLH_TESTWDOG_SHIFT, WDOG_STCTRLH_TESTWDOG_WIDTH))
/*@}*/

/*!
 * @name Register WDOG_STCTRLH, field TESTSEL[11] (RW)
 *
 * Effective only if TESTWDOG is set. Selects the test to be run on the watchdog
 * timer.
 *
 * Values:
 * - 0b0 - Quick test. The timer runs in normal operation. You can load a small
 *     time-out value to do a quick test.
 * - 0b1 - Byte test. Puts the timer in the byte test mode where individual
 *     bytes of the timer are enabled for operation and are compared for time-out
 *     against the corresponding byte of the programmed time-out value. Select the
 *     byte through BYTESEL[1:0] for testing.
 */
/*@{*/
/*! @brief Read current value of the WDOG_STCTRLH_TESTSEL field. */
#define WDOG_RD_STCTRLH_TESTSEL(base) ((WDOG_STCTRLH_REG(base) & WDOG_STCTRLH_TESTSEL_MASK) >> WDOG_STCTRLH_TESTSEL_SHIFT)
#define WDOG_BRD_STCTRLH_TESTSEL(base) (BME_UBFX16(&WDOG_STCTRLH_REG(base), WDOG_STCTRLH_TESTSEL_SHIFT, WDOG_STCTRLH_TESTSEL_WIDTH))

/*! @brief Set the TESTSEL field to a new value. */
#define WDOG_WR_STCTRLH_TESTSEL(base, value) (WDOG_RMW_STCTRLH(base, WDOG_STCTRLH_TESTSEL_MASK, WDOG_STCTRLH_TESTSEL(value)))
#define WDOG_BWR_STCTRLH_TESTSEL(base, value) (BME_BFI16(&WDOG_STCTRLH_REG(base), ((uint16_t)(value) << WDOG_STCTRLH_TESTSEL_SHIFT), WDOG_STCTRLH_TESTSEL_SHIFT, WDOG_STCTRLH_TESTSEL_WIDTH))
/*@}*/

/*!
 * @name Register WDOG_STCTRLH, field BYTESEL[13:12] (RW)
 *
 * This 2-bit field selects the byte to be tested when the watchdog is in the
 * byte test mode.
 *
 * Values:
 * - 0b00 - Byte 0 selected
 * - 0b01 - Byte 1 selected
 * - 0b10 - Byte 2 selected
 * - 0b11 - Byte 3 selected
 */
/*@{*/
/*! @brief Read current value of the WDOG_STCTRLH_BYTESEL field. */
#define WDOG_RD_STCTRLH_BYTESEL(base) ((WDOG_STCTRLH_REG(base) & WDOG_STCTRLH_BYTESEL_MASK) >> WDOG_STCTRLH_BYTESEL_SHIFT)
#define WDOG_BRD_STCTRLH_BYTESEL(base) (BME_UBFX16(&WDOG_STCTRLH_REG(base), WDOG_STCTRLH_BYTESEL_SHIFT, WDOG_STCTRLH_BYTESEL_WIDTH))

/*! @brief Set the BYTESEL field to a new value. */
#define WDOG_WR_STCTRLH_BYTESEL(base, value) (WDOG_RMW_STCTRLH(base, WDOG_STCTRLH_BYTESEL_MASK, WDOG_STCTRLH_BYTESEL(value)))
#define WDOG_BWR_STCTRLH_BYTESEL(base, value) (BME_BFI16(&WDOG_STCTRLH_REG(base), ((uint16_t)(value) << WDOG_STCTRLH_BYTESEL_SHIFT), WDOG_STCTRLH_BYTESEL_SHIFT, WDOG_STCTRLH_BYTESEL_WIDTH))
/*@}*/

/*!
 * @name Register WDOG_STCTRLH, field DISTESTWDOG[14] (RW)
 *
 * Allows the WDOG's functional test mode to be disabled permanently. After it
 * is set, it can only be cleared by a reset. It cannot be unlocked for editing
 * after it is set.
 *
 * Values:
 * - 0b0 - WDOG functional test mode is not disabled.
 * - 0b1 - WDOG functional test mode is disabled permanently until reset.
 */
/*@{*/
/*! @brief Read current value of the WDOG_STCTRLH_DISTESTWDOG field. */
#define WDOG_RD_STCTRLH_DISTESTWDOG(base) ((WDOG_STCTRLH_REG(base) & WDOG_STCTRLH_DISTESTWDOG_MASK) >> WDOG_STCTRLH_DISTESTWDOG_SHIFT)
#define WDOG_BRD_STCTRLH_DISTESTWDOG(base) (BME_UBFX16(&WDOG_STCTRLH_REG(base), WDOG_STCTRLH_DISTESTWDOG_SHIFT, WDOG_STCTRLH_DISTESTWDOG_WIDTH))

/*! @brief Set the DISTESTWDOG field to a new value. */
#define WDOG_WR_STCTRLH_DISTESTWDOG(base, value) (WDOG_RMW_STCTRLH(base, WDOG_STCTRLH_DISTESTWDOG_MASK, WDOG_STCTRLH_DISTESTWDOG(value)))
#define WDOG_BWR_STCTRLH_DISTESTWDOG(base, value) (BME_BFI16(&WDOG_STCTRLH_REG(base), ((uint16_t)(value) << WDOG_STCTRLH_DISTESTWDOG_SHIFT), WDOG_STCTRLH_DISTESTWDOG_SHIFT, WDOG_STCTRLH_DISTESTWDOG_WIDTH))
/*@}*/

/*******************************************************************************
 * WDOG_STCTRLL - Watchdog Status and Control Register Low
 ******************************************************************************/

/*!
 * @brief WDOG_STCTRLL - Watchdog Status and Control Register Low (RW)
 *
 * Reset value: 0x0001U
 */
/*!
 * @name Constants and macros for entire WDOG_STCTRLL register
 */
/*@{*/
#define WDOG_RD_STCTRLL(base)    (WDOG_STCTRLL_REG(base))
#define WDOG_WR_STCTRLL(base, value) (WDOG_STCTRLL_REG(base) = (value))
#define WDOG_RMW_STCTRLL(base, mask, value) (WDOG_WR_STCTRLL(base, (WDOG_RD_STCTRLL(base) & ~(mask)) | (value)))
#define WDOG_SET_STCTRLL(base, value) (BME_OR16(&WDOG_STCTRLL_REG(base), (uint16_t)(value)))
#define WDOG_CLR_STCTRLL(base, value) (BME_AND16(&WDOG_STCTRLL_REG(base), (uint16_t)(~(value))))
#define WDOG_TOG_STCTRLL(base, value) (BME_XOR16(&WDOG_STCTRLL_REG(base), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual WDOG_STCTRLL bitfields
 */

/*!
 * @name Register WDOG_STCTRLL, field INTFLG[15] (RW)
 *
 * Interrupt flag. It is set when an exception occurs. IRQRSTEN = 1 is a
 * precondition to set this flag. INTFLG = 1 results in an interrupt being issued
 * followed by a reset, WCT later. The interrupt can be cleared by writing 1 to this
 * bit. It also gets cleared on a system reset.
 */
/*@{*/
/*! @brief Read current value of the WDOG_STCTRLL_INTFLG field. */
#define WDOG_RD_STCTRLL_INTFLG(base) ((WDOG_STCTRLL_REG(base) & WDOG_STCTRLL_INTFLG_MASK) >> WDOG_STCTRLL_INTFLG_SHIFT)
#define WDOG_BRD_STCTRLL_INTFLG(base) (BME_UBFX16(&WDOG_STCTRLL_REG(base), WDOG_STCTRLL_INTFLG_SHIFT, WDOG_STCTRLL_INTFLG_WIDTH))

/*! @brief Set the INTFLG field to a new value. */
#define WDOG_WR_STCTRLL_INTFLG(base, value) (WDOG_RMW_STCTRLL(base, WDOG_STCTRLL_INTFLG_MASK, WDOG_STCTRLL_INTFLG(value)))
#define WDOG_BWR_STCTRLL_INTFLG(base, value) (BME_BFI16(&WDOG_STCTRLL_REG(base), ((uint16_t)(value) << WDOG_STCTRLL_INTFLG_SHIFT), WDOG_STCTRLL_INTFLG_SHIFT, WDOG_STCTRLL_INTFLG_WIDTH))
/*@}*/

/*******************************************************************************
 * WDOG_TOVALH - Watchdog Time-out Value Register High
 ******************************************************************************/

/*!
 * @brief WDOG_TOVALH - Watchdog Time-out Value Register High (RW)
 *
 * Reset value: 0x004CU
 */
/*!
 * @name Constants and macros for entire WDOG_TOVALH register
 */
/*@{*/
#define WDOG_RD_TOVALH(base)     (WDOG_TOVALH_REG(base))
#define WDOG_WR_TOVALH(base, value) (WDOG_TOVALH_REG(base) = (value))
#define WDOG_RMW_TOVALH(base, mask, value) (WDOG_WR_TOVALH(base, (WDOG_RD_TOVALH(base) & ~(mask)) | (value)))
#define WDOG_SET_TOVALH(base, value) (BME_OR16(&WDOG_TOVALH_REG(base), (uint16_t)(value)))
#define WDOG_CLR_TOVALH(base, value) (BME_AND16(&WDOG_TOVALH_REG(base), (uint16_t)(~(value))))
#define WDOG_TOG_TOVALH(base, value) (BME_XOR16(&WDOG_TOVALH_REG(base), (uint16_t)(value)))
/*@}*/

/*******************************************************************************
 * WDOG_TOVALL - Watchdog Time-out Value Register Low
 ******************************************************************************/

/*!
 * @brief WDOG_TOVALL - Watchdog Time-out Value Register Low (RW)
 *
 * Reset value: 0x4B40U
 *
 * The time-out value of the watchdog must be set to a minimum of four watchdog
 * clock cycles. This is to take into account the delay in new settings taking
 * effect in the watchdog clock domain.
 */
/*!
 * @name Constants and macros for entire WDOG_TOVALL register
 */
/*@{*/
#define WDOG_RD_TOVALL(base)     (WDOG_TOVALL_REG(base))
#define WDOG_WR_TOVALL(base, value) (WDOG_TOVALL_REG(base) = (value))
#define WDOG_RMW_TOVALL(base, mask, value) (WDOG_WR_TOVALL(base, (WDOG_RD_TOVALL(base) & ~(mask)) | (value)))
#define WDOG_SET_TOVALL(base, value) (BME_OR16(&WDOG_TOVALL_REG(base), (uint16_t)(value)))
#define WDOG_CLR_TOVALL(base, value) (BME_AND16(&WDOG_TOVALL_REG(base), (uint16_t)(~(value))))
#define WDOG_TOG_TOVALL(base, value) (BME_XOR16(&WDOG_TOVALL_REG(base), (uint16_t)(value)))
/*@}*/

/*******************************************************************************
 * WDOG_WINH - Watchdog Window Register High
 ******************************************************************************/

/*!
 * @brief WDOG_WINH - Watchdog Window Register High (RW)
 *
 * Reset value: 0x0000U
 *
 * You must set the Window Register value lower than the Time-out Value Register.
 */
/*!
 * @name Constants and macros for entire WDOG_WINH register
 */
/*@{*/
#define WDOG_RD_WINH(base)       (WDOG_WINH_REG(base))
#define WDOG_WR_WINH(base, value) (WDOG_WINH_REG(base) = (value))
#define WDOG_RMW_WINH(base, mask, value) (WDOG_WR_WINH(base, (WDOG_RD_WINH(base) & ~(mask)) | (value)))
#define WDOG_SET_WINH(base, value) (BME_OR16(&WDOG_WINH_REG(base), (uint16_t)(value)))
#define WDOG_CLR_WINH(base, value) (BME_AND16(&WDOG_WINH_REG(base), (uint16_t)(~(value))))
#define WDOG_TOG_WINH(base, value) (BME_XOR16(&WDOG_WINH_REG(base), (uint16_t)(value)))
/*@}*/

/*******************************************************************************
 * WDOG_WINL - Watchdog Window Register Low
 ******************************************************************************/

/*!
 * @brief WDOG_WINL - Watchdog Window Register Low (RW)
 *
 * Reset value: 0x0010U
 *
 * You must set the Window Register value lower than the Time-out Value Register.
 */
/*!
 * @name Constants and macros for entire WDOG_WINL register
 */
/*@{*/
#define WDOG_RD_WINL(base)       (WDOG_WINL_REG(base))
#define WDOG_WR_WINL(base, value) (WDOG_WINL_REG(base) = (value))
#define WDOG_RMW_WINL(base, mask, value) (WDOG_WR_WINL(base, (WDOG_RD_WINL(base) & ~(mask)) | (value)))
#define WDOG_SET_WINL(base, value) (BME_OR16(&WDOG_WINL_REG(base), (uint16_t)(value)))
#define WDOG_CLR_WINL(base, value) (BME_AND16(&WDOG_WINL_REG(base), (uint16_t)(~(value))))
#define WDOG_TOG_WINL(base, value) (BME_XOR16(&WDOG_WINL_REG(base), (uint16_t)(value)))
/*@}*/

/*******************************************************************************
 * WDOG_REFRESH - Watchdog Refresh register
 ******************************************************************************/

/*!
 * @brief WDOG_REFRESH - Watchdog Refresh register (RW)
 *
 * Reset value: 0xB480U
 */
/*!
 * @name Constants and macros for entire WDOG_REFRESH register
 */
/*@{*/
#define WDOG_RD_REFRESH(base)    (WDOG_REFRESH_REG(base))
#define WDOG_WR_REFRESH(base, value) (WDOG_REFRESH_REG(base) = (value))
#define WDOG_RMW_REFRESH(base, mask, value) (WDOG_WR_REFRESH(base, (WDOG_RD_REFRESH(base) & ~(mask)) | (value)))
#define WDOG_SET_REFRESH(base, value) (BME_OR16(&WDOG_REFRESH_REG(base), (uint16_t)(value)))
#define WDOG_CLR_REFRESH(base, value) (BME_AND16(&WDOG_REFRESH_REG(base), (uint16_t)(~(value))))
#define WDOG_TOG_REFRESH(base, value) (BME_XOR16(&WDOG_REFRESH_REG(base), (uint16_t)(value)))
/*@}*/

/*******************************************************************************
 * WDOG_UNLOCK - Watchdog Unlock register
 ******************************************************************************/

/*!
 * @brief WDOG_UNLOCK - Watchdog Unlock register (RW)
 *
 * Reset value: 0xD928U
 */
/*!
 * @name Constants and macros for entire WDOG_UNLOCK register
 */
/*@{*/
#define WDOG_RD_UNLOCK(base)     (WDOG_UNLOCK_REG(base))
#define WDOG_WR_UNLOCK(base, value) (WDOG_UNLOCK_REG(base) = (value))
#define WDOG_RMW_UNLOCK(base, mask, value) (WDOG_WR_UNLOCK(base, (WDOG_RD_UNLOCK(base) & ~(mask)) | (value)))
#define WDOG_SET_UNLOCK(base, value) (BME_OR16(&WDOG_UNLOCK_REG(base), (uint16_t)(value)))
#define WDOG_CLR_UNLOCK(base, value) (BME_AND16(&WDOG_UNLOCK_REG(base), (uint16_t)(~(value))))
#define WDOG_TOG_UNLOCK(base, value) (BME_XOR16(&WDOG_UNLOCK_REG(base), (uint16_t)(value)))
/*@}*/

/*******************************************************************************
 * WDOG_TMROUTH - Watchdog Timer Output Register High
 ******************************************************************************/

/*!
 * @brief WDOG_TMROUTH - Watchdog Timer Output Register High (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire WDOG_TMROUTH register
 */
/*@{*/
#define WDOG_RD_TMROUTH(base)    (WDOG_TMROUTH_REG(base))
#define WDOG_WR_TMROUTH(base, value) (WDOG_TMROUTH_REG(base) = (value))
#define WDOG_RMW_TMROUTH(base, mask, value) (WDOG_WR_TMROUTH(base, (WDOG_RD_TMROUTH(base) & ~(mask)) | (value)))
#define WDOG_SET_TMROUTH(base, value) (BME_OR16(&WDOG_TMROUTH_REG(base), (uint16_t)(value)))
#define WDOG_CLR_TMROUTH(base, value) (BME_AND16(&WDOG_TMROUTH_REG(base), (uint16_t)(~(value))))
#define WDOG_TOG_TMROUTH(base, value) (BME_XOR16(&WDOG_TMROUTH_REG(base), (uint16_t)(value)))
/*@}*/

/*******************************************************************************
 * WDOG_TMROUTL - Watchdog Timer Output Register Low
 ******************************************************************************/

/*!
 * @brief WDOG_TMROUTL - Watchdog Timer Output Register Low (RW)
 *
 * Reset value: 0x0000U
 *
 * During Stop mode, the WDOG_TIMER_OUT will be caught at the pre-stop value of
 * the watchdog timer. After exiting Stop mode, a maximum delay of 1 WDOG_CLK
 * cycle + 3 bus clock cycles will occur before the WDOG_TIMER_OUT starts following
 * the watchdog timer.
 */
/*!
 * @name Constants and macros for entire WDOG_TMROUTL register
 */
/*@{*/
#define WDOG_RD_TMROUTL(base)    (WDOG_TMROUTL_REG(base))
#define WDOG_WR_TMROUTL(base, value) (WDOG_TMROUTL_REG(base) = (value))
#define WDOG_RMW_TMROUTL(base, mask, value) (WDOG_WR_TMROUTL(base, (WDOG_RD_TMROUTL(base) & ~(mask)) | (value)))
#define WDOG_SET_TMROUTL(base, value) (BME_OR16(&WDOG_TMROUTL_REG(base), (uint16_t)(value)))
#define WDOG_CLR_TMROUTL(base, value) (BME_AND16(&WDOG_TMROUTL_REG(base), (uint16_t)(~(value))))
#define WDOG_TOG_TMROUTL(base, value) (BME_XOR16(&WDOG_TMROUTL_REG(base), (uint16_t)(value)))
/*@}*/

/*******************************************************************************
 * WDOG_RSTCNT - Watchdog Reset Count register
 ******************************************************************************/

/*!
 * @brief WDOG_RSTCNT - Watchdog Reset Count register (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire WDOG_RSTCNT register
 */
/*@{*/
#define WDOG_RD_RSTCNT(base)     (WDOG_RSTCNT_REG(base))
#define WDOG_WR_RSTCNT(base, value) (WDOG_RSTCNT_REG(base) = (value))
#define WDOG_RMW_RSTCNT(base, mask, value) (WDOG_WR_RSTCNT(base, (WDOG_RD_RSTCNT(base) & ~(mask)) | (value)))
#define WDOG_SET_RSTCNT(base, value) (BME_OR16(&WDOG_RSTCNT_REG(base), (uint16_t)(value)))
#define WDOG_CLR_RSTCNT(base, value) (BME_AND16(&WDOG_RSTCNT_REG(base), (uint16_t)(~(value))))
#define WDOG_TOG_RSTCNT(base, value) (BME_XOR16(&WDOG_RSTCNT_REG(base), (uint16_t)(value)))
/*@}*/

/*******************************************************************************
 * WDOG_PRESC - Watchdog Prescaler register
 ******************************************************************************/

/*!
 * @brief WDOG_PRESC - Watchdog Prescaler register (RW)
 *
 * Reset value: 0x0400U
 */
/*!
 * @name Constants and macros for entire WDOG_PRESC register
 */
/*@{*/
#define WDOG_RD_PRESC(base)      (WDOG_PRESC_REG(base))
#define WDOG_WR_PRESC(base, value) (WDOG_PRESC_REG(base) = (value))
#define WDOG_RMW_PRESC(base, mask, value) (WDOG_WR_PRESC(base, (WDOG_RD_PRESC(base) & ~(mask)) | (value)))
#define WDOG_SET_PRESC(base, value) (BME_OR16(&WDOG_PRESC_REG(base), (uint16_t)(value)))
#define WDOG_CLR_PRESC(base, value) (BME_AND16(&WDOG_PRESC_REG(base), (uint16_t)(~(value))))
#define WDOG_TOG_PRESC(base, value) (BME_XOR16(&WDOG_PRESC_REG(base), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual WDOG_PRESC bitfields
 */

/*!
 * @name Register WDOG_PRESC, field PRESCVAL[10:8] (RW)
 *
 * 3-bit prescaler for the watchdog clock source. A value of zero indicates no
 * division of the input WDOG clock. The watchdog clock is divided by (PRESCVAL +
 * 1) to provide the prescaled WDOG_CLK.
 */
/*@{*/
/*! @brief Read current value of the WDOG_PRESC_PRESCVAL field. */
#define WDOG_RD_PRESC_PRESCVAL(base) ((WDOG_PRESC_REG(base) & WDOG_PRESC_PRESCVAL_MASK) >> WDOG_PRESC_PRESCVAL_SHIFT)
#define WDOG_BRD_PRESC_PRESCVAL(base) (BME_UBFX16(&WDOG_PRESC_REG(base), WDOG_PRESC_PRESCVAL_SHIFT, WDOG_PRESC_PRESCVAL_WIDTH))

/*! @brief Set the PRESCVAL field to a new value. */
#define WDOG_WR_PRESC_PRESCVAL(base, value) (WDOG_RMW_PRESC(base, WDOG_PRESC_PRESCVAL_MASK, WDOG_PRESC_PRESCVAL(value)))
#define WDOG_BWR_PRESC_PRESCVAL(base, value) (BME_BFI16(&WDOG_PRESC_REG(base), ((uint16_t)(value) << WDOG_PRESC_PRESCVAL_SHIFT), WDOG_PRESC_PRESCVAL_SHIFT, WDOG_PRESC_PRESCVAL_WIDTH))
/*@}*/

/*
 * MKM34Z7 XBAR
 *
 * Crossbar Switch
 *
 * Registers defined in this header file:
 * - XBAR_SEL0 - Crossbar Select Register 0
 * - XBAR_SEL1 - Crossbar Select Register 1
 * - XBAR_SEL2 - Crossbar Select Register 2
 * - XBAR_SEL3 - Crossbar Select Register 3
 * - XBAR_SEL4 - Crossbar Select Register 4
 * - XBAR_SEL5 - Crossbar Select Register 5
 * - XBAR_SEL6 - Crossbar Select Register 6
 * - XBAR_SEL7 - Crossbar Select Register 7
 * - XBAR_SEL8 - Crossbar Select Register 8
 * - XBAR_SEL9 - Crossbar Select Register 9
 * - XBAR_SEL10 - Crossbar Select Register 10
 * - XBAR_SEL11 - Crossbar Select Register 11
 * - XBAR_SEL12 - Crossbar Select Register 12
 * - XBAR_SEL13 - Crossbar Select Register 13
 * - XBAR_SEL14 - Crossbar Select Register 14
 * - XBAR_SEL15 - Crossbar Select Register 15
 * - XBAR_SEL16 - Crossbar Select Register 16
 * - XBAR_SEL17 - Crossbar Select Register 17
 * - XBAR_SEL18 - Crossbar Select Register 18
 * - XBAR_SEL19 - Crossbar Select Register 19
 * - XBAR_SEL20 - Crossbar Select Register 20
 * - XBAR_SEL21 - Crossbar Select Register 21
 * - XBAR_CTRL0 - Crossbar Control Register 0
 * - XBAR_CTRL1 - Crossbar Control Register 1
 */

#define XBAR_INSTANCE_COUNT (1U) /*!< Number of instances of the XBAR module. */
#define XBAR_IDX (0U) /*!< Instance number for XBAR. */

/*******************************************************************************
 * XBAR_SEL0 - Crossbar Select Register 0
 ******************************************************************************/

/*!
 * @brief XBAR_SEL0 - Crossbar Select Register 0 (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire XBAR_SEL0 register
 */
/*@{*/
#define XBAR_RD_SEL0(base)       (XBAR_SEL0_REG(base))
#define XBAR_WR_SEL0(base, value) (XBAR_SEL0_REG(base) = (value))
#define XBAR_RMW_SEL0(base, mask, value) (XBAR_WR_SEL0(base, (XBAR_RD_SEL0(base) & ~(mask)) | (value)))
#define XBAR_SET_SEL0(base, value) (BME_OR16(&XBAR_SEL0_REG(base), (uint16_t)(value)))
#define XBAR_CLR_SEL0(base, value) (BME_AND16(&XBAR_SEL0_REG(base), (uint16_t)(~(value))))
#define XBAR_TOG_SEL0(base, value) (BME_XOR16(&XBAR_SEL0_REG(base), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XBAR_SEL0 bitfields
 */

/*!
 * @name Register XBAR_SEL0, field SEL0[5:0] (RW)
 *
 * Input (XBAR_INn) to be muxed to XBAR_OUT0 (refer to Functional Description
 * section for input/output assignment)
 */
/*@{*/
/*! @brief Read current value of the XBAR_SEL0_SEL0 field. */
#define XBAR_RD_SEL0_SEL0(base) ((XBAR_SEL0_REG(base) & XBAR_SEL0_SEL0_MASK) >> XBAR_SEL0_SEL0_SHIFT)
#define XBAR_BRD_SEL0_SEL0(base) (BME_UBFX16(&XBAR_SEL0_REG(base), XBAR_SEL0_SEL0_SHIFT, XBAR_SEL0_SEL0_WIDTH))

/*! @brief Set the SEL0 field to a new value. */
#define XBAR_WR_SEL0_SEL0(base, value) (XBAR_RMW_SEL0(base, XBAR_SEL0_SEL0_MASK, XBAR_SEL0_SEL0(value)))
#define XBAR_BWR_SEL0_SEL0(base, value) (BME_BFI16(&XBAR_SEL0_REG(base), ((uint16_t)(value) << XBAR_SEL0_SEL0_SHIFT), XBAR_SEL0_SEL0_SHIFT, XBAR_SEL0_SEL0_WIDTH))
/*@}*/

/*!
 * @name Register XBAR_SEL0, field SEL1[13:8] (RW)
 *
 * Input (XBAR_INn) to be muxed to XBAR_OUT1 (refer to Functional Description
 * section for input/output assignment)
 */
/*@{*/
/*! @brief Read current value of the XBAR_SEL0_SEL1 field. */
#define XBAR_RD_SEL0_SEL1(base) ((XBAR_SEL0_REG(base) & XBAR_SEL0_SEL1_MASK) >> XBAR_SEL0_SEL1_SHIFT)
#define XBAR_BRD_SEL0_SEL1(base) (BME_UBFX16(&XBAR_SEL0_REG(base), XBAR_SEL0_SEL1_SHIFT, XBAR_SEL0_SEL1_WIDTH))

/*! @brief Set the SEL1 field to a new value. */
#define XBAR_WR_SEL0_SEL1(base, value) (XBAR_RMW_SEL0(base, XBAR_SEL0_SEL1_MASK, XBAR_SEL0_SEL1(value)))
#define XBAR_BWR_SEL0_SEL1(base, value) (BME_BFI16(&XBAR_SEL0_REG(base), ((uint16_t)(value) << XBAR_SEL0_SEL1_SHIFT), XBAR_SEL0_SEL1_SHIFT, XBAR_SEL0_SEL1_WIDTH))
/*@}*/

/*******************************************************************************
 * XBAR_SEL1 - Crossbar Select Register 1
 ******************************************************************************/

/*!
 * @brief XBAR_SEL1 - Crossbar Select Register 1 (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire XBAR_SEL1 register
 */
/*@{*/
#define XBAR_RD_SEL1(base)       (XBAR_SEL1_REG(base))
#define XBAR_WR_SEL1(base, value) (XBAR_SEL1_REG(base) = (value))
#define XBAR_RMW_SEL1(base, mask, value) (XBAR_WR_SEL1(base, (XBAR_RD_SEL1(base) & ~(mask)) | (value)))
#define XBAR_SET_SEL1(base, value) (BME_OR16(&XBAR_SEL1_REG(base), (uint16_t)(value)))
#define XBAR_CLR_SEL1(base, value) (BME_AND16(&XBAR_SEL1_REG(base), (uint16_t)(~(value))))
#define XBAR_TOG_SEL1(base, value) (BME_XOR16(&XBAR_SEL1_REG(base), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XBAR_SEL1 bitfields
 */

/*!
 * @name Register XBAR_SEL1, field SEL2[5:0] (RW)
 *
 * Input (XBAR_INn) to be muxed to XBAR_OUT2 (refer to Functional Description
 * section for input/output assignment)
 */
/*@{*/
/*! @brief Read current value of the XBAR_SEL1_SEL2 field. */
#define XBAR_RD_SEL1_SEL2(base) ((XBAR_SEL1_REG(base) & XBAR_SEL1_SEL2_MASK) >> XBAR_SEL1_SEL2_SHIFT)
#define XBAR_BRD_SEL1_SEL2(base) (BME_UBFX16(&XBAR_SEL1_REG(base), XBAR_SEL1_SEL2_SHIFT, XBAR_SEL1_SEL2_WIDTH))

/*! @brief Set the SEL2 field to a new value. */
#define XBAR_WR_SEL1_SEL2(base, value) (XBAR_RMW_SEL1(base, XBAR_SEL1_SEL2_MASK, XBAR_SEL1_SEL2(value)))
#define XBAR_BWR_SEL1_SEL2(base, value) (BME_BFI16(&XBAR_SEL1_REG(base), ((uint16_t)(value) << XBAR_SEL1_SEL2_SHIFT), XBAR_SEL1_SEL2_SHIFT, XBAR_SEL1_SEL2_WIDTH))
/*@}*/

/*!
 * @name Register XBAR_SEL1, field SEL3[13:8] (RW)
 *
 * Input (XBAR_INn) to be muxed to XBAR_OUT3 (refer to Functional Description
 * section for input/output assignment)
 */
/*@{*/
/*! @brief Read current value of the XBAR_SEL1_SEL3 field. */
#define XBAR_RD_SEL1_SEL3(base) ((XBAR_SEL1_REG(base) & XBAR_SEL1_SEL3_MASK) >> XBAR_SEL1_SEL3_SHIFT)
#define XBAR_BRD_SEL1_SEL3(base) (BME_UBFX16(&XBAR_SEL1_REG(base), XBAR_SEL1_SEL3_SHIFT, XBAR_SEL1_SEL3_WIDTH))

/*! @brief Set the SEL3 field to a new value. */
#define XBAR_WR_SEL1_SEL3(base, value) (XBAR_RMW_SEL1(base, XBAR_SEL1_SEL3_MASK, XBAR_SEL1_SEL3(value)))
#define XBAR_BWR_SEL1_SEL3(base, value) (BME_BFI16(&XBAR_SEL1_REG(base), ((uint16_t)(value) << XBAR_SEL1_SEL3_SHIFT), XBAR_SEL1_SEL3_SHIFT, XBAR_SEL1_SEL3_WIDTH))
/*@}*/

/*******************************************************************************
 * XBAR_SEL2 - Crossbar Select Register 2
 ******************************************************************************/

/*!
 * @brief XBAR_SEL2 - Crossbar Select Register 2 (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire XBAR_SEL2 register
 */
/*@{*/
#define XBAR_RD_SEL2(base)       (XBAR_SEL2_REG(base))
#define XBAR_WR_SEL2(base, value) (XBAR_SEL2_REG(base) = (value))
#define XBAR_RMW_SEL2(base, mask, value) (XBAR_WR_SEL2(base, (XBAR_RD_SEL2(base) & ~(mask)) | (value)))
#define XBAR_SET_SEL2(base, value) (BME_OR16(&XBAR_SEL2_REG(base), (uint16_t)(value)))
#define XBAR_CLR_SEL2(base, value) (BME_AND16(&XBAR_SEL2_REG(base), (uint16_t)(~(value))))
#define XBAR_TOG_SEL2(base, value) (BME_XOR16(&XBAR_SEL2_REG(base), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XBAR_SEL2 bitfields
 */

/*!
 * @name Register XBAR_SEL2, field SEL4[5:0] (RW)
 *
 * Input (XBAR_INn) to be muxed to XBAR_OUT4 (refer to Functional Description
 * section for input/output assignment)
 */
/*@{*/
/*! @brief Read current value of the XBAR_SEL2_SEL4 field. */
#define XBAR_RD_SEL2_SEL4(base) ((XBAR_SEL2_REG(base) & XBAR_SEL2_SEL4_MASK) >> XBAR_SEL2_SEL4_SHIFT)
#define XBAR_BRD_SEL2_SEL4(base) (BME_UBFX16(&XBAR_SEL2_REG(base), XBAR_SEL2_SEL4_SHIFT, XBAR_SEL2_SEL4_WIDTH))

/*! @brief Set the SEL4 field to a new value. */
#define XBAR_WR_SEL2_SEL4(base, value) (XBAR_RMW_SEL2(base, XBAR_SEL2_SEL4_MASK, XBAR_SEL2_SEL4(value)))
#define XBAR_BWR_SEL2_SEL4(base, value) (BME_BFI16(&XBAR_SEL2_REG(base), ((uint16_t)(value) << XBAR_SEL2_SEL4_SHIFT), XBAR_SEL2_SEL4_SHIFT, XBAR_SEL2_SEL4_WIDTH))
/*@}*/

/*!
 * @name Register XBAR_SEL2, field SEL5[13:8] (RW)
 *
 * Input (XBAR_INn) to be muxed to XBAR_OUT5 (refer to Functional Description
 * section for input/output assignment)
 */
/*@{*/
/*! @brief Read current value of the XBAR_SEL2_SEL5 field. */
#define XBAR_RD_SEL2_SEL5(base) ((XBAR_SEL2_REG(base) & XBAR_SEL2_SEL5_MASK) >> XBAR_SEL2_SEL5_SHIFT)
#define XBAR_BRD_SEL2_SEL5(base) (BME_UBFX16(&XBAR_SEL2_REG(base), XBAR_SEL2_SEL5_SHIFT, XBAR_SEL2_SEL5_WIDTH))

/*! @brief Set the SEL5 field to a new value. */
#define XBAR_WR_SEL2_SEL5(base, value) (XBAR_RMW_SEL2(base, XBAR_SEL2_SEL5_MASK, XBAR_SEL2_SEL5(value)))
#define XBAR_BWR_SEL2_SEL5(base, value) (BME_BFI16(&XBAR_SEL2_REG(base), ((uint16_t)(value) << XBAR_SEL2_SEL5_SHIFT), XBAR_SEL2_SEL5_SHIFT, XBAR_SEL2_SEL5_WIDTH))
/*@}*/

/*******************************************************************************
 * XBAR_SEL3 - Crossbar Select Register 3
 ******************************************************************************/

/*!
 * @brief XBAR_SEL3 - Crossbar Select Register 3 (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire XBAR_SEL3 register
 */
/*@{*/
#define XBAR_RD_SEL3(base)       (XBAR_SEL3_REG(base))
#define XBAR_WR_SEL3(base, value) (XBAR_SEL3_REG(base) = (value))
#define XBAR_RMW_SEL3(base, mask, value) (XBAR_WR_SEL3(base, (XBAR_RD_SEL3(base) & ~(mask)) | (value)))
#define XBAR_SET_SEL3(base, value) (BME_OR16(&XBAR_SEL3_REG(base), (uint16_t)(value)))
#define XBAR_CLR_SEL3(base, value) (BME_AND16(&XBAR_SEL3_REG(base), (uint16_t)(~(value))))
#define XBAR_TOG_SEL3(base, value) (BME_XOR16(&XBAR_SEL3_REG(base), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XBAR_SEL3 bitfields
 */

/*!
 * @name Register XBAR_SEL3, field SEL6[5:0] (RW)
 *
 * Input (XBAR_INn) to be muxed to XBAR_OUT6 (refer to Functional Description
 * section for input/output assignment)
 */
/*@{*/
/*! @brief Read current value of the XBAR_SEL3_SEL6 field. */
#define XBAR_RD_SEL3_SEL6(base) ((XBAR_SEL3_REG(base) & XBAR_SEL3_SEL6_MASK) >> XBAR_SEL3_SEL6_SHIFT)
#define XBAR_BRD_SEL3_SEL6(base) (BME_UBFX16(&XBAR_SEL3_REG(base), XBAR_SEL3_SEL6_SHIFT, XBAR_SEL3_SEL6_WIDTH))

/*! @brief Set the SEL6 field to a new value. */
#define XBAR_WR_SEL3_SEL6(base, value) (XBAR_RMW_SEL3(base, XBAR_SEL3_SEL6_MASK, XBAR_SEL3_SEL6(value)))
#define XBAR_BWR_SEL3_SEL6(base, value) (BME_BFI16(&XBAR_SEL3_REG(base), ((uint16_t)(value) << XBAR_SEL3_SEL6_SHIFT), XBAR_SEL3_SEL6_SHIFT, XBAR_SEL3_SEL6_WIDTH))
/*@}*/

/*!
 * @name Register XBAR_SEL3, field SEL7[13:8] (RW)
 *
 * Input (XBAR_INn) to be muxed to XBAR_OUT7 (refer to Functional Description
 * section for input/output assignment)
 */
/*@{*/
/*! @brief Read current value of the XBAR_SEL3_SEL7 field. */
#define XBAR_RD_SEL3_SEL7(base) ((XBAR_SEL3_REG(base) & XBAR_SEL3_SEL7_MASK) >> XBAR_SEL3_SEL7_SHIFT)
#define XBAR_BRD_SEL3_SEL7(base) (BME_UBFX16(&XBAR_SEL3_REG(base), XBAR_SEL3_SEL7_SHIFT, XBAR_SEL3_SEL7_WIDTH))

/*! @brief Set the SEL7 field to a new value. */
#define XBAR_WR_SEL3_SEL7(base, value) (XBAR_RMW_SEL3(base, XBAR_SEL3_SEL7_MASK, XBAR_SEL3_SEL7(value)))
#define XBAR_BWR_SEL3_SEL7(base, value) (BME_BFI16(&XBAR_SEL3_REG(base), ((uint16_t)(value) << XBAR_SEL3_SEL7_SHIFT), XBAR_SEL3_SEL7_SHIFT, XBAR_SEL3_SEL7_WIDTH))
/*@}*/

/*******************************************************************************
 * XBAR_SEL4 - Crossbar Select Register 4
 ******************************************************************************/

/*!
 * @brief XBAR_SEL4 - Crossbar Select Register 4 (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire XBAR_SEL4 register
 */
/*@{*/
#define XBAR_RD_SEL4(base)       (XBAR_SEL4_REG(base))
#define XBAR_WR_SEL4(base, value) (XBAR_SEL4_REG(base) = (value))
#define XBAR_RMW_SEL4(base, mask, value) (XBAR_WR_SEL4(base, (XBAR_RD_SEL4(base) & ~(mask)) | (value)))
#define XBAR_SET_SEL4(base, value) (BME_OR16(&XBAR_SEL4_REG(base), (uint16_t)(value)))
#define XBAR_CLR_SEL4(base, value) (BME_AND16(&XBAR_SEL4_REG(base), (uint16_t)(~(value))))
#define XBAR_TOG_SEL4(base, value) (BME_XOR16(&XBAR_SEL4_REG(base), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XBAR_SEL4 bitfields
 */

/*!
 * @name Register XBAR_SEL4, field SEL8[5:0] (RW)
 *
 * Input (XBAR_INn) to be muxed to XBAR_OUT8 (refer to Functional Description
 * section for input/output assignment)
 */
/*@{*/
/*! @brief Read current value of the XBAR_SEL4_SEL8 field. */
#define XBAR_RD_SEL4_SEL8(base) ((XBAR_SEL4_REG(base) & XBAR_SEL4_SEL8_MASK) >> XBAR_SEL4_SEL8_SHIFT)
#define XBAR_BRD_SEL4_SEL8(base) (BME_UBFX16(&XBAR_SEL4_REG(base), XBAR_SEL4_SEL8_SHIFT, XBAR_SEL4_SEL8_WIDTH))

/*! @brief Set the SEL8 field to a new value. */
#define XBAR_WR_SEL4_SEL8(base, value) (XBAR_RMW_SEL4(base, XBAR_SEL4_SEL8_MASK, XBAR_SEL4_SEL8(value)))
#define XBAR_BWR_SEL4_SEL8(base, value) (BME_BFI16(&XBAR_SEL4_REG(base), ((uint16_t)(value) << XBAR_SEL4_SEL8_SHIFT), XBAR_SEL4_SEL8_SHIFT, XBAR_SEL4_SEL8_WIDTH))
/*@}*/

/*!
 * @name Register XBAR_SEL4, field SEL9[13:8] (RW)
 *
 * Input (XBAR_INn) to be muxed to XBAR_OUT9 (refer to Functional Description
 * section for input/output assignment)
 */
/*@{*/
/*! @brief Read current value of the XBAR_SEL4_SEL9 field. */
#define XBAR_RD_SEL4_SEL9(base) ((XBAR_SEL4_REG(base) & XBAR_SEL4_SEL9_MASK) >> XBAR_SEL4_SEL9_SHIFT)
#define XBAR_BRD_SEL4_SEL9(base) (BME_UBFX16(&XBAR_SEL4_REG(base), XBAR_SEL4_SEL9_SHIFT, XBAR_SEL4_SEL9_WIDTH))

/*! @brief Set the SEL9 field to a new value. */
#define XBAR_WR_SEL4_SEL9(base, value) (XBAR_RMW_SEL4(base, XBAR_SEL4_SEL9_MASK, XBAR_SEL4_SEL9(value)))
#define XBAR_BWR_SEL4_SEL9(base, value) (BME_BFI16(&XBAR_SEL4_REG(base), ((uint16_t)(value) << XBAR_SEL4_SEL9_SHIFT), XBAR_SEL4_SEL9_SHIFT, XBAR_SEL4_SEL9_WIDTH))
/*@}*/

/*******************************************************************************
 * XBAR_SEL5 - Crossbar Select Register 5
 ******************************************************************************/

/*!
 * @brief XBAR_SEL5 - Crossbar Select Register 5 (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire XBAR_SEL5 register
 */
/*@{*/
#define XBAR_RD_SEL5(base)       (XBAR_SEL5_REG(base))
#define XBAR_WR_SEL5(base, value) (XBAR_SEL5_REG(base) = (value))
#define XBAR_RMW_SEL5(base, mask, value) (XBAR_WR_SEL5(base, (XBAR_RD_SEL5(base) & ~(mask)) | (value)))
#define XBAR_SET_SEL5(base, value) (BME_OR16(&XBAR_SEL5_REG(base), (uint16_t)(value)))
#define XBAR_CLR_SEL5(base, value) (BME_AND16(&XBAR_SEL5_REG(base), (uint16_t)(~(value))))
#define XBAR_TOG_SEL5(base, value) (BME_XOR16(&XBAR_SEL5_REG(base), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XBAR_SEL5 bitfields
 */

/*!
 * @name Register XBAR_SEL5, field SEL10[5:0] (RW)
 *
 * Input (XBAR_INn) to be muxed to XBAR_OUT10 (refer to Functional Description
 * section for input/output assignment)
 */
/*@{*/
/*! @brief Read current value of the XBAR_SEL5_SEL10 field. */
#define XBAR_RD_SEL5_SEL10(base) ((XBAR_SEL5_REG(base) & XBAR_SEL5_SEL10_MASK) >> XBAR_SEL5_SEL10_SHIFT)
#define XBAR_BRD_SEL5_SEL10(base) (BME_UBFX16(&XBAR_SEL5_REG(base), XBAR_SEL5_SEL10_SHIFT, XBAR_SEL5_SEL10_WIDTH))

/*! @brief Set the SEL10 field to a new value. */
#define XBAR_WR_SEL5_SEL10(base, value) (XBAR_RMW_SEL5(base, XBAR_SEL5_SEL10_MASK, XBAR_SEL5_SEL10(value)))
#define XBAR_BWR_SEL5_SEL10(base, value) (BME_BFI16(&XBAR_SEL5_REG(base), ((uint16_t)(value) << XBAR_SEL5_SEL10_SHIFT), XBAR_SEL5_SEL10_SHIFT, XBAR_SEL5_SEL10_WIDTH))
/*@}*/

/*!
 * @name Register XBAR_SEL5, field SEL11[13:8] (RW)
 *
 * Input (XBAR_INn) to be muxed to XBAR_OUT11 (refer to Functional Description
 * section for input/output assignment)
 */
/*@{*/
/*! @brief Read current value of the XBAR_SEL5_SEL11 field. */
#define XBAR_RD_SEL5_SEL11(base) ((XBAR_SEL5_REG(base) & XBAR_SEL5_SEL11_MASK) >> XBAR_SEL5_SEL11_SHIFT)
#define XBAR_BRD_SEL5_SEL11(base) (BME_UBFX16(&XBAR_SEL5_REG(base), XBAR_SEL5_SEL11_SHIFT, XBAR_SEL5_SEL11_WIDTH))

/*! @brief Set the SEL11 field to a new value. */
#define XBAR_WR_SEL5_SEL11(base, value) (XBAR_RMW_SEL5(base, XBAR_SEL5_SEL11_MASK, XBAR_SEL5_SEL11(value)))
#define XBAR_BWR_SEL5_SEL11(base, value) (BME_BFI16(&XBAR_SEL5_REG(base), ((uint16_t)(value) << XBAR_SEL5_SEL11_SHIFT), XBAR_SEL5_SEL11_SHIFT, XBAR_SEL5_SEL11_WIDTH))
/*@}*/

/*******************************************************************************
 * XBAR_SEL6 - Crossbar Select Register 6
 ******************************************************************************/

/*!
 * @brief XBAR_SEL6 - Crossbar Select Register 6 (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire XBAR_SEL6 register
 */
/*@{*/
#define XBAR_RD_SEL6(base)       (XBAR_SEL6_REG(base))
#define XBAR_WR_SEL6(base, value) (XBAR_SEL6_REG(base) = (value))
#define XBAR_RMW_SEL6(base, mask, value) (XBAR_WR_SEL6(base, (XBAR_RD_SEL6(base) & ~(mask)) | (value)))
#define XBAR_SET_SEL6(base, value) (BME_OR16(&XBAR_SEL6_REG(base), (uint16_t)(value)))
#define XBAR_CLR_SEL6(base, value) (BME_AND16(&XBAR_SEL6_REG(base), (uint16_t)(~(value))))
#define XBAR_TOG_SEL6(base, value) (BME_XOR16(&XBAR_SEL6_REG(base), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XBAR_SEL6 bitfields
 */

/*!
 * @name Register XBAR_SEL6, field SEL12[5:0] (RW)
 *
 * Input (XBAR_INn) to be muxed to XBAR_OUT12 (refer to Functional Description
 * section for input/output assignment)
 */
/*@{*/
/*! @brief Read current value of the XBAR_SEL6_SEL12 field. */
#define XBAR_RD_SEL6_SEL12(base) ((XBAR_SEL6_REG(base) & XBAR_SEL6_SEL12_MASK) >> XBAR_SEL6_SEL12_SHIFT)
#define XBAR_BRD_SEL6_SEL12(base) (BME_UBFX16(&XBAR_SEL6_REG(base), XBAR_SEL6_SEL12_SHIFT, XBAR_SEL6_SEL12_WIDTH))

/*! @brief Set the SEL12 field to a new value. */
#define XBAR_WR_SEL6_SEL12(base, value) (XBAR_RMW_SEL6(base, XBAR_SEL6_SEL12_MASK, XBAR_SEL6_SEL12(value)))
#define XBAR_BWR_SEL6_SEL12(base, value) (BME_BFI16(&XBAR_SEL6_REG(base), ((uint16_t)(value) << XBAR_SEL6_SEL12_SHIFT), XBAR_SEL6_SEL12_SHIFT, XBAR_SEL6_SEL12_WIDTH))
/*@}*/

/*!
 * @name Register XBAR_SEL6, field SEL13[13:8] (RW)
 *
 * Input (XBAR_INn) to be muxed to XBAR_OUT13 (refer to Functional Description
 * section for input/output assignment)
 */
/*@{*/
/*! @brief Read current value of the XBAR_SEL6_SEL13 field. */
#define XBAR_RD_SEL6_SEL13(base) ((XBAR_SEL6_REG(base) & XBAR_SEL6_SEL13_MASK) >> XBAR_SEL6_SEL13_SHIFT)
#define XBAR_BRD_SEL6_SEL13(base) (BME_UBFX16(&XBAR_SEL6_REG(base), XBAR_SEL6_SEL13_SHIFT, XBAR_SEL6_SEL13_WIDTH))

/*! @brief Set the SEL13 field to a new value. */
#define XBAR_WR_SEL6_SEL13(base, value) (XBAR_RMW_SEL6(base, XBAR_SEL6_SEL13_MASK, XBAR_SEL6_SEL13(value)))
#define XBAR_BWR_SEL6_SEL13(base, value) (BME_BFI16(&XBAR_SEL6_REG(base), ((uint16_t)(value) << XBAR_SEL6_SEL13_SHIFT), XBAR_SEL6_SEL13_SHIFT, XBAR_SEL6_SEL13_WIDTH))
/*@}*/

/*******************************************************************************
 * XBAR_SEL7 - Crossbar Select Register 7
 ******************************************************************************/

/*!
 * @brief XBAR_SEL7 - Crossbar Select Register 7 (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire XBAR_SEL7 register
 */
/*@{*/
#define XBAR_RD_SEL7(base)       (XBAR_SEL7_REG(base))
#define XBAR_WR_SEL7(base, value) (XBAR_SEL7_REG(base) = (value))
#define XBAR_RMW_SEL7(base, mask, value) (XBAR_WR_SEL7(base, (XBAR_RD_SEL7(base) & ~(mask)) | (value)))
#define XBAR_SET_SEL7(base, value) (BME_OR16(&XBAR_SEL7_REG(base), (uint16_t)(value)))
#define XBAR_CLR_SEL7(base, value) (BME_AND16(&XBAR_SEL7_REG(base), (uint16_t)(~(value))))
#define XBAR_TOG_SEL7(base, value) (BME_XOR16(&XBAR_SEL7_REG(base), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XBAR_SEL7 bitfields
 */

/*!
 * @name Register XBAR_SEL7, field SEL14[5:0] (RW)
 *
 * Input (XBAR_INn) to be muxed to XBAR_OUT14 (refer to Functional Description
 * section for input/output assignment)
 */
/*@{*/
/*! @brief Read current value of the XBAR_SEL7_SEL14 field. */
#define XBAR_RD_SEL7_SEL14(base) ((XBAR_SEL7_REG(base) & XBAR_SEL7_SEL14_MASK) >> XBAR_SEL7_SEL14_SHIFT)
#define XBAR_BRD_SEL7_SEL14(base) (BME_UBFX16(&XBAR_SEL7_REG(base), XBAR_SEL7_SEL14_SHIFT, XBAR_SEL7_SEL14_WIDTH))

/*! @brief Set the SEL14 field to a new value. */
#define XBAR_WR_SEL7_SEL14(base, value) (XBAR_RMW_SEL7(base, XBAR_SEL7_SEL14_MASK, XBAR_SEL7_SEL14(value)))
#define XBAR_BWR_SEL7_SEL14(base, value) (BME_BFI16(&XBAR_SEL7_REG(base), ((uint16_t)(value) << XBAR_SEL7_SEL14_SHIFT), XBAR_SEL7_SEL14_SHIFT, XBAR_SEL7_SEL14_WIDTH))
/*@}*/

/*!
 * @name Register XBAR_SEL7, field SEL15[13:8] (RW)
 *
 * Input (XBAR_INn) to be muxed to XBAR_OUT15 (refer to Functional Description
 * section for input/output assignment)
 */
/*@{*/
/*! @brief Read current value of the XBAR_SEL7_SEL15 field. */
#define XBAR_RD_SEL7_SEL15(base) ((XBAR_SEL7_REG(base) & XBAR_SEL7_SEL15_MASK) >> XBAR_SEL7_SEL15_SHIFT)
#define XBAR_BRD_SEL7_SEL15(base) (BME_UBFX16(&XBAR_SEL7_REG(base), XBAR_SEL7_SEL15_SHIFT, XBAR_SEL7_SEL15_WIDTH))

/*! @brief Set the SEL15 field to a new value. */
#define XBAR_WR_SEL7_SEL15(base, value) (XBAR_RMW_SEL7(base, XBAR_SEL7_SEL15_MASK, XBAR_SEL7_SEL15(value)))
#define XBAR_BWR_SEL7_SEL15(base, value) (BME_BFI16(&XBAR_SEL7_REG(base), ((uint16_t)(value) << XBAR_SEL7_SEL15_SHIFT), XBAR_SEL7_SEL15_SHIFT, XBAR_SEL7_SEL15_WIDTH))
/*@}*/

/*******************************************************************************
 * XBAR_SEL8 - Crossbar Select Register 8
 ******************************************************************************/

/*!
 * @brief XBAR_SEL8 - Crossbar Select Register 8 (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire XBAR_SEL8 register
 */
/*@{*/
#define XBAR_RD_SEL8(base)       (XBAR_SEL8_REG(base))
#define XBAR_WR_SEL8(base, value) (XBAR_SEL8_REG(base) = (value))
#define XBAR_RMW_SEL8(base, mask, value) (XBAR_WR_SEL8(base, (XBAR_RD_SEL8(base) & ~(mask)) | (value)))
#define XBAR_SET_SEL8(base, value) (BME_OR16(&XBAR_SEL8_REG(base), (uint16_t)(value)))
#define XBAR_CLR_SEL8(base, value) (BME_AND16(&XBAR_SEL8_REG(base), (uint16_t)(~(value))))
#define XBAR_TOG_SEL8(base, value) (BME_XOR16(&XBAR_SEL8_REG(base), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XBAR_SEL8 bitfields
 */

/*!
 * @name Register XBAR_SEL8, field SEL16[5:0] (RW)
 *
 * Input (XBAR_INn) to be muxed to XBAR_OUT16 (refer to Functional Description
 * section for input/output assignment)
 */
/*@{*/
/*! @brief Read current value of the XBAR_SEL8_SEL16 field. */
#define XBAR_RD_SEL8_SEL16(base) ((XBAR_SEL8_REG(base) & XBAR_SEL8_SEL16_MASK) >> XBAR_SEL8_SEL16_SHIFT)
#define XBAR_BRD_SEL8_SEL16(base) (BME_UBFX16(&XBAR_SEL8_REG(base), XBAR_SEL8_SEL16_SHIFT, XBAR_SEL8_SEL16_WIDTH))

/*! @brief Set the SEL16 field to a new value. */
#define XBAR_WR_SEL8_SEL16(base, value) (XBAR_RMW_SEL8(base, XBAR_SEL8_SEL16_MASK, XBAR_SEL8_SEL16(value)))
#define XBAR_BWR_SEL8_SEL16(base, value) (BME_BFI16(&XBAR_SEL8_REG(base), ((uint16_t)(value) << XBAR_SEL8_SEL16_SHIFT), XBAR_SEL8_SEL16_SHIFT, XBAR_SEL8_SEL16_WIDTH))
/*@}*/

/*!
 * @name Register XBAR_SEL8, field SEL17[13:8] (RW)
 *
 * Input (XBAR_INn) to be muxed to XBAR_OUT17 (refer to Functional Description
 * section for input/output assignment)
 */
/*@{*/
/*! @brief Read current value of the XBAR_SEL8_SEL17 field. */
#define XBAR_RD_SEL8_SEL17(base) ((XBAR_SEL8_REG(base) & XBAR_SEL8_SEL17_MASK) >> XBAR_SEL8_SEL17_SHIFT)
#define XBAR_BRD_SEL8_SEL17(base) (BME_UBFX16(&XBAR_SEL8_REG(base), XBAR_SEL8_SEL17_SHIFT, XBAR_SEL8_SEL17_WIDTH))

/*! @brief Set the SEL17 field to a new value. */
#define XBAR_WR_SEL8_SEL17(base, value) (XBAR_RMW_SEL8(base, XBAR_SEL8_SEL17_MASK, XBAR_SEL8_SEL17(value)))
#define XBAR_BWR_SEL8_SEL17(base, value) (BME_BFI16(&XBAR_SEL8_REG(base), ((uint16_t)(value) << XBAR_SEL8_SEL17_SHIFT), XBAR_SEL8_SEL17_SHIFT, XBAR_SEL8_SEL17_WIDTH))
/*@}*/

/*******************************************************************************
 * XBAR_SEL9 - Crossbar Select Register 9
 ******************************************************************************/

/*!
 * @brief XBAR_SEL9 - Crossbar Select Register 9 (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire XBAR_SEL9 register
 */
/*@{*/
#define XBAR_RD_SEL9(base)       (XBAR_SEL9_REG(base))
#define XBAR_WR_SEL9(base, value) (XBAR_SEL9_REG(base) = (value))
#define XBAR_RMW_SEL9(base, mask, value) (XBAR_WR_SEL9(base, (XBAR_RD_SEL9(base) & ~(mask)) | (value)))
#define XBAR_SET_SEL9(base, value) (BME_OR16(&XBAR_SEL9_REG(base), (uint16_t)(value)))
#define XBAR_CLR_SEL9(base, value) (BME_AND16(&XBAR_SEL9_REG(base), (uint16_t)(~(value))))
#define XBAR_TOG_SEL9(base, value) (BME_XOR16(&XBAR_SEL9_REG(base), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XBAR_SEL9 bitfields
 */

/*!
 * @name Register XBAR_SEL9, field SEL18[5:0] (RW)
 *
 * Input (XBAR_INn) to be muxed to XBAR_OUT18 (refer to Functional Description
 * section for input/output assignment)
 */
/*@{*/
/*! @brief Read current value of the XBAR_SEL9_SEL18 field. */
#define XBAR_RD_SEL9_SEL18(base) ((XBAR_SEL9_REG(base) & XBAR_SEL9_SEL18_MASK) >> XBAR_SEL9_SEL18_SHIFT)
#define XBAR_BRD_SEL9_SEL18(base) (BME_UBFX16(&XBAR_SEL9_REG(base), XBAR_SEL9_SEL18_SHIFT, XBAR_SEL9_SEL18_WIDTH))

/*! @brief Set the SEL18 field to a new value. */
#define XBAR_WR_SEL9_SEL18(base, value) (XBAR_RMW_SEL9(base, XBAR_SEL9_SEL18_MASK, XBAR_SEL9_SEL18(value)))
#define XBAR_BWR_SEL9_SEL18(base, value) (BME_BFI16(&XBAR_SEL9_REG(base), ((uint16_t)(value) << XBAR_SEL9_SEL18_SHIFT), XBAR_SEL9_SEL18_SHIFT, XBAR_SEL9_SEL18_WIDTH))
/*@}*/

/*!
 * @name Register XBAR_SEL9, field SEL19[13:8] (RW)
 *
 * Input (XBAR_INn) to be muxed to XBAR_OUT19 (refer to Functional Description
 * section for input/output assignment)
 */
/*@{*/
/*! @brief Read current value of the XBAR_SEL9_SEL19 field. */
#define XBAR_RD_SEL9_SEL19(base) ((XBAR_SEL9_REG(base) & XBAR_SEL9_SEL19_MASK) >> XBAR_SEL9_SEL19_SHIFT)
#define XBAR_BRD_SEL9_SEL19(base) (BME_UBFX16(&XBAR_SEL9_REG(base), XBAR_SEL9_SEL19_SHIFT, XBAR_SEL9_SEL19_WIDTH))

/*! @brief Set the SEL19 field to a new value. */
#define XBAR_WR_SEL9_SEL19(base, value) (XBAR_RMW_SEL9(base, XBAR_SEL9_SEL19_MASK, XBAR_SEL9_SEL19(value)))
#define XBAR_BWR_SEL9_SEL19(base, value) (BME_BFI16(&XBAR_SEL9_REG(base), ((uint16_t)(value) << XBAR_SEL9_SEL19_SHIFT), XBAR_SEL9_SEL19_SHIFT, XBAR_SEL9_SEL19_WIDTH))
/*@}*/

/*******************************************************************************
 * XBAR_SEL10 - Crossbar Select Register 10
 ******************************************************************************/

/*!
 * @brief XBAR_SEL10 - Crossbar Select Register 10 (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire XBAR_SEL10 register
 */
/*@{*/
#define XBAR_RD_SEL10(base)      (XBAR_SEL10_REG(base))
#define XBAR_WR_SEL10(base, value) (XBAR_SEL10_REG(base) = (value))
#define XBAR_RMW_SEL10(base, mask, value) (XBAR_WR_SEL10(base, (XBAR_RD_SEL10(base) & ~(mask)) | (value)))
#define XBAR_SET_SEL10(base, value) (BME_OR16(&XBAR_SEL10_REG(base), (uint16_t)(value)))
#define XBAR_CLR_SEL10(base, value) (BME_AND16(&XBAR_SEL10_REG(base), (uint16_t)(~(value))))
#define XBAR_TOG_SEL10(base, value) (BME_XOR16(&XBAR_SEL10_REG(base), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XBAR_SEL10 bitfields
 */

/*!
 * @name Register XBAR_SEL10, field SEL20[5:0] (RW)
 *
 * Input (XBAR_INn) to be muxed to XBAR_OUT20 (refer to Functional Description
 * section for input/output assignment)
 */
/*@{*/
/*! @brief Read current value of the XBAR_SEL10_SEL20 field. */
#define XBAR_RD_SEL10_SEL20(base) ((XBAR_SEL10_REG(base) & XBAR_SEL10_SEL20_MASK) >> XBAR_SEL10_SEL20_SHIFT)
#define XBAR_BRD_SEL10_SEL20(base) (BME_UBFX16(&XBAR_SEL10_REG(base), XBAR_SEL10_SEL20_SHIFT, XBAR_SEL10_SEL20_WIDTH))

/*! @brief Set the SEL20 field to a new value. */
#define XBAR_WR_SEL10_SEL20(base, value) (XBAR_RMW_SEL10(base, XBAR_SEL10_SEL20_MASK, XBAR_SEL10_SEL20(value)))
#define XBAR_BWR_SEL10_SEL20(base, value) (BME_BFI16(&XBAR_SEL10_REG(base), ((uint16_t)(value) << XBAR_SEL10_SEL20_SHIFT), XBAR_SEL10_SEL20_SHIFT, XBAR_SEL10_SEL20_WIDTH))
/*@}*/

/*!
 * @name Register XBAR_SEL10, field SEL21[13:8] (RW)
 *
 * Input (XBAR_INn) to be muxed to XBAR_OUT21 (refer to Functional Description
 * section for input/output assignment)
 */
/*@{*/
/*! @brief Read current value of the XBAR_SEL10_SEL21 field. */
#define XBAR_RD_SEL10_SEL21(base) ((XBAR_SEL10_REG(base) & XBAR_SEL10_SEL21_MASK) >> XBAR_SEL10_SEL21_SHIFT)
#define XBAR_BRD_SEL10_SEL21(base) (BME_UBFX16(&XBAR_SEL10_REG(base), XBAR_SEL10_SEL21_SHIFT, XBAR_SEL10_SEL21_WIDTH))

/*! @brief Set the SEL21 field to a new value. */
#define XBAR_WR_SEL10_SEL21(base, value) (XBAR_RMW_SEL10(base, XBAR_SEL10_SEL21_MASK, XBAR_SEL10_SEL21(value)))
#define XBAR_BWR_SEL10_SEL21(base, value) (BME_BFI16(&XBAR_SEL10_REG(base), ((uint16_t)(value) << XBAR_SEL10_SEL21_SHIFT), XBAR_SEL10_SEL21_SHIFT, XBAR_SEL10_SEL21_WIDTH))
/*@}*/

/*******************************************************************************
 * XBAR_SEL11 - Crossbar Select Register 11
 ******************************************************************************/

/*!
 * @brief XBAR_SEL11 - Crossbar Select Register 11 (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire XBAR_SEL11 register
 */
/*@{*/
#define XBAR_RD_SEL11(base)      (XBAR_SEL11_REG(base))
#define XBAR_WR_SEL11(base, value) (XBAR_SEL11_REG(base) = (value))
#define XBAR_RMW_SEL11(base, mask, value) (XBAR_WR_SEL11(base, (XBAR_RD_SEL11(base) & ~(mask)) | (value)))
#define XBAR_SET_SEL11(base, value) (BME_OR16(&XBAR_SEL11_REG(base), (uint16_t)(value)))
#define XBAR_CLR_SEL11(base, value) (BME_AND16(&XBAR_SEL11_REG(base), (uint16_t)(~(value))))
#define XBAR_TOG_SEL11(base, value) (BME_XOR16(&XBAR_SEL11_REG(base), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XBAR_SEL11 bitfields
 */

/*!
 * @name Register XBAR_SEL11, field SEL22[5:0] (RW)
 *
 * Input (XBAR_INn) to be muxed to XBAR_OUT22 (refer to Functional Description
 * section for input/output assignment)
 */
/*@{*/
/*! @brief Read current value of the XBAR_SEL11_SEL22 field. */
#define XBAR_RD_SEL11_SEL22(base) ((XBAR_SEL11_REG(base) & XBAR_SEL11_SEL22_MASK) >> XBAR_SEL11_SEL22_SHIFT)
#define XBAR_BRD_SEL11_SEL22(base) (BME_UBFX16(&XBAR_SEL11_REG(base), XBAR_SEL11_SEL22_SHIFT, XBAR_SEL11_SEL22_WIDTH))

/*! @brief Set the SEL22 field to a new value. */
#define XBAR_WR_SEL11_SEL22(base, value) (XBAR_RMW_SEL11(base, XBAR_SEL11_SEL22_MASK, XBAR_SEL11_SEL22(value)))
#define XBAR_BWR_SEL11_SEL22(base, value) (BME_BFI16(&XBAR_SEL11_REG(base), ((uint16_t)(value) << XBAR_SEL11_SEL22_SHIFT), XBAR_SEL11_SEL22_SHIFT, XBAR_SEL11_SEL22_WIDTH))
/*@}*/

/*!
 * @name Register XBAR_SEL11, field SEL23[13:8] (RW)
 *
 * Input (XBAR_INn) to be muxed to XBAR_OUT23 (refer to Functional Description
 * section for input/output assignment)
 */
/*@{*/
/*! @brief Read current value of the XBAR_SEL11_SEL23 field. */
#define XBAR_RD_SEL11_SEL23(base) ((XBAR_SEL11_REG(base) & XBAR_SEL11_SEL23_MASK) >> XBAR_SEL11_SEL23_SHIFT)
#define XBAR_BRD_SEL11_SEL23(base) (BME_UBFX16(&XBAR_SEL11_REG(base), XBAR_SEL11_SEL23_SHIFT, XBAR_SEL11_SEL23_WIDTH))

/*! @brief Set the SEL23 field to a new value. */
#define XBAR_WR_SEL11_SEL23(base, value) (XBAR_RMW_SEL11(base, XBAR_SEL11_SEL23_MASK, XBAR_SEL11_SEL23(value)))
#define XBAR_BWR_SEL11_SEL23(base, value) (BME_BFI16(&XBAR_SEL11_REG(base), ((uint16_t)(value) << XBAR_SEL11_SEL23_SHIFT), XBAR_SEL11_SEL23_SHIFT, XBAR_SEL11_SEL23_WIDTH))
/*@}*/

/*******************************************************************************
 * XBAR_SEL12 - Crossbar Select Register 12
 ******************************************************************************/

/*!
 * @brief XBAR_SEL12 - Crossbar Select Register 12 (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire XBAR_SEL12 register
 */
/*@{*/
#define XBAR_RD_SEL12(base)      (XBAR_SEL12_REG(base))
#define XBAR_WR_SEL12(base, value) (XBAR_SEL12_REG(base) = (value))
#define XBAR_RMW_SEL12(base, mask, value) (XBAR_WR_SEL12(base, (XBAR_RD_SEL12(base) & ~(mask)) | (value)))
#define XBAR_SET_SEL12(base, value) (BME_OR16(&XBAR_SEL12_REG(base), (uint16_t)(value)))
#define XBAR_CLR_SEL12(base, value) (BME_AND16(&XBAR_SEL12_REG(base), (uint16_t)(~(value))))
#define XBAR_TOG_SEL12(base, value) (BME_XOR16(&XBAR_SEL12_REG(base), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XBAR_SEL12 bitfields
 */

/*!
 * @name Register XBAR_SEL12, field SEL24[5:0] (RW)
 *
 * Input (XBAR_INn) to be muxed to XBAR_OUT24 (refer to Functional Description
 * section for input/output assignment)
 */
/*@{*/
/*! @brief Read current value of the XBAR_SEL12_SEL24 field. */
#define XBAR_RD_SEL12_SEL24(base) ((XBAR_SEL12_REG(base) & XBAR_SEL12_SEL24_MASK) >> XBAR_SEL12_SEL24_SHIFT)
#define XBAR_BRD_SEL12_SEL24(base) (BME_UBFX16(&XBAR_SEL12_REG(base), XBAR_SEL12_SEL24_SHIFT, XBAR_SEL12_SEL24_WIDTH))

/*! @brief Set the SEL24 field to a new value. */
#define XBAR_WR_SEL12_SEL24(base, value) (XBAR_RMW_SEL12(base, XBAR_SEL12_SEL24_MASK, XBAR_SEL12_SEL24(value)))
#define XBAR_BWR_SEL12_SEL24(base, value) (BME_BFI16(&XBAR_SEL12_REG(base), ((uint16_t)(value) << XBAR_SEL12_SEL24_SHIFT), XBAR_SEL12_SEL24_SHIFT, XBAR_SEL12_SEL24_WIDTH))
/*@}*/

/*!
 * @name Register XBAR_SEL12, field SEL25[13:8] (RW)
 *
 * Input (XBAR_INn) to be muxed to XBAR_OUT25 (refer to Functional Description
 * section for input/output assignment)
 */
/*@{*/
/*! @brief Read current value of the XBAR_SEL12_SEL25 field. */
#define XBAR_RD_SEL12_SEL25(base) ((XBAR_SEL12_REG(base) & XBAR_SEL12_SEL25_MASK) >> XBAR_SEL12_SEL25_SHIFT)
#define XBAR_BRD_SEL12_SEL25(base) (BME_UBFX16(&XBAR_SEL12_REG(base), XBAR_SEL12_SEL25_SHIFT, XBAR_SEL12_SEL25_WIDTH))

/*! @brief Set the SEL25 field to a new value. */
#define XBAR_WR_SEL12_SEL25(base, value) (XBAR_RMW_SEL12(base, XBAR_SEL12_SEL25_MASK, XBAR_SEL12_SEL25(value)))
#define XBAR_BWR_SEL12_SEL25(base, value) (BME_BFI16(&XBAR_SEL12_REG(base), ((uint16_t)(value) << XBAR_SEL12_SEL25_SHIFT), XBAR_SEL12_SEL25_SHIFT, XBAR_SEL12_SEL25_WIDTH))
/*@}*/

/*******************************************************************************
 * XBAR_SEL13 - Crossbar Select Register 13
 ******************************************************************************/

/*!
 * @brief XBAR_SEL13 - Crossbar Select Register 13 (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire XBAR_SEL13 register
 */
/*@{*/
#define XBAR_RD_SEL13(base)      (XBAR_SEL13_REG(base))
#define XBAR_WR_SEL13(base, value) (XBAR_SEL13_REG(base) = (value))
#define XBAR_RMW_SEL13(base, mask, value) (XBAR_WR_SEL13(base, (XBAR_RD_SEL13(base) & ~(mask)) | (value)))
#define XBAR_SET_SEL13(base, value) (BME_OR16(&XBAR_SEL13_REG(base), (uint16_t)(value)))
#define XBAR_CLR_SEL13(base, value) (BME_AND16(&XBAR_SEL13_REG(base), (uint16_t)(~(value))))
#define XBAR_TOG_SEL13(base, value) (BME_XOR16(&XBAR_SEL13_REG(base), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XBAR_SEL13 bitfields
 */

/*!
 * @name Register XBAR_SEL13, field SEL26[5:0] (RW)
 *
 * Input (XBAR_INn) to be muxed to XBAR_OUT26 (refer to Functional Description
 * section for input/output assignment)
 */
/*@{*/
/*! @brief Read current value of the XBAR_SEL13_SEL26 field. */
#define XBAR_RD_SEL13_SEL26(base) ((XBAR_SEL13_REG(base) & XBAR_SEL13_SEL26_MASK) >> XBAR_SEL13_SEL26_SHIFT)
#define XBAR_BRD_SEL13_SEL26(base) (BME_UBFX16(&XBAR_SEL13_REG(base), XBAR_SEL13_SEL26_SHIFT, XBAR_SEL13_SEL26_WIDTH))

/*! @brief Set the SEL26 field to a new value. */
#define XBAR_WR_SEL13_SEL26(base, value) (XBAR_RMW_SEL13(base, XBAR_SEL13_SEL26_MASK, XBAR_SEL13_SEL26(value)))
#define XBAR_BWR_SEL13_SEL26(base, value) (BME_BFI16(&XBAR_SEL13_REG(base), ((uint16_t)(value) << XBAR_SEL13_SEL26_SHIFT), XBAR_SEL13_SEL26_SHIFT, XBAR_SEL13_SEL26_WIDTH))
/*@}*/

/*!
 * @name Register XBAR_SEL13, field SEL27[13:8] (RW)
 *
 * Input (XBAR_INn) to be muxed to XBAR_OUT27 (refer to Functional Description
 * section for input/output assignment)
 */
/*@{*/
/*! @brief Read current value of the XBAR_SEL13_SEL27 field. */
#define XBAR_RD_SEL13_SEL27(base) ((XBAR_SEL13_REG(base) & XBAR_SEL13_SEL27_MASK) >> XBAR_SEL13_SEL27_SHIFT)
#define XBAR_BRD_SEL13_SEL27(base) (BME_UBFX16(&XBAR_SEL13_REG(base), XBAR_SEL13_SEL27_SHIFT, XBAR_SEL13_SEL27_WIDTH))

/*! @brief Set the SEL27 field to a new value. */
#define XBAR_WR_SEL13_SEL27(base, value) (XBAR_RMW_SEL13(base, XBAR_SEL13_SEL27_MASK, XBAR_SEL13_SEL27(value)))
#define XBAR_BWR_SEL13_SEL27(base, value) (BME_BFI16(&XBAR_SEL13_REG(base), ((uint16_t)(value) << XBAR_SEL13_SEL27_SHIFT), XBAR_SEL13_SEL27_SHIFT, XBAR_SEL13_SEL27_WIDTH))
/*@}*/

/*******************************************************************************
 * XBAR_SEL14 - Crossbar Select Register 14
 ******************************************************************************/

/*!
 * @brief XBAR_SEL14 - Crossbar Select Register 14 (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire XBAR_SEL14 register
 */
/*@{*/
#define XBAR_RD_SEL14(base)      (XBAR_SEL14_REG(base))
#define XBAR_WR_SEL14(base, value) (XBAR_SEL14_REG(base) = (value))
#define XBAR_RMW_SEL14(base, mask, value) (XBAR_WR_SEL14(base, (XBAR_RD_SEL14(base) & ~(mask)) | (value)))
#define XBAR_SET_SEL14(base, value) (BME_OR16(&XBAR_SEL14_REG(base), (uint16_t)(value)))
#define XBAR_CLR_SEL14(base, value) (BME_AND16(&XBAR_SEL14_REG(base), (uint16_t)(~(value))))
#define XBAR_TOG_SEL14(base, value) (BME_XOR16(&XBAR_SEL14_REG(base), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XBAR_SEL14 bitfields
 */

/*!
 * @name Register XBAR_SEL14, field SEL28[5:0] (RW)
 *
 * Input (XBAR_INn) to be muxed to XBAR_OUT28 (refer to Functional Description
 * section for input/output assignment)
 */
/*@{*/
/*! @brief Read current value of the XBAR_SEL14_SEL28 field. */
#define XBAR_RD_SEL14_SEL28(base) ((XBAR_SEL14_REG(base) & XBAR_SEL14_SEL28_MASK) >> XBAR_SEL14_SEL28_SHIFT)
#define XBAR_BRD_SEL14_SEL28(base) (BME_UBFX16(&XBAR_SEL14_REG(base), XBAR_SEL14_SEL28_SHIFT, XBAR_SEL14_SEL28_WIDTH))

/*! @brief Set the SEL28 field to a new value. */
#define XBAR_WR_SEL14_SEL28(base, value) (XBAR_RMW_SEL14(base, XBAR_SEL14_SEL28_MASK, XBAR_SEL14_SEL28(value)))
#define XBAR_BWR_SEL14_SEL28(base, value) (BME_BFI16(&XBAR_SEL14_REG(base), ((uint16_t)(value) << XBAR_SEL14_SEL28_SHIFT), XBAR_SEL14_SEL28_SHIFT, XBAR_SEL14_SEL28_WIDTH))
/*@}*/

/*!
 * @name Register XBAR_SEL14, field SEL29[13:8] (RW)
 *
 * Input (XBAR_INn) to be muxed to XBAR_OUT29 (refer to Functional Description
 * section for input/output assignment)
 */
/*@{*/
/*! @brief Read current value of the XBAR_SEL14_SEL29 field. */
#define XBAR_RD_SEL14_SEL29(base) ((XBAR_SEL14_REG(base) & XBAR_SEL14_SEL29_MASK) >> XBAR_SEL14_SEL29_SHIFT)
#define XBAR_BRD_SEL14_SEL29(base) (BME_UBFX16(&XBAR_SEL14_REG(base), XBAR_SEL14_SEL29_SHIFT, XBAR_SEL14_SEL29_WIDTH))

/*! @brief Set the SEL29 field to a new value. */
#define XBAR_WR_SEL14_SEL29(base, value) (XBAR_RMW_SEL14(base, XBAR_SEL14_SEL29_MASK, XBAR_SEL14_SEL29(value)))
#define XBAR_BWR_SEL14_SEL29(base, value) (BME_BFI16(&XBAR_SEL14_REG(base), ((uint16_t)(value) << XBAR_SEL14_SEL29_SHIFT), XBAR_SEL14_SEL29_SHIFT, XBAR_SEL14_SEL29_WIDTH))
/*@}*/

/*******************************************************************************
 * XBAR_SEL15 - Crossbar Select Register 15
 ******************************************************************************/

/*!
 * @brief XBAR_SEL15 - Crossbar Select Register 15 (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire XBAR_SEL15 register
 */
/*@{*/
#define XBAR_RD_SEL15(base)      (XBAR_SEL15_REG(base))
#define XBAR_WR_SEL15(base, value) (XBAR_SEL15_REG(base) = (value))
#define XBAR_RMW_SEL15(base, mask, value) (XBAR_WR_SEL15(base, (XBAR_RD_SEL15(base) & ~(mask)) | (value)))
#define XBAR_SET_SEL15(base, value) (BME_OR16(&XBAR_SEL15_REG(base), (uint16_t)(value)))
#define XBAR_CLR_SEL15(base, value) (BME_AND16(&XBAR_SEL15_REG(base), (uint16_t)(~(value))))
#define XBAR_TOG_SEL15(base, value) (BME_XOR16(&XBAR_SEL15_REG(base), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XBAR_SEL15 bitfields
 */

/*!
 * @name Register XBAR_SEL15, field SEL30[5:0] (RW)
 *
 * Input (XBAR_INn) to be muxed to XBAR_OUT30 (refer to Functional Description
 * section for input/output assignment)
 */
/*@{*/
/*! @brief Read current value of the XBAR_SEL15_SEL30 field. */
#define XBAR_RD_SEL15_SEL30(base) ((XBAR_SEL15_REG(base) & XBAR_SEL15_SEL30_MASK) >> XBAR_SEL15_SEL30_SHIFT)
#define XBAR_BRD_SEL15_SEL30(base) (BME_UBFX16(&XBAR_SEL15_REG(base), XBAR_SEL15_SEL30_SHIFT, XBAR_SEL15_SEL30_WIDTH))

/*! @brief Set the SEL30 field to a new value. */
#define XBAR_WR_SEL15_SEL30(base, value) (XBAR_RMW_SEL15(base, XBAR_SEL15_SEL30_MASK, XBAR_SEL15_SEL30(value)))
#define XBAR_BWR_SEL15_SEL30(base, value) (BME_BFI16(&XBAR_SEL15_REG(base), ((uint16_t)(value) << XBAR_SEL15_SEL30_SHIFT), XBAR_SEL15_SEL30_SHIFT, XBAR_SEL15_SEL30_WIDTH))
/*@}*/

/*!
 * @name Register XBAR_SEL15, field SEL31[13:8] (RW)
 *
 * Input (XBAR_INn) to be muxed to XBAR_OUT31 (refer to Functional Description
 * section for input/output assignment)
 */
/*@{*/
/*! @brief Read current value of the XBAR_SEL15_SEL31 field. */
#define XBAR_RD_SEL15_SEL31(base) ((XBAR_SEL15_REG(base) & XBAR_SEL15_SEL31_MASK) >> XBAR_SEL15_SEL31_SHIFT)
#define XBAR_BRD_SEL15_SEL31(base) (BME_UBFX16(&XBAR_SEL15_REG(base), XBAR_SEL15_SEL31_SHIFT, XBAR_SEL15_SEL31_WIDTH))

/*! @brief Set the SEL31 field to a new value. */
#define XBAR_WR_SEL15_SEL31(base, value) (XBAR_RMW_SEL15(base, XBAR_SEL15_SEL31_MASK, XBAR_SEL15_SEL31(value)))
#define XBAR_BWR_SEL15_SEL31(base, value) (BME_BFI16(&XBAR_SEL15_REG(base), ((uint16_t)(value) << XBAR_SEL15_SEL31_SHIFT), XBAR_SEL15_SEL31_SHIFT, XBAR_SEL15_SEL31_WIDTH))
/*@}*/

/*******************************************************************************
 * XBAR_SEL16 - Crossbar Select Register 16
 ******************************************************************************/

/*!
 * @brief XBAR_SEL16 - Crossbar Select Register 16 (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire XBAR_SEL16 register
 */
/*@{*/
#define XBAR_RD_SEL16(base)      (XBAR_SEL16_REG(base))
#define XBAR_WR_SEL16(base, value) (XBAR_SEL16_REG(base) = (value))
#define XBAR_RMW_SEL16(base, mask, value) (XBAR_WR_SEL16(base, (XBAR_RD_SEL16(base) & ~(mask)) | (value)))
#define XBAR_SET_SEL16(base, value) (BME_OR16(&XBAR_SEL16_REG(base), (uint16_t)(value)))
#define XBAR_CLR_SEL16(base, value) (BME_AND16(&XBAR_SEL16_REG(base), (uint16_t)(~(value))))
#define XBAR_TOG_SEL16(base, value) (BME_XOR16(&XBAR_SEL16_REG(base), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XBAR_SEL16 bitfields
 */

/*!
 * @name Register XBAR_SEL16, field SEL32[5:0] (RW)
 *
 * Input (XBAR_INn) to be muxed to XBAR_OUT32
 */
/*@{*/
/*! @brief Read current value of the XBAR_SEL16_SEL32 field. */
#define XBAR_RD_SEL16_SEL32(base) ((XBAR_SEL16_REG(base) & XBAR_SEL16_SEL32_MASK) >> XBAR_SEL16_SEL32_SHIFT)
#define XBAR_BRD_SEL16_SEL32(base) (BME_UBFX16(&XBAR_SEL16_REG(base), XBAR_SEL16_SEL32_SHIFT, XBAR_SEL16_SEL32_WIDTH))

/*! @brief Set the SEL32 field to a new value. */
#define XBAR_WR_SEL16_SEL32(base, value) (XBAR_RMW_SEL16(base, XBAR_SEL16_SEL32_MASK, XBAR_SEL16_SEL32(value)))
#define XBAR_BWR_SEL16_SEL32(base, value) (BME_BFI16(&XBAR_SEL16_REG(base), ((uint16_t)(value) << XBAR_SEL16_SEL32_SHIFT), XBAR_SEL16_SEL32_SHIFT, XBAR_SEL16_SEL32_WIDTH))
/*@}*/

/*!
 * @name Register XBAR_SEL16, field SEL33[13:8] (RW)
 *
 * Input (XBAR_INn) to be muxed to XBAR_OUT33
 */
/*@{*/
/*! @brief Read current value of the XBAR_SEL16_SEL33 field. */
#define XBAR_RD_SEL16_SEL33(base) ((XBAR_SEL16_REG(base) & XBAR_SEL16_SEL33_MASK) >> XBAR_SEL16_SEL33_SHIFT)
#define XBAR_BRD_SEL16_SEL33(base) (BME_UBFX16(&XBAR_SEL16_REG(base), XBAR_SEL16_SEL33_SHIFT, XBAR_SEL16_SEL33_WIDTH))

/*! @brief Set the SEL33 field to a new value. */
#define XBAR_WR_SEL16_SEL33(base, value) (XBAR_RMW_SEL16(base, XBAR_SEL16_SEL33_MASK, XBAR_SEL16_SEL33(value)))
#define XBAR_BWR_SEL16_SEL33(base, value) (BME_BFI16(&XBAR_SEL16_REG(base), ((uint16_t)(value) << XBAR_SEL16_SEL33_SHIFT), XBAR_SEL16_SEL33_SHIFT, XBAR_SEL16_SEL33_WIDTH))
/*@}*/

/*******************************************************************************
 * XBAR_SEL17 - Crossbar Select Register 17
 ******************************************************************************/

/*!
 * @brief XBAR_SEL17 - Crossbar Select Register 17 (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire XBAR_SEL17 register
 */
/*@{*/
#define XBAR_RD_SEL17(base)      (XBAR_SEL17_REG(base))
#define XBAR_WR_SEL17(base, value) (XBAR_SEL17_REG(base) = (value))
#define XBAR_RMW_SEL17(base, mask, value) (XBAR_WR_SEL17(base, (XBAR_RD_SEL17(base) & ~(mask)) | (value)))
#define XBAR_SET_SEL17(base, value) (BME_OR16(&XBAR_SEL17_REG(base), (uint16_t)(value)))
#define XBAR_CLR_SEL17(base, value) (BME_AND16(&XBAR_SEL17_REG(base), (uint16_t)(~(value))))
#define XBAR_TOG_SEL17(base, value) (BME_XOR16(&XBAR_SEL17_REG(base), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XBAR_SEL17 bitfields
 */

/*!
 * @name Register XBAR_SEL17, field SEL34[5:0] (RW)
 *
 * Input (XBAR_INn) to be muxed to XBAR_OUT34
 */
/*@{*/
/*! @brief Read current value of the XBAR_SEL17_SEL34 field. */
#define XBAR_RD_SEL17_SEL34(base) ((XBAR_SEL17_REG(base) & XBAR_SEL17_SEL34_MASK) >> XBAR_SEL17_SEL34_SHIFT)
#define XBAR_BRD_SEL17_SEL34(base) (BME_UBFX16(&XBAR_SEL17_REG(base), XBAR_SEL17_SEL34_SHIFT, XBAR_SEL17_SEL34_WIDTH))

/*! @brief Set the SEL34 field to a new value. */
#define XBAR_WR_SEL17_SEL34(base, value) (XBAR_RMW_SEL17(base, XBAR_SEL17_SEL34_MASK, XBAR_SEL17_SEL34(value)))
#define XBAR_BWR_SEL17_SEL34(base, value) (BME_BFI16(&XBAR_SEL17_REG(base), ((uint16_t)(value) << XBAR_SEL17_SEL34_SHIFT), XBAR_SEL17_SEL34_SHIFT, XBAR_SEL17_SEL34_WIDTH))
/*@}*/

/*!
 * @name Register XBAR_SEL17, field SEL35[13:8] (RW)
 *
 * Input (XBAR_INn) to be muxed to XBAR_OUT35
 */
/*@{*/
/*! @brief Read current value of the XBAR_SEL17_SEL35 field. */
#define XBAR_RD_SEL17_SEL35(base) ((XBAR_SEL17_REG(base) & XBAR_SEL17_SEL35_MASK) >> XBAR_SEL17_SEL35_SHIFT)
#define XBAR_BRD_SEL17_SEL35(base) (BME_UBFX16(&XBAR_SEL17_REG(base), XBAR_SEL17_SEL35_SHIFT, XBAR_SEL17_SEL35_WIDTH))

/*! @brief Set the SEL35 field to a new value. */
#define XBAR_WR_SEL17_SEL35(base, value) (XBAR_RMW_SEL17(base, XBAR_SEL17_SEL35_MASK, XBAR_SEL17_SEL35(value)))
#define XBAR_BWR_SEL17_SEL35(base, value) (BME_BFI16(&XBAR_SEL17_REG(base), ((uint16_t)(value) << XBAR_SEL17_SEL35_SHIFT), XBAR_SEL17_SEL35_SHIFT, XBAR_SEL17_SEL35_WIDTH))
/*@}*/

/*******************************************************************************
 * XBAR_SEL18 - Crossbar Select Register 18
 ******************************************************************************/

/*!
 * @brief XBAR_SEL18 - Crossbar Select Register 18 (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire XBAR_SEL18 register
 */
/*@{*/
#define XBAR_RD_SEL18(base)      (XBAR_SEL18_REG(base))
#define XBAR_WR_SEL18(base, value) (XBAR_SEL18_REG(base) = (value))
#define XBAR_RMW_SEL18(base, mask, value) (XBAR_WR_SEL18(base, (XBAR_RD_SEL18(base) & ~(mask)) | (value)))
#define XBAR_SET_SEL18(base, value) (BME_OR16(&XBAR_SEL18_REG(base), (uint16_t)(value)))
#define XBAR_CLR_SEL18(base, value) (BME_AND16(&XBAR_SEL18_REG(base), (uint16_t)(~(value))))
#define XBAR_TOG_SEL18(base, value) (BME_XOR16(&XBAR_SEL18_REG(base), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XBAR_SEL18 bitfields
 */

/*!
 * @name Register XBAR_SEL18, field SEL36[5:0] (RW)
 *
 * Input (XBAR_INn) to be muxed to XBAR_OUT36
 */
/*@{*/
/*! @brief Read current value of the XBAR_SEL18_SEL36 field. */
#define XBAR_RD_SEL18_SEL36(base) ((XBAR_SEL18_REG(base) & XBAR_SEL18_SEL36_MASK) >> XBAR_SEL18_SEL36_SHIFT)
#define XBAR_BRD_SEL18_SEL36(base) (BME_UBFX16(&XBAR_SEL18_REG(base), XBAR_SEL18_SEL36_SHIFT, XBAR_SEL18_SEL36_WIDTH))

/*! @brief Set the SEL36 field to a new value. */
#define XBAR_WR_SEL18_SEL36(base, value) (XBAR_RMW_SEL18(base, XBAR_SEL18_SEL36_MASK, XBAR_SEL18_SEL36(value)))
#define XBAR_BWR_SEL18_SEL36(base, value) (BME_BFI16(&XBAR_SEL18_REG(base), ((uint16_t)(value) << XBAR_SEL18_SEL36_SHIFT), XBAR_SEL18_SEL36_SHIFT, XBAR_SEL18_SEL36_WIDTH))
/*@}*/

/*!
 * @name Register XBAR_SEL18, field SEL37[13:8] (RW)
 *
 * Input (XBAR_INn) to be muxed to XBAR_OUT37
 */
/*@{*/
/*! @brief Read current value of the XBAR_SEL18_SEL37 field. */
#define XBAR_RD_SEL18_SEL37(base) ((XBAR_SEL18_REG(base) & XBAR_SEL18_SEL37_MASK) >> XBAR_SEL18_SEL37_SHIFT)
#define XBAR_BRD_SEL18_SEL37(base) (BME_UBFX16(&XBAR_SEL18_REG(base), XBAR_SEL18_SEL37_SHIFT, XBAR_SEL18_SEL37_WIDTH))

/*! @brief Set the SEL37 field to a new value. */
#define XBAR_WR_SEL18_SEL37(base, value) (XBAR_RMW_SEL18(base, XBAR_SEL18_SEL37_MASK, XBAR_SEL18_SEL37(value)))
#define XBAR_BWR_SEL18_SEL37(base, value) (BME_BFI16(&XBAR_SEL18_REG(base), ((uint16_t)(value) << XBAR_SEL18_SEL37_SHIFT), XBAR_SEL18_SEL37_SHIFT, XBAR_SEL18_SEL37_WIDTH))
/*@}*/

/*******************************************************************************
 * XBAR_SEL19 - Crossbar Select Register 19
 ******************************************************************************/

/*!
 * @brief XBAR_SEL19 - Crossbar Select Register 19 (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire XBAR_SEL19 register
 */
/*@{*/
#define XBAR_RD_SEL19(base)      (XBAR_SEL19_REG(base))
#define XBAR_WR_SEL19(base, value) (XBAR_SEL19_REG(base) = (value))
#define XBAR_RMW_SEL19(base, mask, value) (XBAR_WR_SEL19(base, (XBAR_RD_SEL19(base) & ~(mask)) | (value)))
#define XBAR_SET_SEL19(base, value) (BME_OR16(&XBAR_SEL19_REG(base), (uint16_t)(value)))
#define XBAR_CLR_SEL19(base, value) (BME_AND16(&XBAR_SEL19_REG(base), (uint16_t)(~(value))))
#define XBAR_TOG_SEL19(base, value) (BME_XOR16(&XBAR_SEL19_REG(base), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XBAR_SEL19 bitfields
 */

/*!
 * @name Register XBAR_SEL19, field SEL38[5:0] (RW)
 *
 * Input (XBAR_INn) to be muxed to XBAR_OUT38
 */
/*@{*/
/*! @brief Read current value of the XBAR_SEL19_SEL38 field. */
#define XBAR_RD_SEL19_SEL38(base) ((XBAR_SEL19_REG(base) & XBAR_SEL19_SEL38_MASK) >> XBAR_SEL19_SEL38_SHIFT)
#define XBAR_BRD_SEL19_SEL38(base) (BME_UBFX16(&XBAR_SEL19_REG(base), XBAR_SEL19_SEL38_SHIFT, XBAR_SEL19_SEL38_WIDTH))

/*! @brief Set the SEL38 field to a new value. */
#define XBAR_WR_SEL19_SEL38(base, value) (XBAR_RMW_SEL19(base, XBAR_SEL19_SEL38_MASK, XBAR_SEL19_SEL38(value)))
#define XBAR_BWR_SEL19_SEL38(base, value) (BME_BFI16(&XBAR_SEL19_REG(base), ((uint16_t)(value) << XBAR_SEL19_SEL38_SHIFT), XBAR_SEL19_SEL38_SHIFT, XBAR_SEL19_SEL38_WIDTH))
/*@}*/

/*!
 * @name Register XBAR_SEL19, field SEL39[13:8] (RW)
 *
 * Input (XBAR_INn) to be muxed to XBAR_OUT39
 */
/*@{*/
/*! @brief Read current value of the XBAR_SEL19_SEL39 field. */
#define XBAR_RD_SEL19_SEL39(base) ((XBAR_SEL19_REG(base) & XBAR_SEL19_SEL39_MASK) >> XBAR_SEL19_SEL39_SHIFT)
#define XBAR_BRD_SEL19_SEL39(base) (BME_UBFX16(&XBAR_SEL19_REG(base), XBAR_SEL19_SEL39_SHIFT, XBAR_SEL19_SEL39_WIDTH))

/*! @brief Set the SEL39 field to a new value. */
#define XBAR_WR_SEL19_SEL39(base, value) (XBAR_RMW_SEL19(base, XBAR_SEL19_SEL39_MASK, XBAR_SEL19_SEL39(value)))
#define XBAR_BWR_SEL19_SEL39(base, value) (BME_BFI16(&XBAR_SEL19_REG(base), ((uint16_t)(value) << XBAR_SEL19_SEL39_SHIFT), XBAR_SEL19_SEL39_SHIFT, XBAR_SEL19_SEL39_WIDTH))
/*@}*/

/*******************************************************************************
 * XBAR_SEL20 - Crossbar Select Register 20
 ******************************************************************************/

/*!
 * @brief XBAR_SEL20 - Crossbar Select Register 20 (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire XBAR_SEL20 register
 */
/*@{*/
#define XBAR_RD_SEL20(base)      (XBAR_SEL20_REG(base))
#define XBAR_WR_SEL20(base, value) (XBAR_SEL20_REG(base) = (value))
#define XBAR_RMW_SEL20(base, mask, value) (XBAR_WR_SEL20(base, (XBAR_RD_SEL20(base) & ~(mask)) | (value)))
#define XBAR_SET_SEL20(base, value) (BME_OR16(&XBAR_SEL20_REG(base), (uint16_t)(value)))
#define XBAR_CLR_SEL20(base, value) (BME_AND16(&XBAR_SEL20_REG(base), (uint16_t)(~(value))))
#define XBAR_TOG_SEL20(base, value) (BME_XOR16(&XBAR_SEL20_REG(base), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XBAR_SEL20 bitfields
 */

/*!
 * @name Register XBAR_SEL20, field SEL40[5:0] (RW)
 *
 * Input (XBAR_INn) to be muxed to XBAR_OUT40
 */
/*@{*/
/*! @brief Read current value of the XBAR_SEL20_SEL40 field. */
#define XBAR_RD_SEL20_SEL40(base) ((XBAR_SEL20_REG(base) & XBAR_SEL20_SEL40_MASK) >> XBAR_SEL20_SEL40_SHIFT)
#define XBAR_BRD_SEL20_SEL40(base) (BME_UBFX16(&XBAR_SEL20_REG(base), XBAR_SEL20_SEL40_SHIFT, XBAR_SEL20_SEL40_WIDTH))

/*! @brief Set the SEL40 field to a new value. */
#define XBAR_WR_SEL20_SEL40(base, value) (XBAR_RMW_SEL20(base, XBAR_SEL20_SEL40_MASK, XBAR_SEL20_SEL40(value)))
#define XBAR_BWR_SEL20_SEL40(base, value) (BME_BFI16(&XBAR_SEL20_REG(base), ((uint16_t)(value) << XBAR_SEL20_SEL40_SHIFT), XBAR_SEL20_SEL40_SHIFT, XBAR_SEL20_SEL40_WIDTH))
/*@}*/

/*!
 * @name Register XBAR_SEL20, field SEL41[13:8] (RW)
 *
 * Input (XBAR_INn) to be muxed to XBAR_OUT41
 */
/*@{*/
/*! @brief Read current value of the XBAR_SEL20_SEL41 field. */
#define XBAR_RD_SEL20_SEL41(base) ((XBAR_SEL20_REG(base) & XBAR_SEL20_SEL41_MASK) >> XBAR_SEL20_SEL41_SHIFT)
#define XBAR_BRD_SEL20_SEL41(base) (BME_UBFX16(&XBAR_SEL20_REG(base), XBAR_SEL20_SEL41_SHIFT, XBAR_SEL20_SEL41_WIDTH))

/*! @brief Set the SEL41 field to a new value. */
#define XBAR_WR_SEL20_SEL41(base, value) (XBAR_RMW_SEL20(base, XBAR_SEL20_SEL41_MASK, XBAR_SEL20_SEL41(value)))
#define XBAR_BWR_SEL20_SEL41(base, value) (BME_BFI16(&XBAR_SEL20_REG(base), ((uint16_t)(value) << XBAR_SEL20_SEL41_SHIFT), XBAR_SEL20_SEL41_SHIFT, XBAR_SEL20_SEL41_WIDTH))
/*@}*/

/*******************************************************************************
 * XBAR_SEL21 - Crossbar Select Register 21
 ******************************************************************************/

/*!
 * @brief XBAR_SEL21 - Crossbar Select Register 21 (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire XBAR_SEL21 register
 */
/*@{*/
#define XBAR_RD_SEL21(base)      (XBAR_SEL21_REG(base))
#define XBAR_WR_SEL21(base, value) (XBAR_SEL21_REG(base) = (value))
#define XBAR_RMW_SEL21(base, mask, value) (XBAR_WR_SEL21(base, (XBAR_RD_SEL21(base) & ~(mask)) | (value)))
#define XBAR_SET_SEL21(base, value) (BME_OR16(&XBAR_SEL21_REG(base), (uint16_t)(value)))
#define XBAR_CLR_SEL21(base, value) (BME_AND16(&XBAR_SEL21_REG(base), (uint16_t)(~(value))))
#define XBAR_TOG_SEL21(base, value) (BME_XOR16(&XBAR_SEL21_REG(base), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XBAR_SEL21 bitfields
 */

/*!
 * @name Register XBAR_SEL21, field SEL42[5:0] (RW)
 *
 * Input (XBAR_INn) to be muxed to XBAR_OUT42
 */
/*@{*/
/*! @brief Read current value of the XBAR_SEL21_SEL42 field. */
#define XBAR_RD_SEL21_SEL42(base) ((XBAR_SEL21_REG(base) & XBAR_SEL21_SEL42_MASK) >> XBAR_SEL21_SEL42_SHIFT)
#define XBAR_BRD_SEL21_SEL42(base) (BME_UBFX16(&XBAR_SEL21_REG(base), XBAR_SEL21_SEL42_SHIFT, XBAR_SEL21_SEL42_WIDTH))

/*! @brief Set the SEL42 field to a new value. */
#define XBAR_WR_SEL21_SEL42(base, value) (XBAR_RMW_SEL21(base, XBAR_SEL21_SEL42_MASK, XBAR_SEL21_SEL42(value)))
#define XBAR_BWR_SEL21_SEL42(base, value) (BME_BFI16(&XBAR_SEL21_REG(base), ((uint16_t)(value) << XBAR_SEL21_SEL42_SHIFT), XBAR_SEL21_SEL42_SHIFT, XBAR_SEL21_SEL42_WIDTH))
/*@}*/

/*!
 * @name Register XBAR_SEL21, field SEL43[13:8] (RW)
 *
 * Input (XBAR_INn) to be muxed to XBAR_OUT43
 */
/*@{*/
/*! @brief Read current value of the XBAR_SEL21_SEL43 field. */
#define XBAR_RD_SEL21_SEL43(base) ((XBAR_SEL21_REG(base) & XBAR_SEL21_SEL43_MASK) >> XBAR_SEL21_SEL43_SHIFT)
#define XBAR_BRD_SEL21_SEL43(base) (BME_UBFX16(&XBAR_SEL21_REG(base), XBAR_SEL21_SEL43_SHIFT, XBAR_SEL21_SEL43_WIDTH))

/*! @brief Set the SEL43 field to a new value. */
#define XBAR_WR_SEL21_SEL43(base, value) (XBAR_RMW_SEL21(base, XBAR_SEL21_SEL43_MASK, XBAR_SEL21_SEL43(value)))
#define XBAR_BWR_SEL21_SEL43(base, value) (BME_BFI16(&XBAR_SEL21_REG(base), ((uint16_t)(value) << XBAR_SEL21_SEL43_SHIFT), XBAR_SEL21_SEL43_SHIFT, XBAR_SEL21_SEL43_WIDTH))
/*@}*/

/*******************************************************************************
 * XBAR_CTRL0 - Crossbar Control Register 0
 ******************************************************************************/

/*!
 * @brief XBAR_CTRL0 - Crossbar Control Register 0 (RW)
 *
 * Reset value: 0x0000U
 *
 * Use this register to configure edge detection, interrupt, and DMA features
 * for the XBAR_OUT0 and XBAR_OUT1 outputs. The XBAR_CTRL registers are organized
 * similarly to the XBAR_SEL registers, with control fields for two XBAR_OUT
 * outputs in each register. In control register 0, the LSBs contain the control
 * fields for XBAR_OUT0, and the MSBs contain the control fields for XBAR_OUT1.
 */
/*!
 * @name Constants and macros for entire XBAR_CTRL0 register
 */
/*@{*/
#define XBAR_RD_CTRL0(base)      (XBAR_CTRL0_REG(base))
#define XBAR_WR_CTRL0(base, value) (XBAR_CTRL0_REG(base) = (value))
#define XBAR_RMW_CTRL0(base, mask, value) (XBAR_WR_CTRL0(base, (XBAR_RD_CTRL0(base) & ~(mask)) | (value)))
#define XBAR_SET_CTRL0(base, value) (BME_OR16(&XBAR_CTRL0_REG(base), (uint16_t)(value)))
#define XBAR_CLR_CTRL0(base, value) (BME_AND16(&XBAR_CTRL0_REG(base), (uint16_t)(~(value))))
#define XBAR_TOG_CTRL0(base, value) (BME_XOR16(&XBAR_CTRL0_REG(base), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XBAR_CTRL0 bitfields
 */

/*!
 * @name Register XBAR_CTRL0, field DEN0[0] (RW)
 *
 * This bit enables the DMA function on the corresponding XBAR_OUT0 output. When
 * enabled, DMA_REQ0 presents the value STS0. When disabled, the DMA_REQ0 output
 * remains low. IEN0 and DEN0 should not both be set to 1.
 *
 * Values:
 * - 0b0 - DMA disabled
 * - 0b1 - DMA enabled
 */
/*@{*/
/*! @brief Read current value of the XBAR_CTRL0_DEN0 field. */
#define XBAR_RD_CTRL0_DEN0(base) ((XBAR_CTRL0_REG(base) & XBAR_CTRL0_DEN0_MASK) >> XBAR_CTRL0_DEN0_SHIFT)
#define XBAR_BRD_CTRL0_DEN0(base) (BME_UBFX16(&XBAR_CTRL0_REG(base), XBAR_CTRL0_DEN0_SHIFT, XBAR_CTRL0_DEN0_WIDTH))

/*! @brief Set the DEN0 field to a new value. */
#define XBAR_WR_CTRL0_DEN0(base, value) (XBAR_RMW_CTRL0(base, (XBAR_CTRL0_DEN0_MASK | XBAR_CTRL0_STS0_MASK | XBAR_CTRL0_STS1_MASK), XBAR_CTRL0_DEN0(value)))
#define XBAR_BWR_CTRL0_DEN0(base, value) (BME_BFI16(&XBAR_CTRL0_REG(base), ((uint16_t)(value) << XBAR_CTRL0_DEN0_SHIFT), XBAR_CTRL0_DEN0_SHIFT, XBAR_CTRL0_DEN0_WIDTH))
/*@}*/

/*!
 * @name Register XBAR_CTRL0, field IEN0[1] (RW)
 *
 * This bit enables the interrupt function on the corresponding XBAR_OUT0
 * output. When the interrupt is enabled, the output INT_REQ0 reflects the value STS0.
 * When the interrupt is disabled, INT_REQ0 remains low. The interrupt request is
 * cleared by writing a 1 to STS0. IEN0 and DEN0 should not both be set to 1.
 *
 * Values:
 * - 0b0 - Interrupt disabled
 * - 0b1 - Interrupt enabled
 */
/*@{*/
/*! @brief Read current value of the XBAR_CTRL0_IEN0 field. */
#define XBAR_RD_CTRL0_IEN0(base) ((XBAR_CTRL0_REG(base) & XBAR_CTRL0_IEN0_MASK) >> XBAR_CTRL0_IEN0_SHIFT)
#define XBAR_BRD_CTRL0_IEN0(base) (BME_UBFX16(&XBAR_CTRL0_REG(base), XBAR_CTRL0_IEN0_SHIFT, XBAR_CTRL0_IEN0_WIDTH))

/*! @brief Set the IEN0 field to a new value. */
#define XBAR_WR_CTRL0_IEN0(base, value) (XBAR_RMW_CTRL0(base, (XBAR_CTRL0_IEN0_MASK | XBAR_CTRL0_STS0_MASK | XBAR_CTRL0_STS1_MASK), XBAR_CTRL0_IEN0(value)))
#define XBAR_BWR_CTRL0_IEN0(base, value) (BME_BFI16(&XBAR_CTRL0_REG(base), ((uint16_t)(value) << XBAR_CTRL0_IEN0_SHIFT), XBAR_CTRL0_IEN0_SHIFT, XBAR_CTRL0_IEN0_WIDTH))
/*@}*/

/*!
 * @name Register XBAR_CTRL0, field EDGE0[3:2] (RW)
 *
 * This field selects which edges on XBAR_OUT0 cause STS0 to assert.
 *
 * Values:
 * - 0b00 - STS0 never asserts
 * - 0b01 - STS0 asserts on rising edges of XBAR_OUT0
 * - 0b10 - STS0 asserts on falling edges of XBAR_OUT0
 * - 0b11 - STS0 asserts on rising and falling edges of XBAR_OUT0
 */
/*@{*/
/*! @brief Read current value of the XBAR_CTRL0_EDGE0 field. */
#define XBAR_RD_CTRL0_EDGE0(base) ((XBAR_CTRL0_REG(base) & XBAR_CTRL0_EDGE0_MASK) >> XBAR_CTRL0_EDGE0_SHIFT)
#define XBAR_BRD_CTRL0_EDGE0(base) (BME_UBFX16(&XBAR_CTRL0_REG(base), XBAR_CTRL0_EDGE0_SHIFT, XBAR_CTRL0_EDGE0_WIDTH))

/*! @brief Set the EDGE0 field to a new value. */
#define XBAR_WR_CTRL0_EDGE0(base, value) (XBAR_RMW_CTRL0(base, (XBAR_CTRL0_EDGE0_MASK | XBAR_CTRL0_STS0_MASK | XBAR_CTRL0_STS1_MASK), XBAR_CTRL0_EDGE0(value)))
#define XBAR_BWR_CTRL0_EDGE0(base, value) (BME_BFI16(&XBAR_CTRL0_REG(base), ((uint16_t)(value) << XBAR_CTRL0_EDGE0_SHIFT), XBAR_CTRL0_EDGE0_SHIFT, XBAR_CTRL0_EDGE0_WIDTH))
/*@}*/

/*!
 * @name Register XBAR_CTRL0, field STS0[4] (W1C)
 *
 * This bit reflects the results of edge detection for XBAR_OUT0. This field is
 * set to 1 when an edge consistent with the current setting of EDGE0 is detected
 * on XBAR_OUT0. This field is cleared by writing 1 to it or by a DMA_ACK0
 * reception when DEN0 is set. Writing 0 to the field has no effect. When interrupt or
 * DMA functionality is enabled for XBAR_OUT0, this field is 1 when the
 * interrupt or DMA request is asserted and 0 when the interrupt or DMA request has been
 * cleared.
 *
 * Values:
 * - 0b0 - Active edge not yet detected on XBAR_OUT0
 * - 0b1 - Active edge detected on XBAR_OUT0
 */
/*@{*/
/*! @brief Read current value of the XBAR_CTRL0_STS0 field. */
#define XBAR_RD_CTRL0_STS0(base) ((XBAR_CTRL0_REG(base) & XBAR_CTRL0_STS0_MASK) >> XBAR_CTRL0_STS0_SHIFT)
#define XBAR_BRD_CTRL0_STS0(base) (BME_UBFX16(&XBAR_CTRL0_REG(base), XBAR_CTRL0_STS0_SHIFT, XBAR_CTRL0_STS0_WIDTH))

/*! @brief Set the STS0 field to a new value. */
#define XBAR_WR_CTRL0_STS0(base, value) (XBAR_RMW_CTRL0(base, (XBAR_CTRL0_STS0_MASK | XBAR_CTRL0_STS1_MASK), XBAR_CTRL0_STS0(value)))
#define XBAR_BWR_CTRL0_STS0(base, value) (BME_BFI16(&XBAR_CTRL0_REG(base), ((uint16_t)(value) << XBAR_CTRL0_STS0_SHIFT), XBAR_CTRL0_STS0_SHIFT, XBAR_CTRL0_STS0_WIDTH))
/*@}*/

/*!
 * @name Register XBAR_CTRL0, field DEN1[8] (RW)
 *
 * This bit enables the DMA function on the corresponding XBAR_OUT1 output. When
 * enabled, DMA_REQ1 presents the value STS1. When disabled, the DMA_REQ1 output
 * remains low. IEN1 and DEN1 should not both be set to 1.
 *
 * Values:
 * - 0b0 - DMA disabled
 * - 0b1 - DMA enabled
 */
/*@{*/
/*! @brief Read current value of the XBAR_CTRL0_DEN1 field. */
#define XBAR_RD_CTRL0_DEN1(base) ((XBAR_CTRL0_REG(base) & XBAR_CTRL0_DEN1_MASK) >> XBAR_CTRL0_DEN1_SHIFT)
#define XBAR_BRD_CTRL0_DEN1(base) (BME_UBFX16(&XBAR_CTRL0_REG(base), XBAR_CTRL0_DEN1_SHIFT, XBAR_CTRL0_DEN1_WIDTH))

/*! @brief Set the DEN1 field to a new value. */
#define XBAR_WR_CTRL0_DEN1(base, value) (XBAR_RMW_CTRL0(base, (XBAR_CTRL0_DEN1_MASK | XBAR_CTRL0_STS0_MASK | XBAR_CTRL0_STS1_MASK), XBAR_CTRL0_DEN1(value)))
#define XBAR_BWR_CTRL0_DEN1(base, value) (BME_BFI16(&XBAR_CTRL0_REG(base), ((uint16_t)(value) << XBAR_CTRL0_DEN1_SHIFT), XBAR_CTRL0_DEN1_SHIFT, XBAR_CTRL0_DEN1_WIDTH))
/*@}*/

/*!
 * @name Register XBAR_CTRL0, field IEN1[9] (RW)
 *
 * This bit enables the interrupt function on the corresponding XBAR_OUT1
 * output. When the interrupt is enabled, the output INT_REQ1 reflects the value STS1.
 * When the interrupt is disabled, INT_REQ1 remains low. The interrupt request is
 * cleared by writing a 1 to STS1. IEN1 and DEN1 should not both be set to 1.
 *
 * Values:
 * - 0b0 - Interrupt disabled
 * - 0b1 - Interrupt enabled
 */
/*@{*/
/*! @brief Read current value of the XBAR_CTRL0_IEN1 field. */
#define XBAR_RD_CTRL0_IEN1(base) ((XBAR_CTRL0_REG(base) & XBAR_CTRL0_IEN1_MASK) >> XBAR_CTRL0_IEN1_SHIFT)
#define XBAR_BRD_CTRL0_IEN1(base) (BME_UBFX16(&XBAR_CTRL0_REG(base), XBAR_CTRL0_IEN1_SHIFT, XBAR_CTRL0_IEN1_WIDTH))

/*! @brief Set the IEN1 field to a new value. */
#define XBAR_WR_CTRL0_IEN1(base, value) (XBAR_RMW_CTRL0(base, (XBAR_CTRL0_IEN1_MASK | XBAR_CTRL0_STS0_MASK | XBAR_CTRL0_STS1_MASK), XBAR_CTRL0_IEN1(value)))
#define XBAR_BWR_CTRL0_IEN1(base, value) (BME_BFI16(&XBAR_CTRL0_REG(base), ((uint16_t)(value) << XBAR_CTRL0_IEN1_SHIFT), XBAR_CTRL0_IEN1_SHIFT, XBAR_CTRL0_IEN1_WIDTH))
/*@}*/

/*!
 * @name Register XBAR_CTRL0, field EDGE1[11:10] (RW)
 *
 * This field selects which edges on XBAR_OUT1 cause STS1 to assert.
 *
 * Values:
 * - 0b00 - STS1 never asserts
 * - 0b01 - STS1 asserts on rising edges of XBAR_OUT1
 * - 0b10 - STS1 asserts on falling edges of XBAR_OUT1
 * - 0b11 - STS1 asserts on rising and falling edges of XBAR_OUT1
 */
/*@{*/
/*! @brief Read current value of the XBAR_CTRL0_EDGE1 field. */
#define XBAR_RD_CTRL0_EDGE1(base) ((XBAR_CTRL0_REG(base) & XBAR_CTRL0_EDGE1_MASK) >> XBAR_CTRL0_EDGE1_SHIFT)
#define XBAR_BRD_CTRL0_EDGE1(base) (BME_UBFX16(&XBAR_CTRL0_REG(base), XBAR_CTRL0_EDGE1_SHIFT, XBAR_CTRL0_EDGE1_WIDTH))

/*! @brief Set the EDGE1 field to a new value. */
#define XBAR_WR_CTRL0_EDGE1(base, value) (XBAR_RMW_CTRL0(base, (XBAR_CTRL0_EDGE1_MASK | XBAR_CTRL0_STS0_MASK | XBAR_CTRL0_STS1_MASK), XBAR_CTRL0_EDGE1(value)))
#define XBAR_BWR_CTRL0_EDGE1(base, value) (BME_BFI16(&XBAR_CTRL0_REG(base), ((uint16_t)(value) << XBAR_CTRL0_EDGE1_SHIFT), XBAR_CTRL0_EDGE1_SHIFT, XBAR_CTRL0_EDGE1_WIDTH))
/*@}*/

/*!
 * @name Register XBAR_CTRL0, field STS1[12] (W1C)
 *
 * This bit reflects the results of edge detection for XBAR_OUT1. This field is
 * set to 1 when an edge consistent with the current setting of EDGE1 is detected
 * on XBAR_OUT1. This field is cleared by writing 1 to it or by a DMA_ACK1
 * reception when DEN1 is set. Writing 0 to the field has no effect. When interrupt or
 * DMA functionality is enabled for XBAR_OUT1, this field is 1 when the
 * interrupt or DMA request is asserted and 0 when the interrupt or DMA request has been
 * cleared.
 *
 * Values:
 * - 0b0 - Active edge not yet detected on XBAR_OUT1
 * - 0b1 - Active edge detected on XBAR_OUT1
 */
/*@{*/
/*! @brief Read current value of the XBAR_CTRL0_STS1 field. */
#define XBAR_RD_CTRL0_STS1(base) ((XBAR_CTRL0_REG(base) & XBAR_CTRL0_STS1_MASK) >> XBAR_CTRL0_STS1_SHIFT)
#define XBAR_BRD_CTRL0_STS1(base) (BME_UBFX16(&XBAR_CTRL0_REG(base), XBAR_CTRL0_STS1_SHIFT, XBAR_CTRL0_STS1_WIDTH))

/*! @brief Set the STS1 field to a new value. */
#define XBAR_WR_CTRL0_STS1(base, value) (XBAR_RMW_CTRL0(base, (XBAR_CTRL0_STS1_MASK | XBAR_CTRL0_STS0_MASK), XBAR_CTRL0_STS1(value)))
#define XBAR_BWR_CTRL0_STS1(base, value) (BME_BFI16(&XBAR_CTRL0_REG(base), ((uint16_t)(value) << XBAR_CTRL0_STS1_SHIFT), XBAR_CTRL0_STS1_SHIFT, XBAR_CTRL0_STS1_WIDTH))
/*@}*/

/*******************************************************************************
 * XBAR_CTRL1 - Crossbar Control Register 1
 ******************************************************************************/

/*!
 * @brief XBAR_CTRL1 - Crossbar Control Register 1 (RW)
 *
 * Reset value: 0x0000U
 *
 * Use this register to configure edge detection, interrupt, and DMA features
 * for the XBAR_OUT2 and XBAR_OUT3 outputs. The XBAR_CTRL registers are organized
 * similarly to the XBAR_SEL registers, with control fields for two XBAR_OUT
 * outputs in each register. In control register 1, the LSBs contain the control
 * fields for XBAR_OUT2, and the MSBs contain the control fields for XBAR_OUT3.
 */
/*!
 * @name Constants and macros for entire XBAR_CTRL1 register
 */
/*@{*/
#define XBAR_RD_CTRL1(base)      (XBAR_CTRL1_REG(base))
#define XBAR_WR_CTRL1(base, value) (XBAR_CTRL1_REG(base) = (value))
#define XBAR_RMW_CTRL1(base, mask, value) (XBAR_WR_CTRL1(base, (XBAR_RD_CTRL1(base) & ~(mask)) | (value)))
#define XBAR_SET_CTRL1(base, value) (BME_OR16(&XBAR_CTRL1_REG(base), (uint16_t)(value)))
#define XBAR_CLR_CTRL1(base, value) (BME_AND16(&XBAR_CTRL1_REG(base), (uint16_t)(~(value))))
#define XBAR_TOG_CTRL1(base, value) (BME_XOR16(&XBAR_CTRL1_REG(base), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XBAR_CTRL1 bitfields
 */

/*!
 * @name Register XBAR_CTRL1, field DEN2[0] (RW)
 *
 * This bit enables the DMA function on the corresponding XBAR_OUT2 output. When
 * enabled, DMA_REQ2 presents the value STS2. When disabled, the DMA_REQ2 output
 * remains low. IEN2 and DEN2 should not both be set to 1.
 *
 * Values:
 * - 0b0 - DMA disabled
 * - 0b1 - DMA enabled
 */
/*@{*/
/*! @brief Read current value of the XBAR_CTRL1_DEN2 field. */
#define XBAR_RD_CTRL1_DEN2(base) ((XBAR_CTRL1_REG(base) & XBAR_CTRL1_DEN2_MASK) >> XBAR_CTRL1_DEN2_SHIFT)
#define XBAR_BRD_CTRL1_DEN2(base) (BME_UBFX16(&XBAR_CTRL1_REG(base), XBAR_CTRL1_DEN2_SHIFT, XBAR_CTRL1_DEN2_WIDTH))

/*! @brief Set the DEN2 field to a new value. */
#define XBAR_WR_CTRL1_DEN2(base, value) (XBAR_RMW_CTRL1(base, (XBAR_CTRL1_DEN2_MASK | XBAR_CTRL1_STS2_MASK | XBAR_CTRL1_STS3_MASK), XBAR_CTRL1_DEN2(value)))
#define XBAR_BWR_CTRL1_DEN2(base, value) (BME_BFI16(&XBAR_CTRL1_REG(base), ((uint16_t)(value) << XBAR_CTRL1_DEN2_SHIFT), XBAR_CTRL1_DEN2_SHIFT, XBAR_CTRL1_DEN2_WIDTH))
/*@}*/

/*!
 * @name Register XBAR_CTRL1, field IEN2[1] (RW)
 *
 * This bit enables the interrupt function on the corresponding XBAR_OUT2
 * output. When the interrupt is enabled, the output INT_REQ2 reflects the value STS2.
 * When the interrupt is disabled, INT_REQ2 remains low. The interrupt request is
 * cleared by writing a 1 to STS2. IEN2 and DEN2 should not both be set to 1.
 *
 * Values:
 * - 0b0 - Interrupt disabled
 * - 0b1 - Interrupt enabled
 */
/*@{*/
/*! @brief Read current value of the XBAR_CTRL1_IEN2 field. */
#define XBAR_RD_CTRL1_IEN2(base) ((XBAR_CTRL1_REG(base) & XBAR_CTRL1_IEN2_MASK) >> XBAR_CTRL1_IEN2_SHIFT)
#define XBAR_BRD_CTRL1_IEN2(base) (BME_UBFX16(&XBAR_CTRL1_REG(base), XBAR_CTRL1_IEN2_SHIFT, XBAR_CTRL1_IEN2_WIDTH))

/*! @brief Set the IEN2 field to a new value. */
#define XBAR_WR_CTRL1_IEN2(base, value) (XBAR_RMW_CTRL1(base, (XBAR_CTRL1_IEN2_MASK | XBAR_CTRL1_STS2_MASK | XBAR_CTRL1_STS3_MASK), XBAR_CTRL1_IEN2(value)))
#define XBAR_BWR_CTRL1_IEN2(base, value) (BME_BFI16(&XBAR_CTRL1_REG(base), ((uint16_t)(value) << XBAR_CTRL1_IEN2_SHIFT), XBAR_CTRL1_IEN2_SHIFT, XBAR_CTRL1_IEN2_WIDTH))
/*@}*/

/*!
 * @name Register XBAR_CTRL1, field EDGE2[3:2] (RW)
 *
 * This field selects which edges on XBAR_OUT2 cause STS2 to assert.
 *
 * Values:
 * - 0b00 - STS2 never asserts
 * - 0b01 - STS2 asserts on rising edges of XBAR_OUT2
 * - 0b10 - STS2 asserts on falling edges of XBAR_OUT2
 * - 0b11 - STS2 asserts on rising and falling edges of XBAR_OUT2
 */
/*@{*/
/*! @brief Read current value of the XBAR_CTRL1_EDGE2 field. */
#define XBAR_RD_CTRL1_EDGE2(base) ((XBAR_CTRL1_REG(base) & XBAR_CTRL1_EDGE2_MASK) >> XBAR_CTRL1_EDGE2_SHIFT)
#define XBAR_BRD_CTRL1_EDGE2(base) (BME_UBFX16(&XBAR_CTRL1_REG(base), XBAR_CTRL1_EDGE2_SHIFT, XBAR_CTRL1_EDGE2_WIDTH))

/*! @brief Set the EDGE2 field to a new value. */
#define XBAR_WR_CTRL1_EDGE2(base, value) (XBAR_RMW_CTRL1(base, (XBAR_CTRL1_EDGE2_MASK | XBAR_CTRL1_STS2_MASK | XBAR_CTRL1_STS3_MASK), XBAR_CTRL1_EDGE2(value)))
#define XBAR_BWR_CTRL1_EDGE2(base, value) (BME_BFI16(&XBAR_CTRL1_REG(base), ((uint16_t)(value) << XBAR_CTRL1_EDGE2_SHIFT), XBAR_CTRL1_EDGE2_SHIFT, XBAR_CTRL1_EDGE2_WIDTH))
/*@}*/

/*!
 * @name Register XBAR_CTRL1, field STS2[4] (W1C)
 *
 * This bit reflects the results of edge detection for XBAR_OUT2. This field is
 * set to 1 when an edge consistent with the current setting of EDGE2 is detected
 * on XBAR_OUT2. This field is cleared by writing 1 to it or by a DMA_ACK2
 * reception when DEN2 is set. Writing 0 to the field has no effect. When interrupt or
 * DMA functionality is enabled for XBAR_OUT2, this field is 1 when the
 * interrupt or DMA request is asserted and 0 when the interrupt or DMA request has been
 * cleared.
 *
 * Values:
 * - 0b0 - Active edge not yet detected on XBAR_OUT2
 * - 0b1 - Active edge detected on XBAR_OUT2
 */
/*@{*/
/*! @brief Read current value of the XBAR_CTRL1_STS2 field. */
#define XBAR_RD_CTRL1_STS2(base) ((XBAR_CTRL1_REG(base) & XBAR_CTRL1_STS2_MASK) >> XBAR_CTRL1_STS2_SHIFT)
#define XBAR_BRD_CTRL1_STS2(base) (BME_UBFX16(&XBAR_CTRL1_REG(base), XBAR_CTRL1_STS2_SHIFT, XBAR_CTRL1_STS2_WIDTH))

/*! @brief Set the STS2 field to a new value. */
#define XBAR_WR_CTRL1_STS2(base, value) (XBAR_RMW_CTRL1(base, (XBAR_CTRL1_STS2_MASK | XBAR_CTRL1_STS3_MASK), XBAR_CTRL1_STS2(value)))
#define XBAR_BWR_CTRL1_STS2(base, value) (BME_BFI16(&XBAR_CTRL1_REG(base), ((uint16_t)(value) << XBAR_CTRL1_STS2_SHIFT), XBAR_CTRL1_STS2_SHIFT, XBAR_CTRL1_STS2_WIDTH))
/*@}*/

/*!
 * @name Register XBAR_CTRL1, field DEN3[8] (RW)
 *
 * This bit enables the DMA function on the corresponding XBAR_OUT3 output. When
 * enabled, DMA_REQ3 presents the value STS3. When disabled, the DMA_REQ3 output
 * remains low. IEN3 and DEN3 should not both be set to 1.
 *
 * Values:
 * - 0b0 - DMA disabled
 * - 0b1 - DMA enabled
 */
/*@{*/
/*! @brief Read current value of the XBAR_CTRL1_DEN3 field. */
#define XBAR_RD_CTRL1_DEN3(base) ((XBAR_CTRL1_REG(base) & XBAR_CTRL1_DEN3_MASK) >> XBAR_CTRL1_DEN3_SHIFT)
#define XBAR_BRD_CTRL1_DEN3(base) (BME_UBFX16(&XBAR_CTRL1_REG(base), XBAR_CTRL1_DEN3_SHIFT, XBAR_CTRL1_DEN3_WIDTH))

/*! @brief Set the DEN3 field to a new value. */
#define XBAR_WR_CTRL1_DEN3(base, value) (XBAR_RMW_CTRL1(base, (XBAR_CTRL1_DEN3_MASK | XBAR_CTRL1_STS2_MASK | XBAR_CTRL1_STS3_MASK), XBAR_CTRL1_DEN3(value)))
#define XBAR_BWR_CTRL1_DEN3(base, value) (BME_BFI16(&XBAR_CTRL1_REG(base), ((uint16_t)(value) << XBAR_CTRL1_DEN3_SHIFT), XBAR_CTRL1_DEN3_SHIFT, XBAR_CTRL1_DEN3_WIDTH))
/*@}*/

/*!
 * @name Register XBAR_CTRL1, field IEN3[9] (RW)
 *
 * This bit enables the interrupt function on the corresponding XBAR_OUT3
 * output. When the interrupt is enabled, the output INT_REQ3 reflects the value STS3.
 * When the interrupt is disabled, INT_REQ3 remains low. The interrupt request is
 * cleared by writing a 1 to STS3. IEN3 and DEN3 should not both be set to 1.
 *
 * Values:
 * - 0b0 - Interrupt disabled
 * - 0b1 - Interrupt enabled
 */
/*@{*/
/*! @brief Read current value of the XBAR_CTRL1_IEN3 field. */
#define XBAR_RD_CTRL1_IEN3(base) ((XBAR_CTRL1_REG(base) & XBAR_CTRL1_IEN3_MASK) >> XBAR_CTRL1_IEN3_SHIFT)
#define XBAR_BRD_CTRL1_IEN3(base) (BME_UBFX16(&XBAR_CTRL1_REG(base), XBAR_CTRL1_IEN3_SHIFT, XBAR_CTRL1_IEN3_WIDTH))

/*! @brief Set the IEN3 field to a new value. */
#define XBAR_WR_CTRL1_IEN3(base, value) (XBAR_RMW_CTRL1(base, (XBAR_CTRL1_IEN3_MASK | XBAR_CTRL1_STS2_MASK | XBAR_CTRL1_STS3_MASK), XBAR_CTRL1_IEN3(value)))
#define XBAR_BWR_CTRL1_IEN3(base, value) (BME_BFI16(&XBAR_CTRL1_REG(base), ((uint16_t)(value) << XBAR_CTRL1_IEN3_SHIFT), XBAR_CTRL1_IEN3_SHIFT, XBAR_CTRL1_IEN3_WIDTH))
/*@}*/

/*!
 * @name Register XBAR_CTRL1, field EDGE3[11:10] (RW)
 *
 * This field selects which edges on XBAR_OUT3 cause STS3 to assert.
 *
 * Values:
 * - 0b00 - STS3 never asserts
 * - 0b01 - STS3 asserts on rising edges of XBAR_OUT3
 * - 0b10 - STS3 asserts on falling edges of XBAR_OUT3
 * - 0b11 - STS3 asserts on rising and falling edges of XBAR_OUT3
 */
/*@{*/
/*! @brief Read current value of the XBAR_CTRL1_EDGE3 field. */
#define XBAR_RD_CTRL1_EDGE3(base) ((XBAR_CTRL1_REG(base) & XBAR_CTRL1_EDGE3_MASK) >> XBAR_CTRL1_EDGE3_SHIFT)
#define XBAR_BRD_CTRL1_EDGE3(base) (BME_UBFX16(&XBAR_CTRL1_REG(base), XBAR_CTRL1_EDGE3_SHIFT, XBAR_CTRL1_EDGE3_WIDTH))

/*! @brief Set the EDGE3 field to a new value. */
#define XBAR_WR_CTRL1_EDGE3(base, value) (XBAR_RMW_CTRL1(base, (XBAR_CTRL1_EDGE3_MASK | XBAR_CTRL1_STS2_MASK | XBAR_CTRL1_STS3_MASK), XBAR_CTRL1_EDGE3(value)))
#define XBAR_BWR_CTRL1_EDGE3(base, value) (BME_BFI16(&XBAR_CTRL1_REG(base), ((uint16_t)(value) << XBAR_CTRL1_EDGE3_SHIFT), XBAR_CTRL1_EDGE3_SHIFT, XBAR_CTRL1_EDGE3_WIDTH))
/*@}*/

/*!
 * @name Register XBAR_CTRL1, field STS3[12] (W1C)
 *
 * This bit reflects the results of edge detection for XBAR_OUT3. This field is
 * set to 1 when an edge consistent with the current setting of EDGE3 is detected
 * on XBAR_OUT3. This field is cleared by writing 1 to it or by a DMA_ACK3
 * reception when DEN3 is set. Writing 0 to the field has no effect. When interrupt or
 * DMA functionality is enabled for XBAR_OUT3, this field is 1 when the
 * interrupt or DMA request is asserted and 0 when the interrupt or DMA request has been
 * cleared.
 *
 * Values:
 * - 0b0 - Active edge not yet detected on XBAR_OUT3
 * - 0b1 - Active edge detected on XBAR_OUT3
 */
/*@{*/
/*! @brief Read current value of the XBAR_CTRL1_STS3 field. */
#define XBAR_RD_CTRL1_STS3(base) ((XBAR_CTRL1_REG(base) & XBAR_CTRL1_STS3_MASK) >> XBAR_CTRL1_STS3_SHIFT)
#define XBAR_BRD_CTRL1_STS3(base) (BME_UBFX16(&XBAR_CTRL1_REG(base), XBAR_CTRL1_STS3_SHIFT, XBAR_CTRL1_STS3_WIDTH))

/*! @brief Set the STS3 field to a new value. */
#define XBAR_WR_CTRL1_STS3(base, value) (XBAR_RMW_CTRL1(base, (XBAR_CTRL1_STS3_MASK | XBAR_CTRL1_STS2_MASK), XBAR_CTRL1_STS3(value)))
#define XBAR_BWR_CTRL1_STS3(base, value) (BME_BFI16(&XBAR_CTRL1_REG(base), ((uint16_t)(value) << XBAR_CTRL1_STS3_SHIFT), XBAR_CTRL1_STS3_SHIFT, XBAR_CTRL1_STS3_WIDTH))
/*@}*/

/* Macros for XBAR_SELx register address.  */
#define XBAR_SELx_ADDR(base, index)               ((uintptr_t)&XBAR_SEL0_REG(base) + ((index) & (~1U)))

/* Macros for XBAR_CONTROLx register address. */
#define XBAR_CTRLx_ADDR(base, index)              ((uintptr_t)&XBAR_CTRL0_REG(base) + ((index) & (~1U)))

/* Set the SELx field to a new value. */
#define XBAR_WR_SELx_SELx(base, index, value)     (BME_BFI16(XBAR_SELx_ADDR((base), (index)), ((uint16_t)(value) << (8U * ((index) % 2U))), (8U * ((index) % 2U)), 6U))

/* Read current value of the XBAR_SELx_SELx field. */
#define XBAR_RD_SELx_SELx(base, index)            (BME_UBFX16(XBAR_SELx_ADDR((base), (index)), 8U * ((index) % 2U), 6U))

/* Set the CONTROLx_DENx field to a new value. */
#define XBAR_WR_CTRLx_DENx(base, index, value)    (BME_BFI16(XBAR_CTRLx_ADDR((base), (index)), ((uint16_t)(value) << (8U * ((index) % 2U))), (8U * ((index) % 2U)), 1U))

/* Read current value of the XBAR_CONTROLx_DENx field. */
#define XBAR_RD_CTRLx_DENx(base, index)           (BME_UBFX16(XBAR_CTRLx_ADDR((base), (index)), (8U * ((index) % 2U)), 1U))

/* Set the CONTROLx_IENx field to a new value. */
#define XBAR_WR_CTRLx_IENx(base, index, value)    (BME_BFI16(XBAR_CTRLx_ADDR((base), (index)), ((uint16_t)(value) << (8U * ((index) % 2U) + 1U)), (8U * ((index) % 2U) + 1U), 1U))

/* Read current value of the XBAR_CONTROLx_IENx field. */
#define XBAR_RD_CTRLx_IENx(base, index)           (BME_UBFX16(XBAR_CTRLx_ADDR((base), (index)), (8U * ((index) % 2U) + 1U), 1U))

/* Set the CONTROLx_EDGEx field to a new value. */
#define XBAR_WR_CTRLx_EDGEx(base, index, value)   (BME_BFI16(XBAR_CTRLx_ADDR((base), (index)), ((uint16_t)(value) << (8U * ((index) % 2U) + 2U)), (8U * ((index) % 2U) + 2U), 2U))

/* Read current value of the XBAR_CONTROLx_EDGEx field. */
#define XBAR_RD_CTRLx_EDGEx(base, index)          (BME_UBFX16(XBAR_CTRLx_ADDR((base), (index)), (8U * ((index) % 2U) + 2U), 2U))

/* Set the CONTROLx_STSx field to a new value. */
#define XBAR_WR_CTRLx_STSx(base, index, value)    (BME_BFI16(XBAR_CTRLx_ADDR((base), (index)), ((uint16_t)(value) << ((8U * ((index) % 2)) + 4U)), ((8U * ((index) % 2)) + 4U), 1U))

/* Read current value of the XBAR_CONTROLx_STSx field. */
#define XBAR_RD_CTRLx_STSx(base, index)           (BME_UBFX16(XBAR_CTRLx_ADDR((base), (index)), (8U * ((index) % 2U) + 4U), 1U))

/* Instance numbers for core modules */
#define JTAG_IDX (0) /*!< Instance number for JTAG. */
#define TPIU_IDX (0) /*!< Instance number for TPIU. */
#define SCB_IDX (0) /*!< Instance number for SCB. */
#define CoreDebug_IDX (0) /*!< Instance number for CoreDebug. */

#if defined(__IAR_SYSTEMS_ICC__)
  /* Restore checking of "Error[Pm008]: sections of code should not be 'commented out' (MISRA C 2004 rule 2.4)" */
  #pragma diag_default=pm008
#endif

#endif /* __MKM34Z7_EXTENSION_H__ */
/* EOF */
